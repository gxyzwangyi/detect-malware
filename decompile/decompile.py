#!/usr/bin/env python
# coding:utf-8

import os
import sys
import re
from bs4 import BeautifulSoup


from androwarn.analysis.analysis import *

#预处理阶段-------------------------------------------------------------

# 确定反编译的输出目录，默认是当前apk所属目录
def get_output_folder( ):
	if not len( os.path.dirname( _source_apk_path ) ) == 0:
		print os.path.dirname( _source_apk_path ) + '/'
		return os.path.dirname( _source_apk_path ) + '/'
	else:
		return os.path.dirname( _source_apk_path )


# 获取要反编译的apk路径
def get_input_apk_path( ):
	if len( sys.argv ) == 1:
		return raw_input( 'please input the apk\'s path: ' )
	else:
		return sys.argv[ 1 ]



# apktool获取资源文件
def get_resource( ):
	print '\nGetting resource...'
	os.system('java -jar %s/apktool_2.0.1.jar d -f -o %s %s' % (_tools_path, _apk_resource_folder, _source_apk_path) )


# 获取java源码
def get_source_code( ):
	print '\nGetting source code...'
	convert_apk_to_jar( )
	extract_classes_from_jar( )
	get_package_name( )
	convert_classes_to_java( )
	delete_tmp_files()


# dex2jar将apk转化为jar
def convert_apk_to_jar( ):
	print '****Converting apk to jar...'
	os.system( 'sh %s/dex2jar-2.1/d2j-dex2jar.sh -f -o %s %s' % (_tools_path, _apk_jar, _source_apk_path) )


# unzip将class文件从jar包中解压出来
def extract_classes_from_jar( ):
	print '****Extracting classes from jar...'
	os.system( 'mkdir %s' % _apk_classes_folder )
	os.system( 'unzip -q %s -d %s' % (_apk_jar, _apk_classes_folder) )


# Classyshark读取当前的包名
def get_package_name( ):
	print '****get package from classdex use Classyshark...'
	os.system( 'mkdir %s' % _apk_content_folder )
	os.system( 'java -jar %s/ClassyShark.jar -export %s ' % (_tools_path, _apk_jar) )


# jad将classes文件转换为java代码
def convert_classes_to_java( ):
	print '****Converting classes to java code...'
	os.system( 'mkdir %s' % _apk_source_code_folder )
	os.system( 'find %s -name \"*.class\" | xargs %s/jad -ff -r -nonlb -s java -space -d %s >/dev/null 2>&1' % (
		_apk_classes_folder, _tools_path, _apk_source_code_folder) )

# 删除jar和class文件
def delete_tmp_files( ):
	print '****Clean temp files...'
	os.system( 'rmtrash %s' % _apk_jar )
	os.system( 'rmtrash %s' % _apk_classes_folder )




#清洗阶段-------------------------------------------------------------


# 遍历源码目录,去除系统包和文件
def walk_source( rootDir ):
	list_dirs_use = [ ]
	list_files_use = [ ]
	list_dirs = os.walk( rootDir )
	for root, dirs, files in list_dirs:
		print root, dirs, files
		if is_useless_path( root ) == 0:
			list_dirs_use.append( (root, dirs, files) )

	for root, dirs, files in list_dirs_use:
		for f in files:
			if not f.startswith( "." ):
				list_files_use.append( os.path.join( root, f ) )
	#print  list_files_use
	return list_files_use

# 是否加壳或者混淆
def is_defend( ):
	pn = open( all_classes_file, "r" )
	for line in pn.readlines( ):
		line = line.strip( '\n' )
		pack_list.append( line )
	print pack_list_mani
	for i in pack_list_mani:
		if i not in pack_list:
			return False
	return True

# 判断是否为无需扫描文件(如support)
def is_useless_path( path ):
	for ul in useless_path:
		if ul in path:
			return 1
	return 0


# 判断是否为无需扫描代码(如. / import 等 )
def is_useless_code( line ):
	for uc in useless_code:
		# if line.startswith(uc):
		if uc in line:
			return 1
	return 0


# 判断是否为最终文件夹,暂未使用
def is_end_dir( dirs ):
	list_dirs = os.walk( dirs )
	num = 0
	for root, dirs, files in list_dirs:
		if dirs != [ ]:
			return 1
		num += 1
	if num == 1:
		return 0
	else:
		return 1



#分析阶段-----------------------------------------------------------




#获取全部包名以及第三方库处理
def androwarn():
	a, d, x = AnalyzeAPK(_source_apk_path)
	origin = sys.stdout
	os.system('pwd')
	f = open("output/"+_apk_basename_without_ext+'/permission.txt', 'w')
	sys.stdout = f
	show_Permissions(x)
	sys.stdout = origin
	f.close()
	data = perform_analysis(_source_apk_path, a, d, x, False)
	package_list = data[4]["apis_used"][4][1]
	third_package_list = []
	for n,package in enumerate(package_list):
		t1 = package.startswith(apk_package)
		t2 = package.startswith("com.android") 
		t3 = package.startswith("android.support")
		t4 = package.split(".")[1] in small_letters if len(package.split("."))>1 else false
		if not ( t1 or t2 or t3 or t4) :
			third_package = package.split(".")[0:3] if len(package.split("."))>2 else package.split(".")[0::]
			if third_package[-1] in small_letters:
				third_package = third_package[0:-1]
			third_package = ".".join(third_package)
			third_package_list.append(third_package)
	third_package_list = set(third_package_list)
	return third_package_list

 

# read manifest
def read_manifest( ):
	try:
		f = open( "%s/AndroidManifest.xml" % _apk_resource_folder, "r" )
		ff = f.read( )
		f.close( )
		soup = BeautifulSoup( ff, "xml" )

		new_mani = file( _apk_basename_without_ext + "_mani.txt", "a+" )

		for pa in soup.find_all( 'manifest' ):
			global apk_package
			apk_package = pa.get( 'package' )

		for up in soup.find_all( 'uses-permission' ):
			new_mani.write( up.get( 'android:name' ) + "\r" )
		new_mani.write( "--------------------------" + "\r" )

		for r in soup.find_all( 'receiver' ):
			new_mani.write( r.get( 'android:name' ) + "\r" )
		new_mani.write( "--------------------------" + "\r" )

		for s in soup.find_all( 'service' ):
			new_mani.write( s.get( 'android:name' ) + "\r" )
		new_mani.write( "--------------------------" + "\r" )

		for a in soup.find_all( 'activity' ):
			pack_list_mani.append( a.get( 'android:name' ) )
			new_mani.write( a.get( 'android:name' ) + "\r" )
		f.close( )
	except Exception:
		pass


def java_match_api():
    	for java_file in walk_source( _apk_source_code_folder ):
		f = open( java_file, "r" )
		for line in f.readlines( ):
			for i in range( len( problem ) ):
				if type( problem[i] ) == RegexpType:
					is_match = re.match( problem[ i ], line )
				else:
					is_match = problem[i] in line
				if is_match:
					result[ i ] = 1

		f.close( )



#_apk_resource_folder 
#_apk_content_folder









#收尾阶段---------------------------------------------------------





# 集中文件
def move_file():
	print '**** move file to a dir...'
	os.chdir( _output_path )
	print _apk_basename_without_ext
	os.system('pwd')
	os.system( 'mkdir %s' % _apk_basename_without_ext )
	os.system( 'mv %s %s' % ("../method_counts.txt",_apk_basename_without_ext) )
	os.system( 'mv %s %s' % ("../all_classes.txt",_apk_basename_without_ext) )
	os.system( 'mv %s %s' % ("../"+_apk_basename_without_ext + "_mani.txt",_apk_basename_without_ext) )
	os.system( 'mv %s %s' % ("../"+_apk_source_code_folder,_apk_basename_without_ext) )
	os.system( 'mv %s %s' % ("../"+_apk_resource_folder,_apk_basename_without_ext) )
	os.system( 'mv %s %s' % ("../"+_apk_content_folder,_apk_basename_without_ext) )






# 具体是混淆还是加壳
# def is_obfuscation():
# def is_pack():







# 测试正则
# p1 = re.compile(r'[\s\S]*?getSharedPreferences\S*?, [1,2][\s\S]*?')
# a=r"context.getSharedPreferences(\"umeng_event_snapshot\", 0)esd dw df f 2w;"
# is_match = re.match(p1,a)
# print is_match.group()







# 遍历资源目录
def walk_resource( ):
	pass


# 运行
def process_user_choice():
	get_source_code()
	get_resource()
	read_manifest()
	java_match_api()
	is_defend()
	androwarn()
	move_file()
	#print result






# 初始化相关变量-------------------------------------------------

# 获取此脚本所在的路径
_running_path = os.path.split( os.path.realpath( sys.argv[ 0 ] ) )[ 0 ]
_tools_path = os.path.split( os.path.realpath( sys.argv[ 0 ] ) )[ 0 ]+"/tools"
#_output_path = os.path.split( os.path.realpath( sys.argv[ 0 ] ) )[ 0 ]+"/output"

_source_apk_path = get_input_apk_path( )
_output_path = _running_path+"/output"
_output_folder = get_output_folder( )


_apk_basename = os.path.basename( _source_apk_path ).strip( )
_apk_basename_without_ext = os.path.splitext( _apk_basename )[ 0 ]
_apk_jar = '%s-dex2jar.jar' % (_output_folder + _apk_basename_without_ext)
_apk_classes_folder = '%s_classes' % (_output_folder + _apk_basename_without_ext)
_apk_source_code_folder = '%s_source_code' % (_output_folder + _apk_basename_without_ext)
_apk_resource_folder = '%s_resource' % (_output_folder + _apk_basename_without_ext)
_apk_content_folder = '%s_content' % (_output_folder + _apk_basename_without_ext)
_apk_folder = '%s' % (_output_folder + _apk_basename_without_ext)

all_classes_file = _running_path + "/all_classes.txt"
useless_path = [ _apk_source_code_folder + "/android" ]
useless_code = [ "//", "import", "final", ]
pack_list = [ ]
pack_list_mani = [ ]
#global apk_package
apk_package = " "

small_letters = map(chr, range(ord('a'), ord('z')+1))

RegexpType = type(re.compile(''))


# 存储类问题
p1 = re.compile(r'[\s\S]*?getSharedPreferences\S*?, [1,2][\s\S]*?')
# 读取通讯录
p2 = r"android.provider.ContactsContract.Contacts.CONTENT_URI"
# 拨打电话权限
p3 = r"android.intent.action.SENDTO"
# 发短信权限
p4 = r"android.intent.action.CALL"
# 获取地理位置
p5 = r'getSystemService("location"'
# 获取手机信息
p6 = r'getSystemService("phone"'
# 获取手机信息-获取手机号码
p61 = ["getDeviceId()", "getPhoneType()", "getCellLocation()", "getCallState()", "getLine1Number()", "getSimSerialNumber()", "getNetworkOperatorName()"]
# 获取应用信息
p7 = r'getPackageManager().getInstalledPackages'
# 获取wifi信息
p8 = r'getSystemService("wifi"'
# 拍照
p9 = r"android.media.action.IMAGE_CAPTURE"
#录音或者视频
p10 = r"new MediaRecorder()"
#视频
p11 = r"setVideoSource"


# SmsManager.getDefault().sendDataMessage
# .getDisplayMessageBody()
# (Uri.parse("content://sms/inbox")

# 位置信息
# .getCid()
# .getLac()
# .getNetworkId();
# .getBaseStationId();

# 设备id
# .getSystemService("phone")
# .getSubscriberId()
# 本机号码
# .getSystemService("phone").getLine1Number();
# 安装应用
# PackageManager.getInstalledApplications(128).iterator();
# getSystemService("phone").getSimSerialNumber();
# 动态加载
# .loadClass
# 删
# .delete(Uri.parse("content://sms/")

# query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI
# query(ContactsContract.CommonDataKinds.Email.CONTENT_UR
# .query(ContactsContract.Contacts.CONTENT_URI
# .query(ContactsContract.CommonDataKinds.StructuredPostal.CONTENT_URI
# .query(Uri.parse("content://icc/adn")
# WebView.loadUrl(String.format(Locale.US


# PendingIntent安全检测
# lnotificationManager_NotificationManager.notify

# 剪贴板检测
# ((ClipboardManager) getSystemService("clipboard")).setText(p1_ix.f_f);




problem = [ p1,p2,p3,p4,p5,p6,p7,p8,p9]

result = [0 for i in range(len(problem))]

if __name__ == '__main__':
	process_user_choice( )
