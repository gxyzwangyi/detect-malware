// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.databinding;

import java.util.ArrayList;
import java.util.List;

public class b
    implements Cloneable {
    public static abstract class a {

        public abstract void a(Object obj, Object obj1, int i, Object obj2);

        public a() {
        }
    }


    private List a;
    private long b;
    private long c[];
    private int d;
    private final a e;

    private void a(int i, long l) {
        long l1 = 0x0L;
        for (int j = (i + 64) - 1; j >= i; j--) {
            if ((l & l1) != 0L)
                a.remove(j);
            l1 >>>= 1;
        }

    }

    private void a(Object obj, int i, Object obj1, int j) {
        if (j < 0) {
            b(obj, i, obj1);
        } else {
            long l1 = c[j];
            int l = (j + 1) * 64;
            int k = Math.min(a.size(), l + 64);
            a(obj, i, obj1, j - 1);
            a(obj, i, obj1, l, k, l1);
        }
    }

    private void a(Object obj, int i, Object obj1, int j, int k, long l) {
        long l1 = 1L;
        for (; j < k; j++) {
            if ((l & l1) == 0L)
                e.a(a.get(j), obj, i, obj1);
            l1 <<= 1;
        }

    }

    private boolean a(int i) {
        boolean flag = true;
        if (i >= 64) goto _L2; else goto _L1
_L1:
        if ((1L << i & b) == 0L)
            flag = false;
_L4:
        return flag;
_L2:
        if (c == null) {
            flag = false;
        } else {
            int j = i / 64 - 1;
            if (j >= c.length)
                flag = false;
            else
            if ((c[j] & 1L << i % 64) == 0L)
                flag = false;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private void b(Object obj, int i, Object obj1) {
        a(obj, i, obj1, 0, Math.min(64, a.size()), b);
    }

    private void c(Object obj, int i, Object obj1) {
        int k = a.size();
        int j;
        if (c == null)
            j = -1;
        else
            j = c.length - 1;
        a(obj, i, obj1, j);
        a(obj, i, obj1, (j + 2) * 64, k, 0L);
    }

    public b a() {
        this;
        JVM INSTR monitorenter ;
        b b1 = (b)super.clone();
        int j;
        b1.b = 0L;
        b1.c = null;
        b1.d = 0;
        ArrayList arraylist = JVM INSTR new #80  <Class ArrayList>;
        arraylist.ArrayList();
        b1.a = arraylist;
        j = a.size();
        int i = 0;
_L2:
        Object obj;
        obj = b1;
        if (i >= j)
            break; /* Loop/switch isn't completed */
        if (!a(i))
            b1.a.add(a.get(i));
        i++;
        if (true) goto _L2; else goto _L1
        obj;
        b1 = null;
_L4:
        ((CloneNotSupportedException) (obj)).printStackTrace();
        obj = b1;
_L1:
        this;
        JVM INSTR monitorexit ;
        return ((b) (obj));
        Exception exception;
        exception;
        throw exception;
        obj;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void a(Object obj, int i, Object obj1) {
        this;
        JVM INSTR monitorenter ;
        d = d + 1;
        c(obj, i, obj1);
        d = d - 1;
        if (d != 0)
            break MISSING_BLOCK_LABEL_118;
        if (c == null)
            break MISSING_BLOCK_LABEL_95;
        i = c.length - 1;
_L3:
        if (i < 0) goto _L2; else goto _L1
_L1:
        long l = c[i];
        if (l == 0L)
            continue; /* Loop/switch isn't completed */
        a((i + 1) * 64, l);
        c[i] = 0L;
        i--;
          goto _L3
_L2:
        if (b != 0L) {
            a(0, b);
            b = 0L;
        }
        this;
        JVM INSTR monitorexit ;
        return;
        obj;
        throw obj;
    }

    public Object clone() {
        return a();
    }
}
