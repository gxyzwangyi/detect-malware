// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.v7.util;

import java.lang.reflect.Array;
import java.util.*;

// Referenced classes of package android.support.v7.util:
//            BatchingListUpdateCallback, ListUpdateCallback

public class SortedList {
    public static class BatchedCallback extends Callback {

        private final BatchingListUpdateCallback mBatchingListUpdateCallback;
        final Callback mWrappedCallback;

        public boolean areContentsTheSame(Object obj, Object obj1) {
            return mWrappedCallback.areContentsTheSame(obj, obj1);
        }

        public boolean areItemsTheSame(Object obj, Object obj1) {
            return mWrappedCallback.areItemsTheSame(obj, obj1);
        }

        public int compare(Object obj, Object obj1) {
            return mWrappedCallback.compare(obj, obj1);
        }

        public void dispatchLastEvent() {
            mBatchingListUpdateCallback.dispatchLastEvent();
        }

        public void onChanged(int i, int j) {
            mBatchingListUpdateCallback.onChanged(i, j, null);
        }

        public void onInserted(int i, int j) {
            mBatchingListUpdateCallback.onInserted(i, j);
        }

        public void onMoved(int i, int j) {
            mBatchingListUpdateCallback.onMoved(i, j);
        }

        public void onRemoved(int i, int j) {
            mBatchingListUpdateCallback.onRemoved(i, j);
        }

        public BatchedCallback(Callback callback) {
            mWrappedCallback = callback;
            mBatchingListUpdateCallback = new BatchingListUpdateCallback(mWrappedCallback);
        }
    }

    public static abstract class Callback
        implements ListUpdateCallback, Comparator {

        public abstract boolean areContentsTheSame(Object obj, Object obj1);

        public abstract boolean areItemsTheSame(Object obj, Object obj1);

        public abstract int compare(Object obj, Object obj1);

        public abstract void onChanged(int i, int j);

        public void onChanged(int i, int j, Object obj) {
            onChanged(i, j);
        }

        public Callback() {
        }
    }


    private static final int CAPACITY_GROWTH = 10;
    private static final int DELETION = 2;
    private static final int INSERTION = 1;
    public static final int INVALID_POSITION = -1;
    private static final int LOOKUP = 4;
    private static final int MIN_CAPACITY = 10;
    private BatchedCallback mBatchedCallback;
    private Callback mCallback;
    Object mData[];
    private int mMergedSize;
    private Object mOldData[];
    private int mOldDataSize;
    private int mOldDataStart;
    private int mSize;
    private final Class mTClass;

    public SortedList(Class class1, Callback callback) {
        this(class1, callback, 10);
    }

    public SortedList(Class class1, Callback callback, int i) {
        mTClass = class1;
        mData = (Object[])(Object[])Array.newInstance(class1, i);
        mCallback = callback;
        mSize = 0;
    }

    private int add(Object obj, boolean flag) {
        int i;
        boolean flag1;
        flag1 = false;
        i = findIndexOf(obj, mData, 0, mSize, 1);
        if (i != -1) goto _L2; else goto _L1
_L1:
        i = ((flag1) ? 1 : 0);
_L4:
        addToData(i, obj);
        if (flag)
            mCallback.onInserted(i, 1);
_L6:
        return i;
_L2:
        if (i >= mSize) goto _L4; else goto _L3
_L3:
        Object obj1 = mData[i];
        if (!mCallback.areItemsTheSame(obj1, obj)) goto _L4; else goto _L5
_L5:
        if (mCallback.areContentsTheSame(obj1, obj)) {
            mData[i] = obj;
        } else {
            mData[i] = obj;
            mCallback.onChanged(i, 1);
        }
          goto _L6
    }

    private void addAllInternal(Object aobj[]) {
        boolean flag;
        int i;
        if (!(mCallback instanceof BatchedCallback))
            flag = true;
        else
            flag = false;
        if (flag)
            beginBatchedUpdates();
        mOldData = mData;
        mOldDataStart = 0;
        mOldDataSize = mSize;
        Arrays.sort(aobj, mCallback);
        i = deduplicate(aobj);
        if (mSize == 0) {
            mData = aobj;
            mSize = i;
            mMergedSize = i;
            mCallback.onInserted(0, i);
        } else {
            merge(aobj, i);
        }
        mOldData = null;
        if (flag)
            endBatchedUpdates();
    }

    private void addToData(int i, Object obj) {
        if (i > mSize)
            throw new IndexOutOfBoundsException((new StringBuilder()).append("cannot add item to ").append(i).append(" because size is ").append(mSize).toString());
        if (mSize == mData.length) {
            Object aobj[] = (Object[])(Object[])Array.newInstance(mTClass, mData.length + 10);
            System.arraycopy(((Object) (mData)), 0, ((Object) (aobj)), 0, i);
            aobj[i] = obj;
            System.arraycopy(((Object) (mData)), i, ((Object) (aobj)), i + 1, mSize - i);
            mData = aobj;
        } else {
            System.arraycopy(((Object) (mData)), i, ((Object) (mData)), i + 1, mSize - i);
            mData[i] = obj;
        }
        mSize = mSize + 1;
    }

    private int deduplicate(Object aobj[]) {
        int j = 1;
        if (aobj.length == 0)
            throw new IllegalArgumentException("Input array must be non-empty");
        int k = 0;
        int i = 1;
        while (j < aobj.length)  {
            Object obj = aobj[j];
            int l = mCallback.compare(aobj[k], obj);
            if (l > 0)
                throw new IllegalArgumentException("Input must be sorted in ascending order.");
            if (l == 0) {
                int i1 = findSameItem(obj, aobj, k, i);
                if (i1 != -1) {
                    aobj[i1] = obj;
                } else {
                    if (i != j)
                        aobj[i] = obj;
                    i++;
                }
            } else {
                if (i != j)
                    aobj[i] = obj;
                k = i;
                i++;
            }
            j++;
        }
        return i;
    }

    private int findIndexOf(Object obj, Object aobj[], int i, int j, int k) {
_L2:
        int l;
        int i1;
        Object obj1;
        if (i >= j)
            break MISSING_BLOCK_LABEL_131;
        l = (i + j) / 2;
        obj1 = aobj[l];
        i1 = mCallback.compare(obj1, obj);
        if (i1 >= 0)
            break; /* Loop/switch isn't completed */
        l++;
        i = j;
        j = l;
_L5:
        l = j;
        j = i;
        i = l;
        if (true) goto _L2; else goto _L1
_L1:
        if (i1 != 0) goto _L4; else goto _L3
_L3:
        if (mCallback.areItemsTheSame(obj1, obj)) {
            i = l;
        } else {
            j = linearEqualitySearch(obj, l, i, j);
            if (k == 1) {
                i = l;
                if (j != -1)
                    i = j;
            } else {
                i = j;
            }
        }
_L6:
        return i;
_L4:
        j = i;
        i = l;
          goto _L5
        if (k != 1)
            i = -1;
          goto _L6
    }

    private int findSameItem(Object obj, Object aobj[], int i, int j) {
_L3:
        if (i >= j)
            break MISSING_BLOCK_LABEL_28;
        if (!mCallback.areItemsTheSame(aobj[i], obj)) goto _L2; else goto _L1
_L1:
        return i;
_L2:
        i++;
          goto _L3
        i = -1;
          goto _L1
    }

    private int linearEqualitySearch(Object obj, int i, int j, int k) {
        int i1 = i - 1;
_L9:
        if (i1 < j) goto _L2; else goto _L1
_L1:
        Object obj1 = mData[i1];
        if (mCallback.compare(obj1, obj) == 0) goto _L3; else goto _L2
_L2:
        i++;
_L11:
        if (i >= k) goto _L5; else goto _L4
_L4:
        obj1 = mData[i];
        if (mCallback.compare(obj1, obj) == 0) goto _L6; else goto _L5
_L5:
        int l = -1;
_L8:
        return l;
_L3:
        l = i1;
        if (mCallback.areItemsTheSame(obj1, obj)) goto _L8; else goto _L7
_L7:
        i1--;
          goto _L9
_L6:
        l = i;
        if (mCallback.areItemsTheSame(obj1, obj)) goto _L8; else goto _L10
_L10:
        i++;
          goto _L11
    }

    private void merge(Object aobj[], int i) {
        int j;
        j = mSize;
        mData = (Object[])(Object[])Array.newInstance(mTClass, j + i + 10);
        mMergedSize = 0;
        j = 0;
_L7:
        if (mOldDataStart >= mOldDataSize && j >= i) goto _L2; else goto _L1
_L1:
        if (mOldDataStart != mOldDataSize) goto _L4; else goto _L3
_L3:
        i -= j;
        System.arraycopy(((Object) (aobj)), j, ((Object) (mData)), mMergedSize, i);
        mMergedSize = mMergedSize + i;
        mSize = mSize + i;
        mCallback.onInserted(mMergedSize - i, i);
_L2:
        return;
_L4:
        if (j != i)
            break; /* Loop/switch isn't completed */
        i = mOldDataSize - mOldDataStart;
        System.arraycopy(((Object) (mOldData)), mOldDataStart, ((Object) (mData)), mMergedSize, i);
        mMergedSize = i + mMergedSize;
        if (true) goto _L2; else goto _L5
_L5:
        Object obj1 = mOldData[mOldDataStart];
        Object obj = aobj[j];
        int k = mCallback.compare(obj1, obj);
        if (k > 0) {
            obj1 = ((Object) (mData));
            k = mMergedSize;
            mMergedSize = k + 1;
            obj1[k] = obj;
            mSize = mSize + 1;
            j++;
            mCallback.onInserted(mMergedSize - 1, 1);
        } else
        if (k == 0 && mCallback.areItemsTheSame(obj1, obj)) {
            Object aobj2[] = mData;
            int l = mMergedSize;
            mMergedSize = l + 1;
            aobj2[l] = obj;
            l = j + 1;
            mOldDataStart = mOldDataStart + 1;
            j = l;
            if (!mCallback.areContentsTheSame(obj1, obj)) {
                mCallback.onChanged(mMergedSize - 1, 1);
                j = l;
            }
        } else {
            Object aobj1[] = mData;
            int i1 = mMergedSize;
            mMergedSize = i1 + 1;
            aobj1[i1] = obj1;
            mOldDataStart = mOldDataStart + 1;
        }
        if (true) goto _L7; else goto _L6
_L6:
    }

    private boolean remove(Object obj, boolean flag) {
        boolean flag1 = false;
        int i = findIndexOf(obj, mData, 0, mSize, 2);
        if (i == -1) {
            flag = flag1;
        } else {
            removeItemAtIndex(i, flag);
            flag = true;
        }
        return flag;
    }

    private void removeItemAtIndex(int i, boolean flag) {
        System.arraycopy(((Object) (mData)), i + 1, ((Object) (mData)), i, mSize - i - 1);
        mSize = mSize - 1;
        mData[mSize] = null;
        if (flag)
            mCallback.onRemoved(i, 1);
    }

    private void throwIfMerging() {
        if (mOldData != null)
            throw new IllegalStateException("Cannot call this method from within addAll");
        else
            return;
    }

    public int add(Object obj) {
        throwIfMerging();
        return add(obj, true);
    }

    public void addAll(Collection collection) {
        addAll(collection.toArray((Object[])(Object[])Array.newInstance(mTClass, collection.size())), true);
    }

    public transient void addAll(Object aobj[]) {
        addAll(aobj, false);
    }

    public void addAll(Object aobj[], boolean flag) {
        throwIfMerging();
        if (aobj.length != 0)
            if (flag) {
                addAllInternal(aobj);
            } else {
                Object aobj1[] = (Object[])(Object[])Array.newInstance(mTClass, aobj.length);
                System.arraycopy(((Object) (aobj)), 0, ((Object) (aobj1)), 0, aobj.length);
                addAllInternal(aobj1);
            }
    }

    public void beginBatchedUpdates() {
        throwIfMerging();
        if (!(mCallback instanceof BatchedCallback)) {
            if (mBatchedCallback == null)
                mBatchedCallback = new BatchedCallback(mCallback);
            mCallback = mBatchedCallback;
        }
    }

    public void clear() {
        throwIfMerging();
        if (mSize != 0) {
            int i = mSize;
            Arrays.fill(mData, 0, i, null);
            mSize = 0;
            mCallback.onRemoved(0, i);
        }
    }

    public void endBatchedUpdates() {
        throwIfMerging();
        if (mCallback instanceof BatchedCallback)
            ((BatchedCallback)mCallback).dispatchLastEvent();
        if (mCallback == mBatchedCallback)
            mCallback = mBatchedCallback.mWrappedCallback;
    }

    public Object get(int i) {
        if (i >= mSize || i < 0)
            throw new IndexOutOfBoundsException((new StringBuilder()).append("Asked to get item at ").append(i).append(" but size is ").append(mSize).toString());
        Object obj;
        if (mOldData != null && i >= mMergedSize)
            obj = mOldData[(i - mMergedSize) + mOldDataStart];
        else
            obj = mData[i];
        return obj;
    }

    public int indexOf(Object obj) {
        int i;
        if (mOldData != null) {
            i = findIndexOf(obj, mData, 0, mMergedSize, 4);
            if (i == -1) {
                i = findIndexOf(obj, mOldData, mOldDataStart, mOldDataSize, 4);
                if (i != -1)
                    i = (i - mOldDataStart) + mMergedSize;
                else
                    i = -1;
            }
        } else {
            i = findIndexOf(obj, mData, 0, mSize, 4);
        }
        return i;
    }

    public void recalculatePositionOfItemAt(int i) {
        throwIfMerging();
        Object obj = get(i);
        removeItemAtIndex(i, false);
        int j = add(obj, false);
        if (i != j)
            mCallback.onMoved(i, j);
    }

    public boolean remove(Object obj) {
        throwIfMerging();
        return remove(obj, true);
    }

    public Object removeItemAt(int i) {
        throwIfMerging();
        Object obj = get(i);
        removeItemAtIndex(i, true);
        return obj;
    }

    public int size() {
        return mSize;
    }

    public void updateItemAt(int i, Object obj) {
        boolean flag;
        throwIfMerging();
        Object obj1 = get(i);
        if (obj1 == obj || !mCallback.areContentsTheSame(obj1, obj))
            flag = true;
        else
            flag = false;
        if (obj1 == obj || mCallback.compare(obj1, obj) != 0) goto _L2; else goto _L1
_L1:
        mData[i] = obj;
        if (flag)
            mCallback.onChanged(i, 1);
_L4:
        return;
_L2:
        if (flag)
            mCallback.onChanged(i, 1);
        removeItemAtIndex(i, false);
        int j = add(obj, false);
        if (i != j)
            mCallback.onMoved(i, j);
        if (true) goto _L4; else goto _L3
_L3:
    }
}
