// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.v7.widget;

import android.content.Context;
import android.graphics.PointF;
import android.graphics.Rect;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.accessibility.*;
import android.util.AttributeSet;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import java.util.*;

// Referenced classes of package android.support.v7.widget:
//            LayoutState, OrientationHelper, ScrollbarHelper, RecyclerView, 
//            LinearSmoothScroller

public class StaggeredGridLayoutManager extends RecyclerView.LayoutManager
    implements RecyclerView.SmoothScroller.ScrollVectorProvider {
    class AnchorInfo {

        boolean mInvalidateOffsets;
        boolean mLayoutFromEnd;
        int mOffset;
        int mPosition;
        boolean mValid;
        final StaggeredGridLayoutManager this$0;

        void assignCoordinateFromPadding() {
            int i;
            if (mLayoutFromEnd)
                i = mPrimaryOrientation.getEndAfterPadding();
            else
                i = mPrimaryOrientation.getStartAfterPadding();
            mOffset = i;
        }

        void assignCoordinateFromPadding(int i) {
            if (mLayoutFromEnd)
                mOffset = mPrimaryOrientation.getEndAfterPadding() - i;
            else
                mOffset = mPrimaryOrientation.getStartAfterPadding() + i;
        }

        void reset() {
            mPosition = -1;
            mOffset = 0x80000000;
            mLayoutFromEnd = false;
            mInvalidateOffsets = false;
            mValid = false;
        }

        public AnchorInfo() {
            this$0 = StaggeredGridLayoutManager.this;
            super();
            reset();
        }
    }

    public static class LayoutParams extends RecyclerView.LayoutParams {

        public static final int INVALID_SPAN_ID = -1;
        boolean mFullSpan;
        Span mSpan;

        public final int getSpanIndex() {
            int i;
            if (mSpan == null)
                i = -1;
            else
                i = mSpan.mIndex;
            return i;
        }

        public boolean isFullSpan() {
            return mFullSpan;
        }

        public void setFullSpan(boolean flag) {
            mFullSpan = flag;
        }

        public LayoutParams(int i, int j) {
            super(i, j);
        }

        public LayoutParams(Context context, AttributeSet attributeset) {
            super(context, attributeset);
        }

        public LayoutParams(RecyclerView.LayoutParams layoutparams) {
            super(layoutparams);
        }

        public LayoutParams(android.view.ViewGroup.LayoutParams layoutparams) {
            super(layoutparams);
        }

        public LayoutParams(android.view.ViewGroup.MarginLayoutParams marginlayoutparams) {
            super(marginlayoutparams);
        }
    }

    static class LazySpanLookup {

        private static final int MIN_SIZE = 10;
        int mData[];
        List mFullSpanItems;

        private int invalidateFullSpansAfter(int i) {
            if (mFullSpanItems != null) goto _L2; else goto _L1
_L1:
            i = -1;
_L5:
            return i;
_L2:
            int j;
            int k;
            FullSpanItem fullspanitem = getFullSpanItem(i);
            if (fullspanitem != null)
                mFullSpanItems.remove(fullspanitem);
            k = mFullSpanItems.size();
            j = 0;
_L6:
            if (j >= k)
                break MISSING_BLOCK_LABEL_123;
            if (((FullSpanItem)mFullSpanItems.get(j)).mPosition < i) goto _L4; else goto _L3
_L3:
            if (j != -1) {
                FullSpanItem fullspanitem1 = (FullSpanItem)mFullSpanItems.get(j);
                mFullSpanItems.remove(j);
                i = fullspanitem1.mPosition;
            } else {
                i = -1;
            }
              goto _L5
_L4:
            j++;
              goto _L6
            j = -1;
              goto _L3
        }

        private void offsetFullSpansForAddition(int i, int j) {
            if (mFullSpanItems != null) {
                int k = mFullSpanItems.size() - 1;
                while (k >= 0)  {
                    FullSpanItem fullspanitem = (FullSpanItem)mFullSpanItems.get(k);
                    if (fullspanitem.mPosition >= i)
                        fullspanitem.mPosition = fullspanitem.mPosition + j;
                    k--;
                }
            }
        }

        private void offsetFullSpansForRemoval(int i, int j) {
            if (mFullSpanItems != null) {
                int k = mFullSpanItems.size() - 1;
                while (k >= 0)  {
                    FullSpanItem fullspanitem = (FullSpanItem)mFullSpanItems.get(k);
                    if (fullspanitem.mPosition >= i)
                        if (fullspanitem.mPosition < i + j)
                            mFullSpanItems.remove(k);
                        else
                            fullspanitem.mPosition = fullspanitem.mPosition - j;
                    k--;
                }
            }
        }

        public void addFullSpanItem(FullSpanItem fullspanitem) {
            int i;
            int j;
            if (mFullSpanItems == null)
                mFullSpanItems = new ArrayList();
            j = mFullSpanItems.size();
            i = 0;
_L3:
            FullSpanItem fullspanitem1;
            if (i >= j)
                break MISSING_BLOCK_LABEL_103;
            fullspanitem1 = (FullSpanItem)mFullSpanItems.get(i);
            if (fullspanitem1.mPosition == fullspanitem.mPosition)
                mFullSpanItems.remove(i);
            if (fullspanitem1.mPosition < fullspanitem.mPosition) goto _L2; else goto _L1
_L1:
            mFullSpanItems.add(i, fullspanitem);
_L4:
            return;
_L2:
            i++;
              goto _L3
            mFullSpanItems.add(fullspanitem);
              goto _L4
        }

        void clear() {
            if (mData != null)
                Arrays.fill(mData, -1);
            mFullSpanItems = null;
        }

        void ensureSize(int i) {
            if (mData != null) goto _L2; else goto _L1
_L1:
            mData = new int[Math.max(i, 10) + 1];
            Arrays.fill(mData, -1);
_L4:
            return;
_L2:
            if (i >= mData.length) {
                int ai[] = mData;
                mData = new int[sizeForPosition(i)];
                System.arraycopy(ai, 0, mData, 0, ai.length);
                Arrays.fill(mData, ai.length, mData.length, -1);
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        int forceInvalidateAfter(int i) {
            if (mFullSpanItems != null) {
                for (int j = mFullSpanItems.size() - 1; j >= 0; j--)
                    if (((FullSpanItem)mFullSpanItems.get(j)).mPosition >= i)
                        mFullSpanItems.remove(j);

            }
            return invalidateAfter(i);
        }

        public FullSpanItem getFirstFullSpanItemInRange(int i, int j, int k, boolean flag) {
            if (mFullSpanItems != null) goto _L2; else goto _L1
_L1:
            FullSpanItem fullspanitem = null;
_L4:
            return fullspanitem;
_L2:
            int i1 = mFullSpanItems.size();
            for (int l = 0; l < i1; l++) {
                FullSpanItem fullspanitem1 = (FullSpanItem)mFullSpanItems.get(l);
                if (fullspanitem1.mPosition >= j) {
                    fullspanitem = null;
                    continue; /* Loop/switch isn't completed */
                }
                if (fullspanitem1.mPosition < i)
                    continue;
                fullspanitem = fullspanitem1;
                if (k == 0)
                    continue; /* Loop/switch isn't completed */
                fullspanitem = fullspanitem1;
                if (fullspanitem1.mGapDir == k)
                    continue; /* Loop/switch isn't completed */
                if (!flag)
                    continue;
                fullspanitem = fullspanitem1;
                if (fullspanitem1.mHasUnwantedGapAfter)
                    continue; /* Loop/switch isn't completed */
            }

            fullspanitem = null;
            if (true) goto _L4; else goto _L3
_L3:
        }

        public FullSpanItem getFullSpanItem(int i) {
            if (mFullSpanItems != null) goto _L2; else goto _L1
_L1:
            FullSpanItem fullspanitem = null;
_L4:
            return fullspanitem;
_L2:
            for (int j = mFullSpanItems.size() - 1; j >= 0; j--) {
                FullSpanItem fullspanitem1 = (FullSpanItem)mFullSpanItems.get(j);
                fullspanitem = fullspanitem1;
                if (fullspanitem1.mPosition == i)
                    continue; /* Loop/switch isn't completed */
            }

            fullspanitem = null;
            if (true) goto _L4; else goto _L3
_L3:
        }

        int getSpan(int i) {
            if (mData == null || i >= mData.length)
                i = -1;
            else
                i = mData[i];
            return i;
        }

        int invalidateAfter(int i) {
            int j;
            j = -1;
            break MISSING_BLOCK_LABEL_2;
            if (mData != null && i < mData.length) {
                j = invalidateFullSpansAfter(i);
                if (j == -1) {
                    Arrays.fill(mData, i, mData.length, -1);
                    j = mData.length;
                } else {
                    Arrays.fill(mData, i, j + 1, -1);
                    j++;
                }
            }
            return j;
        }

        void offsetForAddition(int i, int j) {
            if (mData != null && i < mData.length) {
                ensureSize(i + j);
                System.arraycopy(mData, i, mData, i + j, mData.length - i - j);
                Arrays.fill(mData, i, i + j, -1);
                offsetFullSpansForAddition(i, j);
            }
        }

        void offsetForRemoval(int i, int j) {
            if (mData != null && i < mData.length) {
                ensureSize(i + j);
                System.arraycopy(mData, i + j, mData, i, mData.length - i - j);
                Arrays.fill(mData, mData.length - j, mData.length, -1);
                offsetFullSpansForRemoval(i, j);
            }
        }

        void setSpan(int i, Span span) {
            ensureSize(i);
            mData[i] = span.mIndex;
        }

        int sizeForPosition(int i) {
            int j;
            for (j = mData.length; j <= i; j *= 2);
            return j;
        }

        LazySpanLookup() {
        }
    }

    static class LazySpanLookup.FullSpanItem
        implements Parcelable {

        public static final android.os.Parcelable.Creator CREATOR = new android.os.Parcelable.Creator() {

            public LazySpanLookup.FullSpanItem createFromParcel(Parcel parcel) {
                return new LazySpanLookup.FullSpanItem(parcel);
            }

            public volatile Object createFromParcel(Parcel parcel) {
                return createFromParcel(parcel);
            }

            public LazySpanLookup.FullSpanItem[] newArray(int i) {
                return new LazySpanLookup.FullSpanItem[i];
            }

            public volatile Object[] newArray(int i) {
                return newArray(i);
            }

        }
;
        int mGapDir;
        int mGapPerSpan[];
        boolean mHasUnwantedGapAfter;
        int mPosition;

        public int describeContents() {
            return 0;
        }

        int getGapForSpan(int i) {
            if (mGapPerSpan == null)
                i = 0;
            else
                i = mGapPerSpan[i];
            return i;
        }

        public String toString() {
            return (new StringBuilder()).append("FullSpanItem{mPosition=").append(mPosition).append(", mGapDir=").append(mGapDir).append(", mHasUnwantedGapAfter=").append(mHasUnwantedGapAfter).append(", mGapPerSpan=").append(Arrays.toString(mGapPerSpan)).append('}').toString();
        }

        public void writeToParcel(Parcel parcel, int i) {
            parcel.writeInt(mPosition);
            parcel.writeInt(mGapDir);
            if (mHasUnwantedGapAfter)
                i = 1;
            else
                i = 0;
            parcel.writeInt(i);
            if (mGapPerSpan != null && mGapPerSpan.length > 0) {
                parcel.writeInt(mGapPerSpan.length);
                parcel.writeIntArray(mGapPerSpan);
            } else {
                parcel.writeInt(0);
            }
        }


        public LazySpanLookup.FullSpanItem() {
        }

        public LazySpanLookup.FullSpanItem(Parcel parcel) {
            boolean flag = true;
            super();
            mPosition = parcel.readInt();
            mGapDir = parcel.readInt();
            int i;
            if (parcel.readInt() != 1)
                flag = false;
            mHasUnwantedGapAfter = flag;
            i = parcel.readInt();
            if (i > 0) {
                mGapPerSpan = new int[i];
                parcel.readIntArray(mGapPerSpan);
            }
        }
    }

    public static class SavedState
        implements Parcelable {

        public static final android.os.Parcelable.Creator CREATOR = new android.os.Parcelable.Creator() {

            public SavedState createFromParcel(Parcel parcel) {
                return new SavedState(parcel);
            }

            public volatile Object createFromParcel(Parcel parcel) {
                return createFromParcel(parcel);
            }

            public SavedState[] newArray(int i) {
                return new SavedState[i];
            }

            public volatile Object[] newArray(int i) {
                return newArray(i);
            }

        }
;
        boolean mAnchorLayoutFromEnd;
        int mAnchorPosition;
        List mFullSpanItems;
        boolean mLastLayoutRTL;
        boolean mReverseLayout;
        int mSpanLookup[];
        int mSpanLookupSize;
        int mSpanOffsets[];
        int mSpanOffsetsSize;
        int mVisibleAnchorPosition;

        public int describeContents() {
            return 0;
        }

        void invalidateAnchorPositionInfo() {
            mSpanOffsets = null;
            mSpanOffsetsSize = 0;
            mAnchorPosition = -1;
            mVisibleAnchorPosition = -1;
        }

        void invalidateSpanInfo() {
            mSpanOffsets = null;
            mSpanOffsetsSize = 0;
            mSpanLookupSize = 0;
            mSpanLookup = null;
            mFullSpanItems = null;
        }

        public void writeToParcel(Parcel parcel, int i) {
            boolean flag = true;
            parcel.writeInt(mAnchorPosition);
            parcel.writeInt(mVisibleAnchorPosition);
            parcel.writeInt(mSpanOffsetsSize);
            if (mSpanOffsetsSize > 0)
                parcel.writeIntArray(mSpanOffsets);
            parcel.writeInt(mSpanLookupSize);
            if (mSpanLookupSize > 0)
                parcel.writeIntArray(mSpanLookup);
            if (mReverseLayout)
                i = 1;
            else
                i = 0;
            parcel.writeInt(i);
            if (mAnchorLayoutFromEnd)
                i = 1;
            else
                i = 0;
            parcel.writeInt(i);
            if (mLastLayoutRTL)
                i = ((flag) ? 1 : 0);
            else
                i = 0;
            parcel.writeInt(i);
            parcel.writeList(mFullSpanItems);
        }


        public SavedState() {
        }

        SavedState(Parcel parcel) {
            boolean flag1 = true;
            super();
            mAnchorPosition = parcel.readInt();
            mVisibleAnchorPosition = parcel.readInt();
            mSpanOffsetsSize = parcel.readInt();
            if (mSpanOffsetsSize > 0) {
                mSpanOffsets = new int[mSpanOffsetsSize];
                parcel.readIntArray(mSpanOffsets);
            }
            mSpanLookupSize = parcel.readInt();
            if (mSpanLookupSize > 0) {
                mSpanLookup = new int[mSpanLookupSize];
                parcel.readIntArray(mSpanLookup);
            }
            boolean flag;
            if (parcel.readInt() == 1)
                flag = true;
            else
                flag = false;
            mReverseLayout = flag;
            if (parcel.readInt() == 1)
                flag = true;
            else
                flag = false;
            mAnchorLayoutFromEnd = flag;
            if (parcel.readInt() == 1)
                flag = flag1;
            else
                flag = false;
            mLastLayoutRTL = flag;
            mFullSpanItems = parcel.readArrayList(android/support/v7/widget/StaggeredGridLayoutManager$LazySpanLookup$FullSpanItem.getClassLoader());
        }

        public SavedState(SavedState savedstate) {
            mSpanOffsetsSize = savedstate.mSpanOffsetsSize;
            mAnchorPosition = savedstate.mAnchorPosition;
            mVisibleAnchorPosition = savedstate.mVisibleAnchorPosition;
            mSpanOffsets = savedstate.mSpanOffsets;
            mSpanLookupSize = savedstate.mSpanLookupSize;
            mSpanLookup = savedstate.mSpanLookup;
            mReverseLayout = savedstate.mReverseLayout;
            mAnchorLayoutFromEnd = savedstate.mAnchorLayoutFromEnd;
            mLastLayoutRTL = savedstate.mLastLayoutRTL;
            mFullSpanItems = savedstate.mFullSpanItems;
        }
    }

    class Span {

        static final int INVALID_LINE = 0x80000000;
        int mCachedEnd;
        int mCachedStart;
        int mDeletedSize;
        final int mIndex;
        ArrayList mViews;
        final StaggeredGridLayoutManager this$0;

        void appendToSpan(View view) {
            LayoutParams layoutparams = getLayoutParams(view);
            layoutparams.mSpan = this;
            mViews.add(view);
            mCachedEnd = 0x80000000;
            if (mViews.size() == 1)
                mCachedStart = 0x80000000;
            if (layoutparams.isItemRemoved() || layoutparams.isItemChanged())
                mDeletedSize = mDeletedSize + mPrimaryOrientation.getDecoratedMeasurement(view);
        }

        void cacheReferenceLineAndClear(boolean flag, int i) {
            int j;
            if (flag)
                j = getEndLine(0x80000000);
            else
                j = getStartLine(0x80000000);
            clear();
            break MISSING_BLOCK_LABEL_15;
            if (j != 0x80000000 && (!flag || j >= mPrimaryOrientation.getEndAfterPadding()) && (flag || j <= mPrimaryOrientation.getStartAfterPadding())) {
                int k = j;
                if (i != 0x80000000)
                    k = j + i;
                mCachedEnd = k;
                mCachedStart = k;
            }
            return;
        }

        void calculateCachedEnd() {
            View view = (View)mViews.get(mViews.size() - 1);
            Object obj = getLayoutParams(view);
            mCachedEnd = mPrimaryOrientation.getDecoratedEnd(view);
            if (((LayoutParams) (obj)).mFullSpan) {
                obj = mLazySpanLookup.getFullSpanItem(((LayoutParams) (obj)).getViewLayoutPosition());
                if (obj != null && ((LazySpanLookup.FullSpanItem) (obj)).mGapDir == 1) {
                    int i = mCachedEnd;
                    mCachedEnd = ((LazySpanLookup.FullSpanItem) (obj)).getGapForSpan(mIndex) + i;
                }
            }
        }

        void calculateCachedStart() {
            View view = (View)mViews.get(0);
            LayoutParams layoutparams = getLayoutParams(view);
            mCachedStart = mPrimaryOrientation.getDecoratedStart(view);
            if (layoutparams.mFullSpan) {
                LazySpanLookup.FullSpanItem fullspanitem = mLazySpanLookup.getFullSpanItem(layoutparams.getViewLayoutPosition());
                if (fullspanitem != null && fullspanitem.mGapDir == -1)
                    mCachedStart = mCachedStart - fullspanitem.getGapForSpan(mIndex);
            }
        }

        void clear() {
            mViews.clear();
            invalidateCache();
            mDeletedSize = 0;
        }

        public int findFirstCompletelyVisibleItemPosition() {
            int i;
            if (mReverseLayout)
                i = findOneVisibleChild(mViews.size() - 1, -1, true);
            else
                i = findOneVisibleChild(0, mViews.size(), true);
            return i;
        }

        public int findFirstVisibleItemPosition() {
            int i;
            if (mReverseLayout)
                i = findOneVisibleChild(mViews.size() - 1, -1, false);
            else
                i = findOneVisibleChild(0, mViews.size(), false);
            return i;
        }

        public int findLastCompletelyVisibleItemPosition() {
            int i;
            if (mReverseLayout)
                i = findOneVisibleChild(0, mViews.size(), true);
            else
                i = findOneVisibleChild(mViews.size() - 1, -1, true);
            return i;
        }

        public int findLastVisibleItemPosition() {
            int i;
            if (mReverseLayout)
                i = findOneVisibleChild(0, mViews.size(), false);
            else
                i = findOneVisibleChild(mViews.size() - 1, -1, false);
            return i;
        }

        int findOneVisibleChild(int i, int j, boolean flag) {
            byte byte0;
            int k;
            View view;
            byte byte1 = -1;
            int i1 = mPrimaryOrientation.getStartAfterPadding();
            int l = mPrimaryOrientation.getEndAfterPadding();
            int j1;
            if (j > i) {
                byte0 = 1;
                k = i;
            } else {
                byte0 = -1;
                k = i;
            }
_L9:
            i = byte1;
            if (k == j) goto _L2; else goto _L1
_L1:
            view = (View)mViews.get(k);
            i = mPrimaryOrientation.getDecoratedStart(view);
            j1 = mPrimaryOrientation.getDecoratedEnd(view);
            if (i >= l || j1 <= i1) goto _L4; else goto _L3
_L3:
            if (!flag) goto _L6; else goto _L5
_L5:
            if (i < i1 || j1 > l) goto _L4; else goto _L7
_L7:
            i = getPosition(view);
_L2:
            return i;
_L6:
            i = getPosition(view);
            if (true) goto _L2; else goto _L4
_L4:
            k += byte0;
            if (true) goto _L9; else goto _L8
_L8:
        }

        public int getDeletedSize() {
            return mDeletedSize;
        }

        int getEndLine() {
            int i;
            if (mCachedEnd != 0x80000000) {
                i = mCachedEnd;
            } else {
                calculateCachedEnd();
                i = mCachedEnd;
            }
            return i;
        }

        int getEndLine(int i) {
            if (mCachedEnd == 0x80000000) goto _L2; else goto _L1
_L1:
            i = mCachedEnd;
_L4:
            return i;
_L2:
            if (mViews.size() != 0) {
                calculateCachedEnd();
                i = mCachedEnd;
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        public View getFocusableViewAfter(int i, int j) {
            View view;
            View view1;
            view1 = null;
            view = null;
            if (j != -1) goto _L2; else goto _L1
_L1:
            int k = mViews.size();
            j = 0;
            do {
                if (j >= k)
                    break;
                view1 = (View)mViews.get(j);
                if (!view1.isFocusable())
                    break;
                boolean flag2;
                if (getPosition(view1) > i)
                    flag2 = true;
                else
                    flag2 = false;
                if (flag2 != mReverseLayout)
                    break;
                j++;
                view = view1;
            } while (true);
_L4:
            return view;
_L2:
            j = mViews.size() - 1;
            view = view1;
_L7:
            if (j < 0) goto _L4; else goto _L3
_L3:
            view1 = (View)mViews.get(j);
            if (!view1.isFocusable()) goto _L4; else goto _L5
_L5:
            boolean flag;
            boolean flag1;
            if (getPosition(view1) > i)
                flag = true;
            else
                flag = false;
            if (!mReverseLayout)
                flag1 = true;
            else
                flag1 = false;
            if (flag != flag1) goto _L4; else goto _L6
_L6:
            j--;
            view = view1;
              goto _L7
        }

        LayoutParams getLayoutParams(View view) {
            return (LayoutParams)view.getLayoutParams();
        }

        int getStartLine() {
            int i;
            if (mCachedStart != 0x80000000) {
                i = mCachedStart;
            } else {
                calculateCachedStart();
                i = mCachedStart;
            }
            return i;
        }

        int getStartLine(int i) {
            if (mCachedStart == 0x80000000) goto _L2; else goto _L1
_L1:
            i = mCachedStart;
_L4:
            return i;
_L2:
            if (mViews.size() != 0) {
                calculateCachedStart();
                i = mCachedStart;
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        void invalidateCache() {
            mCachedStart = 0x80000000;
            mCachedEnd = 0x80000000;
        }

        void onOffset(int i) {
            if (mCachedStart != 0x80000000)
                mCachedStart = mCachedStart + i;
            if (mCachedEnd != 0x80000000)
                mCachedEnd = mCachedEnd + i;
        }

        void popEnd() {
            int i = mViews.size();
            View view = (View)mViews.remove(i - 1);
            LayoutParams layoutparams = getLayoutParams(view);
            layoutparams.mSpan = null;
            if (layoutparams.isItemRemoved() || layoutparams.isItemChanged())
                mDeletedSize = mDeletedSize - mPrimaryOrientation.getDecoratedMeasurement(view);
            if (i == 1)
                mCachedStart = 0x80000000;
            mCachedEnd = 0x80000000;
        }

        void popStart() {
            View view = (View)mViews.remove(0);
            LayoutParams layoutparams = getLayoutParams(view);
            layoutparams.mSpan = null;
            if (mViews.size() == 0)
                mCachedEnd = 0x80000000;
            if (layoutparams.isItemRemoved() || layoutparams.isItemChanged())
                mDeletedSize = mDeletedSize - mPrimaryOrientation.getDecoratedMeasurement(view);
            mCachedStart = 0x80000000;
        }

        void prependToSpan(View view) {
            LayoutParams layoutparams = getLayoutParams(view);
            layoutparams.mSpan = this;
            mViews.add(0, view);
            mCachedStart = 0x80000000;
            if (mViews.size() == 1)
                mCachedEnd = 0x80000000;
            if (layoutparams.isItemRemoved() || layoutparams.isItemChanged())
                mDeletedSize = mDeletedSize + mPrimaryOrientation.getDecoratedMeasurement(view);
        }

        void setLine(int i) {
            mCachedStart = i;
            mCachedEnd = i;
        }

        Span(int i) {
            this$0 = StaggeredGridLayoutManager.this;
            super();
            mViews = new ArrayList();
            mCachedStart = 0x80000000;
            mCachedEnd = 0x80000000;
            mDeletedSize = 0;
            mIndex = i;
        }
    }


    static final boolean DEBUG = false;
    public static final int GAP_HANDLING_LAZY = 1;
    public static final int GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS = 2;
    public static final int GAP_HANDLING_NONE = 0;
    public static final int HORIZONTAL = 0;
    static final int INVALID_OFFSET = 0x80000000;
    private static final float MAX_SCROLL_FACTOR = 0.3333333F;
    private static final String TAG = "StaggeredGridLayoutManager";
    public static final int VERTICAL = 1;
    private final AnchorInfo mAnchorInfo;
    private final Runnable mCheckForGapsRunnable;
    private int mFullSizeSpec;
    private int mGapStrategy;
    private boolean mLaidOutInvalidFullSpan;
    private boolean mLastLayoutFromEnd;
    private boolean mLastLayoutRTL;
    private final LayoutState mLayoutState;
    LazySpanLookup mLazySpanLookup;
    private int mOrientation;
    private SavedState mPendingSavedState;
    int mPendingScrollPosition;
    int mPendingScrollPositionOffset;
    OrientationHelper mPrimaryOrientation;
    private BitSet mRemainingSpans;
    boolean mReverseLayout;
    OrientationHelper mSecondaryOrientation;
    boolean mShouldReverseLayout;
    private int mSizePerSpan;
    private boolean mSmoothScrollbarEnabled;
    private int mSpanCount;
    Span mSpans[];
    private final Rect mTmpRect;

    public StaggeredGridLayoutManager(int i, int j) {
        boolean flag = true;
        super();
        mSpanCount = -1;
        mReverseLayout = false;
        mShouldReverseLayout = false;
        mPendingScrollPosition = -1;
        mPendingScrollPositionOffset = 0x80000000;
        mLazySpanLookup = new LazySpanLookup();
        mGapStrategy = 2;
        mTmpRect = new Rect();
        mAnchorInfo = new AnchorInfo();
        mLaidOutInvalidFullSpan = false;
        mSmoothScrollbarEnabled = true;
        mCheckForGapsRunnable = new Runnable() {

            final StaggeredGridLayoutManager this$0;

            public void run() {
                checkForGaps();
            }

             {
                this$0 = StaggeredGridLayoutManager.this;
                super();
            }
        }
;
        mOrientation = j;
        setSpanCount(i);
        if (mGapStrategy == 0)
            flag = false;
        setAutoMeasureEnabled(flag);
        mLayoutState = new LayoutState();
        createOrientationHelpers();
    }

    public StaggeredGridLayoutManager(Context context, AttributeSet attributeset, int i, int j) {
        boolean flag = true;
        super();
        mSpanCount = -1;
        mReverseLayout = false;
        mShouldReverseLayout = false;
        mPendingScrollPosition = -1;
        mPendingScrollPositionOffset = 0x80000000;
        mLazySpanLookup = new LazySpanLookup();
        mGapStrategy = 2;
        mTmpRect = new Rect();
        mAnchorInfo = new AnchorInfo();
        mLaidOutInvalidFullSpan = false;
        mSmoothScrollbarEnabled = true;
        mCheckForGapsRunnable = new _cls1();
        context = getProperties(context, attributeset, i, j);
        setOrientation(((RecyclerView.LayoutManager.Properties) (context)).orientation);
        setSpanCount(((RecyclerView.LayoutManager.Properties) (context)).spanCount);
        setReverseLayout(((RecyclerView.LayoutManager.Properties) (context)).reverseLayout);
        if (mGapStrategy == 0)
            flag = false;
        setAutoMeasureEnabled(flag);
        mLayoutState = new LayoutState();
        createOrientationHelpers();
    }

    private void appendViewToAllSpans(View view) {
        for (int i = mSpanCount - 1; i >= 0; i--)
            mSpans[i].appendToSpan(view);

    }

    private void applyPendingSavedState(AnchorInfo anchorinfo) {
        if (mPendingSavedState.mSpanOffsetsSize > 0)
            if (mPendingSavedState.mSpanOffsetsSize == mSpanCount) {
                int j = 0;
                while (j < mSpanCount)  {
                    mSpans[j].clear();
                    int k = mPendingSavedState.mSpanOffsets[j];
                    int i = k;
                    if (k != 0x80000000)
                        if (mPendingSavedState.mAnchorLayoutFromEnd)
                            i = k + mPrimaryOrientation.getEndAfterPadding();
                        else
                            i = k + mPrimaryOrientation.getStartAfterPadding();
                    mSpans[j].setLine(i);
                    j++;
                }
            } else {
                mPendingSavedState.invalidateSpanInfo();
                mPendingSavedState.mAnchorPosition = mPendingSavedState.mVisibleAnchorPosition;
            }
        mLastLayoutRTL = mPendingSavedState.mLastLayoutRTL;
        setReverseLayout(mPendingSavedState.mReverseLayout);
        resolveShouldLayoutReverse();
        if (mPendingSavedState.mAnchorPosition != -1) {
            mPendingScrollPosition = mPendingSavedState.mAnchorPosition;
            anchorinfo.mLayoutFromEnd = mPendingSavedState.mAnchorLayoutFromEnd;
        } else {
            anchorinfo.mLayoutFromEnd = mShouldReverseLayout;
        }
        if (mPendingSavedState.mSpanLookupSize > 1) {
            mLazySpanLookup.mData = mPendingSavedState.mSpanLookup;
            mLazySpanLookup.mFullSpanItems = mPendingSavedState.mFullSpanItems;
        }
    }

    private void attachViewToSpans(View view, LayoutParams layoutparams, LayoutState layoutstate) {
        if (layoutstate.mLayoutDirection == 1) {
            if (layoutparams.mFullSpan)
                appendViewToAllSpans(view);
            else
                layoutparams.mSpan.appendToSpan(view);
        } else
        if (layoutparams.mFullSpan)
            prependViewToAllSpans(view);
        else
            layoutparams.mSpan.prependToSpan(view);
    }

    private int calculateScrollDirectionForPosition(int i) {
        byte byte0 = -1;
        boolean flag = true;
        if (getChildCount() == 0) {
            if (mShouldReverseLayout)
                i = ((flag) ? 1 : 0);
            else
                i = -1;
        } else {
            boolean flag1;
            if (i < getFirstChildPosition())
                flag1 = true;
            else
                flag1 = false;
            if (flag1 != mShouldReverseLayout)
                i = byte0;
            else
                i = 1;
        }
        return i;
    }

    private boolean checkSpanForGap(Span span) {
        boolean flag = true;
        if (!mShouldReverseLayout) goto _L2; else goto _L1
_L1:
        if (span.getEndLine() >= mPrimaryOrientation.getEndAfterPadding()) goto _L4; else goto _L3
_L3:
        if (!span.getLayoutParams((View)span.mViews.get(span.mViews.size() - 1)).mFullSpan)
            flag = true;
        else
            flag = false;
_L6:
        return flag;
_L2:
        if (span.getStartLine() > mPrimaryOrientation.getStartAfterPadding()) {
            if (span.getLayoutParams((View)span.mViews.get(0)).mFullSpan)
                flag = false;
            continue; /* Loop/switch isn't completed */
        }
_L4:
        flag = false;
        if (true) goto _L6; else goto _L5
_L5:
    }

    private int computeScrollExtent(RecyclerView.State state) {
        boolean flag1 = false;
        int i = 0;
        if (getChildCount() != 0) {
            OrientationHelper orientationhelper = mPrimaryOrientation;
            boolean flag;
            View view;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            else
                flag = false;
            view = findFirstVisibleItemClosestToStart(flag, true);
            flag = flag1;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            i = ScrollbarHelper.computeScrollExtent(state, orientationhelper, view, findFirstVisibleItemClosestToEnd(flag, true), this, mSmoothScrollbarEnabled);
        }
        return i;
    }

    private int computeScrollOffset(RecyclerView.State state) {
        boolean flag1 = false;
        int i = 0;
        if (getChildCount() != 0) {
            OrientationHelper orientationhelper = mPrimaryOrientation;
            boolean flag;
            View view;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            else
                flag = false;
            view = findFirstVisibleItemClosestToStart(flag, true);
            flag = flag1;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            i = ScrollbarHelper.computeScrollOffset(state, orientationhelper, view, findFirstVisibleItemClosestToEnd(flag, true), this, mSmoothScrollbarEnabled, mShouldReverseLayout);
        }
        return i;
    }

    private int computeScrollRange(RecyclerView.State state) {
        boolean flag1 = false;
        int i = 0;
        if (getChildCount() != 0) {
            OrientationHelper orientationhelper = mPrimaryOrientation;
            boolean flag;
            View view;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            else
                flag = false;
            view = findFirstVisibleItemClosestToStart(flag, true);
            flag = flag1;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            i = ScrollbarHelper.computeScrollRange(state, orientationhelper, view, findFirstVisibleItemClosestToEnd(flag, true), this, mSmoothScrollbarEnabled);
        }
        return i;
    }

    private int convertFocusDirectionToLayoutDirection(int i) {
        byte byte0;
        int j;
        boolean flag;
        byte0 = -1;
        j = 0x80000000;
        flag = true;
        i;
        JVM INSTR lookupswitch 6: default 68
    //                   1: 73
    //                   2: 97
    //                   17: 155
    //                   33: 124
    //                   66: 170
    //                   130: 140;
           goto _L1 _L2 _L3 _L4 _L5 _L6 _L7
_L1:
        i = 0x80000000;
_L9:
        return i;
_L2:
        i = byte0;
        if (mOrientation != 1) {
            i = byte0;
            if (isLayoutRTL())
                i = 1;
        }
        continue; /* Loop/switch isn't completed */
_L3:
        if (mOrientation == 1) {
            i = 1;
        } else {
            i = byte0;
            if (!isLayoutRTL())
                i = 1;
        }
        continue; /* Loop/switch isn't completed */
_L5:
        i = byte0;
        if (mOrientation != 1)
            i = 0x80000000;
        continue; /* Loop/switch isn't completed */
_L7:
        i = j;
        if (mOrientation == 1)
            i = 1;
        continue; /* Loop/switch isn't completed */
_L4:
        i = byte0;
        if (mOrientation != 0)
            i = 0x80000000;
        continue; /* Loop/switch isn't completed */
_L6:
        if (mOrientation == 0)
            i = ((flag) ? 1 : 0);
        else
            i = 0x80000000;
        if (true) goto _L9; else goto _L8
_L8:
    }

    private LazySpanLookup.FullSpanItem createFullSpanItemFromEnd(int i) {
        LazySpanLookup.FullSpanItem fullspanitem = new LazySpanLookup.FullSpanItem();
        fullspanitem.mGapPerSpan = new int[mSpanCount];
        for (int j = 0; j < mSpanCount; j++)
            fullspanitem.mGapPerSpan[j] = i - mSpans[j].getEndLine(i);

        return fullspanitem;
    }

    private LazySpanLookup.FullSpanItem createFullSpanItemFromStart(int i) {
        LazySpanLookup.FullSpanItem fullspanitem = new LazySpanLookup.FullSpanItem();
        fullspanitem.mGapPerSpan = new int[mSpanCount];
        for (int j = 0; j < mSpanCount; j++)
            fullspanitem.mGapPerSpan[j] = mSpans[j].getStartLine(i) - i;

        return fullspanitem;
    }

    private void createOrientationHelpers() {
        mPrimaryOrientation = OrientationHelper.createOrientationHelper(this, mOrientation);
        mSecondaryOrientation = OrientationHelper.createOrientationHelper(this, 1 - mOrientation);
    }

    private int fill(RecyclerView.Recycler recycler, LayoutState layoutstate, RecyclerView.State state) {
        mRemainingSpans.set(0, mSpanCount, true);
        int i;
        int j;
        int l;
        if (mLayoutState.mInfinite) {
            if (layoutstate.mLayoutDirection == 1)
                i = 0x7fffffff;
            else
                i = 0x80000000;
        } else
        if (layoutstate.mLayoutDirection == 1)
            i = layoutstate.mEndLine + layoutstate.mAvailable;
        else
            i = layoutstate.mStartLine - layoutstate.mAvailable;
        updateAllRemainingSpans(layoutstate.mLayoutDirection, i);
        if (mShouldReverseLayout)
            l = mPrimaryOrientation.getEndAfterPadding();
        else
            l = mPrimaryOrientation.getStartAfterPadding();
        j = 0;
        while (layoutstate.hasMore(state) && (mLayoutState.mInfinite || !mRemainingSpans.isEmpty()))  {
            View view = layoutstate.next(recycler);
            LayoutParams layoutparams = (LayoutParams)view.getLayoutParams();
            int k1 = layoutparams.getViewLayoutPosition();
            j = mLazySpanLookup.getSpan(k1);
            int j1;
            Span span;
            if (j == -1)
                j1 = 1;
            else
                j1 = 0;
            if (j1 != 0) {
                LazySpanLookup.FullSpanItem fullspanitem;
                if (layoutparams.mFullSpan)
                    span = mSpans[0];
                else
                    span = getNextSpan(layoutstate);
                mLazySpanLookup.setSpan(k1, span);
            } else {
                span = mSpans[j];
            }
            layoutparams.mSpan = span;
            if (layoutstate.mLayoutDirection == 1)
                addView(view);
            else
                addView(view, 0);
            measureChildWithDecorationsAndMargin(view, layoutparams, false);
            if (layoutstate.mLayoutDirection == 1) {
                int k;
                int i1;
                if (layoutparams.mFullSpan)
                    j = getMaxEnd(l);
                else
                    j = span.getEndLine(l);
                i1 = j + mPrimaryOrientation.getDecoratedMeasurement(view);
                LazySpanLookup.FullSpanItem fullspanitem1;
                if (j1 != 0 && layoutparams.mFullSpan) {
                    fullspanitem = createFullSpanItemFromEnd(j);
                    fullspanitem.mGapDir = -1;
                    fullspanitem.mPosition = k1;
                    mLazySpanLookup.addFullSpanItem(fullspanitem);
                    k = j;
                } else {
                    k = j;
                }
            } else {
                if (layoutparams.mFullSpan)
                    j = getMinStart(l);
                else
                    j = span.getStartLine(l);
                k = j - mPrimaryOrientation.getDecoratedMeasurement(view);
                if (j1 != 0 && layoutparams.mFullSpan) {
                    fullspanitem1 = createFullSpanItemFromStart(j);
                    fullspanitem1.mGapDir = 1;
                    fullspanitem1.mPosition = k1;
                    mLazySpanLookup.addFullSpanItem(fullspanitem1);
                }
                i1 = j;
            }
            if (layoutparams.mFullSpan && layoutstate.mItemDirection == -1)
                if (j1 != 0) {
                    mLaidOutInvalidFullSpan = true;
                } else {
                    if (layoutstate.mLayoutDirection == 1) {
                        if (!areAllEndsEqual())
                            j = 1;
                        else
                            j = 0;
                    } else
                    if (!areAllStartsEqual())
                        j = 1;
                    else
                        j = 0;
                    if (j != 0) {
                        fullspanitem1 = mLazySpanLookup.getFullSpanItem(k1);
                        if (fullspanitem1 != null)
                            fullspanitem1.mHasUnwantedGapAfter = true;
                        mLaidOutInvalidFullSpan = true;
                    }
                }
            attachViewToSpans(view, layoutparams, layoutstate);
            if (isLayoutRTL() && mOrientation == 1) {
                if (layoutparams.mFullSpan)
                    j = mSecondaryOrientation.getEndAfterPadding();
                else
                    j = mSecondaryOrientation.getEndAfterPadding() - (mSpanCount - 1 - span.mIndex) * mSizePerSpan;
                k1 = j - mSecondaryOrientation.getDecoratedMeasurement(view);
                j1 = j;
                j = k1;
            } else {
                if (layoutparams.mFullSpan)
                    j = mSecondaryOrientation.getStartAfterPadding();
                else
                    j = span.mIndex * mSizePerSpan + mSecondaryOrientation.getStartAfterPadding();
                j1 = j + mSecondaryOrientation.getDecoratedMeasurement(view);
            }
            if (mOrientation == 1)
                layoutDecoratedWithMargins(view, j, k, j1, i1);
            else
                layoutDecoratedWithMargins(view, k, j, i1, j1);
            if (layoutparams.mFullSpan)
                updateAllRemainingSpans(mLayoutState.mLayoutDirection, i);
            else
                updateRemainingSpans(span, mLayoutState.mLayoutDirection, i);
            recycle(recycler, mLayoutState);
            if (mLayoutState.mStopInFocusable && view.isFocusable())
                if (layoutparams.mFullSpan)
                    mRemainingSpans.clear();
                else
                    mRemainingSpans.set(span.mIndex, false);
            j = 1;
        }
        if (j == 0)
            recycle(recycler, mLayoutState);
        if (mLayoutState.mLayoutDirection == -1) {
            i = getMinStart(mPrimaryOrientation.getStartAfterPadding());
            i = mPrimaryOrientation.getStartAfterPadding() - i;
        } else {
            i = getMaxEnd(mPrimaryOrientation.getEndAfterPadding()) - mPrimaryOrientation.getEndAfterPadding();
        }
        if (i > 0)
            i = Math.min(layoutstate.mAvailable, i);
        else
            i = 0;
        return i;
    }

    private int findFirstReferenceChildPosition(int i) {
        int j;
        int l;
        l = getChildCount();
        j = 0;
_L3:
        int k;
        if (j >= l)
            break MISSING_BLOCK_LABEL_43;
        k = getPosition(getChildAt(j));
        if (k < 0 || k >= i) goto _L2; else goto _L1
_L1:
        i = k;
_L4:
        return i;
_L2:
        j++;
          goto _L3
        i = 0;
          goto _L4
    }

    private int findLastReferenceChildPosition(int i) {
        int j = getChildCount() - 1;
_L3:
        int k;
        if (j < 0)
            break MISSING_BLOCK_LABEL_40;
        k = getPosition(getChildAt(j));
        if (k < 0 || k >= i) goto _L2; else goto _L1
_L1:
        i = k;
_L4:
        return i;
_L2:
        j--;
          goto _L3
        i = 0;
          goto _L4
    }

    private void fixEndGap(RecyclerView.Recycler recycler, RecyclerView.State state, boolean flag) {
        int i = getMaxEnd(0x80000000);
        if (i != 0x80000000) goto _L2; else goto _L1
_L1:
        return;
_L2:
        i = mPrimaryOrientation.getEndAfterPadding() - i;
        if (i > 0) {
            i -= -scrollBy(-i, recycler, state);
            if (flag && i > 0)
                mPrimaryOrientation.offsetChildren(i);
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    private void fixStartGap(RecyclerView.Recycler recycler, RecyclerView.State state, boolean flag) {
        int i = getMinStart(0x7fffffff);
        if (i != 0x7fffffff) goto _L2; else goto _L1
_L1:
        return;
_L2:
        i -= mPrimaryOrientation.getStartAfterPadding();
        if (i > 0) {
            i -= scrollBy(i, recycler, state);
            if (flag && i > 0)
                mPrimaryOrientation.offsetChildren(-i);
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    private int getFirstChildPosition() {
        int i = 0;
        if (getChildCount() != 0)
            i = getPosition(getChildAt(0));
        return i;
    }

    private int getLastChildPosition() {
        int i = getChildCount();
        if (i == 0)
            i = 0;
        else
            i = getPosition(getChildAt(i - 1));
        return i;
    }

    private int getMaxEnd(int i) {
        int j = mSpans[0].getEndLine(i);
        for (int l = 1; l < mSpanCount;) {
            int i1 = mSpans[l].getEndLine(i);
            int k = j;
            if (i1 > j)
                k = i1;
            l++;
            j = k;
        }

        return j;
    }

    private int getMaxStart(int i) {
        int k = mSpans[0].getStartLine(i);
        for (int j = 1; j < mSpanCount;) {
            int i1 = mSpans[j].getStartLine(i);
            int l = k;
            if (i1 > k)
                l = i1;
            j++;
            k = l;
        }

        return k;
    }

    private int getMinEnd(int i) {
        int l = mSpans[0].getEndLine(i);
        for (int k = 1; k < mSpanCount;) {
            int i1 = mSpans[k].getEndLine(i);
            int j = l;
            if (i1 < l)
                j = i1;
            k++;
            l = j;
        }

        return l;
    }

    private int getMinStart(int i) {
        int l = mSpans[0].getStartLine(i);
        for (int j = 1; j < mSpanCount;) {
            int i1 = mSpans[j].getStartLine(i);
            int k = l;
            if (i1 < l)
                k = i1;
            j++;
            l = k;
        }

        return l;
    }

    private Span getNextSpan(LayoutState layoutstate) {
        Object obj1 = null;
        Object obj = null;
        byte byte0 = -1;
        int i;
        int j;
        if (preferLastSpan(layoutstate.mLayoutDirection)) {
            i = mSpanCount - 1;
            j = -1;
        } else {
            j = mSpanCount;
            i = 0;
            byte0 = 1;
        }
        if (layoutstate.mLayoutDirection == 1) {
            int i2 = mPrimaryOrientation.getStartAfterPadding();
            int i1 = 0x7fffffff;
            int k = i;
            layoutstate = ((LayoutState) (obj));
            i = i1;
            do {
                obj = layoutstate;
                if (k == j)
                    break;
                obj = mSpans[k];
                int j1 = ((Span) (obj)).getEndLine(i2);
                if (j1 < i) {
                    layoutstate = ((LayoutState) (obj));
                    i = j1;
                }
                k += byte0;
            } while (true);
        } else {
            int j2 = mPrimaryOrientation.getEndAfterPadding();
            int k1 = 0x80000000;
            int l = i;
            layoutstate = obj1;
            i = k1;
            do {
                obj = layoutstate;
                if (l == j)
                    break;
                obj = mSpans[l];
                int l1 = ((Span) (obj)).getStartLine(j2);
                if (l1 > i) {
                    layoutstate = ((LayoutState) (obj));
                    i = l1;
                }
                l += byte0;
            } while (true);
        }
        return ((Span) (obj));
    }

    private void handleUpdate(int i, int j, int k) {
        int l;
        int i1;
        int j1;
        if (mShouldReverseLayout)
            j1 = getLastChildPosition();
        else
            j1 = getFirstChildPosition();
        if (k == 8) {
            if (i < j) {
                i1 = j + 1;
                l = i;
            } else {
                i1 = i + 1;
                l = j;
            }
        } else {
            i1 = i + j;
            l = i;
        }
        mLazySpanLookup.invalidateAfter(l);
        k;
        JVM INSTR lookupswitch 3: default 76
    //                   1: 115
    //                   2: 127
    //                   8: 139;
           goto _L1 _L2 _L3 _L4
_L1:
        break; /* Loop/switch isn't completed */
_L4:
        break MISSING_BLOCK_LABEL_139;
_L5:
        if (i1 > j1) {
            if (mShouldReverseLayout)
                i = getFirstChildPosition();
            else
                i = getLastChildPosition();
            if (l <= i)
                requestLayout();
        }
        return;
_L2:
        mLazySpanLookup.offsetForAddition(i, j);
          goto _L5
_L3:
        mLazySpanLookup.offsetForRemoval(i, j);
          goto _L5
        mLazySpanLookup.offsetForRemoval(i, 1);
        mLazySpanLookup.offsetForAddition(j, 1);
          goto _L5
    }

    private void measureChildWithDecorationsAndMargin(View view, int i, int j, boolean flag) {
        calculateItemDecorationsForChild(view, mTmpRect);
        LayoutParams layoutparams = (LayoutParams)view.getLayoutParams();
        i = updateSpecWithExtra(i, layoutparams.leftMargin + mTmpRect.left, layoutparams.rightMargin + mTmpRect.right);
        j = updateSpecWithExtra(j, layoutparams.topMargin + mTmpRect.top, layoutparams.bottomMargin + mTmpRect.bottom);
        if (flag)
            flag = shouldReMeasureChild(view, i, j, layoutparams);
        else
            flag = shouldMeasureChild(view, i, j, layoutparams);
        if (flag)
            view.measure(i, j);
    }

    private void measureChildWithDecorationsAndMargin(View view, LayoutParams layoutparams, boolean flag) {
        if (layoutparams.mFullSpan) {
            if (mOrientation == 1)
                measureChildWithDecorationsAndMargin(view, mFullSizeSpec, getChildMeasureSpec(getHeight(), getHeightMode(), 0, layoutparams.height, true), flag);
            else
                measureChildWithDecorationsAndMargin(view, getChildMeasureSpec(getWidth(), getWidthMode(), 0, layoutparams.width, true), mFullSizeSpec, flag);
        } else
        if (mOrientation == 1)
            measureChildWithDecorationsAndMargin(view, getChildMeasureSpec(mSizePerSpan, getWidthMode(), 0, layoutparams.width, false), getChildMeasureSpec(getHeight(), getHeightMode(), 0, layoutparams.height, true), flag);
        else
            measureChildWithDecorationsAndMargin(view, getChildMeasureSpec(getWidth(), getWidthMode(), 0, layoutparams.width, true), getChildMeasureSpec(mSizePerSpan, getHeightMode(), 0, layoutparams.height, false), flag);
    }

    private void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state, boolean flag) {
        AnchorInfo anchorinfo = mAnchorInfo;
        if (mPendingSavedState == null && mPendingScrollPosition == -1 || state.getItemCount() != 0) goto _L2; else goto _L1
_L1:
        removeAndRecycleAllViews(recycler);
        anchorinfo.reset();
_L4:
        return;
_L2:
        boolean flag1;
        if (!anchorinfo.mValid || mPendingScrollPosition != -1 || mPendingSavedState != null) {
            anchorinfo.reset();
            int i;
            if (mPendingSavedState != null) {
                applyPendingSavedState(anchorinfo);
            } else {
                resolveShouldLayoutReverse();
                anchorinfo.mLayoutFromEnd = mShouldReverseLayout;
            }
            updateAnchorInfoForLayout(state, anchorinfo);
            anchorinfo.mValid = true;
        }
        if (mPendingSavedState == null && mPendingScrollPosition == -1 && (anchorinfo.mLayoutFromEnd != mLastLayoutFromEnd || isLayoutRTL() != mLastLayoutRTL)) {
            mLazySpanLookup.clear();
            anchorinfo.mInvalidateOffsets = true;
        }
        if (getChildCount() > 0 && (mPendingSavedState == null || mPendingSavedState.mSpanOffsetsSize < 1))
            if (anchorinfo.mInvalidateOffsets) {
                for (i = 0; i < mSpanCount; i++) {
                    mSpans[i].clear();
                    if (anchorinfo.mOffset != 0x80000000)
                        mSpans[i].setLine(anchorinfo.mOffset);
                }

            } else {
                for (int j = 0; j < mSpanCount; j++)
                    mSpans[j].cacheReferenceLineAndClear(mShouldReverseLayout, anchorinfo.mOffset);

            }
        detachAndScrapAttachedViews(recycler);
        mLayoutState.mRecycle = false;
        mLaidOutInvalidFullSpan = false;
        updateMeasureSpecs(mSecondaryOrientation.getTotalSpace());
        updateLayoutState(anchorinfo.mPosition, state);
        if (anchorinfo.mLayoutFromEnd) {
            setLayoutStateDirection(-1);
            fill(recycler, mLayoutState, state);
            setLayoutStateDirection(1);
            mLayoutState.mCurrentPosition = anchorinfo.mPosition + mLayoutState.mItemDirection;
            fill(recycler, mLayoutState, state);
        } else {
            setLayoutStateDirection(1);
            fill(recycler, mLayoutState, state);
            setLayoutStateDirection(-1);
            mLayoutState.mCurrentPosition = anchorinfo.mPosition + mLayoutState.mItemDirection;
            fill(recycler, mLayoutState, state);
        }
        repositionToWrapContentIfNecessary();
        if (getChildCount() > 0)
            if (mShouldReverseLayout) {
                fixEndGap(recycler, state, true);
                fixStartGap(recycler, state, false);
            } else {
                fixStartGap(recycler, state, true);
                fixEndGap(recycler, state, false);
            }
        if (!flag || state.isPreLayout())
            break; /* Loop/switch isn't completed */
        if (mGapStrategy != 0 && getChildCount() > 0 && (mLaidOutInvalidFullSpan || hasGapsToFix() != null))
            flag1 = true;
        else
            flag1 = false;
        if (!flag1)
            break; /* Loop/switch isn't completed */
        removeCallbacks(mCheckForGapsRunnable);
        if (!checkForGaps())
            break; /* Loop/switch isn't completed */
        flag1 = true;
_L5:
        if (state.isPreLayout())
            mAnchorInfo.reset();
        mLastLayoutFromEnd = anchorinfo.mLayoutFromEnd;
        mLastLayoutRTL = isLayoutRTL();
        if (flag1) {
            mAnchorInfo.reset();
            onLayoutChildren(recycler, state, false);
        }
        if (true) goto _L4; else goto _L3
_L3:
        flag1 = false;
          goto _L5
        if (true) goto _L4; else goto _L6
_L6:
    }

    private boolean preferLastSpan(int i) {
        boolean flag2 = true;
        if (mOrientation != 0) goto _L2; else goto _L1
_L1:
        boolean flag;
        if (i == -1)
            flag = true;
        else
            flag = false;
        if (flag != mShouldReverseLayout)
            flag = flag2;
        else
            flag = false;
_L4:
        return flag;
_L2:
        boolean flag1;
        if (i == -1)
            flag = true;
        else
            flag = false;
        if (flag == mShouldReverseLayout)
            flag1 = true;
        else
            flag1 = false;
        flag = flag2;
        if (flag1 != isLayoutRTL())
            flag = false;
        if (true) goto _L4; else goto _L3
_L3:
    }

    private void prependViewToAllSpans(View view) {
        for (int i = mSpanCount - 1; i >= 0; i--)
            mSpans[i].prependToSpan(view);

    }

    private void recycle(RecyclerView.Recycler recycler, LayoutState layoutstate) {
        if (layoutstate.mRecycle && !layoutstate.mInfinite)
            if (layoutstate.mAvailable == 0) {
                if (layoutstate.mLayoutDirection == -1)
                    recycleFromEnd(recycler, layoutstate.mEndLine);
                else
                    recycleFromStart(recycler, layoutstate.mStartLine);
            } else
            if (layoutstate.mLayoutDirection == -1) {
                int i = layoutstate.mStartLine - getMaxStart(layoutstate.mStartLine);
                if (i < 0)
                    i = layoutstate.mEndLine;
                else
                    i = layoutstate.mEndLine - Math.min(i, layoutstate.mAvailable);
                recycleFromEnd(recycler, i);
            } else {
                int j = getMinEnd(layoutstate.mEndLine) - layoutstate.mEndLine;
                if (j < 0) {
                    j = layoutstate.mStartLine;
                } else {
                    int k = layoutstate.mStartLine;
                    j = Math.min(j, layoutstate.mAvailable) + k;
                }
                recycleFromStart(recycler, j);
            }
    }

    private void recycleFromEnd(RecyclerView.Recycler recycler, int i) {
        int j = getChildCount() - 1;
_L12:
        if (j < 0) goto _L2; else goto _L1
_L1:
        View view = getChildAt(j);
        if (mPrimaryOrientation.getDecoratedStart(view) < i || mPrimaryOrientation.getTransformedStartWithDecoration(view) < i) goto _L2; else goto _L3
_L3:
        LayoutParams layoutparams = (LayoutParams)view.getLayoutParams();
        if (!layoutparams.mFullSpan) goto _L5; else goto _L4
_L4:
        int k = 0;
_L9:
        if (k >= mSpanCount) goto _L7; else goto _L6
_L6:
        if (mSpans[k].mViews.size() != 1) goto _L8; else goto _L2
_L2:
        return;
_L8:
        k++;
          goto _L9
_L7:
        for (int l = 0; l < mSpanCount; l++)
            mSpans[l].popEnd();

        break; /* Loop/switch isn't completed */
_L5:
        if (layoutparams.mSpan.mViews.size() == 1)
            continue; /* Loop/switch isn't completed */
        layoutparams.mSpan.popEnd();
        break; /* Loop/switch isn't completed */
        if (true) goto _L2; else goto _L10
_L10:
        removeAndRecycleView(view, recycler);
        j--;
        if (true) goto _L12; else goto _L11
_L11:
    }

    private void recycleFromStart(RecyclerView.Recycler recycler, int i) {
_L12:
        if (getChildCount() <= 0) goto _L2; else goto _L1
_L1:
        View view = getChildAt(0);
        if (mPrimaryOrientation.getDecoratedEnd(view) > i || mPrimaryOrientation.getTransformedEndWithDecoration(view) > i) goto _L2; else goto _L3
_L3:
        LayoutParams layoutparams = (LayoutParams)view.getLayoutParams();
        if (!layoutparams.mFullSpan) goto _L5; else goto _L4
_L4:
        int j = 0;
_L9:
        if (j >= mSpanCount) goto _L7; else goto _L6
_L6:
        if (mSpans[j].mViews.size() != 1) goto _L8; else goto _L2
_L2:
        return;
_L8:
        j++;
          goto _L9
_L7:
        for (int k = 0; k < mSpanCount; k++)
            mSpans[k].popStart();

        break; /* Loop/switch isn't completed */
_L5:
        if (layoutparams.mSpan.mViews.size() == 1)
            continue; /* Loop/switch isn't completed */
        layoutparams.mSpan.popStart();
        break; /* Loop/switch isn't completed */
        if (true) goto _L2; else goto _L10
_L10:
        removeAndRecycleView(view, recycler);
        if (true) goto _L12; else goto _L11
_L11:
    }

    private void repositionToWrapContentIfNecessary() {
        if (mSecondaryOrientation.getMode() != 0x40000000) goto _L2; else goto _L1
_L1:
        return;
_L2:
        float f = 0.0F;
        int i1 = getChildCount();
        int i = 0;
        while (i < i1)  {
            View view = getChildAt(i);
            float f1 = mSecondaryOrientation.getDecoratedMeasurement(view);
            if (f1 >= f) {
                if (((LayoutParams)view.getLayoutParams()).isFullSpan())
                    f1 = (1.0F * f1) / (float)mSpanCount;
                f = Math.max(f, f1);
            }
            i++;
        }
        int j1 = mSizePerSpan;
        int k = Math.round((float)mSpanCount * f);
        i = k;
        if (mSecondaryOrientation.getMode() == 0x80000000)
            i = Math.min(k, mSecondaryOrientation.getTotalSpace());
        updateMeasureSpecs(i);
        if (mSizePerSpan != j1) {
            int j = 0;
            while (j < i1)  {
                View view1 = getChildAt(j);
                LayoutParams layoutparams = (LayoutParams)view1.getLayoutParams();
                if (!layoutparams.mFullSpan)
                    if (isLayoutRTL() && mOrientation == 1) {
                        view1.offsetLeftAndRight(-(mSpanCount - 1 - layoutparams.mSpan.mIndex) * mSizePerSpan - -(mSpanCount - 1 - layoutparams.mSpan.mIndex) * j1);
                    } else {
                        int l = layoutparams.mSpan.mIndex * mSizePerSpan;
                        int k1 = layoutparams.mSpan.mIndex * j1;
                        if (mOrientation == 1)
                            view1.offsetLeftAndRight(l - k1);
                        else
                            view1.offsetTopAndBottom(l - k1);
                    }
                j++;
            }
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    private void resolveShouldLayoutReverse() {
        boolean flag = true;
        if (mOrientation == 1 || !isLayoutRTL()) {
            mShouldReverseLayout = mReverseLayout;
        } else {
            if (mReverseLayout)
                flag = false;
            mShouldReverseLayout = flag;
        }
    }

    private void setLayoutStateDirection(int i) {
        boolean flag = true;
        mLayoutState.mLayoutDirection = i;
        LayoutState layoutstate = mLayoutState;
        boolean flag2 = mShouldReverseLayout;
        boolean flag1;
        if (i == -1)
            flag1 = true;
        else
            flag1 = false;
        if (flag2 == flag1)
            i = ((flag) ? 1 : 0);
        else
            i = -1;
        layoutstate.mItemDirection = i;
    }

    private void updateAllRemainingSpans(int i, int j) {
        int k = 0;
        while (k < mSpanCount)  {
            if (!mSpans[k].mViews.isEmpty())
                updateRemainingSpans(mSpans[k], i, j);
            k++;
        }
    }

    private boolean updateAnchorFromChildren(RecyclerView.State state, AnchorInfo anchorinfo) {
        int i;
        if (mLastLayoutFromEnd)
            i = findLastReferenceChildPosition(state.getItemCount());
        else
            i = findFirstReferenceChildPosition(state.getItemCount());
        anchorinfo.mPosition = i;
        anchorinfo.mOffset = 0x80000000;
        return true;
    }

    private void updateLayoutState(int i, RecyclerView.State state) {
        boolean flag1;
        flag1 = false;
        mLayoutState.mAvailable = 0;
        mLayoutState.mCurrentPosition = i;
        if (!isSmoothScrolling()) goto _L2; else goto _L1
_L1:
        int j = state.getTargetScrollPosition();
        if (j == -1) goto _L2; else goto _L3
_L3:
        boolean flag2 = mShouldReverseLayout;
        boolean flag;
        if (j < i)
            flag = true;
        else
            flag = false;
        if (flag2 == flag) {
            i = mPrimaryOrientation.getTotalSpace();
            j = 0;
        } else {
            j = mPrimaryOrientation.getTotalSpace();
            i = 0;
        }
_L5:
        if (getClipToPadding()) {
            mLayoutState.mStartLine = mPrimaryOrientation.getStartAfterPadding() - j;
            mLayoutState.mEndLine = i + mPrimaryOrientation.getEndAfterPadding();
        } else {
            mLayoutState.mEndLine = i + mPrimaryOrientation.getEnd();
            mLayoutState.mStartLine = -j;
        }
        mLayoutState.mStopInFocusable = false;
        mLayoutState.mRecycle = true;
        state = mLayoutState;
        flag = flag1;
        if (mPrimaryOrientation.getMode() == 0) {
            flag = flag1;
            if (mPrimaryOrientation.getEnd() == 0)
                flag = true;
        }
        state.mInfinite = flag;
        return;
_L2:
        i = 0;
        j = 0;
        if (true) goto _L5; else goto _L4
_L4:
    }

    private void updateRemainingSpans(Span span, int i, int j) {
        int k = span.getDeletedSize();
        if (i != -1) goto _L2; else goto _L1
_L1:
        if (k + span.getStartLine() <= j)
            mRemainingSpans.set(span.mIndex, false);
_L4:
        return;
_L2:
        if (span.getEndLine() - k >= j)
            mRemainingSpans.set(span.mIndex, false);
        if (true) goto _L4; else goto _L3
_L3:
    }

    private int updateSpecWithExtra(int i, int j, int k) {
        if (j != 0 || k != 0) goto _L2; else goto _L1
_L1:
        int l = i;
_L4:
        return l;
_L2:
        int i1 = android.view.View.MeasureSpec.getMode(i);
        if (i1 != 0x80000000) {
            l = i;
            if (i1 != 0x40000000)
                continue; /* Loop/switch isn't completed */
        }
        l = android.view.View.MeasureSpec.makeMeasureSpec(Math.max(0, android.view.View.MeasureSpec.getSize(i) - j - k), i1);
        if (true) goto _L4; else goto _L3
_L3:
    }

    boolean areAllEndsEqual() {
        boolean flag1 = true;
        int j = mSpans[0].getEndLine(0x80000000);
        int i = 1;
        do {
label0:
            {
                boolean flag = flag1;
                if (i < mSpanCount) {
                    if (mSpans[i].getEndLine(0x80000000) == j)
                        break label0;
                    flag = false;
                }
                return flag;
            }
            i++;
        } while (true);
    }

    boolean areAllStartsEqual() {
        boolean flag1 = true;
        int j = mSpans[0].getStartLine(0x80000000);
        int i = 1;
        do {
label0:
            {
                boolean flag = flag1;
                if (i < mSpanCount) {
                    if (mSpans[i].getStartLine(0x80000000) == j)
                        break label0;
                    flag = false;
                }
                return flag;
            }
            i++;
        } while (true);
    }

    public void assertNotInLayoutOrScroll(String s) {
        if (mPendingSavedState == null)
            super.assertNotInLayoutOrScroll(s);
    }

    public boolean canScrollHorizontally() {
        boolean flag;
        if (mOrientation == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean canScrollVertically() {
        boolean flag = true;
        if (mOrientation != 1)
            flag = false;
        return flag;
    }

    boolean checkForGaps() {
        boolean flag = true;
        if (getChildCount() == 0 || mGapStrategy == 0 || !isAttachedToWindow()) {
            flag = false;
        } else {
            int i;
            int j;
            if (mShouldReverseLayout) {
                j = getLastChildPosition();
                i = getFirstChildPosition();
            } else {
                j = getFirstChildPosition();
                i = getLastChildPosition();
            }
            if (j == 0 && hasGapsToFix() != null) {
                mLazySpanLookup.clear();
                requestSimpleAnimationsInNextLayout();
                requestLayout();
            } else
            if (!mLaidOutInvalidFullSpan) {
                flag = false;
            } else {
                byte byte0;
                LazySpanLookup.FullSpanItem fullspanitem1;
                if (mShouldReverseLayout)
                    byte0 = -1;
                else
                    byte0 = 1;
                fullspanitem1 = mLazySpanLookup.getFirstFullSpanItemInRange(j, i + 1, byte0, true);
                if (fullspanitem1 == null) {
                    mLaidOutInvalidFullSpan = false;
                    mLazySpanLookup.forceInvalidateAfter(i + 1);
                    flag = false;
                } else {
                    LazySpanLookup.FullSpanItem fullspanitem = mLazySpanLookup.getFirstFullSpanItemInRange(j, fullspanitem1.mPosition, byte0 * -1, true);
                    if (fullspanitem == null)
                        mLazySpanLookup.forceInvalidateAfter(fullspanitem1.mPosition);
                    else
                        mLazySpanLookup.forceInvalidateAfter(fullspanitem.mPosition + 1);
                    requestSimpleAnimationsInNextLayout();
                    requestLayout();
                }
            }
        }
        return flag;
    }

    public boolean checkLayoutParams(RecyclerView.LayoutParams layoutparams) {
        return layoutparams instanceof LayoutParams;
    }

    public int computeHorizontalScrollExtent(RecyclerView.State state) {
        return computeScrollExtent(state);
    }

    public int computeHorizontalScrollOffset(RecyclerView.State state) {
        return computeScrollOffset(state);
    }

    public int computeHorizontalScrollRange(RecyclerView.State state) {
        return computeScrollRange(state);
    }

    public PointF computeScrollVectorForPosition(int i) {
        i = calculateScrollDirectionForPosition(i);
        PointF pointf = new PointF();
        if (i == 0)
            pointf = null;
        else
        if (mOrientation == 0) {
            pointf.x = i;
            pointf.y = 0.0F;
        } else {
            pointf.x = 0.0F;
            pointf.y = i;
        }
        return pointf;
    }

    public int computeVerticalScrollExtent(RecyclerView.State state) {
        return computeScrollExtent(state);
    }

    public int computeVerticalScrollOffset(RecyclerView.State state) {
        return computeScrollOffset(state);
    }

    public int computeVerticalScrollRange(RecyclerView.State state) {
        return computeScrollRange(state);
    }

    public int[] findFirstCompletelyVisibleItemPositions(int ai[]) {
        int i;
        int ai1[];
        if (ai == null) {
            ai1 = new int[mSpanCount];
        } else {
            ai1 = ai;
            if (ai.length < mSpanCount)
                throw new IllegalArgumentException((new StringBuilder()).append("Provided int[]'s size must be more than or equal to span count. Expected:").append(mSpanCount).append(", array size:").append(ai.length).toString());
        }
        for (i = 0; i < mSpanCount; i++)
            ai1[i] = mSpans[i].findFirstCompletelyVisibleItemPosition();

        return ai1;
    }

    View findFirstVisibleItemClosestToEnd(boolean flag, boolean flag1) {
        int i;
        int j;
        int k;
        Object obj;
        k = mPrimaryOrientation.getStartAfterPadding();
        j = mPrimaryOrientation.getEndAfterPadding();
        i = getChildCount() - 1;
        obj = null;
_L2:
        int l;
        View view;
        View view1;
        if (i < 0)
            break MISSING_BLOCK_LABEL_139;
        view = getChildAt(i);
        int i1 = mPrimaryOrientation.getDecoratedStart(view);
        l = mPrimaryOrientation.getDecoratedEnd(view);
        view1 = obj;
        if (l > k) {
            if (i1 < j)
                break; /* Loop/switch isn't completed */
            view1 = obj;
        }
_L7:
        i--;
        obj = view1;
        if (true) goto _L2; else goto _L1
_L1:
        view1 = view;
        if (l <= j) goto _L4; else goto _L3
_L3:
        if (flag) goto _L6; else goto _L5
_L5:
        view1 = view;
_L4:
        return view1;
_L6:
        view1 = obj;
        if (flag1) {
            view1 = obj;
            if (obj == null)
                view1 = view;
        }
          goto _L7
        view1 = obj;
          goto _L4
    }

    View findFirstVisibleItemClosestToStart(boolean flag, boolean flag1) {
        int i;
        int j;
        int k;
        int l;
        Object obj;
        j = mPrimaryOrientation.getStartAfterPadding();
        l = mPrimaryOrientation.getEndAfterPadding();
        k = getChildCount();
        i = 0;
        obj = null;
_L2:
        int i1;
        View view;
        View view1;
        if (i >= k)
            break MISSING_BLOCK_LABEL_138;
        view = getChildAt(i);
        i1 = mPrimaryOrientation.getDecoratedStart(view);
        view1 = obj;
        if (mPrimaryOrientation.getDecoratedEnd(view) > j) {
            if (i1 < l)
                break; /* Loop/switch isn't completed */
            view1 = obj;
        }
_L7:
        i++;
        obj = view1;
        if (true) goto _L2; else goto _L1
_L1:
        view1 = view;
        if (i1 >= j) goto _L4; else goto _L3
_L3:
        if (flag) goto _L6; else goto _L5
_L5:
        view1 = view;
_L4:
        return view1;
_L6:
        view1 = obj;
        if (flag1) {
            view1 = obj;
            if (obj == null)
                view1 = view;
        }
          goto _L7
        view1 = obj;
          goto _L4
    }

    int findFirstVisibleItemPositionInt() {
        int i;
        View view;
        if (mShouldReverseLayout)
            view = findFirstVisibleItemClosestToEnd(true, true);
        else
            view = findFirstVisibleItemClosestToStart(true, true);
        if (view == null)
            i = -1;
        else
            i = getPosition(view);
        return i;
    }

    public int[] findFirstVisibleItemPositions(int ai[]) {
        int i;
        int ai1[];
        if (ai == null) {
            ai1 = new int[mSpanCount];
        } else {
            ai1 = ai;
            if (ai.length < mSpanCount)
                throw new IllegalArgumentException((new StringBuilder()).append("Provided int[]'s size must be more than or equal to span count. Expected:").append(mSpanCount).append(", array size:").append(ai.length).toString());
        }
        for (i = 0; i < mSpanCount; i++)
            ai1[i] = mSpans[i].findFirstVisibleItemPosition();

        return ai1;
    }

    public int[] findLastCompletelyVisibleItemPositions(int ai[]) {
        int i;
        int ai1[];
        if (ai == null) {
            ai1 = new int[mSpanCount];
        } else {
            ai1 = ai;
            if (ai.length < mSpanCount)
                throw new IllegalArgumentException((new StringBuilder()).append("Provided int[]'s size must be more than or equal to span count. Expected:").append(mSpanCount).append(", array size:").append(ai.length).toString());
        }
        for (i = 0; i < mSpanCount; i++)
            ai1[i] = mSpans[i].findLastCompletelyVisibleItemPosition();

        return ai1;
    }

    public int[] findLastVisibleItemPositions(int ai[]) {
        int i;
        int ai1[];
        if (ai == null) {
            ai1 = new int[mSpanCount];
        } else {
            ai1 = ai;
            if (ai.length < mSpanCount)
                throw new IllegalArgumentException((new StringBuilder()).append("Provided int[]'s size must be more than or equal to span count. Expected:").append(mSpanCount).append(", array size:").append(ai.length).toString());
        }
        for (i = 0; i < mSpanCount; i++)
            ai1[i] = mSpans[i].findLastVisibleItemPosition();

        return ai1;
    }

    public RecyclerView.LayoutParams generateDefaultLayoutParams() {
        LayoutParams layoutparams;
        if (mOrientation == 0)
            layoutparams = new LayoutParams(-2, -1);
        else
            layoutparams = new LayoutParams(-1, -2);
        return layoutparams;
    }

    public RecyclerView.LayoutParams generateLayoutParams(Context context, AttributeSet attributeset) {
        return new LayoutParams(context, attributeset);
    }

    public RecyclerView.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams layoutparams) {
        if (layoutparams instanceof android.view.ViewGroup.MarginLayoutParams)
            layoutparams = new LayoutParams((android.view.ViewGroup.MarginLayoutParams)layoutparams);
        else
            layoutparams = new LayoutParams(layoutparams);
        return layoutparams;
    }

    public int getColumnCountForAccessibility(RecyclerView.Recycler recycler, RecyclerView.State state) {
        int i;
        if (mOrientation == 1)
            i = mSpanCount;
        else
            i = super.getColumnCountForAccessibility(recycler, state);
        return i;
    }

    public int getGapStrategy() {
        return mGapStrategy;
    }

    public int getOrientation() {
        return mOrientation;
    }

    public boolean getReverseLayout() {
        return mReverseLayout;
    }

    public int getRowCountForAccessibility(RecyclerView.Recycler recycler, RecyclerView.State state) {
        int i;
        if (mOrientation == 0)
            i = mSpanCount;
        else
            i = super.getRowCountForAccessibility(recycler, state);
        return i;
    }

    public int getSpanCount() {
        return mSpanCount;
    }

    View hasGapsToFix() {
        byte byte0;
        int k;
        byte byte1;
        int l;
        View view;
        LayoutParams layoutparams;
        BitSet bitset;
        int i = getChildCount() - 1;
        bitset = new BitSet(mSpanCount);
        bitset.set(0, mSpanCount, true);
        if (mOrientation == 1 && isLayoutRTL())
            byte0 = 1;
        else
            byte0 = -1;
        if (mShouldReverseLayout) {
            k = -1;
        } else {
            k = i + 1;
            i = 0;
        }
        if (i < k)
            byte1 = 1;
        else
            byte1 = -1;
        l = i;
_L7:
        if (l == k) goto _L2; else goto _L1
_L1:
        view = getChildAt(l);
        layoutparams = (LayoutParams)view.getLayoutParams();
        if (!bitset.get(layoutparams.mSpan.mIndex)) goto _L4; else goto _L3
_L3:
        if (!checkSpanForGap(layoutparams.mSpan)) goto _L6; else goto _L5
_L5:
        return view;
_L6:
        bitset.clear(layoutparams.mSpan.mIndex);
          goto _L4
_L9:
        l += byte1;
          goto _L7
_L4:
        if (layoutparams.mFullSpan || l + byte1 == k) goto _L9; else goto _L8
_L8:
        Object obj = getChildAt(l + byte1);
        if (!mShouldReverseLayout) goto _L11; else goto _L10
_L10:
        int j;
        int i1;
        i1 = mPrimaryOrientation.getDecoratedEnd(view);
        j = mPrimaryOrientation.getDecoratedEnd(((View) (obj)));
        if (i1 >= j) goto _L12; else goto _L5
_L12:
        if (i1 != j)
            break MISSING_BLOCK_LABEL_349;
        j = 1;
_L15:
        if (j == 0) goto _L9; else goto _L13
_L13:
        obj = (LayoutParams)((View) (obj)).getLayoutParams();
        int j1;
        if (layoutparams.mSpan.mIndex - ((LayoutParams) (obj)).mSpan.mIndex < 0)
            j = 1;
        else
            j = 0;
        if (byte0 < 0)
            j1 = 1;
        else
            j1 = 0;
        if (j == j1) goto _L9; else goto _L5
_L11:
        j = mPrimaryOrientation.getDecoratedStart(view);
        j1 = mPrimaryOrientation.getDecoratedStart(((View) (obj)));
        if (j <= j1) goto _L14; else goto _L5
_L14:
        if (j != j1)
            break MISSING_BLOCK_LABEL_349;
        j = 1;
          goto _L15
_L2:
        view = null;
          goto _L5
        j = 0;
          goto _L15
    }

    public void invalidateSpanAssignments() {
        mLazySpanLookup.clear();
        requestLayout();
    }

    boolean isLayoutRTL() {
        boolean flag = true;
        if (getLayoutDirection() != 1)
            flag = false;
        return flag;
    }

    public void offsetChildrenHorizontal(int i) {
        super.offsetChildrenHorizontal(i);
        for (int j = 0; j < mSpanCount; j++)
            mSpans[j].onOffset(i);

    }

    public void offsetChildrenVertical(int i) {
        super.offsetChildrenVertical(i);
        for (int j = 0; j < mSpanCount; j++)
            mSpans[j].onOffset(i);

    }

    public void onDetachedFromWindow(RecyclerView recyclerview, RecyclerView.Recycler recycler) {
        removeCallbacks(mCheckForGapsRunnable);
        for (int i = 0; i < mSpanCount; i++)
            mSpans[i].clear();

        recyclerview.requestLayout();
    }

    public View onFocusSearchFailed(View view, int i, RecyclerView.Recycler recycler, RecyclerView.State state) {
        int j = 0;
        if (getChildCount() != 0) goto _L2; else goto _L1
_L1:
        view = null;
_L8:
        return view;
_L2:
        int k;
        View view1;
        view1 = findContainingItemView(view);
        if (view1 == null) {
            view = null;
            continue; /* Loop/switch isn't completed */
        }
        resolveShouldLayoutReverse();
        k = convertFocusDirectionToLayoutDirection(i);
        if (k == 0x80000000) {
            view = null;
            continue; /* Loop/switch isn't completed */
        }
        view = (LayoutParams)view1.getLayoutParams();
        boolean flag = ((LayoutParams) (view)).mFullSpan;
        view = ((LayoutParams) (view)).mSpan;
        if (k == 1)
            i = getLastChildPosition();
        else
            i = getFirstChildPosition();
        updateLayoutState(i, state);
        setLayoutStateDirection(k);
        mLayoutState.mCurrentPosition = mLayoutState.mItemDirection + i;
        mLayoutState.mAvailable = (int)(0.3333333F * (float)mPrimaryOrientation.getTotalSpace());
        mLayoutState.mStopInFocusable = true;
        mLayoutState.mRecycle = false;
        fill(recycler, mLayoutState, state);
        mLastLayoutFromEnd = mShouldReverseLayout;
        if (!flag) {
            view = view.getFocusableViewAfter(i, k);
            if (view != null && view != view1)
                continue; /* Loop/switch isn't completed */
        }
        if (!preferLastSpan(k)) goto _L4; else goto _L3
_L3:
        for (j = mSpanCount - 1; j >= 0; j--) {
            view = mSpans[j].getFocusableViewAfter(i, k);
            if (view != null && view != view1)
                continue; /* Loop/switch isn't completed */
        }

          goto _L5
_L6:
        j++;
_L4:
        if (j >= mSpanCount)
            break; /* Loop/switch isn't completed */
        view = mSpans[j].getFocusableViewAfter(i, k);
        if (view != null && view != view1)
            continue; /* Loop/switch isn't completed */
        if (true) goto _L6; else goto _L5
_L5:
        view = null;
        if (true) goto _L8; else goto _L7
_L7:
    }

    public void onInitializeAccessibilityEvent(AccessibilityEvent accessibilityevent) {
        super.onInitializeAccessibilityEvent(accessibilityevent);
        if (getChildCount() > 0) {
            AccessibilityRecordCompat accessibilityrecordcompat = AccessibilityEventCompat.asRecord(accessibilityevent);
            accessibilityevent = findFirstVisibleItemClosestToStart(false, true);
            View view = findFirstVisibleItemClosestToEnd(false, true);
            if (accessibilityevent != null && view != null) {
                int j = getPosition(accessibilityevent);
                int i = getPosition(view);
                if (j < i) {
                    accessibilityrecordcompat.setFromIndex(j);
                    accessibilityrecordcompat.setToIndex(i);
                } else {
                    accessibilityrecordcompat.setFromIndex(i);
                    accessibilityrecordcompat.setToIndex(j);
                }
            }
        }
    }

    public void onInitializeAccessibilityNodeInfoForItem(RecyclerView.Recycler recycler, RecyclerView.State state, View view, AccessibilityNodeInfoCompat accessibilitynodeinfocompat) {
        recycler = view.getLayoutParams();
        if (!(recycler instanceof LayoutParams)) {
            super.onInitializeAccessibilityNodeInfoForItem(view, accessibilitynodeinfocompat);
        } else {
            recycler = (LayoutParams)recycler;
            if (mOrientation == 0) {
                int k = recycler.getSpanIndex();
                int i;
                if (((LayoutParams) (recycler)).mFullSpan)
                    i = mSpanCount;
                else
                    i = 1;
                accessibilitynodeinfocompat.setCollectionItemInfo(android.support.v4.view.accessibility.AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(k, i, -1, -1, ((LayoutParams) (recycler)).mFullSpan, false));
            } else {
                int l = recycler.getSpanIndex();
                int j;
                if (((LayoutParams) (recycler)).mFullSpan)
                    j = mSpanCount;
                else
                    j = 1;
                accessibilitynodeinfocompat.setCollectionItemInfo(android.support.v4.view.accessibility.AccessibilityNodeInfoCompat.CollectionItemInfoCompat.obtain(-1, -1, l, j, ((LayoutParams) (recycler)).mFullSpan, false));
            }
        }
    }

    public void onItemsAdded(RecyclerView recyclerview, int i, int j) {
        handleUpdate(i, j, 1);
    }

    public void onItemsChanged(RecyclerView recyclerview) {
        mLazySpanLookup.clear();
        requestLayout();
    }

    public void onItemsMoved(RecyclerView recyclerview, int i, int j, int k) {
        handleUpdate(i, j, 8);
    }

    public void onItemsRemoved(RecyclerView recyclerview, int i, int j) {
        handleUpdate(i, j, 2);
    }

    public void onItemsUpdated(RecyclerView recyclerview, int i, int j, Object obj) {
        handleUpdate(i, j, 4);
    }

    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        onLayoutChildren(recycler, state, true);
    }

    public void onLayoutCompleted(RecyclerView.State state) {
        super.onLayoutCompleted(state);
        mPendingScrollPosition = -1;
        mPendingScrollPositionOffset = 0x80000000;
        mPendingSavedState = null;
        mAnchorInfo.reset();
    }

    public void onRestoreInstanceState(Parcelable parcelable) {
        if (parcelable instanceof SavedState) {
            mPendingSavedState = (SavedState)parcelable;
            requestLayout();
        }
    }

    public Parcelable onSaveInstanceState() {
        if (mPendingSavedState == null) goto _L2; else goto _L1
_L1:
        SavedState savedstate = new SavedState(mPendingSavedState);
_L10:
        return savedstate;
_L2:
        int i;
        int j;
        savedstate = new SavedState();
        savedstate.mReverseLayout = mReverseLayout;
        savedstate.mAnchorLayoutFromEnd = mLastLayoutFromEnd;
        savedstate.mLastLayoutRTL = mLastLayoutRTL;
        int k;
        if (mLazySpanLookup != null && mLazySpanLookup.mData != null) {
            savedstate.mSpanLookup = mLazySpanLookup.mData;
            savedstate.mSpanLookupSize = savedstate.mSpanLookup.length;
            savedstate.mFullSpanItems = mLazySpanLookup.mFullSpanItems;
        } else {
            savedstate.mSpanLookupSize = 0;
        }
        if (getChildCount() <= 0)
            break MISSING_BLOCK_LABEL_276;
        if (mLastLayoutFromEnd)
            i = getLastChildPosition();
        else
            i = getFirstChildPosition();
        savedstate.mAnchorPosition = i;
        savedstate.mVisibleAnchorPosition = findFirstVisibleItemPositionInt();
        savedstate.mSpanOffsetsSize = mSpanCount;
        savedstate.mSpanOffsets = new int[mSpanCount];
        j = 0;
_L8:
        if (j >= mSpanCount)
            continue; /* Loop/switch isn't completed */
        if (!mLastLayoutFromEnd)
            break; /* Loop/switch isn't completed */
        k = mSpans[j].getEndLine(0x80000000);
        i = k;
        if (k != 0x80000000)
            i = k - mPrimaryOrientation.getEndAfterPadding();
_L6:
        savedstate.mSpanOffsets[j] = i;
        j++;
        if (true) goto _L4; else goto _L3
_L4:
        break MISSING_BLOCK_LABEL_167;
_L3:
        int l = mSpans[j].getStartLine(0x80000000);
        i = l;
        if (l != 0x80000000)
            i = l - mPrimaryOrientation.getStartAfterPadding();
        if (true) goto _L6; else goto _L5
_L5:
        if (true) goto _L8; else goto _L7
_L7:
        savedstate.mAnchorPosition = -1;
        savedstate.mVisibleAnchorPosition = -1;
        savedstate.mSpanOffsetsSize = 0;
        if (true) goto _L10; else goto _L9
_L9:
    }

    public void onScrollStateChanged(int i) {
        if (i == 0)
            checkForGaps();
    }

    int scrollBy(int i, RecyclerView.Recycler recycler, RecyclerView.State state) {
        int j;
        int k;
        if (i > 0) {
            k = getLastChildPosition();
            j = 1;
        } else {
            j = -1;
            k = getFirstChildPosition();
        }
        mLayoutState.mRecycle = true;
        updateLayoutState(k, state);
        setLayoutStateDirection(j);
        mLayoutState.mCurrentPosition = mLayoutState.mItemDirection + k;
        k = Math.abs(i);
        mLayoutState.mAvailable = k;
        j = fill(recycler, mLayoutState, state);
        if (k >= j)
            if (i < 0)
                i = -j;
            else
                i = j;
        mPrimaryOrientation.offsetChildren(-i);
        mLastLayoutFromEnd = mShouldReverseLayout;
        return i;
    }

    public int scrollHorizontallyBy(int i, RecyclerView.Recycler recycler, RecyclerView.State state) {
        return scrollBy(i, recycler, state);
    }

    public void scrollToPosition(int i) {
        if (mPendingSavedState != null && mPendingSavedState.mAnchorPosition != i)
            mPendingSavedState.invalidateAnchorPositionInfo();
        mPendingScrollPosition = i;
        mPendingScrollPositionOffset = 0x80000000;
        requestLayout();
    }

    public void scrollToPositionWithOffset(int i, int j) {
        if (mPendingSavedState != null)
            mPendingSavedState.invalidateAnchorPositionInfo();
        mPendingScrollPosition = i;
        mPendingScrollPositionOffset = j;
        requestLayout();
    }

    public int scrollVerticallyBy(int i, RecyclerView.Recycler recycler, RecyclerView.State state) {
        return scrollBy(i, recycler, state);
    }

    public void setGapStrategy(int i) {
        assertNotInLayoutOrScroll(null);
        if (i != mGapStrategy) {
            if (i != 0 && i != 2)
                throw new IllegalArgumentException("invalid gap strategy. Must be GAP_HANDLING_NONE or GAP_HANDLING_MOVE_ITEMS_BETWEEN_SPANS");
            mGapStrategy = i;
            boolean flag;
            if (mGapStrategy != 0)
                flag = true;
            else
                flag = false;
            setAutoMeasureEnabled(flag);
            requestLayout();
        }
    }

    public void setMeasuredDimension(Rect rect, int i, int j) {
        int k = getPaddingLeft();
        k = getPaddingRight() + k;
        int l = getPaddingTop() + getPaddingBottom();
        if (mOrientation == 1) {
            j = chooseSize(j, l + rect.height(), getMinimumHeight());
            i = chooseSize(i, k + mSizePerSpan * mSpanCount, getMinimumWidth());
        } else {
            i = chooseSize(i, k + rect.width(), getMinimumWidth());
            j = chooseSize(j, l + mSizePerSpan * mSpanCount, getMinimumHeight());
        }
        setMeasuredDimension(i, j);
    }

    public void setOrientation(int i) {
        if (i != 0 && i != 1)
            throw new IllegalArgumentException("invalid orientation.");
        assertNotInLayoutOrScroll(null);
        if (i != mOrientation) {
            mOrientation = i;
            OrientationHelper orientationhelper = mPrimaryOrientation;
            mPrimaryOrientation = mSecondaryOrientation;
            mSecondaryOrientation = orientationhelper;
            requestLayout();
        }
    }

    public void setReverseLayout(boolean flag) {
        assertNotInLayoutOrScroll(null);
        if (mPendingSavedState != null && mPendingSavedState.mReverseLayout != flag)
            mPendingSavedState.mReverseLayout = flag;
        mReverseLayout = flag;
        requestLayout();
    }

    public void setSpanCount(int i) {
        assertNotInLayoutOrScroll(null);
        if (i != mSpanCount) {
            invalidateSpanAssignments();
            mSpanCount = i;
            mRemainingSpans = new BitSet(mSpanCount);
            mSpans = new Span[mSpanCount];
            for (i = 0; i < mSpanCount; i++)
                mSpans[i] = new Span(i);

            requestLayout();
        }
    }

    public void smoothScrollToPosition(RecyclerView recyclerview, RecyclerView.State state, int i) {
        recyclerview = new LinearSmoothScroller(recyclerview.getContext());
        recyclerview.setTargetPosition(i);
        startSmoothScroll(recyclerview);
    }

    public boolean supportsPredictiveItemAnimations() {
        boolean flag;
        if (mPendingSavedState == null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    boolean updateAnchorFromPendingData(RecyclerView.State state, AnchorInfo anchorinfo) {
        boolean flag = false;
        boolean flag1 = true;
        if (state.isPreLayout() || mPendingScrollPosition == -1)
            flag = false;
        else
        if (mPendingScrollPosition < 0 || mPendingScrollPosition >= state.getItemCount()) {
            mPendingScrollPosition = -1;
            mPendingScrollPositionOffset = 0x80000000;
            flag = false;
        } else
        if (mPendingSavedState == null || mPendingSavedState.mAnchorPosition == -1 || mPendingSavedState.mSpanOffsetsSize < 1) {
            state = findViewByPosition(mPendingScrollPosition);
            if (state != null) {
                int i;
                if (mShouldReverseLayout)
                    i = getLastChildPosition();
                else
                    i = getFirstChildPosition();
                anchorinfo.mPosition = i;
                if (mPendingScrollPositionOffset != 0x80000000) {
                    if (anchorinfo.mLayoutFromEnd) {
                        anchorinfo.mOffset = mPrimaryOrientation.getEndAfterPadding() - mPendingScrollPositionOffset - mPrimaryOrientation.getDecoratedEnd(state);
                        flag = flag1;
                    } else {
                        anchorinfo.mOffset = (mPrimaryOrientation.getStartAfterPadding() + mPendingScrollPositionOffset) - mPrimaryOrientation.getDecoratedStart(state);
                        flag = flag1;
                    }
                } else
                if (mPrimaryOrientation.getDecoratedMeasurement(state) > mPrimaryOrientation.getTotalSpace()) {
                    int j;
                    if (anchorinfo.mLayoutFromEnd)
                        j = mPrimaryOrientation.getEndAfterPadding();
                    else
                        j = mPrimaryOrientation.getStartAfterPadding();
                    anchorinfo.mOffset = j;
                    flag = flag1;
                } else {
                    int k = mPrimaryOrientation.getDecoratedStart(state) - mPrimaryOrientation.getStartAfterPadding();
                    if (k < 0) {
                        anchorinfo.mOffset = -k;
                        flag = flag1;
                    } else {
                        int l = mPrimaryOrientation.getEndAfterPadding() - mPrimaryOrientation.getDecoratedEnd(state);
                        if (l < 0) {
                            anchorinfo.mOffset = l;
                            flag = flag1;
                        } else {
                            anchorinfo.mOffset = 0x80000000;
                            flag = flag1;
                        }
                    }
                }
            } else {
                anchorinfo.mPosition = mPendingScrollPosition;
                if (mPendingScrollPositionOffset == 0x80000000) {
                    if (calculateScrollDirectionForPosition(anchorinfo.mPosition) == 1)
                        flag = true;
                    anchorinfo.mLayoutFromEnd = flag;
                    anchorinfo.assignCoordinateFromPadding();
                } else {
                    anchorinfo.assignCoordinateFromPadding(mPendingScrollPositionOffset);
                }
                anchorinfo.mInvalidateOffsets = true;
                flag = flag1;
            }
        } else {
            anchorinfo.mOffset = 0x80000000;
            anchorinfo.mPosition = mPendingScrollPosition;
            flag = flag1;
        }
        return flag;
    }

    void updateAnchorInfoForLayout(RecyclerView.State state, AnchorInfo anchorinfo) {
        if (!updateAnchorFromPendingData(state, anchorinfo) && !updateAnchorFromChildren(state, anchorinfo)) {
            anchorinfo.assignCoordinateFromPadding();
            anchorinfo.mPosition = 0;
        }
    }

    void updateMeasureSpecs(int i) {
        mSizePerSpan = i / mSpanCount;
        mFullSizeSpec = android.view.View.MeasureSpec.makeMeasureSpec(i, mSecondaryOrientation.getMode());
    }
}
