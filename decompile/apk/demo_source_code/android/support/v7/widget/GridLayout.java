// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.v7.widget;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.support.v4.view.ViewCompat;
import android.support.v4.view.ViewGroupCompat;
import android.util.*;
import android.view.View;
import android.view.ViewGroup;
import java.lang.reflect.Array;
import java.util.*;

// Referenced classes of package android.support.v7.widget:
//            Space

public class GridLayout extends ViewGroup {
    public static abstract class Alignment {

        abstract int getAlignmentValue(View view, int i, int j);

        Bounds getBounds() {
            return new Bounds();
        }

        abstract String getDebugString();

        abstract int getGravityOffset(View view, int i);

        int getSizeInCell(View view, int i, int j) {
            return i;
        }

        public String toString() {
            return (new StringBuilder()).append("Alignment:").append(getDebugString()).toString();
        }

        Alignment() {
        }
    }

    static final class Arc {

        public final Interval span;
        public boolean valid;
        public final MutableInt value;

        public String toString() {
            StringBuilder stringbuilder = (new StringBuilder()).append(span).append(" ");
            String s;
            if (!valid)
                s = "+>";
            else
                s = "->";
            return stringbuilder.append(s).append(" ").append(value).toString();
        }

        public Arc(Interval interval, MutableInt mutableint) {
            valid = true;
            span = interval;
            value = mutableint;
        }
    }

    static final class Assoc extends ArrayList {

        private final Class keyType;
        private final Class valueType;

        public static Assoc of(Class class1, Class class2) {
            return new Assoc(class1, class2);
        }

        public PackedMap pack() {
            int j = size();
            Object aobj1[] = (Object[])(Object[])Array.newInstance(keyType, j);
            Object aobj[] = (Object[])(Object[])Array.newInstance(valueType, j);
            for (int i = 0; i < j; i++) {
                aobj1[i] = ((Pair)get(i)).first;
                aobj[i] = ((Pair)get(i)).second;
            }

            return new PackedMap(aobj1, aobj);
        }

        public void put(Object obj, Object obj1) {
            add(Pair.create(obj, obj1));
        }

        private Assoc(Class class1, Class class2) {
            keyType = class1;
            valueType = class2;
        }
    }

    final class Axis {

        static final boolean $assertionsDisabled;
        static final int COMPLETE = 2;
        static final int NEW = 0;
        static final int PENDING = 1;
        public Arc arcs[];
        public boolean arcsValid;
        PackedMap backwardLinks;
        public boolean backwardLinksValid;
        public int definedCount;
        public int deltas[];
        PackedMap forwardLinks;
        public boolean forwardLinksValid;
        PackedMap groupBounds;
        public boolean groupBoundsValid;
        public boolean hasWeights;
        public boolean hasWeightsValid;
        public final boolean horizontal;
        public int leadingMargins[];
        public boolean leadingMarginsValid;
        public int locations[];
        public boolean locationsValid;
        private int maxIndex;
        boolean orderPreserved;
        private MutableInt parentMax;
        private MutableInt parentMin;
        final GridLayout this$0;
        public int trailingMargins[];
        public boolean trailingMarginsValid;

        private void addComponentSizes(List list, PackedMap packedmap) {
            for (int i = 0; i < ((Interval[])packedmap.keys).length; i++)
                include(list, ((Interval[])packedmap.keys)[i], ((MutableInt[])packedmap.values)[i], false);

        }

        private String arcsToString(List list) {
            boolean flag;
            String s;
            StringBuilder stringbuilder;
            Iterator iterator;
            if (horizontal)
                s = "x";
            else
                s = "y";
            stringbuilder = new StringBuilder();
            iterator = list.iterator();
            list = stringbuilder;
            flag = true;
            while (iterator.hasNext())  {
                Object obj = (Arc)iterator.next();
                int i;
                int j;
                int k;
                if (flag)
                    flag = false;
                else
                    list = list.append(", ");
                j = ((Arc) (obj)).span.min;
                k = ((Arc) (obj)).span.max;
                i = ((Arc) (obj)).value.value;
                if (j < k)
                    obj = (new StringBuilder()).append(s).append(k).append("-").append(s).append(j).append(">=").append(i).toString();
                else
                    obj = (new StringBuilder()).append(s).append(j).append("-").append(s).append(k).append("<=").append(-i).toString();
                list.append(((String) (obj)));
            }
            return list.toString();
        }

        private int calculateMaxIndex() {
            int k = getChildCount();
            int j = 0;
            int i = -1;
            while (j < k)  {
                Object obj = getChildAt(j);
                obj = getLayoutParams(((View) (obj)));
                if (horizontal)
                    obj = ((LayoutParams) (obj)).columnSpec;
                else
                    obj = ((LayoutParams) (obj)).rowSpec;
                obj = ((Spec) (obj)).span;
                i = Math.max(Math.max(Math.max(i, ((Interval) (obj)).min), ((Interval) (obj)).max), ((Interval) (obj)).size());
                j++;
            }
            if (i == -1)
                i = 0x80000000;
            return i;
        }

        private float calculateTotalWeight() {
            float f = 0.0F;
            int j = getChildCount();
            int i = 0;
            while (i < j)  {
                Object obj = getChildAt(i);
                if (((View) (obj)).getVisibility() != 8) {
                    obj = getLayoutParams(((View) (obj)));
                    if (horizontal)
                        obj = ((LayoutParams) (obj)).columnSpec;
                    else
                        obj = ((LayoutParams) (obj)).rowSpec;
                    f = ((Spec) (obj)).weight + f;
                }
                i++;
            }
            return f;
        }

        private void computeArcs() {
            getForwardLinks();
            getBackwardLinks();
        }

        private void computeGroupBounds() {
            Bounds abounds[] = (Bounds[])groupBounds.values;
            for (int i = 0; i < abounds.length; i++)
                abounds[i].reset();

            int l = getChildCount();
            int j = 0;
            while (j < l)  {
                View view = getChildAt(j);
                Object obj = getLayoutParams(view);
                int k;
                int i1;
                if (horizontal)
                    obj = ((LayoutParams) (obj)).columnSpec;
                else
                    obj = ((LayoutParams) (obj)).rowSpec;
                i1 = getMeasurementIncludingMargin(view, horizontal);
                if (((Spec) (obj)).weight == 0.0F)
                    k = 0;
                else
                    k = getDeltas()[j];
                ((Bounds)groupBounds.getValue(j)).include(GridLayout.this, view, ((Spec) (obj)), this, i1 + k);
                j++;
            }
        }

        private boolean computeHasWeights() {
            int i;
            int j;
            j = getChildCount();
            i = 0;
_L5:
            if (i >= j) goto _L2; else goto _L1
_L1:
            Object obj = getChildAt(i);
            if (((View) (obj)).getVisibility() != 8) goto _L4; else goto _L3
_L3:
            i++;
              goto _L5
_L4:
            boolean flag;
            obj = getLayoutParams(((View) (obj)));
            if (horizontal)
                obj = ((LayoutParams) (obj)).columnSpec;
            else
                obj = ((LayoutParams) (obj)).rowSpec;
            if (((Spec) (obj)).weight == 0.0F) goto _L3; else goto _L6
_L6:
            flag = true;
_L8:
            return flag;
_L2:
            flag = false;
            if (true) goto _L8; else goto _L7
_L7:
        }

        private void computeLinks(PackedMap packedmap, boolean flag) {
            boolean flag1 = false;
            MutableInt amutableint[] = (MutableInt[])packedmap.values;
            for (int i = 0; i < amutableint.length; i++)
                amutableint[i].reset();

            Bounds abounds[] = (Bounds[])getGroupBounds().values;
            int j = ((flag1) ? 1 : 0);
            while (j < abounds.length)  {
                int k = abounds[j].size(flag);
                MutableInt mutableint = (MutableInt)packedmap.getValue(j);
                int l = mutableint.value;
                if (!flag)
                    k = -k;
                mutableint.value = Math.max(l, k);
                j++;
            }
        }

        private void computeLocations(int ai[]) {
            int i = 0;
            if (!hasWeights())
                solve(ai);
            else
                solveAndDistributeSpace(ai);
            if (!orderPreserved) {
                int j = ai[0];
                for (int k = ai.length; i < k; i++)
                    ai[i] = ai[i] - j;

            }
        }

        private void computeMargins(boolean flag) {
            int i;
            int k;
            int ai[];
            if (flag)
                ai = leadingMargins;
            else
                ai = trailingMargins;
            k = getChildCount();
            i = 0;
            while (i < k)  {
                View view = getChildAt(i);
                if (view.getVisibility() != 8) {
                    Object obj = getLayoutParams(view);
                    int j;
                    if (horizontal)
                        obj = ((LayoutParams) (obj)).columnSpec;
                    else
                        obj = ((LayoutParams) (obj)).rowSpec;
                    obj = ((Spec) (obj)).span;
                    if (flag)
                        j = ((Interval) (obj)).min;
                    else
                        j = ((Interval) (obj)).max;
                    ai[j] = Math.max(ai[j], getMargin1(view, horizontal, flag));
                }
                i++;
            }
        }

        private Arc[] createArcs() {
            ArrayList arraylist = new ArrayList();
            ArrayList arraylist1 = new ArrayList();
            addComponentSizes(arraylist, getForwardLinks());
            addComponentSizes(arraylist1, getBackwardLinks());
            if (orderPreserved) {
                for (int i = 0; i < getCount(); i++)
                    include(arraylist, new Interval(i, i + 1), new MutableInt(0));

            }
            int j = getCount();
            include(arraylist, new Interval(0, j), parentMin, false);
            include(arraylist1, new Interval(j, 0), parentMax, false);
            return (Arc[])GridLayout.append(topologicalSort(arraylist), topologicalSort(arraylist1));
        }

        private PackedMap createGroupBounds() {
            Assoc assoc = Assoc.of(android/support/v7/widget/GridLayout$Spec, android/support/v7/widget/GridLayout$Bounds);
            int j = getChildCount();
            int i = 0;
            while (i < j)  {
                Object obj = getChildAt(i);
                obj = getLayoutParams(((View) (obj)));
                if (horizontal)
                    obj = ((LayoutParams) (obj)).columnSpec;
                else
                    obj = ((LayoutParams) (obj)).rowSpec;
                assoc.put(obj, ((Spec) (obj)).getAbsoluteAlignment(horizontal).getBounds());
                i++;
            }
            return assoc.pack();
        }

        private PackedMap createLinks(boolean flag) {
            Assoc assoc = Assoc.of(android/support/v7/widget/GridLayout$Interval, android/support/v7/widget/GridLayout$MutableInt);
            Spec aspec[] = (Spec[])getGroupBounds().keys;
            int j = aspec.length;
            int i = 0;
            while (i < j)  {
                Interval interval;
                if (flag)
                    interval = aspec[i].span;
                else
                    interval = aspec[i].span.inverse();
                assoc.put(interval, new MutableInt());
                i++;
            }
            return assoc.pack();
        }

        private PackedMap getBackwardLinks() {
            if (backwardLinks == null)
                backwardLinks = createLinks(false);
            if (!backwardLinksValid) {
                computeLinks(backwardLinks, false);
                backwardLinksValid = true;
            }
            return backwardLinks;
        }

        private PackedMap getForwardLinks() {
            if (forwardLinks == null)
                forwardLinks = createLinks(true);
            if (!forwardLinksValid) {
                computeLinks(forwardLinks, true);
                forwardLinksValid = true;
            }
            return forwardLinks;
        }

        private int getMaxIndex() {
            if (maxIndex == 0x80000000)
                maxIndex = Math.max(0, calculateMaxIndex());
            return maxIndex;
        }

        private int getMeasure(int i, int j) {
            setParentConstraints(i, j);
            return size(getLocations());
        }

        private boolean hasWeights() {
            if (!hasWeightsValid) {
                hasWeights = computeHasWeights();
                hasWeightsValid = true;
            }
            return hasWeights;
        }

        private void include(List list, Interval interval, MutableInt mutableint) {
            include(list, interval, mutableint, true);
        }

        private void include(List list, Interval interval, MutableInt mutableint, boolean flag) {
            if (interval.size() != 0) goto _L2; else goto _L1
_L1:
            return;
_L2:
label0:
            {
                if (!flag)
                    break label0;
                Iterator iterator = list.iterator();
                do
                    if (!iterator.hasNext())
                        break label0;
                while (!((Arc)iterator.next()).span.equals(interval));
                continue; /* Loop/switch isn't completed */
            }
            list.add(new Arc(interval, mutableint));
            if (true) goto _L1; else goto _L3
_L3:
        }

        private void init(int ai[]) {
            Arrays.fill(ai, 0);
        }

        private void logError(String s, Arc aarc[], boolean aflag[]) {
            ArrayList arraylist = new ArrayList();
            ArrayList arraylist1 = new ArrayList();
            for (int i = 0; i < aarc.length; i++) {
                Arc arc = aarc[i];
                if (aflag[i])
                    arraylist.add(arc);
                if (!arc.valid)
                    arraylist1.add(arc);
            }

            mPrinter.println((new StringBuilder()).append(s).append(" constraints: ").append(arcsToString(arraylist)).append(" are inconsistent; permanently removing: ").append(arcsToString(arraylist1)).append(". ").toString());
        }

        private boolean relax(int ai[], Arc arc) {
            boolean flag = false;
            if (arc.valid) goto _L2; else goto _L1
_L1:
            return flag;
_L2:
            Interval interval = arc.span;
            int k = interval.min;
            int i = interval.max;
            int j = arc.value.value;
            j = ai[k] + j;
            if (j > ai[i]) {
                ai[i] = j;
                flag = true;
            }
            if (true) goto _L1; else goto _L3
_L3:
        }

        private void setParentConstraints(int i, int j) {
            parentMin.value = i;
            parentMax.value = -j;
            locationsValid = false;
        }

        private void shareOutDelta(int i, float f) {
            Arrays.fill(deltas, 0);
            int k = getChildCount();
            int j = 0;
            while (j < k)  {
                Object obj = getChildAt(j);
                if (((View) (obj)).getVisibility() != 8) {
                    obj = getLayoutParams(((View) (obj)));
                    float f1;
                    if (horizontal)
                        obj = ((LayoutParams) (obj)).columnSpec;
                    else
                        obj = ((LayoutParams) (obj)).rowSpec;
                    f1 = ((Spec) (obj)).weight;
                    if (f1 != 0.0F) {
                        int l = Math.round(((float)i * f1) / f);
                        deltas[j] = l;
                        f -= f1;
                        i -= l;
                    }
                }
                j++;
            }
        }

        private int size(int ai[]) {
            return ai[getCount()];
        }

        private boolean solve(int ai[]) {
            return solve(getArcs(), ai);
        }

        private boolean solve(Arc aarc[], int ai[]) {
            return solve(aarc, ai, true);
        }

        private boolean solve(Arc aarc[], int ai[], boolean flag) {
            int i;
            int j;
            boolean flag1;
            int l1;
            boolean flag3;
            String s;
            boolean aflag[];
            flag3 = false;
            int i1;
            int i2;
            if (horizontal)
                s = "horizontal";
            else
                s = "vertical";
            l1 = getCount() + 1;
            aflag = null;
            i = 0;
_L10:
            if (i >= aarc.length) goto _L2; else goto _L1
_L1:
            init(ai);
            j = 0;
_L7:
            if (j >= l1) goto _L4; else goto _L3
_L3:
            i2 = aarc.length;
            i1 = 0;
            flag1 = false;
            for (; i1 < i2; i1++)
                flag1 |= relax(ai, aarc[i1]);

            if (flag1) goto _L6; else goto _L5
_L5:
            boolean flag2;
            if (aflag != null)
                logError(s, aarc, aflag);
            flag2 = true;
_L9:
            return flag2;
_L6:
            j++;
              goto _L7
_L4:
            flag2 = flag3;
            if (!flag) goto _L9; else goto _L8
_L8:
            boolean aflag1[] = new boolean[aarc.length];
            for (int k = 0; k < l1; k++) {
                int k1 = aarc.length;
                for (int j1 = 0; j1 < k1; j1++)
                    aflag1[j1] = aflag1[j1] | relax(ai, aarc[j1]);

            }

            if (i == 0)
                aflag = aflag1;
            int l = 0;
            Arc arc;
            do {
                if (l >= aarc.length)
                    continue; /* Loop/switch isn't completed */
                if (aflag1[l]) {
                    arc = aarc[l];
                    if (arc.span.min >= arc.span.max)
                        break;
                }
                l++;
            } while (true);
            arc.valid = false;
            i++;
              goto _L10
_L2:
            flag2 = true;
              goto _L9
        }

        private void solveAndDistributeSpace(int ai[]) {
            int j;
            Arrays.fill(getDeltas(), 0);
            solve(ai);
            j = parentMin.value * getChildCount() + 1;
            if (j >= 2) goto _L2; else goto _L1
_L1:
            return;
_L2:
            float f = calculateTotalWeight();
            int i = -1;
            boolean flag = true;
            int k = 0;
            while (k < j)  {
                int l = (int)(((long)k + (long)j) / 2L);
                invalidateValues();
                shareOutDelta(l, f);
                flag = solve(getArcs(), ai, false);
                if (flag) {
                    i = l + 1;
                    k = j;
                    j = i;
                    i = l;
                } else {
                    j = k;
                    k = l;
                }
                l = k;
                k = j;
                j = l;
            }
            if (i > 0 && !flag) {
                invalidateValues();
                shareOutDelta(i, f);
                solve(ai);
            }
            if (true) goto _L1; else goto _L3
_L3:
        }

        private Arc[] topologicalSort(List list) {
            return topologicalSort((Arc[])list.toArray(new Arc[list.size()]));
        }

        private Arc[] topologicalSort(Arc aarc[]) {
            return (aarc. new Object() {

                static final boolean $assertionsDisabled;
                Arc arcsByVertex[][];
                int cursor;
                Arc result[];
                final Axis this$1;
                final Arc val$arcs[];
                int visited[];

                Arc[] sort() {
                    int i = 0;
                    for (int j = arcsByVertex.length; i < j; i++)
                        walk(i);

                    if (!$assertionsDisabled && cursor != -1)
                        throw new AssertionError();
                    else
                        return result;
                }

                void walk(int i) {
                    visited[i];
                    JVM INSTR tableswitch 0 1: default 28
                //                               0 29
                //                               1 116;
                       goto _L1 _L2 _L3
_L1:
                    return;
_L2:
                    visited[i] = 1;
                    Arc aarc[] = arcsByVertex[i];
                    int k = aarc.length;
                    for (int j = 0; j < k; j++) {
                        Arc arc = aarc[j];
                        walk(arc.span.max);
                        Arc aarc1[] = result;
                        int l = cursor;
                        cursor = l - 1;
                        aarc1[l] = arc;
                    }

                    visited[i] = 2;
                    continue; /* Loop/switch isn't completed */
_L3:
                    if (!$assertionsDisabled)
                        throw new AssertionError();
                    if (true) goto _L1; else goto _L4
_L4:
                }

                static  {
                    boolean flag;
                    if (!android/support/v7/widget/GridLayout.desiredAssertionStatus())
                        flag = true;
                    else
                        flag = false;
                    $assertionsDisabled = flag;
                }

             {
                this$1 = final_axis;
                arcs = _5B_Landroid.support.v7.widget.Arc_3B_.this;
                super();
                result = new Arc[arcs.length];
                cursor = result.length - 1;
                arcsByVertex = groupArcsByFirstVertex(arcs);
                visited = new int[getCount() + 1];
            }
            }
).sort();
        }

        public Arc[] getArcs() {
            if (arcs == null)
                arcs = createArcs();
            if (!arcsValid) {
                computeArcs();
                arcsValid = true;
            }
            return arcs;
        }

        public int getCount() {
            return Math.max(definedCount, getMaxIndex());
        }

        public int[] getDeltas() {
            if (deltas == null)
                deltas = new int[getChildCount()];
            return deltas;
        }

        public PackedMap getGroupBounds() {
            if (groupBounds == null)
                groupBounds = createGroupBounds();
            if (!groupBoundsValid) {
                computeGroupBounds();
                groupBoundsValid = true;
            }
            return groupBounds;
        }

        public int[] getLeadingMargins() {
            if (leadingMargins == null)
                leadingMargins = new int[getCount() + 1];
            if (!leadingMarginsValid) {
                computeMargins(true);
                leadingMarginsValid = true;
            }
            return leadingMargins;
        }

        public int[] getLocations() {
            if (locations == null)
                locations = new int[getCount() + 1];
            if (!locationsValid) {
                computeLocations(locations);
                locationsValid = true;
            }
            return locations;
        }

        public int getMeasure(int i) {
            boolean flag;
            int j;
            flag = false;
            j = android.view.View.MeasureSpec.getMode(i);
            i = android.view.View.MeasureSpec.getSize(i);
            j;
            JVM INSTR lookupswitch 3: default 48
        //                       -2147483648: 85
        //                       0: 64
        //                       1073741824: 75;
               goto _L1 _L2 _L3 _L4
_L1:
            i = ((flag) ? 1 : 0);
            if (!$assertionsDisabled)
                throw new AssertionError();
            break; /* Loop/switch isn't completed */
_L3:
            i = getMeasure(0, 0x186a0);
_L6:
            return i;
_L4:
            i = getMeasure(i, i);
            continue; /* Loop/switch isn't completed */
_L2:
            i = getMeasure(0, i);
            if (true) goto _L6; else goto _L5
_L5:
        }

        public int[] getTrailingMargins() {
            if (trailingMargins == null)
                trailingMargins = new int[getCount() + 1];
            if (!trailingMarginsValid) {
                computeMargins(false);
                trailingMarginsValid = true;
            }
            return trailingMargins;
        }

        Arc[][] groupArcsByFirstVertex(Arc aarc[]) {
            boolean flag = false;
            int i = getCount() + 1;
            Arc aarc1[][] = new Arc[i][];
            int ai[] = new int[i];
            int j1 = aarc.length;
            for (int j = 0; j < j1; j++) {
                int k1 = aarc[j].span.min;
                ai[k1] = ai[k1] + 1;
            }

            for (int k = 0; k < ai.length; k++)
                aarc1[k] = new Arc[ai[k]];

            Arrays.fill(ai, 0);
            j1 = aarc.length;
            for (int l = ((flag) ? 1 : 0); l < j1; l++) {
                Arc arc = aarc[l];
                int i1 = arc.span.min;
                Arc aarc2[] = aarc1[i1];
                int l1 = ai[i1];
                ai[i1] = l1 + 1;
                aarc2[l1] = arc;
            }

            return aarc1;
        }

        public void invalidateStructure() {
            maxIndex = 0x80000000;
            groupBounds = null;
            forwardLinks = null;
            backwardLinks = null;
            leadingMargins = null;
            trailingMargins = null;
            arcs = null;
            locations = null;
            deltas = null;
            hasWeightsValid = false;
            invalidateValues();
        }

        public void invalidateValues() {
            groupBoundsValid = false;
            forwardLinksValid = false;
            backwardLinksValid = false;
            leadingMarginsValid = false;
            trailingMarginsValid = false;
            arcsValid = false;
            locationsValid = false;
        }

        public boolean isOrderPreserved() {
            return orderPreserved;
        }

        public void layout(int i) {
            setParentConstraints(i, i);
            getLocations();
        }

        public void setCount(int i) {
            if (i != 0x80000000 && i < getMaxIndex()) {
                StringBuilder stringbuilder = new StringBuilder();
                String s;
                if (horizontal)
                    s = "column";
                else
                    s = "row";
                GridLayout.handleInvalidParams(stringbuilder.append(s).append("Count must be greater than or equal to the maximum of all grid indices ").append("(and spans) defined in the LayoutParams of each child").toString());
            }
            definedCount = i;
        }

        public void setOrderPreserved(boolean flag) {
            orderPreserved = flag;
            invalidateStructure();
        }

        static  {
            boolean flag;
            if (!android/support/v7/widget/GridLayout.desiredAssertionStatus())
                flag = true;
            else
                flag = false;
            $assertionsDisabled = flag;
        }

        Axis(boolean flag) {
            this$0 = GridLayout.this;
            super();
            definedCount = 0x80000000;
            maxIndex = 0x80000000;
            groupBoundsValid = false;
            forwardLinksValid = false;
            backwardLinksValid = false;
            leadingMarginsValid = false;
            trailingMarginsValid = false;
            arcsValid = false;
            locationsValid = false;
            hasWeightsValid = false;
            orderPreserved = true;
            parentMin = new MutableInt(0);
            parentMax = new MutableInt(0xfffe7960);
            horizontal = flag;
        }
    }

    static class Bounds {

        public int after;
        public int before;
        public int flexibility;

        protected int getOffset(GridLayout gridlayout, View view, Alignment alignment, int i, boolean flag) {
            return before - alignment.getAlignmentValue(view, i, ViewGroupCompat.getLayoutMode(gridlayout));
        }

        protected void include(int i, int j) {
            before = Math.max(before, i);
            after = Math.max(after, j);
        }

        protected final void include(GridLayout gridlayout, View view, Spec spec1, Axis axis, int i) {
            flexibility = flexibility & spec1.getFlexibility();
            int j = spec1.getAbsoluteAlignment(axis.horizontal).getAlignmentValue(view, i, ViewGroupCompat.getLayoutMode(gridlayout));
            include(j, i - j);
        }

        protected void reset() {
            before = 0x80000000;
            after = 0x80000000;
            flexibility = 2;
        }

        protected int size(boolean flag) {
            int i;
            if (!flag && GridLayout.canStretch(flexibility))
                i = 0x186a0;
            else
                i = before + after;
            return i;
        }

        public String toString() {
            return (new StringBuilder()).append("Bounds{before=").append(before).append(", after=").append(after).append('}').toString();
        }

        Bounds() {
            reset();
        }
    }

    static final class Interval {

        public final int max;
        public final int min;

        public boolean equals(Object obj) {
            boolean flag = true;
            if (this != obj) goto _L2; else goto _L1
_L1:
            return flag;
_L2:
            if (obj == null || getClass() != obj.getClass()) {
                flag = false;
            } else {
                obj = (Interval)obj;
                if (max != ((Interval) (obj)).max)
                    flag = false;
                else
                if (min != ((Interval) (obj)).min)
                    flag = false;
            }
            if (true) goto _L1; else goto _L3
_L3:
        }

        public int hashCode() {
            return min * 31 + max;
        }

        Interval inverse() {
            return new Interval(max, min);
        }

        int size() {
            return max - min;
        }

        public String toString() {
            return (new StringBuilder()).append("[").append(min).append(", ").append(max).append("]").toString();
        }

        public Interval(int i, int j) {
            min = i;
            max = j;
        }
    }

    public static class LayoutParams extends android.view.ViewGroup.MarginLayoutParams {

        private static final int BOTTOM_MARGIN;
        private static final int COLUMN;
        private static final int COLUMN_SPAN;
        private static final int COLUMN_WEIGHT;
        private static final int DEFAULT_COLUMN = 0x80000000;
        private static final int DEFAULT_HEIGHT = -2;
        private static final int DEFAULT_MARGIN = 0x80000000;
        private static final int DEFAULT_ROW = 0x80000000;
        private static final Interval DEFAULT_SPAN;
        private static final int DEFAULT_SPAN_SIZE;
        private static final int DEFAULT_WIDTH = -2;
        private static final int GRAVITY;
        private static final int LEFT_MARGIN;
        private static final int MARGIN;
        private static final int RIGHT_MARGIN;
        private static final int ROW;
        private static final int ROW_SPAN;
        private static final int ROW_WEIGHT;
        private static final int TOP_MARGIN;
        public Spec columnSpec;
        public Spec rowSpec;

        private void init(Context context, AttributeSet attributeset) {
            attributeset = context.obtainStyledAttributes(attributeset, android.support.v7.gridlayout.R.styleable.GridLayout_Layout);
            int i = attributeset.getInt(GRAVITY, 0);
            int k = attributeset.getInt(COLUMN, 0x80000000);
            int j = attributeset.getInt(COLUMN_SPAN, DEFAULT_SPAN_SIZE);
            float f = attributeset.getFloat(COLUMN_WEIGHT, 0.0F);
            columnSpec = GridLayout.spec(k, j, GridLayout.getAlignment(i, true), f);
            k = attributeset.getInt(ROW, 0x80000000);
            j = attributeset.getInt(ROW_SPAN, DEFAULT_SPAN_SIZE);
            f = attributeset.getFloat(ROW_WEIGHT, 0.0F);
            rowSpec = GridLayout.spec(k, j, GridLayout.getAlignment(i, false), f);
            attributeset.recycle();
            return;
            context;
            attributeset.recycle();
            throw context;
        }

        private void reInitSuper(Context context, AttributeSet attributeset) {
            attributeset = context.obtainStyledAttributes(attributeset, android.support.v7.gridlayout.R.styleable.GridLayout_Layout);
            int i = attributeset.getDimensionPixelSize(MARGIN, 0x80000000);
            leftMargin = attributeset.getDimensionPixelSize(LEFT_MARGIN, i);
            topMargin = attributeset.getDimensionPixelSize(TOP_MARGIN, i);
            rightMargin = attributeset.getDimensionPixelSize(RIGHT_MARGIN, i);
            bottomMargin = attributeset.getDimensionPixelSize(BOTTOM_MARGIN, i);
            attributeset.recycle();
            return;
            context;
            attributeset.recycle();
            throw context;
        }

        public boolean equals(Object obj) {
            boolean flag = true;
            if (this != obj) goto _L2; else goto _L1
_L1:
            return flag;
_L2:
            if (obj == null || getClass() != obj.getClass()) {
                flag = false;
            } else {
                obj = (LayoutParams)obj;
                if (!columnSpec.equals(((LayoutParams) (obj)).columnSpec))
                    flag = false;
                else
                if (!rowSpec.equals(((LayoutParams) (obj)).rowSpec))
                    flag = false;
            }
            if (true) goto _L1; else goto _L3
_L3:
        }

        public int hashCode() {
            return rowSpec.hashCode() * 31 + columnSpec.hashCode();
        }

        protected void setBaseAttributes(TypedArray typedarray, int i, int j) {
            width = typedarray.getLayoutDimension(i, -2);
            height = typedarray.getLayoutDimension(j, -2);
        }

        final void setColumnSpecSpan(Interval interval) {
            columnSpec = columnSpec.copyWriteSpan(interval);
        }

        public void setGravity(int i) {
            rowSpec = rowSpec.copyWriteAlignment(GridLayout.getAlignment(i, false));
            columnSpec = columnSpec.copyWriteAlignment(GridLayout.getAlignment(i, true));
        }

        final void setRowSpecSpan(Interval interval) {
            rowSpec = rowSpec.copyWriteSpan(interval);
        }

        static  {
            DEFAULT_SPAN = new Interval(0x80000000, 0x80000001);
            DEFAULT_SPAN_SIZE = DEFAULT_SPAN.size();
            MARGIN = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_android_layout_margin;
            LEFT_MARGIN = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_android_layout_marginLeft;
            TOP_MARGIN = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_android_layout_marginTop;
            RIGHT_MARGIN = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_android_layout_marginRight;
            BOTTOM_MARGIN = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_android_layout_marginBottom;
            COLUMN = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_layout_column;
            COLUMN_SPAN = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_layout_columnSpan;
            COLUMN_WEIGHT = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_layout_columnWeight;
            ROW = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_layout_row;
            ROW_SPAN = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_layout_rowSpan;
            ROW_WEIGHT = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_layout_rowWeight;
            GRAVITY = android.support.v7.gridlayout.R.styleable.GridLayout_Layout_layout_gravity;
        }

        public LayoutParams() {
            this(Spec.UNDEFINED, Spec.UNDEFINED);
        }

        private LayoutParams(int i, int j, int k, int l, int i1, int j1, Spec spec1, 
                Spec spec2) {
            super(i, j);
            rowSpec = Spec.UNDEFINED;
            columnSpec = Spec.UNDEFINED;
            setMargins(k, l, i1, j1);
            rowSpec = spec1;
            columnSpec = spec2;
        }

        public LayoutParams(Context context, AttributeSet attributeset) {
            super(context, attributeset);
            rowSpec = Spec.UNDEFINED;
            columnSpec = Spec.UNDEFINED;
            reInitSuper(context, attributeset);
            init(context, attributeset);
        }

        public LayoutParams(LayoutParams layoutparams) {
            super(layoutparams);
            rowSpec = Spec.UNDEFINED;
            columnSpec = Spec.UNDEFINED;
            rowSpec = layoutparams.rowSpec;
            columnSpec = layoutparams.columnSpec;
        }

        public LayoutParams(Spec spec1, Spec spec2) {
            this(-2, -2, 0x80000000, 0x80000000, 0x80000000, 0x80000000, spec1, spec2);
        }

        public LayoutParams(android.view.ViewGroup.LayoutParams layoutparams) {
            super(layoutparams);
            rowSpec = Spec.UNDEFINED;
            columnSpec = Spec.UNDEFINED;
        }

        public LayoutParams(android.view.ViewGroup.MarginLayoutParams marginlayoutparams) {
            super(marginlayoutparams);
            rowSpec = Spec.UNDEFINED;
            columnSpec = Spec.UNDEFINED;
        }
    }

    static final class MutableInt {

        public int value;

        public void reset() {
            value = 0x80000000;
        }

        public String toString() {
            return Integer.toString(value);
        }

        public MutableInt() {
            reset();
        }

        public MutableInt(int i) {
            value = i;
        }
    }

    static final class PackedMap {

        public final int index[];
        public final Object keys[];
        public final Object values[];

        private static Object[] compact(Object aobj[], int ai[]) {
            int j = aobj.length;
            Object aobj1[] = (Object[])(Object[])Array.newInstance(((Object) (aobj)).getClass().getComponentType(), GridLayout.max2(ai, -1) + 1);
            for (int i = 0; i < j; i++)
                aobj1[ai[i]] = aobj[i];

            return aobj1;
        }

        private static int[] createIndex(Object aobj[]) {
            int j = aobj.length;
            int ai[] = new int[j];
            HashMap hashmap = new HashMap();
            for (int i = 0; i < j; i++) {
                Object obj = aobj[i];
                Integer integer1 = (Integer)hashmap.get(obj);
                Integer integer = integer1;
                if (integer1 == null) {
                    integer = Integer.valueOf(hashmap.size());
                    hashmap.put(obj, integer);
                }
                ai[i] = integer.intValue();
            }

            return ai;
        }

        public Object getValue(int i) {
            return values[index[i]];
        }

        PackedMap(Object aobj[], Object aobj1[]) {
            index = createIndex(aobj);
            keys = compact(aobj, index);
            values = compact(aobj1, index);
        }
    }

    public static class Spec {

        static final float DEFAULT_WEIGHT = 0F;
        static final Spec UNDEFINED = GridLayout.spec(0x80000000);
        final Alignment alignment;
        final Interval span;
        final boolean startDefined;
        final float weight;

        final Spec copyWriteAlignment(Alignment alignment1) {
            return new Spec(startDefined, span, alignment1, weight);
        }

        final Spec copyWriteSpan(Interval interval) {
            return new Spec(startDefined, interval, alignment, weight);
        }

        public boolean equals(Object obj) {
            boolean flag = true;
            if (this != obj) goto _L2; else goto _L1
_L1:
            return flag;
_L2:
            if (obj == null || getClass() != obj.getClass()) {
                flag = false;
            } else {
                obj = (Spec)obj;
                if (!alignment.equals(((Spec) (obj)).alignment))
                    flag = false;
                else
                if (!span.equals(((Spec) (obj)).span))
                    flag = false;
            }
            if (true) goto _L1; else goto _L3
_L3:
        }

        public Alignment getAbsoluteAlignment(boolean flag) {
            Alignment alignment1;
            if (alignment != GridLayout.UNDEFINED_ALIGNMENT)
                alignment1 = alignment;
            else
            if (weight == 0.0F) {
                if (flag)
                    alignment1 = GridLayout.START;
                else
                    alignment1 = GridLayout.BASELINE;
            } else {
                alignment1 = GridLayout.FILL;
            }
            return alignment1;
        }

        final int getFlexibility() {
            int i;
            if (alignment == GridLayout.UNDEFINED_ALIGNMENT && weight == 0.0F)
                i = 0;
            else
                i = 2;
            return i;
        }

        public int hashCode() {
            return span.hashCode() * 31 + alignment.hashCode();
        }


        Spec(boolean flag, int i, int j, Alignment alignment1, float f) {
            this(flag, new Interval(i, i + j), alignment1, f);
        }

        private Spec(boolean flag, Interval interval, Alignment alignment1, float f) {
            startDefined = flag;
            span = interval;
            alignment = alignment1;
            weight = f;
        }
    }


    private static final int ALIGNMENT_MODE;
    public static final int ALIGN_BOUNDS = 0;
    public static final int ALIGN_MARGINS = 1;
    public static final Alignment BASELINE = new Alignment() {

        public int getAlignmentValue(View view, int i, int j) {
            if (view.getVisibility() != 8) goto _L2; else goto _L1
_L1:
            i = 0;
_L4:
            return i;
_L2:
            j = view.getBaseline();
            i = j;
            if (j == -1)
                i = 0x80000000;
            if (true) goto _L4; else goto _L3
_L3:
        }

        public Bounds getBounds() {
            return new Bounds() {

                private int size;
                final _cls7 this$0;

                protected int getOffset(GridLayout gridlayout, View view, Alignment alignment, int i, boolean flag) {
                    return Math.max(0, super.getOffset(gridlayout, view, alignment, i, flag));
                }

                protected void include(int i, int j) {
                    super.include(i, j);
                    size = Math.max(size, i + j);
                }

                protected void reset() {
                    super.reset();
                    size = 0x80000000;
                }

                protected int size(boolean flag) {
                    return Math.max(super.size(flag), size);
                }

             {
                this$0 = _cls7.this;
                super();
            }
            }
;
        }

        String getDebugString() {
            return "BASELINE";
        }

        int getGravityOffset(View view, int i) {
            return 0;
        }

    }
;
    public static final Alignment BOTTOM;
    static final int CAN_STRETCH = 2;
    public static final Alignment CENTER = new Alignment() {

        public int getAlignmentValue(View view, int i, int j) {
            return i >> 1;
        }

        String getDebugString() {
            return "CENTER";
        }

        int getGravityOffset(View view, int i) {
            return i >> 1;
        }

    }
;
    private static final int COLUMN_COUNT;
    private static final int COLUMN_ORDER_PRESERVED;
    private static final int DEFAULT_ALIGNMENT_MODE = 1;
    static final int DEFAULT_CONTAINER_MARGIN = 0;
    private static final int DEFAULT_COUNT = 0x80000000;
    static final boolean DEFAULT_ORDER_PRESERVED = true;
    private static final int DEFAULT_ORIENTATION = 0;
    private static final boolean DEFAULT_USE_DEFAULT_MARGINS = false;
    public static final Alignment END;
    public static final Alignment FILL = new Alignment() {

        public int getAlignmentValue(View view, int i, int j) {
            return 0x80000000;
        }

        String getDebugString() {
            return "FILL";
        }

        int getGravityOffset(View view, int i) {
            return 0;
        }

        public int getSizeInCell(View view, int i, int j) {
            return j;
        }

    }
;
    public static final int HORIZONTAL = 0;
    static final int INFLEXIBLE = 0;
    private static final Alignment LEADING;
    public static final Alignment LEFT;
    static final Printer LOG_PRINTER = new LogPrinter(3, android/support/v7/widget/GridLayout.getName());
    static final int MAX_SIZE = 0x186a0;
    static final Printer NO_PRINTER = new Printer() {

        public void println(String s) {
        }

    }
;
    private static final int ORIENTATION;
    public static final Alignment RIGHT;
    private static final int ROW_COUNT;
    private static final int ROW_ORDER_PRESERVED;
    public static final Alignment START;
    public static final Alignment TOP;
    private static final Alignment TRAILING;
    public static final int UNDEFINED = 0x80000000;
    static final Alignment UNDEFINED_ALIGNMENT = new Alignment() {

        public int getAlignmentValue(View view, int i, int j) {
            return 0x80000000;
        }

        String getDebugString() {
            return "UNDEFINED";
        }

        int getGravityOffset(View view, int i) {
            return 0x80000000;
        }

    }
;
    static final int UNINITIALIZED_HASH = 0;
    private static final int USE_DEFAULT_MARGINS;
    public static final int VERTICAL = 1;
    int mAlignmentMode;
    int mDefaultGap;
    final Axis mHorizontalAxis;
    int mLastLayoutParamsHashCode;
    int mOrientation;
    Printer mPrinter;
    boolean mUseDefaultMargins;
    final Axis mVerticalAxis;

    public GridLayout(Context context) {
        this(context, null);
    }

    public GridLayout(Context context, AttributeSet attributeset) {
        this(context, attributeset, 0);
    }

    public GridLayout(Context context, AttributeSet attributeset, int i) {
        super(context, attributeset, i);
        mHorizontalAxis = new Axis(true);
        mVerticalAxis = new Axis(false);
        mOrientation = 0;
        mUseDefaultMargins = false;
        mAlignmentMode = 1;
        mLastLayoutParamsHashCode = 0;
        mPrinter = LOG_PRINTER;
        mDefaultGap = context.getResources().getDimensionPixelOffset(android.support.v7.gridlayout.R.dimen.default_gap);
        context = context.obtainStyledAttributes(attributeset, android.support.v7.gridlayout.R.styleable.GridLayout);
        setRowCount(context.getInt(ROW_COUNT, 0x80000000));
        setColumnCount(context.getInt(COLUMN_COUNT, 0x80000000));
        setOrientation(context.getInt(ORIENTATION, 0));
        setUseDefaultMargins(context.getBoolean(USE_DEFAULT_MARGINS, false));
        setAlignmentMode(context.getInt(ALIGNMENT_MODE, 1));
        setRowOrderPreserved(context.getBoolean(ROW_ORDER_PRESERVED, true));
        setColumnOrderPreserved(context.getBoolean(COLUMN_ORDER_PRESERVED, true));
        context.recycle();
        return;
        attributeset;
        context.recycle();
        throw attributeset;
    }

    static int adjust(int i, int j) {
        return android.view.View.MeasureSpec.makeMeasureSpec(android.view.View.MeasureSpec.getSize(i + j), android.view.View.MeasureSpec.getMode(i));
    }

    static Object[] append(Object aobj[], Object aobj1[]) {
        Object aobj2[] = (Object[])(Object[])Array.newInstance(((Object) (aobj)).getClass().getComponentType(), aobj.length + aobj1.length);
        System.arraycopy(((Object) (aobj)), 0, ((Object) (aobj2)), 0, aobj.length);
        System.arraycopy(((Object) (aobj1)), 0, ((Object) (aobj2)), aobj.length, aobj1.length);
        return aobj2;
    }

    static boolean canStretch(int i) {
        boolean flag;
        if ((i & 2) != 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private void checkLayoutParams(LayoutParams layoutparams, boolean flag) {
        int i;
        String s;
        Interval interval;
        if (flag)
            s = "column";
        else
            s = "row";
        if (flag)
            layoutparams = layoutparams.columnSpec;
        else
            layoutparams = layoutparams.rowSpec;
        interval = ((Spec) (layoutparams)).span;
        if (interval.min != 0x80000000 && interval.min < 0)
            handleInvalidParams((new StringBuilder()).append(s).append(" indices must be positive").toString());
        if (flag)
            layoutparams = mHorizontalAxis;
        else
            layoutparams = mVerticalAxis;
        i = ((Axis) (layoutparams)).definedCount;
        if (i != 0x80000000) {
            if (interval.max > i)
                handleInvalidParams((new StringBuilder()).append(s).append(" indices (start + span) mustn't exceed the ").append(s).append(" count").toString());
            if (interval.size() > i)
                handleInvalidParams((new StringBuilder()).append(s).append(" span mustn't exceed the ").append(s).append(" count").toString());
        }
    }

    private static int clip(Interval interval, boolean flag, int i) {
        int k = interval.size();
        if (i == 0) {
            i = k;
        } else {
            int j;
            if (flag)
                j = Math.min(interval.min, i);
            else
                j = 0;
            i = Math.min(k, i - j);
        }
        return i;
    }

    private int computeLayoutParamsHashCode() {
        int i = 1;
        int k = getChildCount();
        int j = 0;
        while (j < k)  {
            View view = getChildAt(j);
            if (view.getVisibility() != 8)
                i = ((LayoutParams)view.getLayoutParams()).hashCode() + i * 31;
            j++;
        }
        return i;
    }

    private void consistencyCheck() {
        if (mLastLayoutParamsHashCode != 0) goto _L2; else goto _L1
_L1:
        validateLayoutParams();
        mLastLayoutParamsHashCode = computeLayoutParamsHashCode();
_L4:
        return;
_L2:
        if (mLastLayoutParamsHashCode != computeLayoutParamsHashCode()) {
            mPrinter.println("The fields of some layout parameters were modified in between layout operations. Check the javadoc for GridLayout.LayoutParams#rowSpec.");
            invalidateStructure();
            consistencyCheck();
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private static Alignment createSwitchingAlignment(Alignment alignment, Alignment alignment1) {
        return new Alignment(alignment, alignment1) {

            final Alignment val$ltr;
            final Alignment val$rtl;

            public int getAlignmentValue(View view, int i, int j) {
                boolean flag = true;
                Alignment alignment2;
                if (ViewCompat.getLayoutDirection(view) != 1)
                    flag = false;
                if (!flag)
                    alignment2 = ltr;
                else
                    alignment2 = rtl;
                return alignment2.getAlignmentValue(view, i, j);
            }

            String getDebugString() {
                return (new StringBuilder()).append("SWITCHING[L:").append(ltr.getDebugString()).append(", R:").append(rtl.getDebugString()).append("]").toString();
            }

            int getGravityOffset(View view, int i) {
                boolean flag = true;
                Alignment alignment2;
                if (ViewCompat.getLayoutDirection(view) != 1)
                    flag = false;
                if (!flag)
                    alignment2 = ltr;
                else
                    alignment2 = rtl;
                return alignment2.getGravityOffset(view, i);
            }

             {
                ltr = alignment;
                rtl = alignment1;
                super();
            }
        }
;
    }

    private void drawLine(Canvas canvas, int i, int j, int k, int l, Paint paint) {
        if (isLayoutRtlCompat()) {
            int i1 = getWidth();
            canvas.drawLine(i1 - i, j, i1 - k, l, paint);
        } else {
            canvas.drawLine(i, j, k, l, paint);
        }
    }

    private static boolean fits(int ai[], int i, int j, int k) {
        boolean flag = false;
        if (k <= ai.length) goto _L2; else goto _L1
_L1:
        return flag;
_L4:
        j++;
_L2:
        if (j >= k)
            break; /* Loop/switch isn't completed */
        if (ai[j] > i)
            continue; /* Loop/switch isn't completed */
        if (true) goto _L4; else goto _L3
_L3:
        flag = true;
        if (true) goto _L1; else goto _L5
_L5:
    }

    static Alignment getAlignment(int i, boolean flag) {
        Alignment alignment;
        byte byte0;
        int j;
        if (flag)
            byte0 = 7;
        else
            byte0 = 112;
        if (flag)
            j = 0;
        else
            j = 4;
        (byte0 & i) >> j;
        JVM INSTR lookupswitch 6: default 76
    //                   1: 143
    //                   3: 95
    //                   5: 115
    //                   7: 135
    //                   8388611: 151
    //                   8388613: 159;
           goto _L1 _L2 _L3 _L4 _L5 _L6 _L7
_L1:
        alignment = UNDEFINED_ALIGNMENT;
_L9:
        return alignment;
_L3:
        if (flag)
            alignment = LEFT;
        else
            alignment = TOP;
        continue; /* Loop/switch isn't completed */
_L4:
        if (flag)
            alignment = RIGHT;
        else
            alignment = BOTTOM;
        continue; /* Loop/switch isn't completed */
_L5:
        alignment = FILL;
        continue; /* Loop/switch isn't completed */
_L2:
        alignment = CENTER;
        continue; /* Loop/switch isn't completed */
_L6:
        alignment = START;
        continue; /* Loop/switch isn't completed */
_L7:
        alignment = END;
        if (true) goto _L9; else goto _L8
_L8:
    }

    private int getDefaultMargin(View view, LayoutParams layoutparams, boolean flag, boolean flag1) {
        int i = 0;
        if (mUseDefaultMargins) goto _L2; else goto _L1
_L1:
        return i;
_L2:
        boolean flag2;
        Axis axis;
        if (flag)
            layoutparams = layoutparams.columnSpec;
        else
            layoutparams = layoutparams.rowSpec;
        if (flag)
            axis = mHorizontalAxis;
        else
            axis = mVerticalAxis;
        layoutparams = ((Spec) (layoutparams)).span;
        if (flag && isLayoutRtlCompat()) {
            if (!flag1)
                flag2 = true;
            else
                flag2 = false;
        } else {
            flag2 = flag1;
        }
        if (!flag2)
            break; /* Loop/switch isn't completed */
        if (((Interval) (layoutparams)).min == 0)
            flag2 = true;
        else
            flag2 = false;
_L4:
        i = getDefaultMargin(view, flag2, flag, flag1);
        if (true) goto _L1; else goto _L3
_L3:
        if (((Interval) (layoutparams)).max == axis.getCount())
            flag2 = true;
        else
            flag2 = false;
          goto _L4
        if (true) goto _L1; else goto _L5
_L5:
    }

    private int getDefaultMargin(View view, boolean flag, boolean flag1) {
        int i;
        if (view.getClass() == android/support/v7/widget/Space)
            i = 0;
        else
            i = mDefaultGap / 2;
        return i;
    }

    private int getDefaultMargin(View view, boolean flag, boolean flag1, boolean flag2) {
        return getDefaultMargin(view, flag1, flag2);
    }

    private int getMargin(View view, boolean flag, boolean flag1) {
        int i;
        if (mAlignmentMode == 1) {
            i = getMargin1(view, flag, flag1);
        } else {
            Object obj;
            if (flag)
                obj = mHorizontalAxis;
            else
                obj = mVerticalAxis;
            if (flag1)
                obj = ((Axis) (obj)).getLeadingMargins();
            else
                obj = ((Axis) (obj)).getTrailingMargins();
            view = getLayoutParams(view);
            if (flag)
                view = ((LayoutParams) (view)).columnSpec;
            else
                view = ((LayoutParams) (view)).rowSpec;
            if (flag1)
                i = ((Spec) (view)).span.min;
            else
                i = ((Spec) (view)).span.max;
            i = obj[i];
        }
        return i;
    }

    private int getMeasurement(View view, boolean flag) {
        int i;
        if (flag)
            i = view.getMeasuredWidth();
        else
            i = view.getMeasuredHeight();
        return i;
    }

    private int getTotalMargin(View view, boolean flag) {
        return getMargin(view, flag, true) + getMargin(view, flag, false);
    }

    static void handleInvalidParams(String s) {
        throw new IllegalArgumentException((new StringBuilder()).append(s).append(". ").toString());
    }

    private void invalidateStructure() {
        mLastLayoutParamsHashCode = 0;
        if (mHorizontalAxis != null)
            mHorizontalAxis.invalidateStructure();
        if (mVerticalAxis != null)
            mVerticalAxis.invalidateStructure();
        invalidateValues();
    }

    private void invalidateValues() {
        if (mHorizontalAxis != null && mVerticalAxis != null) {
            mHorizontalAxis.invalidateValues();
            mVerticalAxis.invalidateValues();
        }
    }

    private boolean isLayoutRtlCompat() {
        boolean flag = true;
        if (ViewCompat.getLayoutDirection(this) != 1)
            flag = false;
        return flag;
    }

    static int max2(int ai[], int i) {
        int j = 0;
        for (int k = ai.length; j < k; j++)
            i = Math.max(i, ai[j]);

        return i;
    }

    private void measureChildWithMargins2(View view, int i, int j, int k, int l) {
        view.measure(getChildMeasureSpec(i, getTotalMargin(view, true), k), getChildMeasureSpec(j, getTotalMargin(view, false), l));
    }

    private void measureChildrenWithMargins(int i, int j, boolean flag) {
        int l = getChildCount();
        int k = 0;
        while (k < l)  {
            View view = getChildAt(k);
            if (view.getVisibility() != 8) {
                LayoutParams layoutparams = getLayoutParams(view);
                if (flag) {
                    measureChildWithMargins2(view, i, j, layoutparams.width, layoutparams.height);
                } else {
                    boolean flag1;
                    Object obj;
                    if (mOrientation == 0)
                        flag1 = true;
                    else
                        flag1 = false;
                    if (flag1)
                        obj = layoutparams.columnSpec;
                    else
                        obj = layoutparams.rowSpec;
                    if (((Spec) (obj)).getAbsoluteAlignment(flag1) == FILL) {
                        Interval interval = ((Spec) (obj)).span;
                        int i1;
                        if (flag1)
                            obj = mHorizontalAxis;
                        else
                            obj = mVerticalAxis;
                        obj = ((Axis) (obj)).getLocations();
                        i1 = obj[interval.max] - obj[interval.min] - getTotalMargin(view, flag1);
                        if (flag1)
                            measureChildWithMargins2(view, i, j, i1, layoutparams.height);
                        else
                            measureChildWithMargins2(view, i, j, layoutparams.width, i1);
                    }
                }
            }
            k++;
        }
    }

    private static void procrusteanFill(int ai[], int i, int j, int k) {
        int l = ai.length;
        Arrays.fill(ai, Math.min(i, l), Math.min(j, l), k);
    }

    private static void setCellGroup(LayoutParams layoutparams, int i, int j, int k, int l) {
        layoutparams.setRowSpecSpan(new Interval(i, i + j));
        layoutparams.setColumnSpecSpan(new Interval(k, k + l));
    }

    public static Spec spec(int i) {
        return spec(i, 1);
    }

    public static Spec spec(int i, float f) {
        return spec(i, 1, f);
    }

    public static Spec spec(int i, int j) {
        return spec(i, j, UNDEFINED_ALIGNMENT);
    }

    public static Spec spec(int i, int j, float f) {
        return spec(i, j, UNDEFINED_ALIGNMENT, f);
    }

    public static Spec spec(int i, int j, Alignment alignment) {
        return spec(i, j, alignment, 0.0F);
    }

    public static Spec spec(int i, int j, Alignment alignment, float f) {
        boolean flag;
        if (i != 0x80000000)
            flag = true;
        else
            flag = false;
        return new Spec(flag, i, j, alignment, f);
    }

    public static Spec spec(int i, Alignment alignment) {
        return spec(i, 1, alignment);
    }

    public static Spec spec(int i, Alignment alignment, float f) {
        return spec(i, 1, alignment, f);
    }

    private void validateLayoutParams() {
        int i;
        int j;
        boolean flag;
        int k1;
        int l1;
        int i2;
        Object obj;
        int ai[];
        if (mOrientation == 0)
            flag = true;
        else
            flag = false;
        if (flag)
            obj = mHorizontalAxis;
        else
            obj = mVerticalAxis;
        if (((Axis) (obj)).definedCount != 0x80000000)
            k1 = ((Axis) (obj)).definedCount;
        else
            k1 = 0;
        ai = new int[k1];
        i2 = getChildCount();
        l1 = 0;
        j = 0;
        i = 0;
        while (l1 < i2)  {
            int k;
            int i1;
            int j2;
            int k2;
            LayoutParams layoutparams;
label0:
            {
                int j1;
label1:
                {
                    layoutparams = (LayoutParams)getChildAt(l1).getLayoutParams();
                    int l;
                    boolean flag1;
                    boolean flag2;
                    Interval interval;
                    if (flag)
                        obj = layoutparams.rowSpec;
                    else
                        obj = layoutparams.columnSpec;
                    interval = ((Spec) (obj)).span;
                    flag1 = ((Spec) (obj)).startDefined;
                    j2 = interval.size();
                    if (flag1)
                        i = interval.min;
                    if (flag)
                        obj = layoutparams.columnSpec;
                    else
                        obj = layoutparams.rowSpec;
                    interval = ((Spec) (obj)).span;
                    flag2 = ((Spec) (obj)).startDefined;
                    k2 = clip(interval, flag2, k1);
                    if (flag2)
                        j = interval.min;
                    i1 = j;
                    k = i;
                    if (k1 == 0)
                        break label0;
                    k = j;
                    l = i;
                    if (flag1) {
                        i1 = j;
                        j1 = i;
                        if (flag2)
                            break label1;
                        l = i;
                        k = j;
                    }
                    do {
                        i1 = k;
                        j1 = l;
                        if (fits(ai, l, k, k + k2))
                            break;
                        if (flag2)
                            l++;
                        else
                        if (k + k2 <= k1) {
                            k++;
                        } else {
                            l++;
                            k = 0;
                        }
                    } while (true);
                }
                procrusteanFill(ai, i1, i1 + k2, j1 + j2);
                k = j1;
            }
            if (flag)
                setCellGroup(layoutparams, k, j2, i1, k2);
            else
                setCellGroup(layoutparams, i1, k2, k, j2);
            j = i1 + k2;
            l1++;
            i = k;
        }
    }

    protected boolean checkLayoutParams(android.view.ViewGroup.LayoutParams layoutparams) {
        boolean flag = false;
        if (layoutparams instanceof LayoutParams) {
            layoutparams = (LayoutParams)layoutparams;
            checkLayoutParams(((LayoutParams) (layoutparams)), true);
            checkLayoutParams(((LayoutParams) (layoutparams)), false);
            flag = true;
        }
        return flag;
    }

    protected LayoutParams generateDefaultLayoutParams() {
        return new LayoutParams();
    }

    protected volatile android.view.ViewGroup.LayoutParams generateDefaultLayoutParams() {
        return generateDefaultLayoutParams();
    }

    public LayoutParams generateLayoutParams(AttributeSet attributeset) {
        return new LayoutParams(getContext(), attributeset);
    }

    protected LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams layoutparams) {
        if (layoutparams instanceof LayoutParams)
            layoutparams = new LayoutParams((LayoutParams)layoutparams);
        else
        if (layoutparams instanceof android.view.ViewGroup.MarginLayoutParams)
            layoutparams = new LayoutParams((android.view.ViewGroup.MarginLayoutParams)layoutparams);
        else
            layoutparams = new LayoutParams(layoutparams);
        return layoutparams;
    }

    public volatile android.view.ViewGroup.LayoutParams generateLayoutParams(AttributeSet attributeset) {
        return generateLayoutParams(attributeset);
    }

    protected volatile android.view.ViewGroup.LayoutParams generateLayoutParams(android.view.ViewGroup.LayoutParams layoutparams) {
        return generateLayoutParams(layoutparams);
    }

    public int getAlignmentMode() {
        return mAlignmentMode;
    }

    public int getColumnCount() {
        return mHorizontalAxis.getCount();
    }

    final LayoutParams getLayoutParams(View view) {
        return (LayoutParams)view.getLayoutParams();
    }

    int getMargin1(View view, boolean flag, boolean flag1) {
        LayoutParams layoutparams = getLayoutParams(view);
        int i;
        int j;
        if (flag) {
            if (flag1)
                i = layoutparams.leftMargin;
            else
                i = layoutparams.rightMargin;
        } else
        if (flag1)
            i = layoutparams.topMargin;
        else
            i = layoutparams.bottomMargin;
        j = i;
        if (i == 0x80000000)
            j = getDefaultMargin(view, layoutparams, flag, flag1);
        return j;
    }

    final int getMeasurementIncludingMargin(View view, boolean flag) {
        int i;
        if (view.getVisibility() == 8)
            i = 0;
        else
            i = getMeasurement(view, flag) + getTotalMargin(view, flag);
        return i;
    }

    public int getOrientation() {
        return mOrientation;
    }

    public Printer getPrinter() {
        return mPrinter;
    }

    public int getRowCount() {
        return mVerticalAxis.getCount();
    }

    public boolean getUseDefaultMargins() {
        return mUseDefaultMargins;
    }

    public boolean isColumnOrderPreserved() {
        return mHorizontalAxis.isOrderPreserved();
    }

    public boolean isRowOrderPreserved() {
        return mVerticalAxis.isOrderPreserved();
    }

    protected void onLayout(boolean flag, int i, int j, int k, int l) {
        consistencyCheck();
        k -= i;
        int i1 = getPaddingLeft();
        int j1 = getPaddingTop();
        int k1 = getPaddingRight();
        i = getPaddingBottom();
        mHorizontalAxis.layout(k - i1 - k1);
        mVerticalAxis.layout(l - j - j1 - i);
        int ai1[] = mHorizontalAxis.getLocations();
        int ai[] = mVerticalAxis.getLocations();
        l = getChildCount();
        i = 0;
        while (i < l)  {
            View view = getChildAt(i);
            if (view.getVisibility() != 8) {
                Object obj1 = getLayoutParams(view);
                Object obj = ((LayoutParams) (obj1)).columnSpec;
                obj1 = ((LayoutParams) (obj1)).rowSpec;
                Object obj2 = ((Spec) (obj)).span;
                Object obj3 = ((Spec) (obj1)).span;
                j = ai1[((Interval) (obj2)).min];
                int l1 = ai[((Interval) (obj3)).min];
                int j2 = ai1[((Interval) (obj2)).max];
                int i2 = ai[((Interval) (obj3)).max];
                int i3 = j2 - j;
                int l3 = i2 - l1;
                int i5 = getMeasurement(view, true);
                int j4 = getMeasurement(view, false);
                obj = ((Spec) (obj)).getAbsoluteAlignment(true);
                obj2 = ((Spec) (obj1)).getAbsoluteAlignment(false);
                obj1 = (Bounds)mHorizontalAxis.getGroupBounds().getValue(i);
                obj3 = (Bounds)mVerticalAxis.getGroupBounds().getValue(i);
                int k3 = ((Alignment) (obj)).getGravityOffset(view, i3 - ((Bounds) (obj1)).size(true));
                i2 = ((Alignment) (obj2)).getGravityOffset(view, l3 - ((Bounds) (obj3)).size(true));
                int l2 = getMargin(view, true, true);
                j2 = getMargin(view, false, true);
                int j3 = getMargin(view, true, false);
                int k2 = getMargin(view, false, false);
                int l4 = l2 + j3;
                int k4 = j2 + k2;
                int i4 = ((Bounds) (obj1)).getOffset(this, view, ((Alignment) (obj)), i5 + l4, true);
                k2 = ((Bounds) (obj3)).getOffset(this, view, ((Alignment) (obj2)), j4 + k4, false);
                i3 = ((Alignment) (obj)).getSizeInCell(view, i5, i3 - l4);
                l3 = ((Alignment) (obj2)).getSizeInCell(view, j4, l3 - k4);
                j = i4 + (j + k3);
                if (!isLayoutRtlCompat())
                    j += i1 + l2;
                else
                    j = k - i3 - k1 - j3 - j;
                l1 = k2 + (j1 + l1 + i2) + j2;
                if (i3 != view.getMeasuredWidth() || l3 != view.getMeasuredHeight())
                    view.measure(android.view.View.MeasureSpec.makeMeasureSpec(i3, 0x40000000), android.view.View.MeasureSpec.makeMeasureSpec(l3, 0x40000000));
                view.layout(j, l1, i3 + j, l3 + l1);
            }
            i++;
        }
    }

    protected void onMeasure(int i, int j) {
        consistencyCheck();
        invalidateValues();
        int j1 = getPaddingLeft() + getPaddingRight();
        int i1 = getPaddingTop() + getPaddingBottom();
        int k1 = adjust(i, -j1);
        int l1 = adjust(j, -i1);
        measureChildrenWithMargins(k1, l1, true);
        int k;
        int l;
        if (mOrientation == 0) {
            l = mHorizontalAxis.getMeasure(k1);
            measureChildrenWithMargins(k1, l1, false);
            k = mVerticalAxis.getMeasure(l1);
        } else {
            k = mVerticalAxis.getMeasure(l1);
            measureChildrenWithMargins(k1, l1, false);
            l = mHorizontalAxis.getMeasure(k1);
        }
        l = Math.max(l + j1, getSuggestedMinimumWidth());
        k = Math.max(k + i1, getSuggestedMinimumHeight());
        setMeasuredDimension(ViewCompat.resolveSizeAndState(l, i, 0), ViewCompat.resolveSizeAndState(k, j, 0));
    }

    public void requestLayout() {
        super.requestLayout();
        invalidateStructure();
    }

    public void setAlignmentMode(int i) {
        mAlignmentMode = i;
        requestLayout();
    }

    public void setColumnCount(int i) {
        mHorizontalAxis.setCount(i);
        invalidateStructure();
        requestLayout();
    }

    public void setColumnOrderPreserved(boolean flag) {
        mHorizontalAxis.setOrderPreserved(flag);
        invalidateStructure();
        requestLayout();
    }

    public void setOrientation(int i) {
        if (mOrientation != i) {
            mOrientation = i;
            invalidateStructure();
            requestLayout();
        }
    }

    public void setPrinter(Printer printer) {
        Printer printer1 = printer;
        if (printer == null)
            printer1 = NO_PRINTER;
        mPrinter = printer1;
    }

    public void setRowCount(int i) {
        mVerticalAxis.setCount(i);
        invalidateStructure();
        requestLayout();
    }

    public void setRowOrderPreserved(boolean flag) {
        mVerticalAxis.setOrderPreserved(flag);
        invalidateStructure();
        requestLayout();
    }

    public void setUseDefaultMargins(boolean flag) {
        mUseDefaultMargins = flag;
        requestLayout();
    }

    static  {
        ORIENTATION = android.support.v7.gridlayout.R.styleable.GridLayout_orientation;
        ROW_COUNT = android.support.v7.gridlayout.R.styleable.GridLayout_rowCount;
        COLUMN_COUNT = android.support.v7.gridlayout.R.styleable.GridLayout_columnCount;
        USE_DEFAULT_MARGINS = android.support.v7.gridlayout.R.styleable.GridLayout_useDefaultMargins;
        ALIGNMENT_MODE = android.support.v7.gridlayout.R.styleable.GridLayout_alignmentMode;
        ROW_ORDER_PRESERVED = android.support.v7.gridlayout.R.styleable.GridLayout_rowOrderPreserved;
        COLUMN_ORDER_PRESERVED = android.support.v7.gridlayout.R.styleable.GridLayout_columnOrderPreserved;
        LEADING = new Alignment() {

            public int getAlignmentValue(View view, int i, int j) {
                return 0;
            }

            String getDebugString() {
                return "LEADING";
            }

            int getGravityOffset(View view, int i) {
                return 0;
            }

        }
;
        TRAILING = new Alignment() {

            public int getAlignmentValue(View view, int i, int j) {
                return i;
            }

            String getDebugString() {
                return "TRAILING";
            }

            int getGravityOffset(View view, int i) {
                return i;
            }

        }
;
        TOP = LEADING;
        BOTTOM = TRAILING;
        START = LEADING;
        END = TRAILING;
        LEFT = createSwitchingAlignment(START, END);
        RIGHT = createSwitchingAlignment(END, START);
    }
}
