// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.v7.widget;

import android.content.Context;
import android.graphics.PointF;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.view.accessibility.AccessibilityEventCompat;
import android.support.v4.view.accessibility.AccessibilityRecordCompat;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import java.util.List;

// Referenced classes of package android.support.v7.widget:
//            ScrollbarHelper, OrientationHelper, LinearSmoothScroller, RecyclerView

public class LinearLayoutManager extends RecyclerView.LayoutManager
    implements RecyclerView.SmoothScroller.ScrollVectorProvider, android.support.v7.widget.helper.ItemTouchHelper.ViewDropHandler {
    class AnchorInfo {

        int mCoordinate;
        boolean mLayoutFromEnd;
        int mPosition;
        boolean mValid;
        final LinearLayoutManager this$0;

        void assignCoordinateFromPadding() {
            int i;
            if (mLayoutFromEnd)
                i = mOrientationHelper.getEndAfterPadding();
            else
                i = mOrientationHelper.getStartAfterPadding();
            mCoordinate = i;
        }

        public void assignFromView(View view) {
            if (mLayoutFromEnd)
                mCoordinate = mOrientationHelper.getDecoratedEnd(view) + mOrientationHelper.getTotalSpaceChange();
            else
                mCoordinate = mOrientationHelper.getDecoratedStart(view);
            mPosition = getPosition(view);
        }

        public void assignFromViewAndKeepVisibleRect(View view) {
            int k = mOrientationHelper.getTotalSpaceChange();
            if (k < 0) goto _L2; else goto _L1
_L1:
            assignFromView(view);
_L4:
            return;
_L2:
            mPosition = getPosition(view);
            if (mLayoutFromEnd) {
                int i = mOrientationHelper.getEndAfterPadding() - k - mOrientationHelper.getDecoratedEnd(view);
                mCoordinate = mOrientationHelper.getEndAfterPadding() - i;
                if (i > 0) {
                    k = mOrientationHelper.getDecoratedMeasurement(view);
                    int l = mCoordinate;
                    int k1 = mOrientationHelper.getStartAfterPadding();
                    k = l - k - (k1 + Math.min(mOrientationHelper.getDecoratedStart(view) - k1, 0));
                    if (k < 0) {
                        int i1 = mCoordinate;
                        mCoordinate = Math.min(i, -k) + i1;
                    }
                }
            } else {
                int j2 = mOrientationHelper.getDecoratedStart(view);
                int j = j2 - mOrientationHelper.getStartAfterPadding();
                mCoordinate = j2;
                if (j > 0) {
                    int l1 = mOrientationHelper.getDecoratedMeasurement(view);
                    int i2 = mOrientationHelper.getEndAfterPadding();
                    int j1 = mOrientationHelper.getDecoratedEnd(view);
                    k = mOrientationHelper.getEndAfterPadding() - Math.min(0, i2 - k - j1) - (j2 + l1);
                    if (k < 0)
                        mCoordinate = mCoordinate - Math.min(j, -k);
                }
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        boolean isViewValidAsAnchor(View view, RecyclerView.State state) {
            view = (RecyclerView.LayoutParams)view.getLayoutParams();
            boolean flag;
            if (!view.isItemRemoved() && view.getViewLayoutPosition() >= 0 && view.getViewLayoutPosition() < state.getItemCount())
                flag = true;
            else
                flag = false;
            return flag;
        }

        void reset() {
            mPosition = -1;
            mCoordinate = 0x80000000;
            mLayoutFromEnd = false;
            mValid = false;
        }

        public String toString() {
            return (new StringBuilder()).append("AnchorInfo{mPosition=").append(mPosition).append(", mCoordinate=").append(mCoordinate).append(", mLayoutFromEnd=").append(mLayoutFromEnd).append(", mValid=").append(mValid).append('}').toString();
        }

        AnchorInfo() {
            this$0 = LinearLayoutManager.this;
            super();
            reset();
        }
    }

    protected static class LayoutChunkResult {

        public int mConsumed;
        public boolean mFinished;
        public boolean mFocusable;
        public boolean mIgnoreConsumed;

        void resetInternal() {
            mConsumed = 0;
            mFinished = false;
            mIgnoreConsumed = false;
            mFocusable = false;
        }

        protected LayoutChunkResult() {
        }
    }

    static class LayoutState {

        static final int INVALID_LAYOUT = 0x80000000;
        static final int ITEM_DIRECTION_HEAD = -1;
        static final int ITEM_DIRECTION_TAIL = 1;
        static final int LAYOUT_END = 1;
        static final int LAYOUT_START = -1;
        static final int SCROLLING_OFFSET_NaN = 0x80000000;
        static final String TAG = "LLM#LayoutState";
        int mAvailable;
        int mCurrentPosition;
        int mExtra;
        boolean mInfinite;
        boolean mIsPreLayout;
        int mItemDirection;
        int mLastScrollDelta;
        int mLayoutDirection;
        int mOffset;
        boolean mRecycle;
        List mScrapList;
        int mScrollingOffset;

        private View nextViewFromScrapList() {
            int i;
            int j;
            j = mScrapList.size();
            i = 0;
_L3:
            View view;
            RecyclerView.LayoutParams layoutparams;
            if (i >= j)
                break; /* Loop/switch isn't completed */
            view = ((RecyclerView.ViewHolder)mScrapList.get(i)).itemView;
            layoutparams = (RecyclerView.LayoutParams)view.getLayoutParams();
              goto _L1
_L5:
            i++;
            if (true) goto _L3; else goto _L2
_L1:
            if (layoutparams.isItemRemoved() || mCurrentPosition != layoutparams.getViewLayoutPosition()) goto _L5; else goto _L4
_L4:
            assignPositionFromScrapList(view);
_L7:
            return view;
_L2:
            view = null;
            if (true) goto _L7; else goto _L6
_L6:
        }

        public void assignPositionFromScrapList() {
            assignPositionFromScrapList(null);
        }

        public void assignPositionFromScrapList(View view) {
            view = nextViewInLimitedList(view);
            if (view == null)
                mCurrentPosition = -1;
            else
                mCurrentPosition = ((RecyclerView.LayoutParams)view.getLayoutParams()).getViewLayoutPosition();
        }

        boolean hasMore(RecyclerView.State state) {
            boolean flag;
            if (mCurrentPosition >= 0 && mCurrentPosition < state.getItemCount())
                flag = true;
            else
                flag = false;
            return flag;
        }

        void log() {
            Log.d("LLM#LayoutState", (new StringBuilder()).append("avail:").append(mAvailable).append(", ind:").append(mCurrentPosition).append(", dir:").append(mItemDirection).append(", offset:").append(mOffset).append(", layoutDir:").append(mLayoutDirection).toString());
        }

        View next(RecyclerView.Recycler recycler) {
            if (mScrapList != null) {
                recycler = nextViewFromScrapList();
            } else {
                recycler = recycler.getViewForPosition(mCurrentPosition);
                mCurrentPosition = mCurrentPosition + mItemDirection;
            }
            return recycler;
        }

        public View nextViewInLimitedList(View view) {
            int i;
            int j;
            int l;
            View view1;
            l = mScrapList.size();
            view1 = null;
            i = 0x7fffffff;
            j = 0;
_L5:
            if (j >= l) goto _L2; else goto _L1
_L1:
            View view2;
            RecyclerView.LayoutParams layoutparams;
            view2 = ((RecyclerView.ViewHolder)mScrapList.get(j)).itemView;
            layoutparams = (RecyclerView.LayoutParams)view2.getLayoutParams();
            if (view2 != view && !layoutparams.isItemRemoved()) goto _L4; else goto _L3
_L3:
            j++;
              goto _L5
_L4:
            int k = (layoutparams.getViewLayoutPosition() - mCurrentPosition) * mItemDirection;
            if (k < 0 || k >= i) goto _L3; else goto _L6
_L6:
            if (k != 0)
                break MISSING_BLOCK_LABEL_116;
            view1 = view2;
_L2:
            return view1;
            view1 = view2;
            i = k;
              goto _L3
        }

        LayoutState() {
            mRecycle = true;
            mExtra = 0;
            mIsPreLayout = false;
            mScrapList = null;
        }
    }

    public static class SavedState
        implements Parcelable {

        public static final android.os.Parcelable.Creator CREATOR = new android.os.Parcelable.Creator() {

            public SavedState createFromParcel(Parcel parcel) {
                return new SavedState(parcel);
            }

            public volatile Object createFromParcel(Parcel parcel) {
                return createFromParcel(parcel);
            }

            public SavedState[] newArray(int i) {
                return new SavedState[i];
            }

            public volatile Object[] newArray(int i) {
                return newArray(i);
            }

        }
;
        boolean mAnchorLayoutFromEnd;
        int mAnchorOffset;
        int mAnchorPosition;

        public int describeContents() {
            return 0;
        }

        boolean hasValidAnchor() {
            boolean flag;
            if (mAnchorPosition >= 0)
                flag = true;
            else
                flag = false;
            return flag;
        }

        void invalidateAnchor() {
            mAnchorPosition = -1;
        }

        public void writeToParcel(Parcel parcel, int i) {
            parcel.writeInt(mAnchorPosition);
            parcel.writeInt(mAnchorOffset);
            if (mAnchorLayoutFromEnd)
                i = 1;
            else
                i = 0;
            parcel.writeInt(i);
        }


        public SavedState() {
        }

        SavedState(Parcel parcel) {
            boolean flag = true;
            super();
            mAnchorPosition = parcel.readInt();
            mAnchorOffset = parcel.readInt();
            if (parcel.readInt() != 1)
                flag = false;
            mAnchorLayoutFromEnd = flag;
        }

        public SavedState(SavedState savedstate) {
            mAnchorPosition = savedstate.mAnchorPosition;
            mAnchorOffset = savedstate.mAnchorOffset;
            mAnchorLayoutFromEnd = savedstate.mAnchorLayoutFromEnd;
        }
    }


    static final boolean DEBUG = false;
    public static final int HORIZONTAL = 0;
    public static final int INVALID_OFFSET = 0x80000000;
    private static final float MAX_SCROLL_FACTOR = 0.3333333F;
    private static final String TAG = "LinearLayoutManager";
    public static final int VERTICAL = 1;
    final AnchorInfo mAnchorInfo;
    private boolean mLastStackFromEnd;
    private final LayoutChunkResult mLayoutChunkResult;
    private LayoutState mLayoutState;
    int mOrientation;
    OrientationHelper mOrientationHelper;
    SavedState mPendingSavedState;
    int mPendingScrollPosition;
    int mPendingScrollPositionOffset;
    private boolean mRecycleChildrenOnDetach;
    private boolean mReverseLayout;
    boolean mShouldReverseLayout;
    private boolean mSmoothScrollbarEnabled;
    private boolean mStackFromEnd;

    public LinearLayoutManager(Context context) {
        this(context, 1, false);
    }

    public LinearLayoutManager(Context context, int i, boolean flag) {
        mReverseLayout = false;
        mShouldReverseLayout = false;
        mStackFromEnd = false;
        mSmoothScrollbarEnabled = true;
        mPendingScrollPosition = -1;
        mPendingScrollPositionOffset = 0x80000000;
        mPendingSavedState = null;
        mAnchorInfo = new AnchorInfo();
        mLayoutChunkResult = new LayoutChunkResult();
        setOrientation(i);
        setReverseLayout(flag);
        setAutoMeasureEnabled(true);
    }

    public LinearLayoutManager(Context context, AttributeSet attributeset, int i, int j) {
        mReverseLayout = false;
        mShouldReverseLayout = false;
        mStackFromEnd = false;
        mSmoothScrollbarEnabled = true;
        mPendingScrollPosition = -1;
        mPendingScrollPositionOffset = 0x80000000;
        mPendingSavedState = null;
        mAnchorInfo = new AnchorInfo();
        mLayoutChunkResult = new LayoutChunkResult();
        context = getProperties(context, attributeset, i, j);
        setOrientation(((RecyclerView.LayoutManager.Properties) (context)).orientation);
        setReverseLayout(((RecyclerView.LayoutManager.Properties) (context)).reverseLayout);
        setStackFromEnd(((RecyclerView.LayoutManager.Properties) (context)).stackFromEnd);
        setAutoMeasureEnabled(true);
    }

    private int computeScrollExtent(RecyclerView.State state) {
        boolean flag1 = false;
        int i = 0;
        if (getChildCount() != 0) {
            ensureLayoutState();
            OrientationHelper orientationhelper = mOrientationHelper;
            boolean flag;
            View view;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            else
                flag = false;
            view = findFirstVisibleChildClosestToStart(flag, true);
            flag = flag1;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            i = ScrollbarHelper.computeScrollExtent(state, orientationhelper, view, findFirstVisibleChildClosestToEnd(flag, true), this, mSmoothScrollbarEnabled);
        }
        return i;
    }

    private int computeScrollOffset(RecyclerView.State state) {
        boolean flag1 = false;
        int i = 0;
        if (getChildCount() != 0) {
            ensureLayoutState();
            OrientationHelper orientationhelper = mOrientationHelper;
            boolean flag;
            View view;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            else
                flag = false;
            view = findFirstVisibleChildClosestToStart(flag, true);
            flag = flag1;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            i = ScrollbarHelper.computeScrollOffset(state, orientationhelper, view, findFirstVisibleChildClosestToEnd(flag, true), this, mSmoothScrollbarEnabled, mShouldReverseLayout);
        }
        return i;
    }

    private int computeScrollRange(RecyclerView.State state) {
        boolean flag1 = false;
        int i = 0;
        if (getChildCount() != 0) {
            ensureLayoutState();
            OrientationHelper orientationhelper = mOrientationHelper;
            boolean flag;
            View view;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            else
                flag = false;
            view = findFirstVisibleChildClosestToStart(flag, true);
            flag = flag1;
            if (!mSmoothScrollbarEnabled)
                flag = true;
            i = ScrollbarHelper.computeScrollRange(state, orientationhelper, view, findFirstVisibleChildClosestToEnd(flag, true), this, mSmoothScrollbarEnabled);
        }
        return i;
    }

    private View findFirstReferenceChild(RecyclerView.Recycler recycler, RecyclerView.State state) {
        return findReferenceChild(recycler, state, 0, getChildCount(), state.getItemCount());
    }

    private View findFirstVisibleChildClosestToEnd(boolean flag, boolean flag1) {
        View view;
        if (mShouldReverseLayout)
            view = findOneVisibleChild(0, getChildCount(), flag, flag1);
        else
            view = findOneVisibleChild(getChildCount() - 1, -1, flag, flag1);
        return view;
    }

    private View findFirstVisibleChildClosestToStart(boolean flag, boolean flag1) {
        View view;
        if (mShouldReverseLayout)
            view = findOneVisibleChild(getChildCount() - 1, -1, flag, flag1);
        else
            view = findOneVisibleChild(0, getChildCount(), flag, flag1);
        return view;
    }

    private View findLastReferenceChild(RecyclerView.Recycler recycler, RecyclerView.State state) {
        return findReferenceChild(recycler, state, getChildCount() - 1, -1, state.getItemCount());
    }

    private View findReferenceChildClosestToEnd(RecyclerView.Recycler recycler, RecyclerView.State state) {
        if (mShouldReverseLayout)
            recycler = findFirstReferenceChild(recycler, state);
        else
            recycler = findLastReferenceChild(recycler, state);
        return recycler;
    }

    private View findReferenceChildClosestToStart(RecyclerView.Recycler recycler, RecyclerView.State state) {
        if (mShouldReverseLayout)
            recycler = findLastReferenceChild(recycler, state);
        else
            recycler = findFirstReferenceChild(recycler, state);
        return recycler;
    }

    private int fixLayoutEndGap(int i, RecyclerView.Recycler recycler, RecyclerView.State state, boolean flag) {
        int j = mOrientationHelper.getEndAfterPadding() - i;
        if (j > 0) {
            int k = -scrollBy(-j, recycler, state);
            j = k;
            if (flag) {
                i = mOrientationHelper.getEndAfterPadding() - (i + k);
                j = k;
                if (i > 0) {
                    mOrientationHelper.offsetChildren(i);
                    j = k + i;
                }
            }
        } else {
            j = 0;
        }
        return j;
    }

    private int fixLayoutStartGap(int i, RecyclerView.Recycler recycler, RecyclerView.State state, boolean flag) {
        int j = i - mOrientationHelper.getStartAfterPadding();
        if (j > 0) {
            int k = -scrollBy(j, recycler, state);
            j = k;
            if (flag) {
                i = (i + k) - mOrientationHelper.getStartAfterPadding();
                j = k;
                if (i > 0) {
                    mOrientationHelper.offsetChildren(-i);
                    j = k - i;
                }
            }
        } else {
            j = 0;
        }
        return j;
    }

    private View getChildClosestToEnd() {
        int i;
        if (mShouldReverseLayout)
            i = 0;
        else
            i = getChildCount() - 1;
        return getChildAt(i);
    }

    private View getChildClosestToStart() {
        int i;
        if (mShouldReverseLayout)
            i = getChildCount() - 1;
        else
            i = 0;
        return getChildAt(i);
    }

    private void layoutForPredictiveAnimations(RecyclerView.Recycler recycler, RecyclerView.State state, int i, int j) {
        if (state.willRunPredictiveAnimations() && getChildCount() != 0 && !state.isPreLayout() && supportsPredictiveItemAnimations()) {
            int k = 0;
            int l = 0;
            List list = recycler.getScrapList();
            int j2 = list.size();
            int k2 = getPosition(getChildAt(0));
            int i1 = 0;
            while (i1 < j2)  {
                RecyclerView.ViewHolder viewholder = (RecyclerView.ViewHolder)list.get(i1);
                int k1;
                if (viewholder.isRemoved()) {
                    int j1 = l;
                    l = k;
                    k = j1;
                } else {
                    int l1;
                    boolean flag;
                    if (viewholder.getLayoutPosition() < k2)
                        flag = true;
                    else
                        flag = false;
                    if (flag != mShouldReverseLayout)
                        l1 = -1;
                    else
                        l1 = 1;
                    if (l1 == -1) {
                        l1 = mOrientationHelper.getDecoratedMeasurement(viewholder.itemView) + k;
                        k = l;
                        l = l1;
                    } else {
                        int i2 = mOrientationHelper.getDecoratedMeasurement(viewholder.itemView) + l;
                        l = k;
                        k = i2;
                    }
                }
                k1 = i1 + 1;
                i1 = l;
                l = k;
                k = i1;
                i1 = k1;
            }
            mLayoutState.mScrapList = list;
            if (k > 0) {
                updateLayoutStateToFillStart(getPosition(getChildClosestToStart()), i);
                mLayoutState.mExtra = k;
                mLayoutState.mAvailable = 0;
                mLayoutState.assignPositionFromScrapList();
                fill(recycler, mLayoutState, state, false);
            }
            if (l > 0) {
                updateLayoutStateToFillEnd(getPosition(getChildClosestToEnd()), j);
                mLayoutState.mExtra = l;
                mLayoutState.mAvailable = 0;
                mLayoutState.assignPositionFromScrapList();
                fill(recycler, mLayoutState, state, false);
            }
            mLayoutState.mScrapList = null;
        }
    }

    private void logChildren() {
        Log.d("LinearLayoutManager", "internal representation of views on the screen");
        for (int i = 0; i < getChildCount(); i++) {
            View view = getChildAt(i);
            Log.d("LinearLayoutManager", (new StringBuilder()).append("item ").append(getPosition(view)).append(", coord:").append(mOrientationHelper.getDecoratedStart(view)).toString());
        }

        Log.d("LinearLayoutManager", "==============");
    }

    private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutstate) {
        if (layoutstate.mRecycle && !layoutstate.mInfinite)
            if (layoutstate.mLayoutDirection == -1)
                recycleViewsFromEnd(recycler, layoutstate.mScrollingOffset);
            else
                recycleViewsFromStart(recycler, layoutstate.mScrollingOffset);
    }

    private void recycleChildren(RecyclerView.Recycler recycler, int i, int j) {
        if (i != j) goto _L2; else goto _L1
_L1:
        return;
_L2:
        int k;
        k = i;
        if (j <= i)
            break; /* Loop/switch isn't completed */
        j--;
        while (j >= i)  {
            removeAndRecycleViewAt(j, recycler);
            j--;
        }
        if (true) goto _L1; else goto _L3
_L3:
        while (k > j)  {
            removeAndRecycleViewAt(k, recycler);
            k--;
        }
        if (true) goto _L1; else goto _L4
_L4:
    }

    private void recycleViewsFromEnd(RecyclerView.Recycler recycler, int i) {
        int j = getChildCount();
        if (i >= 0) goto _L2; else goto _L1
_L1:
        return;
_L2:
        int k;
        k = mOrientationHelper.getEnd() - i;
        if (mShouldReverseLayout) {
            i = 0;
            do {
                if (i >= j)
                    continue; /* Loop/switch isn't completed */
                View view = getChildAt(i);
                if (mOrientationHelper.getDecoratedStart(view) < k || mOrientationHelper.getTransformedStartWithDecoration(view) < k) {
                    recycleChildren(recycler, 0, i);
                    continue; /* Loop/switch isn't completed */
                }
                i++;
            } while (true);
        }
        i = j - 1;
_L4:
        if (i >= 0) {
label0:
            {
                View view1 = getChildAt(i);
                if (mOrientationHelper.getDecoratedStart(view1) >= k && mOrientationHelper.getTransformedStartWithDecoration(view1) >= k)
                    break label0;
                recycleChildren(recycler, j - 1, i);
            }
        }
        if (true) goto _L1; else goto _L3
_L3:
        i--;
          goto _L4
        if (true) goto _L1; else goto _L5
_L5:
    }

    private void recycleViewsFromStart(RecyclerView.Recycler recycler, int i) {
        if (i >= 0) goto _L2; else goto _L1
_L1:
        return;
_L2:
        int k;
        int l;
        l = getChildCount();
        if (mShouldReverseLayout) {
            int j = l - 1;
            do {
                if (j < 0)
                    continue; /* Loop/switch isn't completed */
                View view = getChildAt(j);
                if (mOrientationHelper.getDecoratedEnd(view) > i || mOrientationHelper.getTransformedEndWithDecoration(view) > i) {
                    recycleChildren(recycler, l - 1, j);
                    continue; /* Loop/switch isn't completed */
                }
                j--;
            } while (true);
        }
        k = 0;
_L4:
        if (k < l) {
label0:
            {
                View view1 = getChildAt(k);
                if (mOrientationHelper.getDecoratedEnd(view1) <= i && mOrientationHelper.getTransformedEndWithDecoration(view1) <= i)
                    break label0;
                recycleChildren(recycler, 0, k);
            }
        }
        if (true) goto _L1; else goto _L3
_L3:
        k++;
          goto _L4
        if (true) goto _L1; else goto _L5
_L5:
    }

    private void resolveShouldLayoutReverse() {
        boolean flag = true;
        if (mOrientation == 1 || !isLayoutRTL()) {
            mShouldReverseLayout = mReverseLayout;
        } else {
            if (mReverseLayout)
                flag = false;
            mShouldReverseLayout = flag;
        }
    }

    private boolean updateAnchorFromChildren(RecyclerView.Recycler recycler, RecyclerView.State state, AnchorInfo anchorinfo) {
        boolean flag;
        boolean flag2;
        flag = false;
        flag2 = false;
        if (getChildCount() != 0) goto _L2; else goto _L1
_L1:
        boolean flag1 = flag2;
_L4:
        return flag1;
_L2:
        View view = getFocusedChild();
        if (view != null && anchorinfo.isViewValidAsAnchor(view, state)) {
            anchorinfo.assignFromViewAndKeepVisibleRect(view);
            flag1 = true;
        } else {
            flag1 = flag2;
            if (mLastStackFromEnd == mStackFromEnd) {
                if (anchorinfo.mLayoutFromEnd)
                    recycler = findReferenceChildClosestToEnd(recycler, state);
                else
                    recycler = findReferenceChildClosestToStart(recycler, state);
                flag1 = flag2;
                if (recycler != null) {
                    anchorinfo.assignFromView(recycler);
                    if (!state.isPreLayout() && supportsPredictiveItemAnimations()) {
                        if (mOrientationHelper.getDecoratedStart(recycler) >= mOrientationHelper.getEndAfterPadding() || mOrientationHelper.getDecoratedEnd(recycler) < mOrientationHelper.getStartAfterPadding())
                            flag = true;
                        if (flag) {
                            int i;
                            if (anchorinfo.mLayoutFromEnd)
                                i = mOrientationHelper.getEndAfterPadding();
                            else
                                i = mOrientationHelper.getStartAfterPadding();
                            anchorinfo.mCoordinate = i;
                        }
                    }
                    flag1 = true;
                }
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private boolean updateAnchorFromPendingData(RecyclerView.State state, AnchorInfo anchorinfo) {
        boolean flag1 = false;
        boolean flag2 = true;
        boolean flag;
        if (state.isPreLayout() || mPendingScrollPosition == -1)
            flag = false;
        else
        if (mPendingScrollPosition < 0 || mPendingScrollPosition >= state.getItemCount()) {
            mPendingScrollPosition = -1;
            mPendingScrollPositionOffset = 0x80000000;
            flag = false;
        } else {
            anchorinfo.mPosition = mPendingScrollPosition;
            if (mPendingSavedState != null && mPendingSavedState.hasValidAnchor()) {
                anchorinfo.mLayoutFromEnd = mPendingSavedState.mAnchorLayoutFromEnd;
                if (anchorinfo.mLayoutFromEnd) {
                    anchorinfo.mCoordinate = mOrientationHelper.getEndAfterPadding() - mPendingSavedState.mAnchorOffset;
                    flag = flag2;
                } else {
                    anchorinfo.mCoordinate = mOrientationHelper.getStartAfterPadding() + mPendingSavedState.mAnchorOffset;
                    flag = flag2;
                }
            } else
            if (mPendingScrollPositionOffset == 0x80000000) {
                state = findViewByPosition(mPendingScrollPosition);
                if (state != null) {
                    if (mOrientationHelper.getDecoratedMeasurement(state) > mOrientationHelper.getTotalSpace()) {
                        anchorinfo.assignCoordinateFromPadding();
                        flag = flag2;
                    } else
                    if (mOrientationHelper.getDecoratedStart(state) - mOrientationHelper.getStartAfterPadding() < 0) {
                        anchorinfo.mCoordinate = mOrientationHelper.getStartAfterPadding();
                        anchorinfo.mLayoutFromEnd = false;
                        flag = flag2;
                    } else
                    if (mOrientationHelper.getEndAfterPadding() - mOrientationHelper.getDecoratedEnd(state) < 0) {
                        anchorinfo.mCoordinate = mOrientationHelper.getEndAfterPadding();
                        anchorinfo.mLayoutFromEnd = true;
                        flag = flag2;
                    } else {
                        int i;
                        if (anchorinfo.mLayoutFromEnd)
                            i = mOrientationHelper.getDecoratedEnd(state) + mOrientationHelper.getTotalSpaceChange();
                        else
                            i = mOrientationHelper.getDecoratedStart(state);
                        anchorinfo.mCoordinate = i;
                        flag = flag2;
                    }
                } else {
                    if (getChildCount() > 0) {
                        int j = getPosition(getChildAt(0));
                        if (mPendingScrollPosition < j)
                            flag = true;
                        else
                            flag = false;
                        if (flag == mShouldReverseLayout)
                            flag1 = true;
                        anchorinfo.mLayoutFromEnd = flag1;
                    }
                    anchorinfo.assignCoordinateFromPadding();
                    flag = flag2;
                }
            } else {
                anchorinfo.mLayoutFromEnd = mShouldReverseLayout;
                if (mShouldReverseLayout) {
                    anchorinfo.mCoordinate = mOrientationHelper.getEndAfterPadding() - mPendingScrollPositionOffset;
                    flag = flag2;
                } else {
                    anchorinfo.mCoordinate = mOrientationHelper.getStartAfterPadding() + mPendingScrollPositionOffset;
                    flag = flag2;
                }
            }
        }
        return flag;
    }

    private void updateAnchorInfoForLayout(RecyclerView.Recycler recycler, RecyclerView.State state, AnchorInfo anchorinfo) {
        if (!updateAnchorFromPendingData(state, anchorinfo) && !updateAnchorFromChildren(recycler, state, anchorinfo)) {
            anchorinfo.assignCoordinateFromPadding();
            int i;
            if (mStackFromEnd)
                i = state.getItemCount() - 1;
            else
                i = 0;
            anchorinfo.mPosition = i;
        }
    }

    private void updateLayoutState(int i, int j, boolean flag, RecyclerView.State state) {
        byte byte0 = -1;
        boolean flag1 = true;
        mLayoutState.mInfinite = resolveIsInfinite();
        mLayoutState.mExtra = getExtraLayoutSpace(state);
        mLayoutState.mLayoutDirection = i;
        if (i == 1) {
            state = mLayoutState;
            state.mExtra = ((LayoutState) (state)).mExtra + mOrientationHelper.getEndPadding();
            View view = getChildClosestToEnd();
            state = mLayoutState;
            if (mShouldReverseLayout)
                i = byte0;
            else
                i = 1;
            state.mItemDirection = i;
            mLayoutState.mCurrentPosition = getPosition(view) + mLayoutState.mItemDirection;
            mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(view);
            i = mOrientationHelper.getDecoratedEnd(view) - mOrientationHelper.getEndAfterPadding();
        } else {
            state = getChildClosestToStart();
            LayoutState layoutstate = mLayoutState;
            layoutstate.mExtra = layoutstate.mExtra + mOrientationHelper.getStartAfterPadding();
            layoutstate = mLayoutState;
            if (mShouldReverseLayout)
                i = ((flag1) ? 1 : 0);
            else
                i = -1;
            layoutstate.mItemDirection = i;
            mLayoutState.mCurrentPosition = getPosition(state) + mLayoutState.mItemDirection;
            mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(state);
            i = -mOrientationHelper.getDecoratedStart(state) + mOrientationHelper.getStartAfterPadding();
        }
        mLayoutState.mAvailable = j;
        if (flag) {
            state = mLayoutState;
            state.mAvailable = ((LayoutState) (state)).mAvailable - i;
        }
        mLayoutState.mScrollingOffset = i;
    }

    private void updateLayoutStateToFillEnd(int i, int j) {
        mLayoutState.mAvailable = mOrientationHelper.getEndAfterPadding() - j;
        LayoutState layoutstate = mLayoutState;
        int k;
        if (mShouldReverseLayout)
            k = -1;
        else
            k = 1;
        layoutstate.mItemDirection = k;
        mLayoutState.mCurrentPosition = i;
        mLayoutState.mLayoutDirection = 1;
        mLayoutState.mOffset = j;
        mLayoutState.mScrollingOffset = 0x80000000;
    }

    private void updateLayoutStateToFillEnd(AnchorInfo anchorinfo) {
        updateLayoutStateToFillEnd(anchorinfo.mPosition, anchorinfo.mCoordinate);
    }

    private void updateLayoutStateToFillStart(int i, int j) {
        mLayoutState.mAvailable = j - mOrientationHelper.getStartAfterPadding();
        mLayoutState.mCurrentPosition = i;
        LayoutState layoutstate = mLayoutState;
        if (mShouldReverseLayout)
            i = 1;
        else
            i = -1;
        layoutstate.mItemDirection = i;
        mLayoutState.mLayoutDirection = -1;
        mLayoutState.mOffset = j;
        mLayoutState.mScrollingOffset = 0x80000000;
    }

    private void updateLayoutStateToFillStart(AnchorInfo anchorinfo) {
        updateLayoutStateToFillStart(anchorinfo.mPosition, anchorinfo.mCoordinate);
    }

    public void assertNotInLayoutOrScroll(String s) {
        if (mPendingSavedState == null)
            super.assertNotInLayoutOrScroll(s);
    }

    public boolean canScrollHorizontally() {
        boolean flag;
        if (mOrientation == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean canScrollVertically() {
        boolean flag = true;
        if (mOrientation != 1)
            flag = false;
        return flag;
    }

    public int computeHorizontalScrollExtent(RecyclerView.State state) {
        return computeScrollExtent(state);
    }

    public int computeHorizontalScrollOffset(RecyclerView.State state) {
        return computeScrollOffset(state);
    }

    public int computeHorizontalScrollRange(RecyclerView.State state) {
        return computeScrollRange(state);
    }

    public PointF computeScrollVectorForPosition(int i) {
        boolean flag = true;
        boolean flag1 = false;
        PointF pointf;
        if (getChildCount() == 0) {
            pointf = null;
        } else {
            if (i < getPosition(getChildAt(0)))
                flag1 = true;
            i = ((flag) ? 1 : 0);
            if (flag1 != mShouldReverseLayout)
                i = -1;
            if (mOrientation == 0)
                pointf = new PointF(i, 0.0F);
            else
                pointf = new PointF(0.0F, i);
        }
        return pointf;
    }

    public int computeVerticalScrollExtent(RecyclerView.State state) {
        return computeScrollExtent(state);
    }

    public int computeVerticalScrollOffset(RecyclerView.State state) {
        return computeScrollOffset(state);
    }

    public int computeVerticalScrollRange(RecyclerView.State state) {
        return computeScrollRange(state);
    }

    int convertFocusDirectionToLayoutDirection(int i) {
        byte byte0;
        int j;
        boolean flag;
        byte0 = -1;
        j = 0x80000000;
        flag = true;
        i;
        JVM INSTR lookupswitch 6: default 68
    //                   1: 73
    //                   2: 97
    //                   17: 155
    //                   33: 124
    //                   66: 170
    //                   130: 140;
           goto _L1 _L2 _L3 _L4 _L5 _L6 _L7
_L1:
        i = 0x80000000;
_L9:
        return i;
_L2:
        i = byte0;
        if (mOrientation != 1) {
            i = byte0;
            if (isLayoutRTL())
                i = 1;
        }
        continue; /* Loop/switch isn't completed */
_L3:
        if (mOrientation == 1) {
            i = 1;
        } else {
            i = byte0;
            if (!isLayoutRTL())
                i = 1;
        }
        continue; /* Loop/switch isn't completed */
_L5:
        i = byte0;
        if (mOrientation != 1)
            i = 0x80000000;
        continue; /* Loop/switch isn't completed */
_L7:
        i = j;
        if (mOrientation == 1)
            i = 1;
        continue; /* Loop/switch isn't completed */
_L4:
        i = byte0;
        if (mOrientation != 0)
            i = 0x80000000;
        continue; /* Loop/switch isn't completed */
_L6:
        if (mOrientation == 0)
            i = ((flag) ? 1 : 0);
        else
            i = 0x80000000;
        if (true) goto _L9; else goto _L8
_L8:
    }

    LayoutState createLayoutState() {
        return new LayoutState();
    }

    void ensureLayoutState() {
        if (mLayoutState == null)
            mLayoutState = createLayoutState();
        if (mOrientationHelper == null)
            mOrientationHelper = OrientationHelper.createOrientationHelper(this, mOrientation);
    }

    int fill(RecyclerView.Recycler recycler, LayoutState layoutstate, RecyclerView.State state, boolean flag) {
        int j;
        int k;
        LayoutChunkResult layoutchunkresult;
        k = layoutstate.mAvailable;
        if (layoutstate.mScrollingOffset != 0x80000000) {
            if (layoutstate.mAvailable < 0)
                layoutstate.mScrollingOffset = layoutstate.mScrollingOffset + layoutstate.mAvailable;
            recycleByLayoutState(recycler, layoutstate);
        }
        j = layoutstate.mAvailable + layoutstate.mExtra;
        layoutchunkresult = mLayoutChunkResult;
_L4:
        if (!layoutstate.mInfinite && j <= 0 || !layoutstate.hasMore(state)) goto _L2; else goto _L1
_L1:
        layoutchunkresult.resetInternal();
        layoutChunk(recycler, state, layoutstate, layoutchunkresult);
        if (!layoutchunkresult.mFinished) goto _L3; else goto _L2
_L2:
        return k - layoutstate.mAvailable;
_L3:
        int i;
label0:
        {
            layoutstate.mOffset = layoutstate.mOffset + layoutchunkresult.mConsumed * layoutstate.mLayoutDirection;
            if (layoutchunkresult.mIgnoreConsumed && mLayoutState.mScrapList == null) {
                i = j;
                if (state.isPreLayout())
                    break label0;
            }
            layoutstate.mAvailable = layoutstate.mAvailable - layoutchunkresult.mConsumed;
            i = j - layoutchunkresult.mConsumed;
        }
        if (layoutstate.mScrollingOffset != 0x80000000) {
            layoutstate.mScrollingOffset = layoutstate.mScrollingOffset + layoutchunkresult.mConsumed;
            if (layoutstate.mAvailable < 0)
                layoutstate.mScrollingOffset = layoutstate.mScrollingOffset + layoutstate.mAvailable;
            recycleByLayoutState(recycler, layoutstate);
        }
        j = i;
        if (!flag)
            break; /* Loop/switch isn't completed */
        j = i;
        if (!layoutchunkresult.mFocusable) goto _L4; else goto _L2
    }

    public int findFirstCompletelyVisibleItemPosition() {
        View view = findOneVisibleChild(0, getChildCount(), true, false);
        int i;
        if (view == null)
            i = -1;
        else
            i = getPosition(view);
        return i;
    }

    public int findFirstVisibleItemPosition() {
        View view = findOneVisibleChild(0, getChildCount(), false, true);
        int i;
        if (view == null)
            i = -1;
        else
            i = getPosition(view);
        return i;
    }

    public int findLastCompletelyVisibleItemPosition() {
        int i = -1;
        View view = findOneVisibleChild(getChildCount() - 1, -1, true, false);
        if (view != null)
            i = getPosition(view);
        return i;
    }

    public int findLastVisibleItemPosition() {
        int i = -1;
        View view = findOneVisibleChild(getChildCount() - 1, -1, false, true);
        if (view != null)
            i = getPosition(view);
        return i;
    }

    View findOneVisibleChild(int i, int j, boolean flag, boolean flag1) {
        byte byte0;
        View view;
        View view1;
        View view2;
        ensureLayoutState();
        int l = mOrientationHelper.getStartAfterPadding();
        int k = mOrientationHelper.getEndAfterPadding();
        int i1;
        int j1;
        if (j > i)
            byte0 = 1;
        else
            byte0 = -1;
        view = null;
_L7:
        if (i == j) goto _L2; else goto _L1
_L1:
        view1 = getChildAt(i);
        i1 = mOrientationHelper.getDecoratedStart(view1);
        j1 = mOrientationHelper.getDecoratedEnd(view1);
        if (i1 >= k || j1 <= l)
            continue; /* Loop/switch isn't completed */
        view2 = view1;
        if (!flag) goto _L4; else goto _L3
_L3:
        if (i1 < l || j1 > k) goto _L6; else goto _L5
_L5:
        view2 = view1;
_L4:
        return view2;
_L6:
        if (flag1 && view == null)
            view = view1;
        i += byte0;
          goto _L7
_L2:
        view2 = view;
          goto _L4
    }

    View findReferenceChild(RecyclerView.Recycler recycler, RecyclerView.State state, int i, int j, int k) {
        int i1;
        int j1;
        Object obj;
        state = null;
        ensureLayoutState();
        j1 = mOrientationHelper.getStartAfterPadding();
        i1 = mOrientationHelper.getEndAfterPadding();
        int l;
        int k1;
        if (j > i)
            l = 1;
        else
            l = -1;
        recycler = null;
        if (i == j) goto _L2; else goto _L1
_L1:
        obj = getChildAt(i);
        k1 = getPosition(((View) (obj)));
        if (k1 < 0 || k1 >= k)
            break MISSING_BLOCK_LABEL_172;
        if (!((RecyclerView.LayoutParams)((View) (obj)).getLayoutParams()).isItemRemoved()) goto _L4; else goto _L3
_L3:
        if (recycler != null)
            break MISSING_BLOCK_LABEL_172;
        recycler = state;
        state = ((RecyclerView.State) (obj));
_L9:
        i += l;
        obj = state;
        state = recycler;
        recycler = ((RecyclerView.Recycler) (obj));
        break MISSING_BLOCK_LABEL_35;
_L4:
        if (mOrientationHelper.getDecoratedStart(((View) (obj))) >= i1) goto _L6; else goto _L5
_L5:
        Object obj1 = obj;
        if (mOrientationHelper.getDecoratedEnd(((View) (obj))) >= j1) goto _L7; else goto _L6
_L6:
        if (state != null)
            break MISSING_BLOCK_LABEL_172;
        state = recycler;
        recycler = ((RecyclerView.Recycler) (obj));
        continue; /* Loop/switch isn't completed */
_L2:
        if (state == null)
            state = recycler;
        obj1 = state;
_L7:
        return ((View) (obj1));
        RecyclerView.State state1 = state;
        state = recycler;
        recycler = state1;
        if (true) goto _L9; else goto _L8
_L8:
    }

    public View findViewByPosition(int i) {
        int j = getChildCount();
        if (j != 0) goto _L2; else goto _L1
_L1:
        View view = null;
_L4:
        return view;
_L2:
        int k = i - getPosition(getChildAt(0));
        if (k >= 0 && k < j) {
            View view1 = getChildAt(k);
            view = view1;
            if (getPosition(view1) == i)
                continue; /* Loop/switch isn't completed */
        }
        view = super.findViewByPosition(i);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public RecyclerView.LayoutParams generateDefaultLayoutParams() {
        return new RecyclerView.LayoutParams(-2, -2);
    }

    protected int getExtraLayoutSpace(RecyclerView.State state) {
        int i;
        if (state.hasTargetScrollPosition())
            i = mOrientationHelper.getTotalSpace();
        else
            i = 0;
        return i;
    }

    public int getOrientation() {
        return mOrientation;
    }

    public boolean getRecycleChildrenOnDetach() {
        return mRecycleChildrenOnDetach;
    }

    public boolean getReverseLayout() {
        return mReverseLayout;
    }

    public boolean getStackFromEnd() {
        return mStackFromEnd;
    }

    protected boolean isLayoutRTL() {
        boolean flag = true;
        if (getLayoutDirection() != 1)
            flag = false;
        return flag;
    }

    public boolean isSmoothScrollbarEnabled() {
        return mSmoothScrollbarEnabled;
    }

    void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutstate, LayoutChunkResult layoutchunkresult) {
        recycler = layoutstate.next(recycler);
        if (recycler != null) goto _L2; else goto _L1
_L1:
        layoutchunkresult.mFinished = true;
_L4:
        return;
_L2:
        int i;
        int j;
        int k;
        int l;
        state = (RecyclerView.LayoutParams)recycler.getLayoutParams();
        if (layoutstate.mScrapList == null) {
            boolean flag2 = mShouldReverseLayout;
            boolean flag;
            if (layoutstate.mLayoutDirection == -1)
                flag = true;
            else
                flag = false;
            if (flag2 == flag)
                addView(recycler);
            else
                addView(recycler, 0);
        } else {
            boolean flag3 = mShouldReverseLayout;
            boolean flag1;
            if (layoutstate.mLayoutDirection == -1)
                flag1 = true;
            else
                flag1 = false;
            if (flag3 == flag1)
                addDisappearingView(recycler);
            else
                addDisappearingView(recycler, 0);
        }
        measureChildWithMargins(recycler, 0, 0);
        layoutchunkresult.mConsumed = mOrientationHelper.getDecoratedMeasurement(recycler);
        if (mOrientation != 1)
            break; /* Loop/switch isn't completed */
        if (isLayoutRTL()) {
            i = getWidth() - getPaddingRight();
            j = i - mOrientationHelper.getDecoratedMeasurementInOther(recycler);
        } else {
            j = getPaddingLeft();
            i = mOrientationHelper.getDecoratedMeasurementInOther(recycler) + j;
        }
        if (layoutstate.mLayoutDirection == -1) {
            l = layoutstate.mOffset;
            k = layoutstate.mOffset - layoutchunkresult.mConsumed;
        } else {
            k = layoutstate.mOffset;
            l = layoutstate.mOffset;
            l = layoutchunkresult.mConsumed + l;
        }
_L5:
        layoutDecoratedWithMargins(recycler, j, k, i, l);
        if (state.isItemRemoved() || state.isItemChanged())
            layoutchunkresult.mIgnoreConsumed = true;
        layoutchunkresult.mFocusable = recycler.isFocusable();
        if (true) goto _L4; else goto _L3
_L3:
        k = getPaddingTop();
        l = k + mOrientationHelper.getDecoratedMeasurementInOther(recycler);
        if (layoutstate.mLayoutDirection == -1) {
            i = layoutstate.mOffset;
            j = layoutstate.mOffset - layoutchunkresult.mConsumed;
        } else {
            j = layoutstate.mOffset;
            i = layoutstate.mOffset + layoutchunkresult.mConsumed;
        }
          goto _L5
        if (true) goto _L4; else goto _L6
_L6:
    }

    void onAnchorReady(RecyclerView.Recycler recycler, RecyclerView.State state, AnchorInfo anchorinfo, int i) {
    }

    public void onDetachedFromWindow(RecyclerView recyclerview, RecyclerView.Recycler recycler) {
        super.onDetachedFromWindow(recyclerview, recycler);
        if (mRecycleChildrenOnDetach) {
            removeAndRecycleAllViews(recycler);
            recycler.clear();
        }
    }

    public View onFocusSearchFailed(View view, int i, RecyclerView.Recycler recycler, RecyclerView.State state) {
        Object obj;
        obj = null;
        resolveShouldLayoutReverse();
        if (getChildCount() != 0) goto _L2; else goto _L1
_L1:
        View view2 = obj;
_L4:
        return view2;
_L2:
        i = convertFocusDirectionToLayoutDirection(i);
        view2 = obj;
        if (i != 0x80000000) {
            ensureLayoutState();
            View view1;
            if (i == -1)
                view1 = findReferenceChildClosestToStart(recycler, state);
            else
                view1 = findReferenceChildClosestToEnd(recycler, state);
            view2 = obj;
            if (view1 != null) {
                ensureLayoutState();
                updateLayoutState(i, (int)(0.3333333F * (float)mOrientationHelper.getTotalSpace()), false, state);
                mLayoutState.mScrollingOffset = 0x80000000;
                mLayoutState.mRecycle = false;
                fill(recycler, mLayoutState, state, true);
                if (i == -1)
                    view = getChildClosestToStart();
                else
                    view = getChildClosestToEnd();
                view2 = obj;
                if (view != view1) {
                    view2 = obj;
                    if (view.isFocusable())
                        view2 = view;
                }
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void onInitializeAccessibilityEvent(AccessibilityEvent accessibilityevent) {
        super.onInitializeAccessibilityEvent(accessibilityevent);
        if (getChildCount() > 0) {
            accessibilityevent = AccessibilityEventCompat.asRecord(accessibilityevent);
            accessibilityevent.setFromIndex(findFirstVisibleItemPosition());
            accessibilityevent.setToIndex(findLastVisibleItemPosition());
        }
    }

    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        int k = -1;
        if (mPendingSavedState == null && mPendingScrollPosition == -1 || state.getItemCount() != 0) goto _L2; else goto _L1
_L1:
        removeAndRecycleAllViews(recycler);
_L5:
        return;
_L2:
        int i;
        int j;
        int l;
        if (mPendingSavedState != null && mPendingSavedState.hasValidAnchor())
            mPendingScrollPosition = mPendingSavedState.mAnchorPosition;
        ensureLayoutState();
        mLayoutState.mRecycle = false;
        resolveShouldLayoutReverse();
        if (!mAnchorInfo.mValid || mPendingScrollPosition != -1 || mPendingSavedState != null) {
            mAnchorInfo.reset();
            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;
            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);
            mAnchorInfo.mValid = true;
        }
        i = getExtraLayoutSpace(state);
        int i1;
        if (mLayoutState.mLastScrollDelta >= 0) {
            j = 0;
        } else {
            j = i;
            i = 0;
        }
        l = j + mOrientationHelper.getStartAfterPadding();
        i1 = i + mOrientationHelper.getEndPadding();
        i = i1;
        j = l;
        if (state.isPreLayout()) {
            i = i1;
            j = l;
            if (mPendingScrollPosition != -1) {
                i = i1;
                j = l;
                if (mPendingScrollPositionOffset != 0x80000000) {
                    Object obj = findViewByPosition(mPendingScrollPosition);
                    i = i1;
                    j = l;
                    if (obj != null) {
                        if (mShouldReverseLayout) {
                            i = mOrientationHelper.getEndAfterPadding() - mOrientationHelper.getDecoratedEnd(((View) (obj))) - mPendingScrollPositionOffset;
                        } else {
                            i = mOrientationHelper.getDecoratedStart(((View) (obj)));
                            j = mOrientationHelper.getStartAfterPadding();
                            i = mPendingScrollPositionOffset - (i - j);
                        }
                        if (i > 0) {
                            j = l + i;
                            i = i1;
                        } else {
                            i = i1 - i;
                            j = l;
                        }
                    }
                }
            }
        }
        if (mAnchorInfo.mLayoutFromEnd) {
            if (mShouldReverseLayout)
                k = 1;
        } else
        if (!mShouldReverseLayout)
            k = 1;
        onAnchorReady(recycler, state, mAnchorInfo, k);
        detachAndScrapAttachedViews(recycler);
        mLayoutState.mInfinite = resolveIsInfinite();
        mLayoutState.mIsPreLayout = state.isPreLayout();
        if (!mAnchorInfo.mLayoutFromEnd) goto _L4; else goto _L3
_L3:
        updateLayoutStateToFillStart(mAnchorInfo);
        mLayoutState.mExtra = j;
        fill(recycler, mLayoutState, state, false);
        l = mLayoutState.mOffset;
        i1 = mLayoutState.mCurrentPosition;
        j = i;
        if (mLayoutState.mAvailable > 0)
            j = i + mLayoutState.mAvailable;
        updateLayoutStateToFillEnd(mAnchorInfo);
        mLayoutState.mExtra = j;
        obj = mLayoutState;
        obj.mCurrentPosition = ((LayoutState) (obj)).mCurrentPosition + mLayoutState.mItemDirection;
        fill(recycler, mLayoutState, state, false);
        k = mLayoutState.mOffset;
        int j1;
        LayoutState layoutstate;
        if (mLayoutState.mAvailable > 0) {
            i = mLayoutState.mAvailable;
            updateLayoutStateToFillStart(i1, l);
            mLayoutState.mExtra = i;
            fill(recycler, mLayoutState, state, false);
            i = mLayoutState.mOffset;
        } else {
            i = l;
        }
        j = i;
        i = k;
        k = i;
        l = j;
        if (getChildCount() > 0)
            if (mShouldReverseLayout ^ mStackFromEnd) {
                k = fixLayoutEndGap(i, recycler, state, true);
                l = j + k;
                j = fixLayoutStartGap(l, recycler, state, false);
                l += j;
                k = i + k + j;
            } else {
                l = fixLayoutStartGap(j, recycler, state, true);
                i += l;
                k = fixLayoutEndGap(i, recycler, state, false);
                l = j + l + k;
                k = i + k;
            }
        layoutForPredictiveAnimations(recycler, state, l, k);
        if (!state.isPreLayout())
            mOrientationHelper.onLayoutComplete();
        else
            mAnchorInfo.reset();
        mLastStackFromEnd = mStackFromEnd;
        if (true) goto _L5; else goto _L4
_L4:
        updateLayoutStateToFillEnd(mAnchorInfo);
        mLayoutState.mExtra = i;
        fill(recycler, mLayoutState, state, false);
        k = mLayoutState.mOffset;
        j1 = mLayoutState.mCurrentPosition;
        i = j;
        if (mLayoutState.mAvailable > 0)
            i = j + mLayoutState.mAvailable;
        updateLayoutStateToFillStart(mAnchorInfo);
        mLayoutState.mExtra = i;
        layoutstate = mLayoutState;
        layoutstate.mCurrentPosition = layoutstate.mCurrentPosition + mLayoutState.mItemDirection;
        fill(recycler, mLayoutState, state, false);
        l = mLayoutState.mOffset;
        i = k;
        j = l;
        if (mLayoutState.mAvailable > 0) {
            i = mLayoutState.mAvailable;
            updateLayoutStateToFillEnd(j1, k);
            mLayoutState.mExtra = i;
            fill(recycler, mLayoutState, state, false);
            i = mLayoutState.mOffset;
            j = l;
        }
        break MISSING_BLOCK_LABEL_555;
    }

    public void onLayoutCompleted(RecyclerView.State state) {
        super.onLayoutCompleted(state);
        mPendingSavedState = null;
        mPendingScrollPosition = -1;
        mPendingScrollPositionOffset = 0x80000000;
        mAnchorInfo.reset();
    }

    public void onRestoreInstanceState(Parcelable parcelable) {
        if (parcelable instanceof SavedState) {
            mPendingSavedState = (SavedState)parcelable;
            requestLayout();
        }
    }

    public Parcelable onSaveInstanceState() {
        SavedState savedstate;
        if (mPendingSavedState != null) {
            savedstate = new SavedState(mPendingSavedState);
        } else {
            savedstate = new SavedState();
            if (getChildCount() > 0) {
                ensureLayoutState();
                boolean flag = mLastStackFromEnd ^ mShouldReverseLayout;
                savedstate.mAnchorLayoutFromEnd = flag;
                if (flag) {
                    View view = getChildClosestToEnd();
                    savedstate.mAnchorOffset = mOrientationHelper.getEndAfterPadding() - mOrientationHelper.getDecoratedEnd(view);
                    savedstate.mAnchorPosition = getPosition(view);
                } else {
                    View view1 = getChildClosestToStart();
                    savedstate.mAnchorPosition = getPosition(view1);
                    savedstate.mAnchorOffset = mOrientationHelper.getDecoratedStart(view1) - mOrientationHelper.getStartAfterPadding();
                }
            } else {
                savedstate.invalidateAnchor();
            }
        }
        return savedstate;
    }

    public void prepareForDrop(View view, View view1, int i, int j) {
        assertNotInLayoutOrScroll("Cannot drop a view during a scroll or layout calculation");
        ensureLayoutState();
        resolveShouldLayoutReverse();
        i = getPosition(view);
        j = getPosition(view1);
        if (i < j)
            i = 1;
        else
            i = -1;
        if (mShouldReverseLayout) {
            if (i == 1)
                scrollToPositionWithOffset(j, mOrientationHelper.getEndAfterPadding() - (mOrientationHelper.getDecoratedStart(view1) + mOrientationHelper.getDecoratedMeasurement(view)));
            else
                scrollToPositionWithOffset(j, mOrientationHelper.getEndAfterPadding() - mOrientationHelper.getDecoratedEnd(view1));
        } else
        if (i == -1)
            scrollToPositionWithOffset(j, mOrientationHelper.getDecoratedStart(view1));
        else
            scrollToPositionWithOffset(j, mOrientationHelper.getDecoratedEnd(view1) - mOrientationHelper.getDecoratedMeasurement(view));
    }

    boolean resolveIsInfinite() {
        boolean flag;
        if (mOrientationHelper.getMode() == 0 && mOrientationHelper.getEnd() == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    int scrollBy(int i, RecyclerView.Recycler recycler, RecyclerView.State state) {
        if (getChildCount() == 0 || i == 0) {
            i = 0;
        } else {
            mLayoutState.mRecycle = true;
            ensureLayoutState();
            int j;
            int k;
            int l;
            if (i > 0)
                j = 1;
            else
                j = -1;
            l = Math.abs(i);
            updateLayoutState(j, l, true, state);
            k = mLayoutState.mScrollingOffset + fill(recycler, mLayoutState, state, false);
            if (k < 0) {
                i = 0;
            } else {
                if (l > k)
                    i = j * k;
                mOrientationHelper.offsetChildren(-i);
                mLayoutState.mLastScrollDelta = i;
            }
        }
        return i;
    }

    public int scrollHorizontallyBy(int i, RecyclerView.Recycler recycler, RecyclerView.State state) {
        if (mOrientation == 1)
            i = 0;
        else
            i = scrollBy(i, recycler, state);
        return i;
    }

    public void scrollToPosition(int i) {
        mPendingScrollPosition = i;
        mPendingScrollPositionOffset = 0x80000000;
        if (mPendingSavedState != null)
            mPendingSavedState.invalidateAnchor();
        requestLayout();
    }

    public void scrollToPositionWithOffset(int i, int j) {
        mPendingScrollPosition = i;
        mPendingScrollPositionOffset = j;
        if (mPendingSavedState != null)
            mPendingSavedState.invalidateAnchor();
        requestLayout();
    }

    public int scrollVerticallyBy(int i, RecyclerView.Recycler recycler, RecyclerView.State state) {
        if (mOrientation == 0)
            i = 0;
        else
            i = scrollBy(i, recycler, state);
        return i;
    }

    public void setOrientation(int i) {
        if (i != 0 && i != 1)
            throw new IllegalArgumentException((new StringBuilder()).append("invalid orientation:").append(i).toString());
        assertNotInLayoutOrScroll(null);
        if (i != mOrientation) {
            mOrientation = i;
            mOrientationHelper = null;
            requestLayout();
        }
    }

    public void setRecycleChildrenOnDetach(boolean flag) {
        mRecycleChildrenOnDetach = flag;
    }

    public void setReverseLayout(boolean flag) {
        assertNotInLayoutOrScroll(null);
        if (flag != mReverseLayout) {
            mReverseLayout = flag;
            requestLayout();
        }
    }

    public void setSmoothScrollbarEnabled(boolean flag) {
        mSmoothScrollbarEnabled = flag;
    }

    public void setStackFromEnd(boolean flag) {
        assertNotInLayoutOrScroll(null);
        if (mStackFromEnd != flag) {
            mStackFromEnd = flag;
            requestLayout();
        }
    }

    boolean shouldMeasureTwice() {
        boolean flag;
        if (getHeightMode() != 0x40000000 && getWidthMode() != 0x40000000 && hasFlexibleChildInBothOrientations())
            flag = true;
        else
            flag = false;
        return flag;
    }

    public void smoothScrollToPosition(RecyclerView recyclerview, RecyclerView.State state, int i) {
        recyclerview = new LinearSmoothScroller(recyclerview.getContext());
        recyclerview.setTargetPosition(i);
        startSmoothScroll(recyclerview);
    }

    public boolean supportsPredictiveItemAnimations() {
        boolean flag;
        if (mPendingSavedState == null && mLastStackFromEnd == mStackFromEnd)
            flag = true;
        else
            flag = false;
        return flag;
    }

    void validateChildOrder() {
        boolean flag;
        boolean flag2;
        flag2 = true;
        flag = true;
        Log.d("LinearLayoutManager", (new StringBuilder()).append("validating child count ").append(getChildCount()).toString());
        if (getChildCount() >= 1) goto _L2; else goto _L1
_L1:
        return;
_L2:
        int k;
        int l;
        l = getPosition(getChildAt(0));
        k = mOrientationHelper.getDecoratedStart(getChildAt(0));
        if (!mShouldReverseLayout)
            break; /* Loop/switch isn't completed */
        int i = 1;
        while (i < getChildCount())  {
            View view = getChildAt(i);
            int i1 = getPosition(view);
            int k1 = mOrientationHelper.getDecoratedStart(view);
            if (i1 < l) {
                logChildren();
                StringBuilder stringbuilder = (new StringBuilder()).append("detected invalid position. loc invalid? ");
                if (k1 >= k)
                    flag = false;
                throw new RuntimeException(stringbuilder.append(flag).toString());
            }
            if (k1 > k) {
                logChildren();
                throw new RuntimeException("detected invalid location");
            }
            i++;
        }
        if (true) goto _L1; else goto _L3
_L3:
        int j = 1;
        while (j < getChildCount())  {
            View view1 = getChildAt(j);
            int l1 = getPosition(view1);
            int j1 = mOrientationHelper.getDecoratedStart(view1);
            if (l1 < l) {
                logChildren();
                StringBuilder stringbuilder1 = (new StringBuilder()).append("detected invalid position. loc invalid? ");
                boolean flag1;
                if (j1 < k)
                    flag1 = flag2;
                else
                    flag1 = false;
                throw new RuntimeException(stringbuilder1.append(flag1).toString());
            }
            if (j1 < k) {
                logChildren();
                throw new RuntimeException("detected invalid location");
            }
            j++;
        }
        if (true) goto _L1; else goto _L4
_L4:
    }
}
