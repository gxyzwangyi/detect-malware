// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.v7.widget;

import android.view.View;
import java.util.ArrayList;
import java.util.List;

class ChildHelper {
    static class Bucket {

        static final int BITS_PER_WORD = 64;
        static final long LAST_BIT = 0x0L;
        long mData;
        Bucket next;

        private void ensureNext() {
            if (next == null)
                next = new Bucket();
        }

        void clear(int i) {
            if (i >= 64) {
                if (next != null)
                    next.clear(i - 64);
            } else {
                mData = mData & ~(1L << i);
            }
        }

        int countOnesBefore(int i) {
            if (next == null) {
                if (i >= 64)
                    i = Long.bitCount(mData);
                else
                    i = Long.bitCount(mData & (1L << i) - 1L);
            } else
            if (i < 64)
                i = Long.bitCount(mData & (1L << i) - 1L);
            else
                i = next.countOnesBefore(i - 64) + Long.bitCount(mData);
            return i;
        }

        boolean get(int i) {
            boolean flag;
            if (i >= 64) {
                ensureNext();
                flag = next.get(i - 64);
            } else
            if ((mData & 1L << i) != 0L)
                flag = true;
            else
                flag = false;
            return flag;
        }

        void insert(int i, boolean flag) {
            if (i < 64) goto _L2; else goto _L1
_L1:
            ensureNext();
            next.insert(i - 64, flag);
_L4:
            return;
_L2:
            boolean flag1;
            long l;
            long l1;
            if ((mData & 0x0L) != 0L)
                flag1 = true;
            else
                flag1 = false;
            l1 = (1L << i) - 1L;
            l = mData;
            mData = (~l1 & mData) << 1 | l & l1;
            if (flag)
                set(i);
            else
                clear(i);
            if (flag1 || next != null) {
                ensureNext();
                next.insert(0, flag1);
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        boolean remove(int i) {
            if (i < 64) goto _L2; else goto _L1
_L1:
            boolean flag1;
            ensureNext();
            flag1 = next.remove(i - 64);
_L4:
            return flag1;
_L2:
            long l = 1L << i;
            boolean flag;
            long l1;
            if ((mData & l) != 0L)
                flag = true;
            else
                flag = false;
            mData = mData & ~l;
            l--;
            l1 = mData;
            mData = Long.rotateRight(~l & mData, 1) | l1 & l;
            flag1 = flag;
            if (next != null) {
                if (next.get(0))
                    set(63);
                next.remove(0);
                flag1 = flag;
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        void reset() {
            mData = 0L;
            if (next != null)
                next.reset();
        }

        void set(int i) {
            if (i >= 64) {
                ensureNext();
                next.set(i - 64);
            } else {
                mData = mData | 1L << i;
            }
        }

        public String toString() {
            String s;
            if (next == null)
                s = Long.toBinaryString(mData);
            else
                s = (new StringBuilder()).append(next.toString()).append("xx").append(Long.toBinaryString(mData)).toString();
            return s;
        }

        Bucket() {
            mData = 0L;
        }
    }

    static interface Callback {

        public abstract void addView(View view, int i);

        public abstract void attachViewToParent(View view, int i, android.view.ViewGroup.LayoutParams layoutparams);

        public abstract void detachViewFromParent(int i);

        public abstract View getChildAt(int i);

        public abstract int getChildCount();

        public abstract RecyclerView.ViewHolder getChildViewHolder(View view);

        public abstract int indexOfChild(View view);

        public abstract void onEnteredHiddenState(View view);

        public abstract void onLeftHiddenState(View view);

        public abstract void removeAllViews();

        public abstract void removeViewAt(int i);
    }


    private static final boolean DEBUG = false;
    private static final String TAG = "ChildrenHelper";
    final Bucket mBucket = new Bucket();
    final Callback mCallback;
    final List mHiddenViews = new ArrayList();

    ChildHelper(Callback callback) {
        mCallback = callback;
    }

    private int getOffset(int i) {
        if (i >= 0) goto _L2; else goto _L1
_L1:
        i = -1;
_L4:
        return i;
_L2:
        int k = mCallback.getChildCount();
        int l;
        for (int j = i; j < k; j += l) {
            l = i - (j - mBucket.countOnesBefore(j));
            if (l != 0)
                continue;
            do {
                i = j;
                if (!mBucket.get(j))
                    continue; /* Loop/switch isn't completed */
                j++;
            } while (true);
        }

        i = -1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    private void hideViewInternal(View view) {
        mHiddenViews.add(view);
        mCallback.onEnteredHiddenState(view);
    }

    private boolean unhideViewInternal(View view) {
        boolean flag;
        if (mHiddenViews.remove(view)) {
            mCallback.onLeftHiddenState(view);
            flag = true;
        } else {
            flag = false;
        }
        return flag;
    }

    void addView(View view, int i, boolean flag) {
        if (i < 0)
            i = mCallback.getChildCount();
        else
            i = getOffset(i);
        mBucket.insert(i, flag);
        if (flag)
            hideViewInternal(view);
        mCallback.addView(view, i);
    }

    void addView(View view, boolean flag) {
        addView(view, -1, flag);
    }

    void attachViewToParent(View view, int i, android.view.ViewGroup.LayoutParams layoutparams, boolean flag) {
        if (i < 0)
            i = mCallback.getChildCount();
        else
            i = getOffset(i);
        mBucket.insert(i, flag);
        if (flag)
            hideViewInternal(view);
        mCallback.attachViewToParent(view, i, layoutparams);
    }

    void detachViewFromParent(int i) {
        i = getOffset(i);
        mBucket.remove(i);
        mCallback.detachViewFromParent(i);
    }

    View findHiddenNonRemovedView(int i, int j) {
        int k;
        int l;
        l = mHiddenViews.size();
        k = 0;
_L3:
        if (k >= l) goto _L2; else goto _L1
_L1:
        View view;
        View view1 = (View)mHiddenViews.get(k);
        RecyclerView.ViewHolder viewholder = mCallback.getChildViewHolder(view1);
        if (viewholder.getLayoutPosition() != i || viewholder.isInvalid() || viewholder.isRemoved())
            continue; /* Loop/switch isn't completed */
        view = view1;
        if (j != -1) {
            if (viewholder.getItemViewType() != j)
                continue; /* Loop/switch isn't completed */
            view = view1;
        }
_L4:
        return view;
        k++;
          goto _L3
_L2:
        view = null;
          goto _L4
    }

    View getChildAt(int i) {
        i = getOffset(i);
        return mCallback.getChildAt(i);
    }

    int getChildCount() {
        return mCallback.getChildCount() - mHiddenViews.size();
    }

    View getUnfilteredChildAt(int i) {
        return mCallback.getChildAt(i);
    }

    int getUnfilteredChildCount() {
        return mCallback.getChildCount();
    }

    void hide(View view) {
        int i = mCallback.indexOfChild(view);
        if (i < 0) {
            throw new IllegalArgumentException((new StringBuilder()).append("view is not a child, cannot hide ").append(view).toString());
        } else {
            mBucket.set(i);
            hideViewInternal(view);
            return;
        }
    }

    int indexOfChild(View view) {
        int i;
        int j;
        i = -1;
        j = mCallback.indexOfChild(view);
        break MISSING_BLOCK_LABEL_13;
        if (j != -1 && !mBucket.get(j))
            i = j - mBucket.countOnesBefore(j);
        return i;
    }

    boolean isHidden(View view) {
        return mHiddenViews.contains(view);
    }

    void removeAllViewsUnfiltered() {
        mBucket.reset();
        for (int i = mHiddenViews.size() - 1; i >= 0; i--) {
            mCallback.onLeftHiddenState((View)mHiddenViews.get(i));
            mHiddenViews.remove(i);
        }

        mCallback.removeAllViews();
    }

    void removeView(View view) {
        int i = mCallback.indexOfChild(view);
        if (i >= 0) {
            if (mBucket.remove(i))
                unhideViewInternal(view);
            mCallback.removeViewAt(i);
        }
    }

    void removeViewAt(int i) {
        i = getOffset(i);
        View view = mCallback.getChildAt(i);
        if (view != null) {
            if (mBucket.remove(i))
                unhideViewInternal(view);
            mCallback.removeViewAt(i);
        }
    }

    boolean removeViewIfHidden(View view) {
        boolean flag = true;
        int i = mCallback.indexOfChild(view);
        if (i == -1) {
            if (!unhideViewInternal(view));
        } else
        if (mBucket.get(i)) {
            mBucket.remove(i);
            if (unhideViewInternal(view));
            mCallback.removeViewAt(i);
        } else {
            flag = false;
        }
        return flag;
    }

    public String toString() {
        return (new StringBuilder()).append(mBucket.toString()).append(", hidden list:").append(mHiddenViews.size()).toString();
    }

    void unhide(View view) {
        int i = mCallback.indexOfChild(view);
        if (i < 0)
            throw new IllegalArgumentException((new StringBuilder()).append("view is not a child, cannot hide ").append(view).toString());
        if (!mBucket.get(i)) {
            throw new RuntimeException((new StringBuilder()).append("trying to unhide a view that was not hidden").append(view).toString());
        } else {
            mBucket.clear(i);
            unhideViewInternal(view);
            return;
        }
    }
}
