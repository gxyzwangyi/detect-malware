// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.design.widget;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.os.Parcel;
import android.os.Parcelable;
import android.support.v4.os.ParcelableCompat;
import android.support.v4.os.ParcelableCompatCreatorCallbacks;
import android.support.v4.view.*;
import android.support.v4.widget.ViewDragHelper;
import android.util.AttributeSet;
import android.util.TypedValue;
import android.view.*;
import java.lang.annotation.Annotation;
import java.lang.ref.WeakReference;

// Referenced classes of package android.support.design.widget:
//            CoordinatorLayout, MathUtils

public class BottomSheetBehavior extends CoordinatorLayout.Behavior {
    public static abstract class BottomSheetCallback {

        public abstract void onSlide(View view, float f);

        public abstract void onStateChanged(View view, int i);

        public BottomSheetCallback() {
        }
    }

    protected static class SavedState extends AbsSavedState {

        public static final android.os.Parcelable.Creator CREATOR = ParcelableCompat.newCreator(new ParcelableCompatCreatorCallbacks() {

            public SavedState createFromParcel(Parcel parcel, ClassLoader classloader) {
                return new SavedState(parcel, classloader);
            }

            public volatile Object createFromParcel(Parcel parcel, ClassLoader classloader) {
                return createFromParcel(parcel, classloader);
            }

            public SavedState[] newArray(int i) {
                return new SavedState[i];
            }

            public volatile Object[] newArray(int i) {
                return newArray(i);
            }

        }
);
        final int state;

        public void writeToParcel(Parcel parcel, int i) {
            super.writeToParcel(parcel, i);
            parcel.writeInt(state);
        }


        public SavedState(Parcel parcel) {
            this(parcel, ((ClassLoader) (null)));
        }

        public SavedState(Parcel parcel, ClassLoader classloader) {
            super(parcel, classloader);
            state = parcel.readInt();
        }

        public SavedState(Parcelable parcelable, int i) {
            super(parcelable);
            state = i;
        }
    }

    private class SettleRunnable
        implements Runnable {

        private final int mTargetState;
        private final View mView;
        final BottomSheetBehavior this$0;

        public void run() {
            if (mViewDragHelper != null && mViewDragHelper.continueSettling(true))
                ViewCompat.postOnAnimation(mView, this);
            else
                setStateInternal(mTargetState);
        }

        SettleRunnable(View view, int i) {
            this$0 = BottomSheetBehavior.this;
            super();
            mView = view;
            mTargetState = i;
        }
    }

    public static interface State
        extends Annotation {
    }


    private static final float HIDE_FRICTION = 0.1F;
    private static final float HIDE_THRESHOLD = 0.5F;
    public static final int PEEK_HEIGHT_AUTO = -1;
    public static final int STATE_COLLAPSED = 4;
    public static final int STATE_DRAGGING = 1;
    public static final int STATE_EXPANDED = 3;
    public static final int STATE_HIDDEN = 5;
    public static final int STATE_SETTLING = 2;
    int mActivePointerId;
    private BottomSheetCallback mCallback;
    private final android.support.v4.widget.ViewDragHelper.Callback mDragCallback;
    boolean mHideable;
    private boolean mIgnoreEvents;
    private int mInitialY;
    private int mLastNestedScrollDy;
    int mMaxOffset;
    private float mMaximumVelocity;
    int mMinOffset;
    private boolean mNestedScrolled;
    WeakReference mNestedScrollingChildRef;
    int mParentHeight;
    private int mPeekHeight;
    private boolean mPeekHeightAuto;
    private int mPeekHeightMin;
    private boolean mSkipCollapsed;
    int mState;
    boolean mTouchingScrollingChild;
    private VelocityTracker mVelocityTracker;
    ViewDragHelper mViewDragHelper;
    WeakReference mViewRef;

    public BottomSheetBehavior() {
        mState = 4;
        mDragCallback = new android.support.v4.widget.ViewDragHelper.Callback() {

            final BottomSheetBehavior this$0;

            public int clampViewPositionHorizontal(View view, int i, int j) {
                return view.getLeft();
            }

            public int clampViewPositionVertical(View view, int i, int j) {
                int k = mMinOffset;
                if (mHideable)
                    j = mParentHeight;
                else
                    j = mMaxOffset;
                return MathUtils.constrain(i, k, j);
            }

            public int getViewVerticalDragRange(View view) {
                int i;
                if (mHideable)
                    i = mParentHeight - mMinOffset;
                else
                    i = mMaxOffset - mMinOffset;
                return i;
            }

            public void onViewDragStateChanged(int i) {
                if (i == 1)
                    setStateInternal(1);
            }

            public void onViewPositionChanged(View view, int i, int j, int k, int l) {
                dispatchOnSlide(j);
            }

            public void onViewReleased(View view, float f, float f1) {
                byte byte0 = 3;
                int i;
                if (f1 < 0.0F)
                    i = mMinOffset;
                else
                if (mHideable && shouldHide(view, f1)) {
                    i = mParentHeight;
                    byte0 = 5;
                } else
                if (f1 == 0.0F) {
                    i = view.getTop();
                    if (Math.abs(i - mMinOffset) < Math.abs(i - mMaxOffset)) {
                        i = mMinOffset;
                    } else {
                        i = mMaxOffset;
                        byte0 = 4;
                    }
                } else {
                    i = mMaxOffset;
                    byte0 = 4;
                }
                if (mViewDragHelper.settleCapturedViewAt(view.getLeft(), i)) {
                    setStateInternal(2);
                    ViewCompat.postOnAnimation(view, new SettleRunnable(view, byte0));
                } else {
                    setStateInternal(byte0);
                }
            }

            public boolean tryCaptureView(View view, int i) {
                boolean flag1 = false;
                if (mState != 1) goto _L2; else goto _L1
_L1:
                boolean flag = flag1;
_L4:
                return flag;
_L2:
                flag = flag1;
                if (mTouchingScrollingChild)
                    continue; /* Loop/switch isn't completed */
                if (mState == 3 && mActivePointerId == i) {
                    View view1 = (View)mNestedScrollingChildRef.get();
                    if (view1 != null) {
                        flag = flag1;
                        if (ViewCompat.canScrollVertically(view1, -1))
                            continue; /* Loop/switch isn't completed */
                    }
                }
                if (mViewRef != null && mViewRef.get() == view)
                    flag = true;
                else
                    flag = false;
                if (true) goto _L4; else goto _L3
_L3:
            }

             {
                this$0 = BottomSheetBehavior.this;
                super();
            }
        }
;
    }

    public BottomSheetBehavior(Context context, AttributeSet attributeset) {
        super(context, attributeset);
        mState = 4;
        mDragCallback = new _cls2();
        TypedArray typedarray = context.obtainStyledAttributes(attributeset, android.support.design.R.styleable.BottomSheetBehavior_Layout);
        attributeset = typedarray.peekValue(android.support.design.R.styleable.BottomSheetBehavior_Layout_behavior_peekHeight);
        if (attributeset != null && ((TypedValue) (attributeset)).data == -1)
            setPeekHeight(((TypedValue) (attributeset)).data);
        else
            setPeekHeight(typedarray.getDimensionPixelSize(android.support.design.R.styleable.BottomSheetBehavior_Layout_behavior_peekHeight, -1));
        setHideable(typedarray.getBoolean(android.support.design.R.styleable.BottomSheetBehavior_Layout_behavior_hideable, false));
        setSkipCollapsed(typedarray.getBoolean(android.support.design.R.styleable.BottomSheetBehavior_Layout_behavior_skipCollapsed, false));
        typedarray.recycle();
        mMaximumVelocity = ViewConfiguration.get(context).getScaledMaximumFlingVelocity();
    }

    private View findScrollingChild(View view) {
        if (!(view instanceof NestedScrollingChild)) goto _L2; else goto _L1
_L1:
        return view;
_L2:
        if (view instanceof ViewGroup) {
            ViewGroup viewgroup = (ViewGroup)view;
            int j = viewgroup.getChildCount();
            for (int i = 0; i < j; i++) {
                view = findScrollingChild(viewgroup.getChildAt(i));
                if (view != null)
                    continue; /* Loop/switch isn't completed */
            }

        }
        view = null;
        if (true) goto _L1; else goto _L3
_L3:
    }

    public static BottomSheetBehavior from(View view) {
        view = view.getLayoutParams();
        if (!(view instanceof CoordinatorLayout.LayoutParams))
            throw new IllegalArgumentException("The view is not a child of CoordinatorLayout");
        view = ((CoordinatorLayout.LayoutParams)view).getBehavior();
        if (!(view instanceof BottomSheetBehavior))
            throw new IllegalArgumentException("The view is not associated with BottomSheetBehavior");
        else
            return (BottomSheetBehavior)view;
    }

    private float getYVelocity() {
        mVelocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
        return VelocityTrackerCompat.getYVelocity(mVelocityTracker, mActivePointerId);
    }

    private void reset() {
        mActivePointerId = -1;
        if (mVelocityTracker != null) {
            mVelocityTracker.recycle();
            mVelocityTracker = null;
        }
    }

    void dispatchOnSlide(int i) {
        View view = (View)mViewRef.get();
        if (view != null && mCallback != null)
            if (i > mMaxOffset)
                mCallback.onSlide(view, (float)(mMaxOffset - i) / (float)(mParentHeight - mMaxOffset));
            else
                mCallback.onSlide(view, (float)(mMaxOffset - i) / (float)(mMaxOffset - mMinOffset));
    }

    public final int getPeekHeight() {
        int i;
        if (mPeekHeightAuto)
            i = -1;
        else
            i = mPeekHeight;
        return i;
    }

    public boolean getSkipCollapsed() {
        return mSkipCollapsed;
    }

    public final int getState() {
        return mState;
    }

    public boolean isHideable() {
        return mHideable;
    }

    public boolean onInterceptTouchEvent(CoordinatorLayout coordinatorlayout, View view, MotionEvent motionevent) {
        boolean flag;
        boolean flag1;
        flag1 = true;
        flag = false;
        if (view.isShown()) goto _L2; else goto _L1
_L1:
        mIgnoreEvents = true;
_L6:
        return flag;
_L2:
        int i;
        i = MotionEventCompat.getActionMasked(motionevent);
        if (i == 0)
            reset();
        if (mVelocityTracker == null)
            mVelocityTracker = VelocityTracker.obtain();
        mVelocityTracker.addMovement(motionevent);
        i;
        JVM INSTR tableswitch 0 3: default 92
    //                   0 141
    //                   1 116
    //                   2 92
    //                   3 116;
           goto _L3 _L4 _L5 _L3 _L5
_L3:
        if (!mIgnoreEvents && mViewDragHelper.shouldInterceptTouchEvent(motionevent)) {
            flag = true;
        } else {
            view = (View)mNestedScrollingChildRef.get();
            if (i == 2 && view != null && !mIgnoreEvents && mState != 1 && !coordinatorlayout.isPointInChildBounds(view, (int)motionevent.getX(), (int)motionevent.getY()) && Math.abs((float)mInitialY - motionevent.getY()) > (float)mViewDragHelper.getTouchSlop())
                flag = flag1;
            else
                flag = false;
        }
          goto _L6
_L5:
        mTouchingScrollingChild = false;
        mActivePointerId = -1;
        if (!mIgnoreEvents) goto _L3; else goto _L7
_L7:
        mIgnoreEvents = false;
          goto _L6
_L4:
        int j = (int)motionevent.getX();
        mInitialY = (int)motionevent.getY();
        View view1 = (View)mNestedScrollingChildRef.get();
        if (view1 != null && coordinatorlayout.isPointInChildBounds(view1, j, mInitialY)) {
            mActivePointerId = motionevent.getPointerId(motionevent.getActionIndex());
            mTouchingScrollingChild = true;
        }
        if (mActivePointerId == -1 && !coordinatorlayout.isPointInChildBounds(view, j, mInitialY))
            flag = true;
        else
            flag = false;
        mIgnoreEvents = flag;
          goto _L3
    }

    public boolean onLayoutChild(CoordinatorLayout coordinatorlayout, View view, int i) {
        int j;
        if (ViewCompat.getFitsSystemWindows(coordinatorlayout) && !ViewCompat.getFitsSystemWindows(view))
            ViewCompat.setFitsSystemWindows(view, true);
        j = view.getTop();
        coordinatorlayout.onLayoutChild(view, i);
        mParentHeight = coordinatorlayout.getHeight();
        if (mPeekHeightAuto) {
            if (mPeekHeightMin == 0)
                mPeekHeightMin = coordinatorlayout.getResources().getDimensionPixelSize(android.support.design.R.dimen.design_bottom_sheet_peek_height_min);
            i = Math.max(mPeekHeightMin, mParentHeight - (coordinatorlayout.getWidth() * 9) / 16);
        } else {
            i = mPeekHeight;
        }
        mMinOffset = Math.max(0, mParentHeight - view.getHeight());
        mMaxOffset = Math.max(mParentHeight - i, mMinOffset);
        if (mState != 3) goto _L2; else goto _L1
_L1:
        ViewCompat.offsetTopAndBottom(view, mMinOffset);
_L4:
        if (mViewDragHelper == null)
            mViewDragHelper = ViewDragHelper.create(coordinatorlayout, mDragCallback);
        mViewRef = new WeakReference(view);
        mNestedScrollingChildRef = new WeakReference(findScrollingChild(view));
        return true;
_L2:
        if (mHideable && mState == 5)
            ViewCompat.offsetTopAndBottom(view, mParentHeight);
        else
        if (mState == 4)
            ViewCompat.offsetTopAndBottom(view, mMaxOffset);
        else
        if (mState == 1 || mState == 2)
            ViewCompat.offsetTopAndBottom(view, j - view.getTop());
        if (true) goto _L4; else goto _L3
_L3:
    }

    public boolean onNestedPreFling(CoordinatorLayout coordinatorlayout, View view, View view1, float f, float f1) {
        boolean flag;
        if (view1 == mNestedScrollingChildRef.get() && (mState != 3 || super.onNestedPreFling(coordinatorlayout, view, view1, f, f1)))
            flag = true;
        else
            flag = false;
        return flag;
    }

    public void onNestedPreScroll(CoordinatorLayout coordinatorlayout, View view, View view1, int i, int j, int ai[]) {
        if (view1 == (View)mNestedScrollingChildRef.get()) goto _L2; else goto _L1
_L1:
        return;
_L2:
        int k;
        i = view.getTop();
        k = i - j;
        if (j <= 0)
            break; /* Loop/switch isn't completed */
        if (k < mMinOffset) {
            ai[1] = i - mMinOffset;
            ViewCompat.offsetTopAndBottom(view, -ai[1]);
            setStateInternal(3);
        } else {
            ai[1] = j;
            ViewCompat.offsetTopAndBottom(view, -j);
            setStateInternal(1);
        }
_L5:
        dispatchOnSlide(view.getTop());
        mLastNestedScrollDy = j;
        mNestedScrolled = true;
        if (true) goto _L1; else goto _L3
_L3:
        if (j >= 0 || ViewCompat.canScrollVertically(view1, -1)) goto _L5; else goto _L4
_L4:
        if (k <= mMaxOffset || mHideable) {
            ai[1] = j;
            ViewCompat.offsetTopAndBottom(view, -j);
            setStateInternal(1);
        } else {
            ai[1] = i - mMaxOffset;
            ViewCompat.offsetTopAndBottom(view, -ai[1]);
            setStateInternal(4);
        }
          goto _L5
    }

    public void onRestoreInstanceState(CoordinatorLayout coordinatorlayout, View view, Parcelable parcelable) {
        parcelable = (SavedState)parcelable;
        super.onRestoreInstanceState(coordinatorlayout, view, parcelable.getSuperState());
        if (((SavedState) (parcelable)).state == 1 || ((SavedState) (parcelable)).state == 2)
            mState = 4;
        else
            mState = ((SavedState) (parcelable)).state;
    }

    public Parcelable onSaveInstanceState(CoordinatorLayout coordinatorlayout, View view) {
        return new SavedState(super.onSaveInstanceState(coordinatorlayout, view), mState);
    }

    public boolean onStartNestedScroll(CoordinatorLayout coordinatorlayout, View view, View view1, View view2, int i) {
        boolean flag = false;
        mLastNestedScrollDy = 0;
        mNestedScrolled = false;
        if ((i & 2) != 0)
            flag = true;
        return flag;
    }

    public void onStopNestedScroll(CoordinatorLayout coordinatorlayout, View view, View view1) {
        byte byte0 = 3;
        if (view.getTop() != mMinOffset) goto _L2; else goto _L1
_L1:
        setStateInternal(3);
_L7:
        return;
_L2:
        if (view1 != mNestedScrollingChildRef.get() || !mNestedScrolled) goto _L4; else goto _L3
_L3:
        if (mLastNestedScrollDy <= 0) goto _L6; else goto _L5
_L5:
        int i = mMinOffset;
_L8:
        if (mViewDragHelper.smoothSlideViewTo(view, view.getLeft(), i)) {
            setStateInternal(2);
            ViewCompat.postOnAnimation(view, new SettleRunnable(view, byte0));
        } else {
            setStateInternal(byte0);
        }
        mNestedScrolled = false;
_L4:
        if (true) goto _L7; else goto _L6
_L6:
        if (mHideable && shouldHide(view, getYVelocity())) {
            i = mParentHeight;
            byte0 = 5;
        } else
        if (mLastNestedScrollDy == 0) {
            i = view.getTop();
            if (Math.abs(i - mMinOffset) < Math.abs(i - mMaxOffset)) {
                i = mMinOffset;
            } else {
                i = mMaxOffset;
                byte0 = 4;
            }
        } else {
            i = mMaxOffset;
            byte0 = 4;
        }
          goto _L8
    }

    public boolean onTouchEvent(CoordinatorLayout coordinatorlayout, View view, MotionEvent motionevent) {
        boolean flag1 = true;
        if (view.isShown()) goto _L2; else goto _L1
_L1:
        boolean flag = false;
_L4:
        return flag;
_L2:
        int i = MotionEventCompat.getActionMasked(motionevent);
        if (mState == 1) {
            flag = flag1;
            if (i == 0)
                continue; /* Loop/switch isn't completed */
        }
        mViewDragHelper.processTouchEvent(motionevent);
        if (i == 0)
            reset();
        if (mVelocityTracker == null)
            mVelocityTracker = VelocityTracker.obtain();
        mVelocityTracker.addMovement(motionevent);
        if (i == 2 && !mIgnoreEvents && Math.abs((float)mInitialY - motionevent.getY()) > (float)mViewDragHelper.getTouchSlop())
            mViewDragHelper.captureChildView(view, motionevent.getPointerId(motionevent.getActionIndex()));
        flag = flag1;
        if (mIgnoreEvents)
            flag = false;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void setBottomSheetCallback(BottomSheetCallback bottomsheetcallback) {
        mCallback = bottomsheetcallback;
    }

    public void setHideable(boolean flag) {
        mHideable = flag;
    }

    public final void setPeekHeight(int i) {
        boolean flag = true;
        if (i != -1) goto _L2; else goto _L1
_L1:
        if (mPeekHeightAuto) goto _L4; else goto _L3
_L3:
        mPeekHeightAuto = true;
        i = ((flag) ? 1 : 0);
_L6:
        if (i != 0 && mState == 4 && mViewRef != null) {
            View view = (View)mViewRef.get();
            if (view != null)
                view.requestLayout();
        }
        return;
_L2:
        if (mPeekHeightAuto || mPeekHeight != i) {
            mPeekHeightAuto = false;
            mPeekHeight = Math.max(0, i);
            mMaxOffset = mParentHeight - i;
            i = ((flag) ? 1 : 0);
            continue; /* Loop/switch isn't completed */
        }
_L4:
        i = 0;
        if (true) goto _L6; else goto _L5
_L5:
    }

    public void setSkipCollapsed(boolean flag) {
        mSkipCollapsed = flag;
    }

    public final void setState(final int state) {
        if (state != mState) goto _L2; else goto _L1
_L1:
        return;
_L2:
        if (mViewRef == null) {
            if (state == 4 || state == 3 || mHideable && state == 5)
                mState = state;
        } else {
            final View child = (View)mViewRef.get();
            if (child != null) {
                ViewParent viewparent = child.getParent();
                if (viewparent != null && viewparent.isLayoutRequested() && ViewCompat.isAttachedToWindow(child))
                    child.post(new Runnable() {

                        final BottomSheetBehavior this$0;
                        final View val$child;
                        final int val$state;

                        public void run() {
                            startSettlingAnimation(child, state);
                        }

             {
                this$0 = BottomSheetBehavior.this;
                child = view;
                state = i;
                super();
            }
                    }
);
                else
                    startSettlingAnimation(child, state);
            }
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    void setStateInternal(int i) {
        if (mState != i) goto _L2; else goto _L1
_L1:
        return;
_L2:
        mState = i;
        View view = (View)mViewRef.get();
        if (view != null && mCallback != null)
            mCallback.onStateChanged(view, i);
        if (true) goto _L1; else goto _L3
_L3:
    }

    boolean shouldHide(View view, float f) {
        boolean flag = true;
        if (!mSkipCollapsed) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        if (view.getTop() < mMaxOffset)
            flag = false;
        else
        if (Math.abs(((float)view.getTop() + 0.1F * f) - (float)mMaxOffset) / (float)mPeekHeight <= 0.5F)
            flag = false;
        if (true) goto _L1; else goto _L3
_L3:
    }

    void startSettlingAnimation(View view, int i) {
        int j;
        if (i == 4)
            j = mMaxOffset;
        else
        if (i == 3)
            j = mMinOffset;
        else
        if (mHideable && i == 5)
            j = mParentHeight;
        else
            throw new IllegalArgumentException((new StringBuilder()).append("Illegal state argument: ").append(i).toString());
        setStateInternal(2);
        if (mViewDragHelper.smoothSlideViewTo(view, view.getLeft(), j))
            ViewCompat.postOnAnimation(view, new SettleRunnable(view, i));
    }
}
