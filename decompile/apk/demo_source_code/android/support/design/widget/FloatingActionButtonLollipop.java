// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.design.widget;

import android.animation.*;
import android.content.res.ColorStateList;
import android.graphics.Rect;
import android.graphics.drawable.*;
import android.support.v4.graphics.drawable.DrawableCompat;
import android.view.View;

// Referenced classes of package android.support.design.widget:
//            FloatingActionButtonIcs, VisibilityAwareImageButton, ShadowViewDelegate, ShadowDrawableWrapper, 
//            CircularBorderDrawableLollipop, CircularBorderDrawable

class FloatingActionButtonLollipop extends FloatingActionButtonIcs {

    private InsetDrawable mInsetDrawable;

    FloatingActionButtonLollipop(VisibilityAwareImageButton visibilityawareimagebutton, ShadowViewDelegate shadowviewdelegate, ValueAnimatorCompat.Creator creator) {
        super(visibilityawareimagebutton, shadowviewdelegate, creator);
    }

    public float getElevation() {
        return mView.getElevation();
    }

    void getPadding(Rect rect) {
        if (mShadowViewDelegate.isCompatPaddingEnabled()) {
            float f1 = mShadowViewDelegate.getRadius();
            float f = getElevation() + mPressedTranslationZ;
            int i = (int)Math.ceil(ShadowDrawableWrapper.calculateHorizontalPadding(f, f1, false));
            int j = (int)Math.ceil(ShadowDrawableWrapper.calculateVerticalPadding(f, f1, false));
            rect.set(i, j, i, j);
        } else {
            rect.set(0, 0, 0, 0);
        }
    }

    void jumpDrawableToCurrentState() {
    }

    CircularBorderDrawable newCircularDrawable() {
        return new CircularBorderDrawableLollipop();
    }

    void onCompatShadowChanged() {
        updatePadding();
    }

    void onDrawableStateChanged(int ai[]) {
    }

    void onElevationsChanged(float f, float f1) {
        StateListAnimator statelistanimator = new StateListAnimator();
        AnimatorSet animatorset = new AnimatorSet();
        animatorset.play(ObjectAnimator.ofFloat(mView, "elevation", new float[] {
            f
        }).setDuration(0L)).with(ObjectAnimator.ofFloat(mView, View.TRANSLATION_Z, new float[] {
            f1
        }).setDuration(100L));
        animatorset.setInterpolator(ANIM_INTERPOLATOR);
        statelistanimator.addState(PRESSED_ENABLED_STATE_SET, animatorset);
        animatorset = new AnimatorSet();
        animatorset.play(ObjectAnimator.ofFloat(mView, "elevation", new float[] {
            f
        }).setDuration(0L)).with(ObjectAnimator.ofFloat(mView, View.TRANSLATION_Z, new float[] {
            f1
        }).setDuration(100L));
        animatorset.setInterpolator(ANIM_INTERPOLATOR);
        statelistanimator.addState(FOCUSED_ENABLED_STATE_SET, animatorset);
        animatorset = new AnimatorSet();
        AnimatorSet animatorset1 = new AnimatorSet();
        animatorset1.play(ObjectAnimator.ofFloat(mView, View.TRANSLATION_Z, new float[] {
            0.0F
        }).setDuration(100L)).after(100L);
        animatorset.play(ObjectAnimator.ofFloat(mView, "elevation", new float[] {
            f
        }).setDuration(0L)).with(animatorset1);
        animatorset.setInterpolator(ANIM_INTERPOLATOR);
        statelistanimator.addState(ENABLED_STATE_SET, animatorset);
        animatorset = new AnimatorSet();
        animatorset.play(ObjectAnimator.ofFloat(mView, "elevation", new float[] {
            0.0F
        }).setDuration(0L)).with(ObjectAnimator.ofFloat(mView, View.TRANSLATION_Z, new float[] {
            0.0F
        }).setDuration(0L));
        animatorset.setInterpolator(ANIM_INTERPOLATOR);
        statelistanimator.addState(EMPTY_STATE_SET, animatorset);
        mView.setStateListAnimator(statelistanimator);
        if (mShadowViewDelegate.isCompatPaddingEnabled())
            updatePadding();
    }

    void onPaddingUpdated(Rect rect) {
        if (mShadowViewDelegate.isCompatPaddingEnabled()) {
            mInsetDrawable = new InsetDrawable(mRippleDrawable, rect.left, rect.top, rect.right, rect.bottom);
            mShadowViewDelegate.setBackgroundDrawable(mInsetDrawable);
        } else {
            mShadowViewDelegate.setBackgroundDrawable(mRippleDrawable);
        }
    }

    boolean requirePreDrawListener() {
        return false;
    }

    void setBackgroundDrawable(ColorStateList colorstatelist, android.graphics.PorterDuff.Mode mode, int i, int j) {
        mShapeDrawable = DrawableCompat.wrap(createShapeDrawable());
        DrawableCompat.setTintList(mShapeDrawable, colorstatelist);
        if (mode != null)
            DrawableCompat.setTintMode(mShapeDrawable, mode);
        if (j > 0) {
            mBorderDrawable = createBorderDrawable(j, colorstatelist);
            colorstatelist = new LayerDrawable(new Drawable[] {
                mBorderDrawable, mShapeDrawable
            });
        } else {
            mBorderDrawable = null;
            colorstatelist = mShapeDrawable;
        }
        mRippleDrawable = new RippleDrawable(ColorStateList.valueOf(i), colorstatelist, null);
        mContentBackground = mRippleDrawable;
        mShadowViewDelegate.setBackgroundDrawable(mRippleDrawable);
    }

    void setRippleColor(int i) {
        if (mRippleDrawable instanceof RippleDrawable)
            ((RippleDrawable)mRippleDrawable).setColor(ColorStateList.valueOf(i));
        else
            super.setRippleColor(i);
    }
}
