// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.design.widget;

import android.os.*;
import java.lang.ref.WeakReference;

class SnackbarManager {
    static interface Callback {

        public abstract void dismiss(int i);

        public abstract void show();
    }

    private static class SnackbarRecord {

        final WeakReference callback;
        int duration;

        boolean isSnackbar(Callback callback1) {
            boolean flag;
            if (callback1 != null && callback.get() == callback1)
                flag = true;
            else
                flag = false;
            return flag;
        }

        SnackbarRecord(int i, Callback callback1) {
            callback = new WeakReference(callback1);
            duration = i;
        }
    }


    private static final int LONG_DURATION_MS = 2750;
    static final int MSG_TIMEOUT = 0;
    private static final int SHORT_DURATION_MS = 1500;
    private static SnackbarManager sSnackbarManager;
    private SnackbarRecord mCurrentSnackbar;
    private final Handler mHandler = new Handler(Looper.getMainLooper(), new android.os.Handler.Callback() {

        final SnackbarManager this$0;

        public boolean handleMessage(Message message) {
            message.what;
            JVM INSTR tableswitch 0 0: default 24
        //                       0 28;
               goto _L1 _L2
_L1:
            boolean flag = false;
_L4:
            return flag;
_L2:
            handleTimeout((SnackbarRecord)message.obj);
            flag = true;
            if (true) goto _L4; else goto _L3
_L3:
        }

             {
                this$0 = SnackbarManager.this;
                super();
            }
    }
);
    private final Object mLock = new Object();
    private SnackbarRecord mNextSnackbar;

    private SnackbarManager() {
    }

    private boolean cancelSnackbarLocked(SnackbarRecord snackbarrecord, int i) {
        Callback callback = (Callback)snackbarrecord.callback.get();
        boolean flag;
        if (callback != null) {
            mHandler.removeCallbacksAndMessages(snackbarrecord);
            callback.dismiss(i);
            flag = true;
        } else {
            flag = false;
        }
        return flag;
    }

    static SnackbarManager getInstance() {
        if (sSnackbarManager == null)
            sSnackbarManager = new SnackbarManager();
        return sSnackbarManager;
    }

    private boolean isCurrentSnackbarLocked(Callback callback) {
        boolean flag;
        if (mCurrentSnackbar != null && mCurrentSnackbar.isSnackbar(callback))
            flag = true;
        else
            flag = false;
        return flag;
    }

    private boolean isNextSnackbarLocked(Callback callback) {
        boolean flag;
        if (mNextSnackbar != null && mNextSnackbar.isSnackbar(callback))
            flag = true;
        else
            flag = false;
        return flag;
    }

    private void scheduleTimeoutLocked(SnackbarRecord snackbarrecord) {
        if (snackbarrecord.duration != -2) goto _L2; else goto _L1
_L1:
        return;
_L2:
        int i;
        i = 2750;
        if (snackbarrecord.duration <= 0)
            break; /* Loop/switch isn't completed */
        i = snackbarrecord.duration;
_L5:
        mHandler.removeCallbacksAndMessages(snackbarrecord);
        mHandler.sendMessageDelayed(Message.obtain(mHandler, 0, snackbarrecord), i);
        if (true) goto _L1; else goto _L3
_L3:
        if (snackbarrecord.duration != -1) goto _L5; else goto _L4
_L4:
        i = 1500;
          goto _L5
    }

    private void showNextSnackbarLocked() {
        if (mNextSnackbar != null) {
            mCurrentSnackbar = mNextSnackbar;
            mNextSnackbar = null;
            Callback callback = (Callback)mCurrentSnackbar.callback.get();
            if (callback != null)
                callback.show();
            else
                mCurrentSnackbar = null;
        }
    }

    public void cancelTimeout(Callback callback) {
        synchronized (mLock) {
            if (isCurrentSnackbarLocked(callback))
                mHandler.removeCallbacksAndMessages(mCurrentSnackbar);
        }
        return;
        callback;
        obj;
        JVM INSTR monitorexit ;
        throw callback;
    }

    public void dismiss(Callback callback, int i) {
        Object obj = mLock;
        obj;
        JVM INSTR monitorenter ;
        if (!isCurrentSnackbarLocked(callback)) goto _L2; else goto _L1
_L1:
        cancelSnackbarLocked(mCurrentSnackbar, i);
_L4:
        return;
_L2:
        if (isNextSnackbarLocked(callback))
            cancelSnackbarLocked(mNextSnackbar, i);
        if (true) goto _L4; else goto _L3
_L3:
        callback;
        obj;
        JVM INSTR monitorexit ;
        throw callback;
    }

    void handleTimeout(SnackbarRecord snackbarrecord) {
        synchronized (mLock) {
            if (mCurrentSnackbar == snackbarrecord || mNextSnackbar == snackbarrecord)
                cancelSnackbarLocked(snackbarrecord, 2);
        }
        return;
        snackbarrecord;
        obj;
        JVM INSTR monitorexit ;
        throw snackbarrecord;
    }

    public boolean isCurrent(Callback callback) {
        boolean flag;
        synchronized (mLock) {
            flag = isCurrentSnackbarLocked(callback);
        }
        return flag;
        callback;
        obj;
        JVM INSTR monitorexit ;
        throw callback;
    }

    public boolean isCurrentOrNext(Callback callback) {
        Object obj = mLock;
        obj;
        JVM INSTR monitorenter ;
        boolean flag;
        if (isCurrentSnackbarLocked(callback) || isNextSnackbarLocked(callback))
            flag = true;
        else
            flag = false;
        obj;
        JVM INSTR monitorexit ;
        return flag;
        callback;
        obj;
        JVM INSTR monitorexit ;
        throw callback;
    }

    public void onDismissed(Callback callback) {
        synchronized (mLock) {
            if (isCurrentSnackbarLocked(callback)) {
                mCurrentSnackbar = null;
                if (mNextSnackbar != null)
                    showNextSnackbarLocked();
            }
        }
        return;
        callback;
        obj;
        JVM INSTR monitorexit ;
        throw callback;
    }

    public void onShown(Callback callback) {
        synchronized (mLock) {
            if (isCurrentSnackbarLocked(callback))
                scheduleTimeoutLocked(mCurrentSnackbar);
        }
        return;
        callback;
        obj;
        JVM INSTR monitorexit ;
        throw callback;
    }

    public void restoreTimeout(Callback callback) {
        synchronized (mLock) {
            if (isCurrentSnackbarLocked(callback))
                scheduleTimeoutLocked(mCurrentSnackbar);
        }
        return;
        callback;
        obj;
        JVM INSTR monitorexit ;
        throw callback;
    }

    public void show(int i, Callback callback) {
        Object obj = mLock;
        obj;
        JVM INSTR monitorenter ;
        if (!isCurrentSnackbarLocked(callback)) goto _L2; else goto _L1
_L1:
        mCurrentSnackbar.duration = i;
        mHandler.removeCallbacksAndMessages(mCurrentSnackbar);
        scheduleTimeoutLocked(mCurrentSnackbar);
_L3:
        return;
_L2:
        if (!isNextSnackbarLocked(callback))
            break MISSING_BLOCK_LABEL_90;
        mNextSnackbar.duration = i;
_L4:
        if (mCurrentSnackbar == null || !cancelSnackbarLocked(mCurrentSnackbar, 4))
            break MISSING_BLOCK_LABEL_111;
          goto _L3
        callback;
        obj;
        JVM INSTR monitorexit ;
        throw callback;
        SnackbarRecord snackbarrecord = JVM INSTR new #11  <Class SnackbarManager$SnackbarRecord>;
        snackbarrecord.SnackbarRecord(i, callback);
        mNextSnackbar = snackbarrecord;
          goto _L4
        mCurrentSnackbar = null;
        showNextSnackbarLocked();
        obj;
        JVM INSTR monitorexit ;
          goto _L3
    }
}
