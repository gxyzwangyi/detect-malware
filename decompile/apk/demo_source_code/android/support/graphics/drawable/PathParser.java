// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.graphics.drawable;

import android.graphics.Path;
import android.util.Log;
import java.util.ArrayList;

class PathParser {
    private static class ExtractFloatResult {

        int mEndPosition;
        boolean mEndWithNegOrDot;

        ExtractFloatResult() {
        }
    }

    public static class PathDataNode {

        float params[];
        char type;

        private static void addCommand(Path path, float af[], char c, char c1, float af1[]) {
            float f;
            float f1;
            float f2;
            float f3;
            float f4;
            float f5;
            f4 = af[0];
            f5 = af[1];
            f3 = af[2];
            f2 = af[3];
            f = af[4];
            f1 = af[5];
            c1;
            JVM INSTR lookupswitch 20: default 200
        //                       65: 490
        //                       67: 477
        //                       72: 471
        //                       76: 465
        //                       77: 465
        //                       81: 484
        //                       83: 484
        //                       84: 465
        //                       86: 471
        //                       90: 431
        //                       97: 490
        //                       99: 477
        //                       104: 471
        //                       108: 465
        //                       109: 465
        //                       113: 484
        //                       115: 484
        //                       116: 465
        //                       118: 471
        //                       122: 431;
               goto _L1 _L2 _L3 _L4 _L5 _L5 _L6 _L6 _L5 _L4 _L7 _L2 _L3 _L4 _L5 _L5 _L6 _L6 _L5 _L4 _L7
_L1:
            byte byte0 = 2;
_L32:
            char c2;
            boolean flag = false;
            float f6 = f5;
            c2 = c;
            f5 = f4;
            f4 = f6;
            c = flag;
_L29:
            if (c >= af1.length) goto _L9; else goto _L8
_L8:
            c1;
            JVM INSTR lookupswitch 18: default 388
        //                       65: 2082
        //                       67: 1130
        //                       72: 888
        //                       76: 788
        //                       77: 605
        //                       81: 1610
        //                       83: 1374
        //                       84: 1818
        //                       86: 972
        //                       97: 1927
        //                       99: 1011
        //                       104: 839
        //                       108: 719
        //                       109: 497
        //                       113: 1503
        //                       115: 1217
        //                       116: 1685
        //                       118: 927;
               goto _L10 _L11 _L12 _L13 _L14 _L15 _L16 _L17 _L18 _L19 _L20 _L21 _L22 _L23 _L24 _L25 _L26 _L27 _L28
_L10:
            float f7 = f1;
            f1 = f2;
            f2 = f;
            f = f7;
_L30:
            c += byte0;
            float f8 = f2;
            c2 = c1;
            f2 = f1;
            f1 = f;
            f = f8;
              goto _L29
_L7:
            path.close();
            path.moveTo(f, f1);
            f2 = f1;
            f3 = f;
            f5 = f1;
            f4 = f;
            byte0 = 2;
            continue; /* Loop/switch isn't completed */
_L5:
            byte0 = 2;
            continue; /* Loop/switch isn't completed */
_L4:
            byte0 = 1;
            continue; /* Loop/switch isn't completed */
_L3:
            byte0 = 6;
            continue; /* Loop/switch isn't completed */
_L6:
            byte0 = 4;
            continue; /* Loop/switch isn't completed */
_L2:
            byte0 = 7;
            continue; /* Loop/switch isn't completed */
_L24:
            f5 += af1[c + 0];
            f4 = af1[c + 1] + f4;
            if (c > 0) {
                path.rLineTo(af1[c + 0], af1[c + 1]);
                float f9 = f;
                f = f1;
                f1 = f2;
                f2 = f9;
            } else {
                path.rMoveTo(af1[c + 0], af1[c + 1]);
                float f23 = f4;
                float f10 = f5;
                f1 = f2;
                f = f4;
                f2 = f5;
                f4 = f23;
                f5 = f10;
            }
              goto _L30
_L15:
            f4 = af1[c + 0];
            f5 = af1[c + 1];
            if (c > 0) {
                path.lineTo(af1[c + 0], af1[c + 1]);
                float f11 = f4;
                f4 = f;
                f = f1;
                f1 = f2;
                f2 = f4;
                f4 = f5;
                f5 = f11;
            } else {
                path.moveTo(af1[c + 0], af1[c + 1]);
                float f24 = f5;
                float f12 = f4;
                f1 = f2;
                f = f5;
                f2 = f4;
                f4 = f24;
                f5 = f12;
            }
              goto _L30
_L23:
            path.rLineTo(af1[c + 0], af1[c + 1]);
            float f25 = af1[c + 0];
            float f13 = af1[c + 1];
            f13 += f4;
            f5 += f25;
            f4 = f;
            f = f1;
            f1 = f2;
            f2 = f4;
            f4 = f13;
              goto _L30
_L14:
            path.lineTo(af1[c + 0], af1[c + 1]);
            f5 = af1[c + 0];
            f4 = af1[c + 1];
            float f14 = f;
            f = f1;
            f1 = f2;
            f2 = f14;
              goto _L30
_L22:
            path.rLineTo(af1[c + 0], 0.0F);
            float f15 = af1[c + 0];
            f15 = f5 + f15;
            f5 = f;
            f = f1;
            f1 = f2;
            f2 = f5;
            f5 = f15;
              goto _L30
_L13:
            path.lineTo(af1[c + 0], f4);
            f5 = af1[c + 0];
            float f16 = f2;
            f2 = f;
            f = f1;
            f1 = f16;
              goto _L30
_L28:
            path.rLineTo(0.0F, af1[c + 0]);
            float f26 = af1[c + 0];
            float f17 = f;
            f4 = f26 + f4;
            f = f1;
            f1 = f2;
            f2 = f17;
              goto _L30
_L19:
            path.lineTo(f5, af1[c + 0]);
            f4 = af1[c + 0];
            float f18 = f;
            f = f1;
            f1 = f2;
            f2 = f18;
              goto _L30
_L21:
            path.rCubicTo(af1[c + 0], af1[c + 1], af1[c + 2], af1[c + 3], af1[c + 4], af1[c + 5]);
            f3 = af1[c + 2];
            float f27 = af1[c + 3];
            f2 = af1[c + 4];
            float f19 = af1[c + 5];
            f3 = f5 + f3;
            f19 += f4;
            f5 += f2;
            f2 = f;
            f4 = f27 + f4;
            f = f1;
            f1 = f4;
            f4 = f19;
              goto _L30
_L12:
            path.cubicTo(af1[c + 0], af1[c + 1], af1[c + 2], af1[c + 3], af1[c + 4], af1[c + 5]);
            f5 = af1[c + 4];
            f4 = af1[c + 5];
            f3 = af1[c + 2];
            float f20 = af1[c + 3];
            f2 = f;
            f = f1;
            f1 = f20;
              goto _L30
_L26:
            float f22;
            float f28;
            float f29;
            boolean flag1;
            boolean flag2;
            if (c2 == 'c' || c2 == 's' || c2 == 'C' || c2 == 'S') {
                float f21 = f5 - f3;
                f3 = f4 - f2;
                f2 = f21;
            } else {
                f3 = 0.0F;
                f2 = 0.0F;
            }
            path.rCubicTo(f2, f3, af1[c + 0], af1[c + 1], af1[c + 2], af1[c + 3]);
            f3 = af1[c + 0];
            f28 = af1[c + 1];
            f2 = af1[c + 2];
            f22 = af1[c + 3];
            f3 = f5 + f3;
            f22 += f4;
            f5 += f2;
            f2 = f;
            f4 = f28 + f4;
            f = f1;
            f1 = f4;
            f4 = f22;
              goto _L30
_L17:
            if (c2 == 'c' || c2 == 's' || c2 == 'C' || c2 == 'S') {
                f3 = 2.0F * f5 - f3;
                f4 = 2.0F * f4 - f2;
                f2 = f3;
            } else {
                f2 = f5;
            }
            path.cubicTo(f2, f4, af1[c + 0], af1[c + 1], af1[c + 2], af1[c + 3]);
            f3 = af1[c + 0];
            f22 = af1[c + 1];
            f5 = af1[c + 2];
            f4 = af1[c + 3];
            f2 = f;
            f = f1;
            f1 = f22;
              goto _L30
_L25:
            path.rQuadTo(af1[c + 0], af1[c + 1], af1[c + 2], af1[c + 3]);
            f3 = af1[c + 0];
            f28 = af1[c + 1];
            f2 = af1[c + 2];
            f22 = af1[c + 3];
            f3 = f5 + f3;
            f22 += f4;
            f5 += f2;
            f2 = f;
            f4 = f28 + f4;
            f = f1;
            f1 = f4;
            f4 = f22;
              goto _L30
_L16:
            path.quadTo(af1[c + 0], af1[c + 1], af1[c + 2], af1[c + 3]);
            f3 = af1[c + 0];
            f22 = af1[c + 1];
            f5 = af1[c + 2];
            f4 = af1[c + 3];
            f2 = f;
            f = f1;
            f1 = f22;
              goto _L30
_L27:
            if (c2 == 'q' || c2 == 't' || c2 == 'Q' || c2 == 'T') {
                f3 = f5 - f3;
                f2 = f4 - f2;
            } else {
                f2 = 0.0F;
                f3 = 0.0F;
            }
            path.rQuadTo(f3, f2, af1[c + 0], af1[c + 1]);
            f29 = af1[c + 0];
            f28 = af1[c + 1];
            f22 = f5 + f3;
            f28 += f4;
            f5 += f29;
            f3 = f;
            f2 += f4;
            f = f1;
            f1 = f2;
            f2 = f3;
            f3 = f22;
            f4 = f28;
              goto _L30
_L18:
label0:
            {
                if (c2 != 'q' && c2 != 't' && c2 != 'Q') {
                    f28 = f4;
                    f22 = f5;
                    if (c2 != 'T')
                        break label0;
                }
                f22 = 2.0F * f5 - f3;
                f28 = 2.0F * f4 - f2;
            }
            path.quadTo(f22, f28, af1[c + 0], af1[c + 1]);
            f5 = af1[c + 0];
            f4 = af1[c + 1];
            f3 = f22;
            f2 = f;
            f = f1;
            f1 = f28;
              goto _L30
_L20:
            f28 = af1[c + 5];
            f22 = af1[c + 6];
            f29 = af1[c + 0];
            f2 = af1[c + 1];
            f3 = af1[c + 2];
            if (af1[c + 3] != 0.0F)
                flag1 = true;
            else
                flag1 = false;
            if (af1[c + 4] != 0.0F)
                flag2 = true;
            else
                flag2 = false;
            drawArc(path, f5, f4, f28 + f5, f22 + f4, f29, f2, f3, flag1, flag2);
            f5 += af1[c + 5];
            f22 = af1[c + 6] + f4;
            f2 = f;
            f3 = f5;
            f4 = f22;
            f = f1;
            f1 = f22;
              goto _L30
_L11:
            f3 = af1[c + 5];
            f2 = af1[c + 6];
            f28 = af1[c + 0];
            f22 = af1[c + 1];
            f29 = af1[c + 2];
            if (af1[c + 3] != 0.0F)
                flag1 = true;
            else
                flag1 = false;
            if (af1[c + 4] != 0.0F)
                flag2 = true;
            else
                flag2 = false;
            drawArc(path, f5, f4, f3, f2, f28, f22, f29, flag1, flag2);
            f5 = af1[c + 5];
            f22 = af1[c + 6];
            f2 = f;
            f3 = f5;
            f4 = f22;
            f = f1;
            f1 = f22;
              goto _L30
_L9:
            af[0] = f5;
            af[1] = f4;
            af[2] = f3;
            af[3] = f2;
            af[4] = f;
            af[5] = f1;
            return;
            if (true) goto _L32; else goto _L31
_L31:
        }

        private static void arcToBezier(Path path, double d, double d1, double d2, double d3, double d4, double d5, double d6, 
                double d7, double d8) {
            int j = (int)Math.ceil(Math.abs((4D * d8) / 3.1415926535897931D));
            double d17 = Math.cos(d6);
            double d18 = Math.sin(d6);
            d6 = Math.cos(d7);
            double d11 = Math.sin(d7);
            double d13 = -d2;
            double d9 = -d2;
            double d19 = d8 / (double)j;
            int i = 0;
            d9 = d11 * (d9 * d18) + d6 * (d3 * d17);
            d6 = d13 * d17 * d11 - d3 * d18 * d6;
            d8 = d7;
            d7 = d5;
            double d12;
            for (d5 = d9; i < j; d5 = d12) {
                double d15 = d8 + d19;
                double d20 = Math.sin(d15);
                d12 = Math.cos(d15);
                double d10 = (d2 * d17 * d12 + d) - d3 * d18 * d20;
                double d14 = d3 * d17 * d20 + (d2 * d18 * d12 + d1);
                double d16 = -d2 * d17 * d20 - d3 * d18 * d12;
                d12 = d12 * (d3 * d17) + d20 * (-d2 * d18);
                d20 = Math.tan((d15 - d8) / 2D);
                d8 = Math.sin(d15 - d8);
                d8 = ((Math.sqrt(d20 * (3D * d20) + 4D) - 1.0D) * d8) / 3D;
                path.cubicTo((float)(d6 * d8 + d4), (float)(d7 + d5 * d8), (float)(d10 - d8 * d16), (float)(d14 - d8 * d12), (float)d10, (float)d14);
                i++;
                d6 = d16;
                d8 = d15;
                d7 = d14;
                d4 = d10;
            }

        }

        private static void drawArc(Path path, float f, float f1, float f2, float f3, float f4, float f5, float f6, 
                boolean flag, boolean flag1) {
            double d6 = Math.toRadians(f6);
            double d4 = Math.cos(d6);
            double d5 = Math.sin(d6);
            double d8 = ((double)f * d4 + (double)f1 * d5) / (double)f4;
            double d7 = ((double)(-f) * d5 + (double)f1 * d4) / (double)f5;
            double d = ((double)f2 * d4 + (double)f3 * d5) / (double)f4;
            double d3 = ((double)(-f2) * d5 + (double)f3 * d4) / (double)f5;
            double d10 = d8 - d;
            double d9 = d7 - d3;
            double d2 = (d8 + d) / 2D;
            double d1 = (d7 + d3) / 2D;
            double d11 = d10 * d10 + d9 * d9;
            if (d11 == 0.0D) {
                Log.w("PathParser", " Points are coincident");
            } else {
                double d13 = 1.0D / d11 - 0.25D;
                if (d13 < 0.0D) {
                    Log.w("PathParser", (new StringBuilder()).append("Points are too far apart ").append(d11).toString());
                    float f7 = (float)(Math.sqrt(d11) / 1.9999899999999999D);
                    drawArc(path, f, f1, f2, f3, f4 * f7, f5 * f7, f6, flag, flag1);
                } else {
                    double d12 = Math.sqrt(d13);
                    d10 *= d12;
                    d9 *= d12;
                    if (flag == flag1) {
                        d2 -= d9;
                        d1 = d10 + d1;
                    } else {
                        d2 = d9 + d2;
                        d1 -= d10;
                    }
                    d7 = Math.atan2(d7 - d1, d8 - d2);
                    d3 = Math.atan2(d3 - d1, d - d2) - d7;
                    if (d3 >= 0.0D)
                        flag = true;
                    else
                        flag = false;
                    d = d3;
                    if (flag1 != flag)
                        if (d3 > 0.0D)
                            d = d3 - 6.2831853071795862D;
                        else
                            d = d3 + 6.2831853071795862D;
                    d2 = (double)f4 * d2;
                    d1 *= f5;
                    arcToBezier(path, d2 * d4 - d1 * d5, d2 * d5 + d1 * d4, f4, f5, f, f1, d6, d7, d);
                }
            }
        }

        public static void nodesToPath(PathDataNode apathdatanode[], Path path) {
            float af[] = new float[6];
            char c = 'm';
            for (int i = 0; i < apathdatanode.length; i++) {
                addCommand(path, af, c, apathdatanode[i].type, apathdatanode[i].params);
                c = apathdatanode[i].type;
            }

        }

        public void interpolatePathDataNode(PathDataNode pathdatanode, PathDataNode pathdatanode1, float f) {
            for (int i = 0; i < pathdatanode.params.length; i++)
                params[i] = pathdatanode.params[i] * (1.0F - f) + pathdatanode1.params[i] * f;

        }

        PathDataNode(char c, float af[]) {
            type = c;
            params = af;
        }

        PathDataNode(PathDataNode pathdatanode) {
            type = pathdatanode.type;
            params = PathParser.copyOfRange(pathdatanode.params, 0, pathdatanode.params.length);
        }
    }


    private static final String LOGTAG = "PathParser";

    PathParser() {
    }

    private static void addNode(ArrayList arraylist, char c, float af[]) {
        arraylist.add(new PathDataNode(c, af));
    }

    public static boolean canMorph(PathDataNode apathdatanode[], PathDataNode apathdatanode1[]) {
        boolean flag;
        boolean flag1;
        flag1 = false;
        flag = flag1;
        if (apathdatanode == null) goto _L2; else goto _L1
_L1:
        if (apathdatanode1 != null) goto _L4; else goto _L3
_L3:
        flag = flag1;
_L2:
        return flag;
_L4:
        flag = flag1;
        if (apathdatanode.length != apathdatanode1.length)
            continue; /* Loop/switch isn't completed */
        for (int i = 0; i < apathdatanode.length; i++) {
            flag = flag1;
            if (apathdatanode[i].type != apathdatanode1[i].type)
                continue; /* Loop/switch isn't completed */
            flag = flag1;
            if (apathdatanode[i].params.length != apathdatanode1[i].params.length)
                continue; /* Loop/switch isn't completed */
        }

        flag = true;
        if (true) goto _L2; else goto _L5
_L5:
    }

    static float[] copyOfRange(float af[], int i, int j) {
        if (i > j)
            throw new IllegalArgumentException();
        int k = af.length;
        if (i < 0 || i > k) {
            throw new ArrayIndexOutOfBoundsException();
        } else {
            j -= i;
            k = Math.min(j, k - i);
            float af1[] = new float[j];
            System.arraycopy(af, i, af1, 0, k);
            return af1;
        }
    }

    public static PathDataNode[] createNodesFromPathData(String s) {
        if (s == null) {
            s = null;
        } else {
            ArrayList arraylist = new ArrayList();
            int j = 1;
            int i = 0;
            int k;
            for (; j < s.length(); j = k) {
                j = nextStart(s, j);
                String s1 = s.substring(i, j).trim();
                if (s1.length() > 0) {
                    float af[] = getFloats(s1);
                    addNode(arraylist, s1.charAt(0), af);
                }
                k = j + 1;
                i = j;
            }

            if (j - i == 1 && i < s.length())
                addNode(arraylist, s.charAt(i), new float[0]);
            s = (PathDataNode[])arraylist.toArray(new PathDataNode[arraylist.size()]);
        }
        return s;
    }

    public static Path createPathFromPathData(String s) {
        Path path = new Path();
        PathDataNode apathdatanode[] = createNodesFromPathData(s);
        if (apathdatanode != null) {
            try {
                PathDataNode.nodesToPath(apathdatanode, path);
            }
            catch (RuntimeException runtimeexception) {
                throw new RuntimeException((new StringBuilder()).append("Error in parsing ").append(s).toString(), runtimeexception);
            }
            s = path;
        } else {
            s = null;
        }
        return s;
    }

    public static PathDataNode[] deepCopyNodes(PathDataNode apathdatanode[]) {
        if (apathdatanode == null) {
            apathdatanode = null;
        } else {
            PathDataNode apathdatanode1[] = new PathDataNode[apathdatanode.length];
            for (int i = 0; i < apathdatanode.length; i++)
                apathdatanode1[i] = new PathDataNode(apathdatanode[i]);

            apathdatanode = apathdatanode1;
        }
        return apathdatanode;
    }

    private static void extract(String s, int i, ExtractFloatResult extractfloatresult) {
        boolean flag;
        boolean flag1;
        int j;
        boolean flag2;
        extractfloatresult.mEndWithNegOrDot = false;
        flag = false;
        flag2 = false;
        flag1 = false;
        j = i;
_L12:
        if (j >= s.length()) goto _L2; else goto _L1
_L1:
        s.charAt(j);
        JVM INSTR lookupswitch 6: default 88
    //                   32: 102
    //                   44: 102
    //                   45: 110
    //                   46: 133
    //                   69: 159
    //                   101: 159;
           goto _L3 _L4 _L4 _L5 _L6 _L7 _L7
_L3:
        flag = false;
_L9:
        if (!flag1) goto _L8; else goto _L2
_L2:
        extractfloatresult.mEndPosition = j;
        return;
_L4:
        flag = false;
        flag1 = true;
          goto _L9
_L5:
        if (j == i || flag) goto _L3; else goto _L10
_L10:
        extractfloatresult.mEndWithNegOrDot = true;
        flag = false;
        flag1 = true;
          goto _L9
_L6:
        if (!flag2) {
            flag = false;
            flag2 = true;
        } else {
            extractfloatresult.mEndWithNegOrDot = true;
            flag = false;
            flag1 = true;
        }
          goto _L9
_L7:
        flag = true;
          goto _L9
_L8:
        j++;
        if (true) goto _L12; else goto _L11
_L11:
    }

    private static float[] getFloats(String s) {
        boolean flag;
        boolean flag1;
        if (s.charAt(0) == 'z')
            flag = true;
        else
            flag = false;
        if (s.charAt(0) == 'Z')
            flag1 = true;
        else
            flag1 = false;
        if (!(flag | flag1)) goto _L2; else goto _L1
_L1:
        s = new float[0];
_L6:
        return s;
_L2:
        int i;
        int j;
        int k;
        int l;
        int i1;
        float af[];
        ExtractFloatResult extractfloatresult;
        try {
            af = new float[s.length()];
            extractfloatresult = JVM INSTR new #6   <Class PathParser$ExtractFloatResult>;
            extractfloatresult.ExtractFloatResult();
            i1 = s.length();
        }
        catch (NumberFormatException numberformatexception) {
            throw new RuntimeException((new StringBuilder()).append("error in parsing \"").append(s).append("\"").toString(), numberformatexception);
        }
        i = 0;
        j = 1;
        if (j >= i1)
            break; /* Loop/switch isn't completed */
        extract(s, j, extractfloatresult);
        k = extractfloatresult.mEndPosition;
        if (j >= k)
            break MISSING_BLOCK_LABEL_119;
        l = i + 1;
        af[i] = Float.parseFloat(s.substring(j, k));
        i = l;
        if (extractfloatresult.mEndWithNegOrDot)
            j = k;
        else
            j = k + 1;
        if (true) goto _L4; else goto _L3
_L4:
        break MISSING_BLOCK_LABEL_74;
_L3:
        af = copyOfRange(af, 0, i);
        s = af;
        if (true) goto _L6; else goto _L5
_L5:
    }

    private static int nextStart(String s, int i) {
        do {
label0:
            {
                if (i < s.length()) {
                    char c = s.charAt(i);
                    if ((c - 65) * (c - 90) > 0 && (c - 97) * (c - 122) > 0 || c == 'e' || c == 'E')
                        break label0;
                }
                return i;
            }
            i++;
        } while (true);
    }

    public static void updateNodes(PathDataNode apathdatanode[], PathDataNode apathdatanode1[]) {
        for (int i = 0; i < apathdatanode1.length; i++) {
            apathdatanode[i].type = apathdatanode1[i].type;
            for (int j = 0; j < apathdatanode1[i].params.length; j++)
                apathdatanode[i].params[j] = apathdatanode1[i].params[j];

        }

    }
}
