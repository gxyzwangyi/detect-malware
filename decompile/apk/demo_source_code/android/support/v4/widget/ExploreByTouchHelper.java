// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.v4.widget;

import android.content.Context;
import android.graphics.Rect;
import android.os.Bundle;
import android.support.v4.util.SparseArrayCompat;
import android.support.v4.view.*;
import android.support.v4.view.accessibility.*;
import android.view.*;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import java.util.ArrayList;
import java.util.List;

// Referenced classes of package android.support.v4.widget:
//            FocusStrategy

public abstract class ExploreByTouchHelper extends AccessibilityDelegateCompat {
    private class MyNodeProvider extends AccessibilityNodeProviderCompat {

        final ExploreByTouchHelper this$0;

        public AccessibilityNodeInfoCompat createAccessibilityNodeInfo(int i) {
            return AccessibilityNodeInfoCompat.obtain(obtainAccessibilityNodeInfo(i));
        }

        public boolean performAction(int i, int j, Bundle bundle) {
            return ExploreByTouchHelper.this.performAction(i, j, bundle);
        }

        MyNodeProvider() {
            this$0 = ExploreByTouchHelper.this;
            super();
        }
    }


    private static final String DEFAULT_CLASS_NAME = "android.view.View";
    public static final int HOST_ID = -1;
    public static final int INVALID_ID = 0x80000000;
    private static final Rect INVALID_PARENT_BOUNDS = new Rect(0x7fffffff, 0x7fffffff, 0x80000000, 0x80000000);
    private static final FocusStrategy.BoundsAdapter NODE_ADAPTER = new FocusStrategy.BoundsAdapter() {

        public void obtainBounds(AccessibilityNodeInfoCompat accessibilitynodeinfocompat, Rect rect) {
            accessibilitynodeinfocompat.getBoundsInParent(rect);
        }

        public volatile void obtainBounds(Object obj, Rect rect) {
            obtainBounds((AccessibilityNodeInfoCompat)obj, rect);
        }

    }
;
    private static final FocusStrategy.CollectionAdapter SPARSE_VALUES_ADAPTER = new FocusStrategy.CollectionAdapter() {

        public AccessibilityNodeInfoCompat get(SparseArrayCompat sparsearraycompat, int i) {
            return (AccessibilityNodeInfoCompat)sparsearraycompat.valueAt(i);
        }

        public volatile Object get(Object obj, int i) {
            return get((SparseArrayCompat)obj, i);
        }

        public int size(SparseArrayCompat sparsearraycompat) {
            return sparsearraycompat.size();
        }

        public volatile int size(Object obj) {
            return size((SparseArrayCompat)obj);
        }

    }
;
    private int mAccessibilityFocusedVirtualViewId;
    private final View mHost;
    private int mHoveredVirtualViewId;
    private int mKeyboardFocusedVirtualViewId;
    private final AccessibilityManager mManager;
    private MyNodeProvider mNodeProvider;
    private final int mTempGlobalRect[] = new int[2];
    private final Rect mTempParentRect = new Rect();
    private final Rect mTempScreenRect = new Rect();
    private final Rect mTempVisibleRect = new Rect();

    public ExploreByTouchHelper(View view) {
        mAccessibilityFocusedVirtualViewId = 0x80000000;
        mKeyboardFocusedVirtualViewId = 0x80000000;
        mHoveredVirtualViewId = 0x80000000;
        if (view == null)
            throw new IllegalArgumentException("View may not be null");
        mHost = view;
        mManager = (AccessibilityManager)view.getContext().getSystemService("accessibility");
        view.setFocusable(true);
        if (ViewCompat.getImportantForAccessibility(view) == 0)
            ViewCompat.setImportantForAccessibility(view, 1);
    }

    private boolean clearAccessibilityFocus(int i) {
        boolean flag;
        if (mAccessibilityFocusedVirtualViewId == i) {
            mAccessibilityFocusedVirtualViewId = 0x80000000;
            mHost.invalidate();
            sendEventForVirtualView(i, 0x10000);
            flag = true;
        } else {
            flag = false;
        }
        return flag;
    }

    private boolean clickKeyboardFocusedVirtualView() {
        boolean flag;
        if (mKeyboardFocusedVirtualViewId != 0x80000000 && onPerformActionForVirtualView(mKeyboardFocusedVirtualViewId, 16, null))
            flag = true;
        else
            flag = false;
        return flag;
    }

    private AccessibilityEvent createEvent(int i, int j) {
        i;
        JVM INSTR tableswitch -1 -1: default 20
    //                   -1 29;
           goto _L1 _L2
_L1:
        AccessibilityEvent accessibilityevent = createEventForChild(i, j);
_L4:
        return accessibilityevent;
_L2:
        accessibilityevent = createEventForHost(j);
        if (true) goto _L4; else goto _L3
_L3:
    }

    private AccessibilityEvent createEventForChild(int i, int j) {
        AccessibilityEvent accessibilityevent = AccessibilityEvent.obtain(j);
        AccessibilityRecordCompat accessibilityrecordcompat = AccessibilityEventCompat.asRecord(accessibilityevent);
        AccessibilityNodeInfoCompat accessibilitynodeinfocompat = obtainAccessibilityNodeInfo(i);
        accessibilityrecordcompat.getText().add(accessibilitynodeinfocompat.getText());
        accessibilityrecordcompat.setContentDescription(accessibilitynodeinfocompat.getContentDescription());
        accessibilityrecordcompat.setScrollable(accessibilitynodeinfocompat.isScrollable());
        accessibilityrecordcompat.setPassword(accessibilitynodeinfocompat.isPassword());
        accessibilityrecordcompat.setEnabled(accessibilitynodeinfocompat.isEnabled());
        accessibilityrecordcompat.setChecked(accessibilitynodeinfocompat.isChecked());
        onPopulateEventForVirtualView(i, accessibilityevent);
        if (accessibilityevent.getText().isEmpty() && accessibilityevent.getContentDescription() == null) {
            throw new RuntimeException("Callbacks must add text or a content description in populateEventForVirtualViewId()");
        } else {
            accessibilityrecordcompat.setClassName(accessibilitynodeinfocompat.getClassName());
            accessibilityrecordcompat.setSource(mHost, i);
            accessibilityevent.setPackageName(mHost.getContext().getPackageName());
            return accessibilityevent;
        }
    }

    private AccessibilityEvent createEventForHost(int i) {
        AccessibilityEvent accessibilityevent = AccessibilityEvent.obtain(i);
        ViewCompat.onInitializeAccessibilityEvent(mHost, accessibilityevent);
        return accessibilityevent;
    }

    private AccessibilityNodeInfoCompat createNodeForChild(int i) {
        AccessibilityNodeInfoCompat accessibilitynodeinfocompat;
        accessibilitynodeinfocompat = AccessibilityNodeInfoCompat.obtain();
        accessibilitynodeinfocompat.setEnabled(true);
        accessibilitynodeinfocompat.setFocusable(true);
        accessibilitynodeinfocompat.setClassName("android.view.View");
        accessibilitynodeinfocompat.setBoundsInParent(INVALID_PARENT_BOUNDS);
        accessibilitynodeinfocompat.setBoundsInScreen(INVALID_PARENT_BOUNDS);
        onPopulateNodeForVirtualView(i, accessibilitynodeinfocompat);
        if (accessibilitynodeinfocompat.getText() == null && accessibilitynodeinfocompat.getContentDescription() == null)
            throw new RuntimeException("Callbacks must add text or a content description in populateNodeForVirtualViewId()");
        accessibilitynodeinfocompat.getBoundsInParent(mTempParentRect);
        if (mTempParentRect.equals(INVALID_PARENT_BOUNDS))
            throw new RuntimeException("Callbacks must set parent bounds in populateNodeForVirtualViewId()");
        int j = accessibilitynodeinfocompat.getActions();
        if ((j & 0x40) != 0)
            throw new RuntimeException("Callbacks must not add ACTION_ACCESSIBILITY_FOCUS in populateNodeForVirtualViewId()");
        if ((j & 0x80) != 0)
            throw new RuntimeException("Callbacks must not add ACTION_CLEAR_ACCESSIBILITY_FOCUS in populateNodeForVirtualViewId()");
        accessibilitynodeinfocompat.setPackageName(mHost.getContext().getPackageName());
        accessibilitynodeinfocompat.setSource(mHost, i);
        accessibilitynodeinfocompat.setParent(mHost);
        boolean flag;
        if (mAccessibilityFocusedVirtualViewId == i) {
            accessibilitynodeinfocompat.setAccessibilityFocused(true);
            accessibilitynodeinfocompat.addAction(128);
        } else {
            accessibilitynodeinfocompat.setAccessibilityFocused(false);
            accessibilitynodeinfocompat.addAction(64);
        }
        if (mKeyboardFocusedVirtualViewId == i)
            flag = true;
        else
            flag = false;
        if (!flag) goto _L2; else goto _L1
_L1:
        accessibilitynodeinfocompat.addAction(2);
_L4:
        accessibilitynodeinfocompat.setFocused(flag);
        if (intersectVisibleToUser(mTempParentRect)) {
            accessibilitynodeinfocompat.setVisibleToUser(true);
            accessibilitynodeinfocompat.setBoundsInParent(mTempParentRect);
        }
        accessibilitynodeinfocompat.getBoundsInScreen(mTempScreenRect);
        if (mTempScreenRect.equals(INVALID_PARENT_BOUNDS)) {
            mHost.getLocationOnScreen(mTempGlobalRect);
            accessibilitynodeinfocompat.getBoundsInParent(mTempScreenRect);
            mTempScreenRect.offset(mTempGlobalRect[0] - mHost.getScrollX(), mTempGlobalRect[1] - mHost.getScrollY());
            accessibilitynodeinfocompat.setBoundsInScreen(mTempScreenRect);
        }
        return accessibilitynodeinfocompat;
_L2:
        if (accessibilitynodeinfocompat.isFocusable())
            accessibilitynodeinfocompat.addAction(1);
        if (true) goto _L4; else goto _L3
_L3:
    }

    private AccessibilityNodeInfoCompat createNodeForHost() {
        AccessibilityNodeInfoCompat accessibilitynodeinfocompat = AccessibilityNodeInfoCompat.obtain(mHost);
        ViewCompat.onInitializeAccessibilityNodeInfo(mHost, accessibilitynodeinfocompat);
        ArrayList arraylist = new ArrayList();
        getVisibleVirtualViews(arraylist);
        if (accessibilitynodeinfocompat.getChildCount() > 0 && arraylist.size() > 0)
            throw new RuntimeException("Views cannot have both real and virtual children");
        int j = arraylist.size();
        for (int i = 0; i < j; i++)
            accessibilitynodeinfocompat.addChild(mHost, ((Integer)arraylist.get(i)).intValue());

        return accessibilitynodeinfocompat;
    }

    private SparseArrayCompat getAllNodes() {
        ArrayList arraylist = new ArrayList();
        getVisibleVirtualViews(arraylist);
        SparseArrayCompat sparsearraycompat = new SparseArrayCompat();
        for (int i = 0; i < arraylist.size(); i++)
            sparsearraycompat.put(i, createNodeForChild(i));

        return sparsearraycompat;
    }

    private void getBoundsInParent(int i, Rect rect) {
        obtainAccessibilityNodeInfo(i).getBoundsInParent(rect);
    }

    private static Rect guessPreviouslyFocusedRect(View view, int i, Rect rect) {
        int j;
        int k;
        j = view.getWidth();
        k = view.getHeight();
        i;
        JVM INSTR lookupswitch 4: default 56
    //                   17: 67
    //                   33: 78
    //                   66: 91
    //                   130: 103;
           goto _L1 _L2 _L3 _L4 _L5
_L1:
        throw new IllegalArgumentException("direction must be one of {FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
_L2:
        rect.set(j, 0, j, k);
_L7:
        return rect;
_L3:
        rect.set(0, k, j, k);
        continue; /* Loop/switch isn't completed */
_L4:
        rect.set(-1, 0, -1, k);
        continue; /* Loop/switch isn't completed */
_L5:
        rect.set(0, -1, j, -1);
        if (true) goto _L7; else goto _L6
_L6:
    }

    private boolean intersectVisibleToUser(Rect rect) {
        if (rect != null && !rect.isEmpty()) goto _L2; else goto _L1
_L1:
        boolean flag = false;
_L4:
        return flag;
_L2:
        if (mHost.getWindowVisibility() != 0) {
            flag = false;
            continue; /* Loop/switch isn't completed */
        }
        Object obj = mHost.getParent();
        do {
            if (!(obj instanceof View))
                break;
            obj = (View)obj;
            if (ViewCompat.getAlpha(((View) (obj))) <= 0.0F || ((View) (obj)).getVisibility() != 0) {
                flag = false;
                continue; /* Loop/switch isn't completed */
            }
            obj = ((View) (obj)).getParent();
        } while (true);
        if (obj == null)
            flag = false;
        else
        if (!mHost.getLocalVisibleRect(mTempVisibleRect))
            flag = false;
        else
            flag = rect.intersect(mTempVisibleRect);
        if (true) goto _L4; else goto _L3
_L3:
    }

    private static int keyToDirection(int i) {
        i;
        JVM INSTR tableswitch 19 22: default 32
    //                   19 44
    //                   20 32
    //                   21 38
    //                   22 50;
           goto _L1 _L2 _L1 _L3 _L4
_L1:
        i = 130;
_L6:
        return i;
_L3:
        i = 17;
        continue; /* Loop/switch isn't completed */
_L2:
        i = 33;
        continue; /* Loop/switch isn't completed */
_L4:
        i = 66;
        if (true) goto _L6; else goto _L5
_L5:
    }

    private boolean moveFocus(int i, Rect rect) {
        AccessibilityNodeInfoCompat accessibilitynodeinfocompat;
        SparseArrayCompat sparsearraycompat;
        boolean flag = true;
        sparsearraycompat = getAllNodes();
        int j = mKeyboardFocusedVirtualViewId;
        if (j == 0x80000000)
            accessibilitynodeinfocompat = null;
        else
            accessibilitynodeinfocompat = (AccessibilityNodeInfoCompat)sparsearraycompat.get(j);
        switch (i) {
        default:
            throw new IllegalArgumentException("direction must be one of {FOCUS_FORWARD, FOCUS_BACKWARD, FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");

        case 17: // '\021'
        case 33: // '!'
        case 66: // 'B'
        case 130: 
            break MISSING_BLOCK_LABEL_160;

        case 1: // '\001'
        case 2: // '\002'
            if (ViewCompat.getLayoutDirection(mHost) != 1)
                flag = false;
            rect = (AccessibilityNodeInfoCompat)FocusStrategy.findNextFocusInRelativeDirection(sparsearraycompat, SPARSE_VALUES_ADAPTER, NODE_ADAPTER, accessibilitynodeinfocompat, i, flag, false);
            break;
        }
_L1:
        Rect rect1;
        if (rect == null)
            i = 0x80000000;
        else
            i = sparsearraycompat.keyAt(sparsearraycompat.indexOfValue(rect));
        return requestKeyboardFocusForVirtualView(i);
        rect1 = new Rect();
        if (mKeyboardFocusedVirtualViewId != 0x80000000)
            getBoundsInParent(mKeyboardFocusedVirtualViewId, rect1);
        else
        if (rect != null)
            rect1.set(rect);
        else
            guessPreviouslyFocusedRect(mHost, i, rect1);
        rect = (AccessibilityNodeInfoCompat)FocusStrategy.findNextFocusInAbsoluteDirection(sparsearraycompat, SPARSE_VALUES_ADAPTER, NODE_ADAPTER, accessibilitynodeinfocompat, rect1, i);
          goto _L1
    }

    private boolean performActionForChild(int i, int j, Bundle bundle) {
        j;
        JVM INSTR lookupswitch 4: default 44
    //                   1: 76
    //                   2: 86
    //                   64: 56
    //                   128: 66;
           goto _L1 _L2 _L3 _L4 _L5
_L1:
        boolean flag = onPerformActionForVirtualView(i, j, bundle);
_L7:
        return flag;
_L4:
        flag = requestAccessibilityFocus(i);
        continue; /* Loop/switch isn't completed */
_L5:
        flag = clearAccessibilityFocus(i);
        continue; /* Loop/switch isn't completed */
_L2:
        flag = requestKeyboardFocusForVirtualView(i);
        continue; /* Loop/switch isn't completed */
_L3:
        flag = clearKeyboardFocusForVirtualView(i);
        if (true) goto _L7; else goto _L6
_L6:
    }

    private boolean performActionForHost(int i, Bundle bundle) {
        return ViewCompat.performAccessibilityAction(mHost, i, bundle);
    }

    private boolean requestAccessibilityFocus(int i) {
        boolean flag;
        boolean flag1;
        flag1 = false;
        flag = flag1;
        if (!mManager.isEnabled()) goto _L2; else goto _L1
_L1:
        if (AccessibilityManagerCompat.isTouchExplorationEnabled(mManager)) goto _L4; else goto _L3
_L3:
        flag = flag1;
_L2:
        return flag;
_L4:
        flag = flag1;
        if (mAccessibilityFocusedVirtualViewId != i) {
            if (mAccessibilityFocusedVirtualViewId != 0x80000000)
                clearAccessibilityFocus(mAccessibilityFocusedVirtualViewId);
            mAccessibilityFocusedVirtualViewId = i;
            mHost.invalidate();
            sendEventForVirtualView(i, 32768);
            flag = true;
        }
        if (true) goto _L2; else goto _L5
_L5:
    }

    private void updateHoveredVirtualView(int i) {
        if (mHoveredVirtualViewId != i) {
            int j = mHoveredVirtualViewId;
            mHoveredVirtualViewId = i;
            sendEventForVirtualView(i, 128);
            sendEventForVirtualView(j, 256);
        }
    }

    public final boolean clearKeyboardFocusForVirtualView(int i) {
        boolean flag = false;
        if (mKeyboardFocusedVirtualViewId == i) {
            mKeyboardFocusedVirtualViewId = 0x80000000;
            onVirtualViewKeyboardFocusChanged(i, false);
            sendEventForVirtualView(i, 8);
            flag = true;
        }
        return flag;
    }

    public final boolean dispatchHoverEvent(MotionEvent motionevent) {
        boolean flag;
        boolean flag1;
        boolean flag2;
        flag1 = true;
        flag2 = false;
        flag = flag2;
        if (!mManager.isEnabled()) goto _L2; else goto _L1
_L1:
        if (AccessibilityManagerCompat.isTouchExplorationEnabled(mManager)) goto _L4; else goto _L3
_L3:
        flag = flag2;
_L2:
        return flag;
_L4:
        switch (motionevent.getAction()) {
        case 8: // '\b'
        default:
            flag = flag2;
            break;

        case 7: // '\007'
        case 9: // '\t'
            int i = getVirtualViewAt(motionevent.getX(), motionevent.getY());
            updateHoveredVirtualView(i);
            if (i != 0x80000000)
                flag = flag1;
            else
                flag = false;
            break;

        case 10: // '\n'
            flag = flag2;
            if (mAccessibilityFocusedVirtualViewId != 0x80000000) {
                updateHoveredVirtualView(0x80000000);
                flag = true;
            }
            break;
        }
        if (true) goto _L2; else goto _L5
_L5:
    }

    public final boolean dispatchKeyEvent(KeyEvent keyevent) {
        boolean flag;
        boolean flag1;
        boolean flag2;
        flag2 = false;
        flag1 = false;
        flag = flag1;
        if (keyevent.getAction() == 1) goto _L2; else goto _L1
_L1:
        int i = keyevent.getKeyCode();
        i;
        JVM INSTR lookupswitch 7: default 92
    //                   19: 99
    //                   20: 99
    //                   21: 99
    //                   22: 99
    //                   23: 161
    //                   61: 194
    //                   66: 161;
           goto _L3 _L4 _L4 _L4 _L4 _L5 _L6 _L5
_L3:
        flag = flag1;
_L2:
        return flag;
_L4:
        flag = flag1;
        if (!KeyEventCompat.hasNoModifiers(keyevent))
            continue; /* Loop/switch isn't completed */
        int k = keyToDirection(i);
        int j = keyevent.getRepeatCount();
        i = 0;
        flag1 = flag2;
        do {
            flag = flag1;
            if (i >= j + 1)
                continue; /* Loop/switch isn't completed */
            flag = flag1;
            if (!moveFocus(k, null))
                continue; /* Loop/switch isn't completed */
            i++;
            flag1 = true;
        } while (true);
_L5:
        flag = flag1;
        if (KeyEventCompat.hasNoModifiers(keyevent)) {
            flag = flag1;
            if (keyevent.getRepeatCount() == 0) {
                clickKeyboardFocusedVirtualView();
                flag = true;
            }
        }
        continue; /* Loop/switch isn't completed */
_L6:
        if (KeyEventCompat.hasNoModifiers(keyevent)) {
            flag = moveFocus(2, null);
        } else {
            flag = flag1;
            if (KeyEventCompat.hasModifiers(keyevent, 1))
                flag = moveFocus(1, null);
        }
        if (true) goto _L2; else goto _L7
_L7:
    }

    public final int getAccessibilityFocusedVirtualViewId() {
        return mAccessibilityFocusedVirtualViewId;
    }

    public AccessibilityNodeProviderCompat getAccessibilityNodeProvider(View view) {
        if (mNodeProvider == null)
            mNodeProvider = new MyNodeProvider();
        return mNodeProvider;
    }

    public int getFocusedVirtualView() {
        return getAccessibilityFocusedVirtualViewId();
    }

    public final int getKeyboardFocusedVirtualViewId() {
        return mKeyboardFocusedVirtualViewId;
    }

    protected abstract int getVirtualViewAt(float f, float f1);

    protected abstract void getVisibleVirtualViews(List list);

    public final void invalidateRoot() {
        invalidateVirtualView(-1, 1);
    }

    public final void invalidateVirtualView(int i) {
        invalidateVirtualView(i, 0);
    }

    public final void invalidateVirtualView(int i, int j) {
        if (i != 0x80000000 && mManager.isEnabled()) {
            android.view.ViewParent viewparent = mHost.getParent();
            if (viewparent != null) {
                AccessibilityEvent accessibilityevent = createEvent(i, 2048);
                AccessibilityEventCompat.setContentChangeTypes(accessibilityevent, j);
                ViewParentCompat.requestSendAccessibilityEvent(viewparent, mHost, accessibilityevent);
            }
        }
    }

    AccessibilityNodeInfoCompat obtainAccessibilityNodeInfo(int i) {
        AccessibilityNodeInfoCompat accessibilitynodeinfocompat;
        if (i == -1)
            accessibilitynodeinfocompat = createNodeForHost();
        else
            accessibilitynodeinfocompat = createNodeForChild(i);
        return accessibilitynodeinfocompat;
    }

    public final void onFocusChanged(boolean flag, int i, Rect rect) {
        if (mKeyboardFocusedVirtualViewId != 0x80000000)
            clearKeyboardFocusForVirtualView(mKeyboardFocusedVirtualViewId);
        if (flag)
            moveFocus(i, rect);
    }

    public void onInitializeAccessibilityEvent(View view, AccessibilityEvent accessibilityevent) {
        super.onInitializeAccessibilityEvent(view, accessibilityevent);
        onPopulateEventForHost(accessibilityevent);
    }

    public void onInitializeAccessibilityNodeInfo(View view, AccessibilityNodeInfoCompat accessibilitynodeinfocompat) {
        super.onInitializeAccessibilityNodeInfo(view, accessibilitynodeinfocompat);
        onPopulateNodeForHost(accessibilitynodeinfocompat);
    }

    protected abstract boolean onPerformActionForVirtualView(int i, int j, Bundle bundle);

    protected void onPopulateEventForHost(AccessibilityEvent accessibilityevent) {
    }

    protected void onPopulateEventForVirtualView(int i, AccessibilityEvent accessibilityevent) {
    }

    protected void onPopulateNodeForHost(AccessibilityNodeInfoCompat accessibilitynodeinfocompat) {
    }

    protected abstract void onPopulateNodeForVirtualView(int i, AccessibilityNodeInfoCompat accessibilitynodeinfocompat);

    protected void onVirtualViewKeyboardFocusChanged(int i, boolean flag) {
    }

    boolean performAction(int i, int j, Bundle bundle) {
        i;
        JVM INSTR tableswitch -1 -1: default 20
    //                   -1 32;
           goto _L1 _L2
_L1:
        boolean flag = performActionForChild(i, j, bundle);
_L4:
        return flag;
_L2:
        flag = performActionForHost(j, bundle);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public final boolean requestKeyboardFocusForVirtualView(int i) {
        boolean flag;
        flag = false;
        break MISSING_BLOCK_LABEL_2;
        if ((mHost.isFocused() || mHost.requestFocus()) && mKeyboardFocusedVirtualViewId != i) {
            if (mKeyboardFocusedVirtualViewId != 0x80000000)
                clearKeyboardFocusForVirtualView(mKeyboardFocusedVirtualViewId);
            mKeyboardFocusedVirtualViewId = i;
            onVirtualViewKeyboardFocusChanged(i, true);
            sendEventForVirtualView(i, 8);
            flag = true;
        }
        return flag;
    }

    public final boolean sendEventForVirtualView(int i, int j) {
        boolean flag;
        boolean flag1;
        flag1 = false;
        flag = flag1;
        if (i == 0x80000000) goto _L2; else goto _L1
_L1:
        if (mManager.isEnabled()) goto _L4; else goto _L3
_L3:
        flag = flag1;
_L2:
        return flag;
_L4:
        android.view.ViewParent viewparent = mHost.getParent();
        flag = flag1;
        if (viewparent != null) {
            AccessibilityEvent accessibilityevent = createEvent(i, j);
            flag = ViewParentCompat.requestSendAccessibilityEvent(viewparent, mHost, accessibilityevent);
        }
        if (true) goto _L2; else goto _L5
_L5:
    }

}
