// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.v4.widget;

import android.graphics.Rect;
import java.util.*;

class FocusStrategy {
    public static interface BoundsAdapter {

        public abstract void obtainBounds(Object obj, Rect rect);
    }

    public static interface CollectionAdapter {

        public abstract Object get(Object obj, int i);

        public abstract int size(Object obj);
    }

    private static class SequentialComparator
        implements Comparator {

        private final BoundsAdapter mAdapter;
        private final boolean mIsLayoutRtl;
        private final Rect mTemp1 = new Rect();
        private final Rect mTemp2 = new Rect();

        public int compare(Object obj, Object obj1) {
            byte byte0;
            byte byte1;
            boolean flag;
            Rect rect;
            Rect rect1;
            flag = true;
            byte0 = 1;
            byte1 = -1;
            rect1 = mTemp1;
            rect = mTemp2;
            mAdapter.obtainBounds(obj, rect1);
            mAdapter.obtainBounds(obj1, rect);
            if (rect1.top >= rect.top) goto _L2; else goto _L1
_L1:
            byte0 = byte1;
_L4:
            return byte0;
_L2:
            if (rect1.top > rect.top)
                byte0 = 1;
            else
            if (rect1.left < rect.left) {
                if (!mIsLayoutRtl)
                    byte0 = -1;
            } else
            if (rect1.left > rect.left) {
                byte0 = byte1;
                if (!mIsLayoutRtl)
                    byte0 = 1;
            } else {
                byte0 = byte1;
                if (rect1.bottom >= rect.bottom)
                    if (rect1.bottom > rect.bottom)
                        byte0 = 1;
                    else
                    if (rect1.right < rect.right) {
                        if (mIsLayoutRtl)
                            byte0 = flag;
                        else
                            byte0 = -1;
                    } else
                    if (rect1.right > rect.right) {
                        byte0 = byte1;
                        if (!mIsLayoutRtl)
                            byte0 = 1;
                    } else {
                        byte0 = 0;
                    }
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        SequentialComparator(boolean flag, BoundsAdapter boundsadapter) {
            mIsLayoutRtl = flag;
            mAdapter = boundsadapter;
        }
    }


    FocusStrategy() {
    }

    private static boolean beamBeats(int i, Rect rect, Rect rect1, Rect rect2) {
        boolean flag;
        boolean flag1;
        flag1 = true;
        flag = beamsOverlap(i, rect, rect1);
        if (!beamsOverlap(i, rect, rect2) && flag) goto _L2; else goto _L1
_L1:
        flag = false;
_L4:
        return flag;
_L2:
        flag = flag1;
        if (isToDirectionOf(i, rect, rect2)) {
            flag = flag1;
            if (i != 17) {
                flag = flag1;
                if (i != 66) {
                    flag = flag1;
                    if (majorAxisDistance(i, rect, rect1) >= majorAxisDistanceToFarEdge(i, rect, rect2))
                        flag = false;
                }
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private static boolean beamsOverlap(int i, Rect rect, Rect rect1) {
        boolean flag = true;
        i;
        JVM INSTR lookupswitch 4: default 44
    //                   17: 54
    //                   33: 83
    //                   66: 54
    //                   130: 83;
           goto _L1 _L2 _L3 _L2 _L3
_L1:
        throw new IllegalArgumentException("direction must be one of {FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
_L2:
        if (rect1.bottom < rect.top || rect1.top > rect.bottom)
            flag = false;
_L5:
        return flag;
_L3:
        if (rect1.right < rect.left || rect1.left > rect.right)
            flag = false;
        if (true) goto _L5; else goto _L4
_L4:
    }

    public static Object findNextFocusInAbsoluteDirection(Object obj, CollectionAdapter collectionadapter, BoundsAdapter boundsadapter, Object obj1, Rect rect, int i) {
        Rect rect2;
        rect2 = new Rect(rect);
        int j;
        int k;
        switch (i) {
        default:
            throw new IllegalArgumentException("direction must be one of {FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");

        case 17: // '\021'
            rect2.offset(rect.width() + 1, 0);
            break;

        case 66: // 'B'
            rect2.offset(-(rect.width() + 1), 0);
            continue;

        case 33: // '!'
            rect2.offset(0, rect.height() + 1);
            continue;

        case 130: 
            rect2.offset(0, -(rect.height() + 1));
            continue;
        }
        break;
        do {
            k = collectionadapter.size(obj);
            Rect rect1 = new Rect();
            j = 0;
            Object obj2 = null;
            while (j < k)  {
                Object obj3 = collectionadapter.get(obj, j);
                if (obj3 != obj1) {
                    boundsadapter.obtainBounds(obj3, rect1);
                    if (isBetterCandidate(i, rect, rect1, rect2)) {
                        rect2.set(rect1);
                        obj2 = obj3;
                    }
                }
                j++;
            }
            return obj2;
        } while (true);
    }

    public static Object findNextFocusInRelativeDirection(Object obj, CollectionAdapter collectionadapter, BoundsAdapter boundsadapter, Object obj1, int i, boolean flag, boolean flag1) {
        ArrayList arraylist;
        int k = collectionadapter.size(obj);
        arraylist = new ArrayList(k);
        for (int j = 0; j < k; j++)
            arraylist.add(collectionadapter.get(obj, j));

        Collections.sort(arraylist, new SequentialComparator(flag, boundsadapter));
        i;
        JVM INSTR tableswitch 1 2: default 92
    //                   1 113
    //                   2 102;
           goto _L1 _L2 _L3
_L1:
        throw new IllegalArgumentException("direction must be one of {FOCUS_FORWARD, FOCUS_BACKWARD}.");
_L3:
        obj = getNextFocusable(obj1, arraylist, flag1);
_L5:
        return obj;
_L2:
        obj = getPreviousFocusable(obj1, arraylist, flag1);
        if (true) goto _L5; else goto _L4
_L4:
    }

    private static Object getNextFocusable(Object obj, ArrayList arraylist, boolean flag) {
        int j = arraylist.size();
        int i;
        if (obj == null)
            i = -1;
        else
            i = arraylist.lastIndexOf(obj);
        if (++i < j)
            obj = arraylist.get(i);
        else
        if (flag && j > 0)
            obj = arraylist.get(0);
        else
            obj = null;
        return obj;
    }

    private static Object getPreviousFocusable(Object obj, ArrayList arraylist, boolean flag) {
        int j = arraylist.size();
        int i;
        if (obj == null)
            i = j;
        else
            i = arraylist.indexOf(obj);
        if (--i >= 0)
            obj = arraylist.get(i);
        else
        if (flag && j > 0)
            obj = arraylist.get(j - 1);
        else
            obj = null;
        return obj;
    }

    private static int getWeightedDistanceFor(int i, int j) {
        return i * 13 * i + j * j;
    }

    private static boolean isBetterCandidate(int i, Rect rect, Rect rect1, Rect rect2) {
        boolean flag1 = true;
        if (isCandidate(rect, rect1, i)) goto _L2; else goto _L1
_L1:
        boolean flag = false;
_L4:
        return flag;
_L2:
        flag = flag1;
        if (isCandidate(rect, rect2, i)) {
            flag = flag1;
            if (!beamBeats(i, rect, rect1, rect2))
                if (beamBeats(i, rect, rect2, rect1)) {
                    flag = false;
                } else {
                    flag = flag1;
                    if (getWeightedDistanceFor(majorAxisDistance(i, rect, rect1), minorAxisDistance(i, rect, rect1)) >= getWeightedDistanceFor(majorAxisDistance(i, rect, rect2), minorAxisDistance(i, rect, rect2)))
                        flag = false;
                }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private static boolean isCandidate(Rect rect, Rect rect1, int i) {
        boolean flag = true;
        i;
        JVM INSTR lookupswitch 4: default 44
    //                   17: 54
    //                   33: 132
    //                   66: 94
    //                   130: 170;
           goto _L1 _L2 _L3 _L4 _L5
_L1:
        throw new IllegalArgumentException("direction must be one of {FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
_L2:
        if (rect.right <= rect1.right && rect.left < rect1.right || rect.left <= rect1.left)
            flag = false;
_L7:
        return flag;
_L4:
        if (rect.left >= rect1.left && rect.right > rect1.left || rect.right >= rect1.right)
            flag = false;
        continue; /* Loop/switch isn't completed */
_L3:
        if (rect.bottom <= rect1.bottom && rect.top < rect1.bottom || rect.top <= rect1.top)
            flag = false;
        continue; /* Loop/switch isn't completed */
_L5:
        if (rect.top >= rect1.top && rect.bottom > rect1.top || rect.bottom >= rect1.bottom)
            flag = false;
        if (true) goto _L7; else goto _L6
_L6:
    }

    private static boolean isToDirectionOf(int i, Rect rect, Rect rect1) {
        boolean flag = true;
        i;
        JVM INSTR lookupswitch 4: default 44
    //                   17: 54
    //                   33: 88
    //                   66: 72
    //                   130: 104;
           goto _L1 _L2 _L3 _L4 _L5
_L1:
        throw new IllegalArgumentException("direction must be one of {FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
_L2:
        if (rect.left < rect1.right)
            flag = false;
_L7:
        return flag;
_L4:
        if (rect.right > rect1.left)
            flag = false;
        continue; /* Loop/switch isn't completed */
_L3:
        if (rect.top < rect1.bottom)
            flag = false;
        continue; /* Loop/switch isn't completed */
_L5:
        if (rect.bottom > rect1.top)
            flag = false;
        if (true) goto _L7; else goto _L6
_L6:
    }

    private static int majorAxisDistance(int i, Rect rect, Rect rect1) {
        return Math.max(0, majorAxisDistanceRaw(i, rect, rect1));
    }

    private static int majorAxisDistanceRaw(int i, Rect rect, Rect rect1) {
        i;
        JVM INSTR lookupswitch 4: default 44
    //                   17: 54
    //                   33: 79
    //                   66: 66
    //                   130: 92;
           goto _L1 _L2 _L3 _L4 _L5
_L1:
        throw new IllegalArgumentException("direction must be one of {FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
_L2:
        i = rect.left - rect1.right;
_L7:
        return i;
_L4:
        i = rect1.left - rect.right;
        continue; /* Loop/switch isn't completed */
_L3:
        i = rect.top - rect1.bottom;
        continue; /* Loop/switch isn't completed */
_L5:
        i = rect1.top - rect.bottom;
        if (true) goto _L7; else goto _L6
_L6:
    }

    private static int majorAxisDistanceToFarEdge(int i, Rect rect, Rect rect1) {
        return Math.max(1, majorAxisDistanceToFarEdgeRaw(i, rect, rect1));
    }

    private static int majorAxisDistanceToFarEdgeRaw(int i, Rect rect, Rect rect1) {
        i;
        JVM INSTR lookupswitch 4: default 44
    //                   17: 54
    //                   33: 79
    //                   66: 66
    //                   130: 92;
           goto _L1 _L2 _L3 _L4 _L5
_L1:
        throw new IllegalArgumentException("direction must be one of {FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
_L2:
        i = rect.left - rect1.left;
_L7:
        return i;
_L4:
        i = rect1.right - rect.right;
        continue; /* Loop/switch isn't completed */
_L3:
        i = rect.top - rect1.top;
        continue; /* Loop/switch isn't completed */
_L5:
        i = rect1.bottom - rect.bottom;
        if (true) goto _L7; else goto _L6
_L6:
    }

    private static int minorAxisDistance(int i, Rect rect, Rect rect1) {
        i;
        JVM INSTR lookupswitch 4: default 44
    //                   17: 54
    //                   33: 83
    //                   66: 54
    //                   130: 83;
           goto _L1 _L2 _L3 _L2 _L3
_L1:
        throw new IllegalArgumentException("direction must be one of {FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT}.");
_L2:
        i = Math.abs((rect.top + rect.height() / 2) - (rect1.top + rect1.height() / 2));
_L5:
        return i;
_L3:
        i = Math.abs((rect.left + rect.width() / 2) - (rect1.left + rect1.width() / 2));
        if (true) goto _L5; else goto _L4
_L4:
    }
}
