// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package android.support.v4.util;


public final class CircularIntArray {

    private int mCapacityBitmask;
    private int mElements[];
    private int mHead;
    private int mTail;

    public CircularIntArray() {
        this(8);
    }

    public CircularIntArray(int i) {
        if (i < 1)
            throw new IllegalArgumentException("capacity must be >= 1");
        if (i > 0x40000000)
            throw new IllegalArgumentException("capacity must be <= 2^30");
        int j = i;
        if (Integer.bitCount(i) != 1)
            j = Integer.highestOneBit(i - 1) << 1;
        mCapacityBitmask = j - 1;
        mElements = new int[j];
    }

    private void doubleCapacity() {
        int j = mElements.length;
        int k = j - mHead;
        int i = j << 1;
        if (i < 0) {
            throw new RuntimeException("Max array capacity exceeded");
        } else {
            int ai[] = new int[i];
            System.arraycopy(mElements, mHead, ai, 0, k);
            System.arraycopy(mElements, 0, ai, k, mHead);
            mElements = ai;
            mHead = 0;
            mTail = j;
            mCapacityBitmask = i - 1;
            return;
        }
    }

    public void addFirst(int i) {
        mHead = mHead - 1 & mCapacityBitmask;
        mElements[mHead] = i;
        if (mHead == mTail)
            doubleCapacity();
    }

    public void addLast(int i) {
        mElements[mTail] = i;
        mTail = mTail + 1 & mCapacityBitmask;
        if (mTail == mHead)
            doubleCapacity();
    }

    public void clear() {
        mTail = mHead;
    }

    public int get(int i) {
        if (i < 0 || i >= size())
            throw new ArrayIndexOutOfBoundsException();
        else
            return mElements[mHead + i & mCapacityBitmask];
    }

    public int getFirst() {
        if (mHead == mTail)
            throw new ArrayIndexOutOfBoundsException();
        else
            return mElements[mHead];
    }

    public int getLast() {
        if (mHead == mTail)
            throw new ArrayIndexOutOfBoundsException();
        else
            return mElements[mTail - 1 & mCapacityBitmask];
    }

    public boolean isEmpty() {
        boolean flag;
        if (mHead == mTail)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public int popFirst() {
        if (mHead == mTail) {
            throw new ArrayIndexOutOfBoundsException();
        } else {
            int i = mElements[mHead];
            mHead = mHead + 1 & mCapacityBitmask;
            return i;
        }
    }

    public int popLast() {
        if (mHead == mTail) {
            throw new ArrayIndexOutOfBoundsException();
        } else {
            int i = mTail - 1 & mCapacityBitmask;
            int j = mElements[i];
            mTail = i;
            return j;
        }
    }

    public void removeFromEnd(int i) {
        if (i > 0) {
            if (i > size())
                throw new ArrayIndexOutOfBoundsException();
            mTail = mTail - i & mCapacityBitmask;
        }
    }

    public void removeFromStart(int i) {
        if (i > 0) {
            if (i > size())
                throw new ArrayIndexOutOfBoundsException();
            mHead = mHead + i & mCapacityBitmask;
        }
    }

    public int size() {
        return mTail - mHead & mCapacityBitmask;
    }
}
