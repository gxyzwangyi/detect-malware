// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.channel.group;

import io.netty.channel.h;
import io.netty.util.concurrent.BlockingOperationException;
import io.netty.util.concurrent.i;
import io.netty.util.concurrent.n;
import io.netty.util.concurrent.p;
import io.netty.util.concurrent.s;
import io.netty.util.concurrent.y;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

// Referenced classes of package io.netty.channel.group:
//            b, ChannelGroupException, a

final class g extends io.netty.util.concurrent.g
    implements b {
    private static final class a
        implements java.util.Map.Entry {

        private final Object a;
        private final Object b;

        public Object getKey() {
            return a;
        }

        public Object getValue() {
            return b;
        }

        public Object setValue(Object obj) {
            throw new UnsupportedOperationException("read-only");
        }

        a(Object obj, Object obj1) {
            a = obj;
            b = obj1;
        }
    }


    private final io.netty.channel.group.a a;
    private final Map b;
    private int c;
    private int d;
    private final h e = new h() {

        static final boolean a;
        final g b;

        public void a(io.netty.channel.g g1) {
            boolean flag1 = g1.g_();
            g1 = b;
            g1;
            JVM INSTR monitorenter ;
            if (!flag1)
                break MISSING_BLOCK_LABEL_114;
            g.a(b);
_L1:
            boolean flag;
            Exception exception;
            if (g.c(b) + g.d(b) == g.e(b).size())
                flag = true;
            else
                flag = false;
            if (!a && g.c(b) + g.d(b) > g.e(b).size()) {
                AssertionError assertionerror = JVM INSTR new #56  <Class AssertionError>;
                assertionerror.AssertionError();
                throw assertionerror;
            }
            break MISSING_BLOCK_LABEL_130;
            exception;
            g1;
            JVM INSTR monitorexit ;
            throw exception;
            g.b(b);
              goto _L1
            g1;
            JVM INSTR monitorexit ;
            if (flag)
                if (g.d(b) > 0) {
                    ArrayList arraylist = new ArrayList(g.d(b));
                    g1 = g.e(b).values().iterator();
                    do {
                        if (!g1.hasNext())
                            break;
                        io.netty.channel.g g2 = (io.netty.channel.g)g1.next();
                        if (!g2.g_())
                            arraylist.add(new a(g2.e(), g2.j()));
                    } while (true);
                    g.a(b, new ChannelGroupException(arraylist));
                } else {
                    g.f(b);
                }
            return;
        }

        public volatile void a(n n1) {
            a((io.netty.channel.g)n1);
        }

        static  {
            boolean flag;
            if (!io/netty/channel/group/g.desiredAssertionStatus())
                flag = true;
            else
                flag = false;
            a = flag;
        }

             {
                b = g.this;
                super();
            }
    }
;

    g(io.netty.channel.group.a a1, Map map, i k) {
        super(k);
        a = a1;
        b = Collections.unmodifiableMap(map);
        for (a1 = b.values().iterator(); a1.hasNext(); ((io.netty.channel.g)a1.next()).a(e));
        if (b.isEmpty())
            f();
    }

    static int a(g g1) {
        int k = g1.c;
        g1.c = k + 1;
        return k;
    }

    private void a(ChannelGroupException channelgroupexception) {
        super.c(channelgroupexception);
    }

    static void a(g g1, ChannelGroupException channelgroupexception) {
        g1.a(channelgroupexception);
    }

    static int b(g g1) {
        int k = g1.d;
        g1.d = k + 1;
        return k;
    }

    static int c(g g1) {
        return g1.c;
    }

    static int d(g g1) {
        return g1.d;
    }

    static Map e(g g1) {
        return g1.b;
    }

    private void f() {
        super.a(null);
    }

    static void f(g g1) {
        g1.f();
    }

    public g a(p p1) {
        super.g(p1);
        return this;
    }

    public g a(Throwable throwable) {
        throw new IllegalStateException();
    }

    public g a(Void void1) {
        throw new IllegalStateException();
    }

    public volatile y a(Object obj) {
        return a((Void)obj);
    }

    public g b() {
        super.p();
        return this;
    }

    public g b(p p1) {
        super.f(p1);
        return this;
    }

    public volatile boolean b(Object obj) {
        return b((Void)obj);
    }

    public boolean b(Throwable throwable) {
        throw new IllegalStateException();
    }

    public boolean b(Void void1) {
        throw new IllegalStateException();
    }

    public g c() {
        super.o();
        return this;
    }

    public y c(Throwable throwable) {
        return a(throwable);
    }

    public g d() {
        super.n();
        return this;
    }

    public n d(p p1) {
        return a(p1);
    }

    public ChannelGroupException e() {
        return (ChannelGroupException)super.j();
    }

    public y f(p p1) {
        return b(p1);
    }

    public n g() {
        return d();
    }

    public y g(p p1) {
        return a(p1);
    }

    public n h() {
        return b();
    }

    public Iterator iterator() {
        return b.values().iterator();
    }

    public Throwable j() {
        return e();
    }

    protected void m() {
        i k = a();
        if (k != null && k != s.a && k.f())
            throw new BlockingOperationException();
        else
            return;
    }

    public y n() {
        return d();
    }

    public y o() {
        return c();
    }

    public y p() {
        return b();
    }
}
