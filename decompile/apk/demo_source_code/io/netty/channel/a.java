// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.channel;

import io.netty.buffer.i;
import io.netty.util.DefaultAttributeMap;
import io.netty.util.concurrent.n;
import io.netty.util.concurrent.y;
import io.netty.util.h;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.ThreadLocalRandom;
import io.netty.util.internal.logging.b;
import io.netty.util.internal.logging.c;
import io.netty.util.internal.o;
import java.io.IOException;
import java.net.*;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.NotYetConnectedException;
import java.util.concurrent.Executor;
import java.util.concurrent.RejectedExecutionException;

// Referenced classes of package io.netty.channel:
//            d, at, au, ab, 
//            ai, q, e, ac, 
//            g, ag, w, t, 
//            p, h

public abstract class io.netty.channel.a extends DefaultAttributeMap
    implements d {
    protected abstract class a
        implements d.a {

        static final boolean a;
        final io.netty.channel.a b;
        private volatile q c;
        private boolean d;
        private boolean e;

        static void a(a a1, w w1) {
            a1.e(w1);
        }

        static void a(a a1, Runnable runnable) {
            a1.a(runnable);
        }

        static void a(a a1, boolean flag) {
            a1.a(flag);
        }

        private void a(w w1, Throwable throwable, ClosedChannelException closedchannelexception, boolean flag) {
            boolean flag1;
            q q1;
            if (w1.f_()) {
                q1 = c;
                if (q1 == null) {
                    if (!(w1 instanceof au))
                        io.netty.channel.a.c(b).c(new io.netty.channel.h(this, w1) {

                            final w a;
                            final a b;

                            public void a(g g1) {
                                a.b();
                            }

                            public volatile void a(n n1) {
                                a((g)n1);
                            }

             {
                b = a1;
                a = w1;
                super();
            }
                        }
);
                } else
                if (io.netty.channel.a.c(b).isDone()) {
                    d(w1);
                } else {
label0:
                    {
                        flag1 = b.G();
                        c = null;
                        Executor executor = j();
                        if (executor == null)
                            break label0;
                        executor.execute(new Runnable(this, w1, q1, throwable, flag, closedchannelexception, flag1) {

                            final w a;
                            final q b;
                            final Throwable c;
                            final boolean d;
                            final ClosedChannelException e;
                            final boolean f;
                            final a g;

                            public void run() {
                                io.netty.channel.a.b(g, a);
                                a.a(g, new Runnable(this) {

                                    final a._cls5 a;

                                    public void run() {
                                        a.b.a(a.c, a.d);
                                        a.b.a(a.e);
                                        a.a(a.g, a.f);
                                    }

             {
                a = _pcls5;
                super();
            }
                                }
);
                                return;
                                Exception exception;
                                exception;
                                a.a(g, new _cls1(this));
                                throw exception;
                            }

             {
                g = a1;
                a = w1;
                b = q1;
                c = throwable;
                d = flag;
                e = closedchannelexception;
                f = flag1;
                super();
            }
                        }
);
                    }
                }
            }
_L2:
            return;
            f(w1);
            q1.a(throwable, flag);
            q1.a(closedchannelexception);
            if (d)
                a(new Runnable(this, flag1) {

                    final boolean a;
                    final a b;

                    public void run() {
                        a.a(b, a);
                    }

             {
                b = a1;
                a = flag;
                super();
            }
                }
);
            else
                a(flag1);
            if (true) goto _L2; else goto _L1
_L1:
            w1;
            q1.a(throwable, flag);
            q1.a(closedchannelexception);
            throw w1;
        }

        private void a(w w1, boolean flag) {
            if (w1.f_())
                if (!io.netty.channel.a.a(b))
                    d(w1);
                else
                    a(new Runnable(this, flag, w1) {

                        final boolean a;
                        final w b;
                        final a c;

                        public void run() {
                            c.b.w();
                            if (a)
                                io.netty.channel.a.d(c.b).j();
                            if (io.netty.channel.a.a(c.b)) {
                                io.netty.channel.a.a(c.b, false);
                                io.netty.channel.a.d(c.b).i();
                            }
                            c.d(b);
_L2:
                            return;
                            Object obj;
                            obj;
                            io.netty.channel.a.y().b("Unexpected exception occurred while deregistering a channel.", ((Throwable) (obj)));
                            if (a)
                                io.netty.channel.a.d(c.b).j();
                            if (io.netty.channel.a.a(c.b)) {
                                io.netty.channel.a.a(c.b, false);
                                io.netty.channel.a.d(c.b).i();
                            }
                            c.d(b);
                            if (true) goto _L2; else goto _L1
_L1:
                            obj;
                            if (a)
                                io.netty.channel.a.d(c.b).j();
                            if (io.netty.channel.a.a(c.b)) {
                                io.netty.channel.a.a(c.b, false);
                                io.netty.channel.a.d(c.b).i();
                            }
                            c.d(b);
                            throw obj;
                        }

             {
                c = a1;
                a = flag;
                b = w1;
                super();
            }
                    }
);
        }

        private void a(Runnable runnable) {
            b.e().execute(runnable);
_L1:
            return;
            runnable;
            io.netty.channel.a.y().b("Can't invoke task later as EventLoop rejected it", runnable);
              goto _L1
        }

        private void a(boolean flag) {
            w w1 = h();
            if (flag && !b.G())
                flag = true;
            else
                flag = false;
            a(w1, flag);
        }

        static void b(a a1, w w1) {
            a1.f(w1);
        }

        private void e(w w1) {
            if (w1.f_() && c(w1)) goto _L2; else goto _L1
_L1:
            return;
_L2:
            boolean flag;
            flag = e;
            b.t();
            e = false;
            io.netty.channel.a.a(b, true);
            io.netty.channel.a.d(b).g();
            d(w1);
            io.netty.channel.a.d(b).a();
            if (!b.G()) goto _L1; else goto _L3
_L3:
            if (!flag) goto _L5; else goto _L4
_L4:
            try {
                io.netty.channel.a.d(b).b();
            }
            catch (Throwable throwable) {
                d();
                io.netty.channel.a.c(b).d();
                a(w1, throwable);
            }
              goto _L1
_L5:
            if (!b.E().f()) goto _L1; else goto _L6
_L6:
            e();
              goto _L1
        }

        private void f(w w1) {
            b.v();
            io.netty.channel.a.c(b).d();
            d(w1);
_L1:
            return;
            Throwable throwable;
            throwable;
            io.netty.channel.a.c(b).d();
            a(w1, throwable);
              goto _L1
        }

        private void l() {
            if (!a && io.netty.channel.a.a(b) && !io.netty.channel.a.b(b).f())
                throw new AssertionError();
            else
                return;
        }

        public final q a() {
            return c;
        }

        protected final Throwable a(Throwable throwable, SocketAddress socketaddress) {
            if (!(throwable instanceof ConnectException)) goto _L2; else goto _L1
_L1:
            Object obj;
            obj = new ConnectException((new StringBuilder()).append(throwable.getMessage()).append(": ").append(socketaddress).toString());
            ((Throwable) (obj)).setStackTrace(throwable.getStackTrace());
_L4:
            return ((Throwable) (obj));
_L2:
            if (throwable instanceof NoRouteToHostException) {
                obj = new NoRouteToHostException((new StringBuilder()).append(throwable.getMessage()).append(": ").append(socketaddress).toString());
                ((Throwable) (obj)).setStackTrace(throwable.getStackTrace());
            } else {
                obj = throwable;
                if (throwable instanceof SocketException) {
                    obj = new SocketException((new StringBuilder()).append(throwable.getMessage()).append(": ").append(socketaddress).toString());
                    ((Throwable) (obj)).setStackTrace(throwable.getStackTrace());
                }
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        public final void a(ag ag1, w w1) {
            if (ag1 == null)
                throw new NullPointerException("eventLoop");
            if (b.h())
                w1.a(new IllegalStateException("registered to an event loop already"));
            else
            if (!b.a(ag1)) {
                w1.a(new IllegalStateException((new StringBuilder()).append("incompatible event loop type: ").append(ag1.getClass().getName()).toString()));
            } else {
                io.netty.channel.a.a(b, ag1);
                if (ag1.f())
                    e(w1);
                else
                    try {
                        Runnable runnable = JVM INSTR new #11  <Class a$a$1>;
                        runnable._cls1(this, w1);
                        ag1.execute(runnable);
                    }
                    // Misplaced declaration of an exception variable
                    catch (ag ag1) {
                        io.netty.channel.a.y().d("Force-closing a channel whose registration task was not accepted by an event loop: {}", b, ag1);
                        d();
                        io.netty.channel.a.c(b).d();
                        a(w1, ((Throwable) (ag1)));
                    }
            }
        }

        public final void a(w w1) {
            l();
            if (w1.f_()) goto _L2; else goto _L1
_L1:
            return;
_L2:
            boolean flag = b.G();
            b.u();
            if (flag && !b.G())
                a(new Runnable(this) {

                    final a a;

                    public void run() {
                        io.netty.channel.a.d(a.b).j();
                    }

             {
                a = a1;
                super();
            }
                }
);
            d(w1);
            i();
            continue; /* Loop/switch isn't completed */
            Throwable throwable;
            throwable;
            a(w1, throwable);
            i();
            if (true) goto _L1; else goto _L3
_L3:
        }

        protected final void a(w w1, Throwable throwable) {
            if (!(w1 instanceof au) && !w1.b(throwable))
                io.netty.channel.a.y().d("Failed to mark a promise as failure because it's done already: {}", w1, throwable);
        }

        public final void a(Object obj, w w1) {
            q q1;
            l();
            q1 = c;
            if (q1 != null) goto _L2; else goto _L1
_L1:
            a(w1, ((Throwable) (io.netty.channel.a.A())));
            io.netty.util.h.b(obj);
_L4:
            return;
_L2:
            Object obj1 = obj;
            obj = b.c(obj);
            obj1 = obj;
            int j1 = io.netty.channel.a.d(b).e().a(obj);
            int i1 = j1;
            if (j1 < 0)
                i1 = 0;
            q1.a(obj, i1, w1);
            continue; /* Loop/switch isn't completed */
            obj;
            a(w1, ((Throwable) (obj)));
            io.netty.util.h.b(obj1);
            if (true) goto _L4; else goto _L3
_L3:
        }

        public final void a(SocketAddress socketaddress, w w1) {
            l();
            if (w1.f_() && c(w1)) goto _L2; else goto _L1
_L1:
            return;
_L2:
            boolean flag;
            if (Boolean.TRUE.equals(b.E().a(p.l)) && (socketaddress instanceof InetSocketAddress) && !((InetSocketAddress)socketaddress).getAddress().isAnyLocalAddress() && !PlatformDependent.b() && !PlatformDependent.c())
                io.netty.channel.a.y().c((new StringBuilder()).append("A non-root user can't receive a broadcast packet if the socket is not bound to a wildcard address; binding to a non-wildcard address (").append(socketaddress).append(") anyway as requested.").toString());
            flag = b.G();
            b.a(socketaddress);
            if (!flag && b.G())
                a(new Runnable(this) {

                    final a a;

                    public void run() {
                        io.netty.channel.a.d(a.b).b();
                    }

             {
                a = a1;
                super();
            }
                }
);
            d(w1);
            continue; /* Loop/switch isn't completed */
            socketaddress;
            a(w1, ((Throwable) (socketaddress)));
            i();
            if (true) goto _L1; else goto _L3
_L3:
        }

        public final SocketAddress b() {
            return b.r();
        }

        public final void b(w w1) {
            l();
            a(w1, io.netty.channel.a.z(), io.netty.channel.a.z(), false);
        }

        public final SocketAddress c() {
            return b.s();
        }

        protected final boolean c(w w1) {
            boolean flag;
            if (b.F()) {
                flag = true;
            } else {
                a(w1, io.netty.channel.a.D());
                flag = false;
            }
            return flag;
        }

        public final void d() {
            l();
            b.v();
_L1:
            return;
            Exception exception;
            exception;
            io.netty.channel.a.y().b("Failed to close a channel.", exception);
              goto _L1
        }

        protected final void d(w w1) {
            if (!(w1 instanceof au) && !w1.c())
                io.netty.channel.a.y().c("Failed to mark a promise as success because it is done already: {}", w1);
        }

        public final void e() {
            l();
            if (b.G())
                try {
                    b.x();
                }
                catch (Exception exception) {
                    a(new Runnable(this, exception) {

                        final Exception a;
                        final a b;

                        public void run() {
                            io.netty.channel.a.d(b.b).a(a);
                        }

             {
                b = a1;
                a = exception;
                super();
            }
                    }
);
                    b(h());
                }
        }

        public final void f() {
            l();
            q q1 = c;
            if (q1 != null) {
                q1.a();
                g();
            }
        }

        protected void g() {
            if (!d) goto _L2; else goto _L1
_L1:
            return;
_L2:
            q q1;
            q1 = c;
            if (q1 == null || q1.i())
                continue; /* Loop/switch isn't completed */
            d = true;
            if (b.G())
                break MISSING_BLOCK_LABEL_84;
            if (!b.F()) goto _L4; else goto _L3
_L3:
            q1.a(io.netty.channel.a.B(), true);
_L6:
            d = false;
            continue; /* Loop/switch isn't completed */
_L4:
            q1.a(io.netty.channel.a.C(), false);
            if (true) goto _L6; else goto _L5
_L5:
            Object obj;
            obj;
            d = false;
            throw obj;
            b.a(q1);
            d = false;
            continue; /* Loop/switch isn't completed */
            obj;
            if (!(obj instanceof IOException) || !b.E().g())
                break; /* Loop/switch isn't completed */
            a(h(), ((Throwable) (obj)), io.netty.channel.a.C(), false);
_L8:
            d = false;
            if (true) goto _L1; else goto _L7
_L7:
            q1.a(((Throwable) (obj)), true);
              goto _L8
            obj;
            d = false;
            throw obj;
        }

        public final w h() {
            l();
            return io.netty.channel.a.e(b);
        }

        protected final void i() {
            if (!b.F())
                b(h());
        }

        protected Executor j() {
            return null;
        }

        static  {
            boolean flag;
            if (!io/netty/channel/a.desiredAssertionStatus())
                flag = true;
            else
                flag = false;
            a = flag;
        }

        protected a() {
            b = io.netty.channel.a.this;
            super();
            c = new q(b);
            e = true;
        }
    }

    static final class b extends ac {

        public w a(Throwable throwable) {
            throw new IllegalStateException();
        }

        public w b() {
            throw new IllegalStateException();
        }

        public boolean b(Throwable throwable) {
            throw new IllegalStateException();
        }

        public y c(Throwable throwable) {
            return a(throwable);
        }

        public boolean c() {
            throw new IllegalStateException();
        }

        boolean d() {
            return super.c();
        }

        b(io.netty.channel.a a1) {
            super(a1);
        }
    }


    private static final io.netty.util.internal.logging.b a = io.netty.util.internal.logging.c.a(io/netty/channel/a);
    private static final ClosedChannelException b = (ClosedChannelException)io.netty.util.internal.o.a(new ClosedChannelException(), io/netty/channel/a$a, "flush0()");
    private static final ClosedChannelException c = (ClosedChannelException)io.netty.util.internal.o.a(new ClosedChannelException(), io/netty/channel/a$a, "ensureOpen(...)");
    private static final ClosedChannelException d = (ClosedChannelException)io.netty.util.internal.o.a(new ClosedChannelException(), io/netty/channel/a$a, "close(...)");
    private static final ClosedChannelException e = (ClosedChannelException)io.netty.util.internal.o.a(new ClosedChannelException(), io/netty/channel/a$a, "write(...)");
    private static final NotYetConnectedException f = (NotYetConnectedException)io.netty.util.internal.o.a(new NotYetConnectedException(), io/netty/channel/a$a, "flush0()");
    private final d g;
    private final long h = ThreadLocalRandom.b().nextLong();
    private final d.a i = p();
    private final ab j = a();
    private final g k = new at(this, null);
    private final au l = new au(this, true);
    private final au m = new au(this, false);
    private final b n = new b(this);
    private volatile SocketAddress o;
    private volatile SocketAddress p;
    private volatile ag q;
    private volatile boolean r;
    private boolean s;
    private String t;

    protected io.netty.channel.a(d d1) {
        g = d1;
    }

    static ClosedChannelException A() {
        return e;
    }

    static NotYetConnectedException B() {
        return f;
    }

    static ClosedChannelException C() {
        return b;
    }

    static ClosedChannelException D() {
        return c;
    }

    static ag a(io.netty.channel.a a1, ag ag) {
        a1.q = ag;
        return ag;
    }

    static boolean a(io.netty.channel.a a1) {
        return a1.r;
    }

    static boolean a(io.netty.channel.a a1, boolean flag) {
        a1.r = flag;
        return flag;
    }

    static ag b(io.netty.channel.a a1) {
        return a1.q;
    }

    static b c(io.netty.channel.a a1) {
        return a1.n;
    }

    static ab d(io.netty.channel.a a1) {
        return a1.j;
    }

    static au e(io.netty.channel.a a1) {
        return a1.m;
    }

    static io.netty.util.internal.logging.b y() {
        return a;
    }

    static ClosedChannelException z() {
        return d;
    }

    public final int a(d d1) {
        int i1;
        if (this == d1) {
            i1 = 0;
        } else {
            long l1 = h - (long)d1.hashCode();
            if (l1 > 0L)
                i1 = 1;
            else
            if (l1 < 0L) {
                i1 = -1;
            } else {
                long l2 = System.identityHashCode(this) - System.identityHashCode(d1);
                if (l2 != 0L)
                    i1 = (int)l2;
                else
                    throw new Error();
            }
        }
        return i1;
    }

    protected ab a() {
        return new ab(this);
    }

    public g a(w w1) {
        return j.a(w1);
    }

    public g a(Object obj) {
        return j.c(obj);
    }

    public g a(Throwable throwable) {
        return new ai(this, null, throwable);
    }

    public g a(SocketAddress socketaddress, w w1) {
        return j.a(socketaddress, w1);
    }

    public g a(SocketAddress socketaddress, SocketAddress socketaddress1, w w1) {
        return j.a(socketaddress, socketaddress1, w1);
    }

    protected abstract void a(q q1);

    protected abstract void a(SocketAddress socketaddress);

    protected abstract boolean a(ag ag);

    public g b(Object obj) {
        return j.d(obj);
    }

    public g b(SocketAddress socketaddress, w w1) {
        return j.b(socketaddress, w1);
    }

    public boolean b() {
        q q1 = i.a();
        boolean flag;
        if (q1 != null && q1.g())
            flag = true;
        else
            flag = false;
        return flag;
    }

    public t c() {
        return j;
    }

    protected Object c(Object obj) {
        return obj;
    }

    public int compareTo(Object obj) {
        return a((d)obj);
    }

    public i d() {
        return E().d();
    }

    public ag e() {
        ag ag = q;
        if (ag == null)
            throw new IllegalStateException("channel not registered to an event loop");
        else
            return ag;
    }

    public final boolean equals(Object obj) {
        boolean flag;
        if (this == obj)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public SocketAddress f() {
        SocketAddress socketaddress1 = o;
        SocketAddress socketaddress = socketaddress1;
        if (socketaddress1 == null)
            try {
                socketaddress = o().b();
                o = socketaddress;
            }
            catch (Throwable throwable) {
                throwable = null;
            }
        return socketaddress;
    }

    public SocketAddress g() {
        SocketAddress socketaddress1 = p;
        SocketAddress socketaddress = socketaddress1;
        if (socketaddress1 == null)
            try {
                socketaddress = o().c();
                p = socketaddress;
            }
            catch (Throwable throwable) {
                throwable = null;
            }
        return socketaddress;
    }

    public boolean h() {
        return r;
    }

    public final int hashCode() {
        return (int)h;
    }

    public g i() {
        return j.k();
    }

    public d j() {
        j.l();
        return this;
    }

    public d k() {
        j.m();
        return this;
    }

    public w l() {
        return new ac(this);
    }

    public g m() {
        return k;
    }

    public g n() {
        return n;
    }

    public d.a o() {
        return i;
    }

    protected abstract a p();

    public final w q() {
        return l;
    }

    protected abstract SocketAddress r();

    protected abstract SocketAddress s();

    protected void t() {
    }

    public String toString() {
        boolean flag = G();
        if (s != flag || t == null) goto _L2; else goto _L1
_L1:
        String s1 = t;
_L4:
        return s1;
_L2:
        SocketAddress socketaddress1;
        SocketAddress socketaddress = g();
        socketaddress1 = f();
        if (socketaddress == null)
            break; /* Loop/switch isn't completed */
        if (flag)
            s1 = "-";
        else
            s1 = "!";
        t = String.format("[id: 0x%08x, L:%s %s R:%s]", new Object[] {
            Integer.valueOf((int)h), socketaddress1, s1, socketaddress
        });
_L5:
        s = flag;
        s1 = t;
        if (true) goto _L4; else goto _L3
_L3:
        if (socketaddress1 != null)
            t = String.format("[id: 0x%08x, L:%s]", new Object[] {
                Integer.valueOf((int)h), socketaddress1
            });
        else
            t = String.format("[id: 0x%08x]", new Object[] {
                Integer.valueOf((int)h)
            });
          goto _L5
        if (true) goto _L4; else goto _L6
_L6:
    }

    protected abstract void u();

    protected abstract void v();

    protected void w() {
    }

    protected abstract void x();


    // Unreferenced inner class io/netty/channel/a$a$1

/* anonymous class */
    class a._cls1
        implements Runnable {

        final w a;
        final a b;

        public void run() {
            a.a(b, a);
        }

             {
                b = a1;
                a = w1;
                super();
            }
    }

}
