// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.channel.a;

import io.netty.buffer.ak;
import io.netty.buffer.h;
import io.netty.buffer.i;
import io.netty.buffer.m;
import io.netty.channel.ChannelException;
import io.netty.channel.ConnectTimeoutException;
import io.netty.channel.a;
import io.netty.channel.ag;
import io.netty.channel.d;
import io.netty.channel.e;
import io.netty.channel.g;
import io.netty.channel.t;
import io.netty.channel.w;
import io.netty.util.concurrent.n;
import io.netty.util.internal.logging.c;
import io.netty.util.internal.o;
import java.io.IOException;
import java.net.SocketAddress;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

// Referenced classes of package io.netty.channel.a:
//            d

public abstract class io.netty.channel.a.b extends io.netty.channel.a {
    protected abstract class a extends io.netty.channel.a.a
        implements b {

        static final boolean d;
        final io.netty.channel.a.b e;

        private void a(w w1, boolean flag) {
            if (w1 != null) goto _L2; else goto _L1
_L1:
            return;
_L2:
            boolean flag1 = w1.c();
            if (!flag && e.G())
                e.c().b();
            if (!flag1)
                b(h());
            if (true) goto _L1; else goto _L3
_L3:
        }

        private void b(w w1, Throwable throwable) {
            if (w1 != null) {
                w1.b(throwable);
                i();
            }
        }

        private boolean o() {
            SelectionKey selectionkey = e.O();
            boolean flag;
            if (selectionkey.isValid() && (selectionkey.interestOps() & 4) != 0)
                flag = true;
            else
                flag = false;
            return flag;
        }

        public final void a(SocketAddress socketaddress, SocketAddress socketaddress1, w w1) {
            if (w1.f_() && c(w1)) goto _L2; else goto _L1
_L1:
            return;
_L2:
            if (io.netty.channel.a.b.a(e) != null) {
                socketaddress1 = JVM INSTR new #94  <Class IllegalStateException>;
                socketaddress1.IllegalStateException("connection attempt already made");
                throw socketaddress1;
            }
            try {
label0:
                {
                    boolean flag = e.G();
                    if (!e.a(socketaddress, socketaddress1))
                        break label0;
                    a(w1, flag);
                }
            }
            // Misplaced declaration of an exception variable
            catch (SocketAddress socketaddress1) {
                w1.b(a(((Throwable) (socketaddress1)), socketaddress));
                i();
            }
              goto _L1
            int i1;
            io.netty.channel.a.b.a(e, w1);
            io.netty.channel.a.b.a(e, socketaddress);
            i1 = e.E().a();
            if (i1 <= 0)
                break MISSING_BLOCK_LABEL_173;
            socketaddress1 = e;
            io.netty.channel.a.d d1 = e.N();
            Runnable runnable = JVM INSTR new #11  <Class b$a$1>;
            runnable._cls1(this, socketaddress);
            io.netty.channel.a.b.a(socketaddress1, d1.a(runnable, i1, TimeUnit.MILLISECONDS));
            socketaddress1 = JVM INSTR new #13  <Class b$a$2>;
            socketaddress1._cls2(this);
            w1.c(socketaddress1);
              goto _L1
        }

        protected final void g() {
            if (!o())
                super.g();
        }

        protected final void l() {
            SelectionKey selectionkey = e.O();
            if (selectionkey.isValid()) goto _L2; else goto _L1
_L1:
            return;
_L2:
            int i1 = selectionkey.interestOps();
            if ((e.a & i1) != 0)
                selectionkey.interestOps(i1 & ~e.a);
            if (true) goto _L1; else goto _L3
_L3:
        }

        public final void m() {
            if (!d && !e.N().f())
                throw new AssertionError();
            boolean flag = e.G();
            e.R();
            a(io.netty.channel.a.b.a(e), flag);
            if (io.netty.channel.a.b.b(e) != null)
                io.netty.channel.a.b.b(e).cancel(false);
            io.netty.channel.a.b.a(e, null);
_L2:
            return;
            Object obj;
            obj;
            b(io.netty.channel.a.b.a(e), a(((Throwable) (obj)), io.netty.channel.a.b.c(e)));
            if (io.netty.channel.a.b.b(e) != null)
                io.netty.channel.a.b.b(e).cancel(false);
            io.netty.channel.a.b.a(e, null);
            if (true) goto _L2; else goto _L1
_L1:
            obj;
            if (io.netty.channel.a.b.b(e) != null)
                io.netty.channel.a.b.b(e).cancel(false);
            io.netty.channel.a.b.a(e, null);
            throw obj;
        }

        public final void n() {
            super.g();
        }

        static  {
            boolean flag;
            if (!io/netty/channel/a/b.desiredAssertionStatus())
                flag = true;
            else
                flag = false;
            d = flag;
        }

        protected a() {
            e = io.netty.channel.a.b.this;
            super(io.netty.channel.a.b.this);
        }
    }

    public static interface b
        extends io.netty.channel.d.a {

        public abstract void k();

        public abstract void m();

        public abstract void n();
    }


    static final boolean c;
    private static final io.netty.util.internal.logging.b d = io.netty.util.internal.logging.c.a(io/netty/channel/a/b);
    private static final ClosedChannelException e = (ClosedChannelException)io.netty.util.internal.o.a(new ClosedChannelException(), io/netty/channel/a/b, "doClose()");
    protected final int a;
    volatile SelectionKey b;
    private final SelectableChannel f;
    private volatile boolean g;
    private volatile boolean h;
    private w i;
    private ScheduledFuture j;
    private SocketAddress k;

    protected io.netty.channel.a.b(d d1, SelectableChannel selectablechannel, int l) {
        super(d1);
        f = selectablechannel;
        a = l;
        try {
            selectablechannel.configureBlocking(false);
            return;
        }
        // Misplaced declaration of an exception variable
        catch (d d1) { }
        selectablechannel.close();
_L2:
        throw new ChannelException("Failed to enter non-blocking mode.", d1);
        selectablechannel;
        if (d.c())
            d.b("Failed to close a partially initialized socket.", selectablechannel);
        if (true) goto _L2; else goto _L1
_L1:
    }

    static w a(io.netty.channel.a.b b1) {
        return b1.i;
    }

    static w a(io.netty.channel.a.b b1, w w1) {
        b1.i = w1;
        return w1;
    }

    static SocketAddress a(io.netty.channel.a.b b1, SocketAddress socketaddress) {
        b1.k = socketaddress;
        return socketaddress;
    }

    static ScheduledFuture a(io.netty.channel.a.b b1, ScheduledFuture scheduledfuture) {
        b1.j = scheduledfuture;
        return scheduledfuture;
    }

    static ScheduledFuture b(io.netty.channel.a.b b1) {
        return b1.j;
    }

    static SocketAddress c(io.netty.channel.a.b b1) {
        return b1.k;
    }

    public boolean F() {
        return f.isOpen();
    }

    public b L() {
        return (b)super.o();
    }

    protected SelectableChannel M() {
        return f;
    }

    public io.netty.channel.a.d N() {
        return (io.netty.channel.a.d)super.e();
    }

    protected SelectionKey O() {
        if (!c && b == null)
            throw new AssertionError();
        else
            return b;
    }

    protected boolean P() {
        return h;
    }

    void Q() {
        g = true;
    }

    protected abstract void R();

    protected boolean a(ag ag) {
        return ag instanceof io.netty.channel.a.d;
    }

    protected abstract boolean a(SocketAddress socketaddress, SocketAddress socketaddress1);

    protected void b(boolean flag) {
        h = flag;
    }

    protected final h c(h h1) {
        int l = h1.f();
        if (l != 0) goto _L2; else goto _L1
_L1:
        Object obj;
        io.netty.util.h.c(h1);
        obj = ak.c;
_L4:
        return ((h) (obj));
_L2:
        obj = d();
        if (((i) (obj)).d()) {
            obj = ((i) (obj)).d(l);
            ((h) (obj)).a(h1, h1.b(), l);
            io.netty.util.h.c(h1);
        } else {
            h h2 = m.a();
            obj = h1;
            if (h2 != null) {
                h2.a(h1, h1.b(), l);
                io.netty.util.h.c(h1);
                obj = h2;
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public ag e() {
        return N();
    }

    public io.netty.channel.d.a o() {
        return L();
    }

    protected void t() {
        boolean flag = false;
        do
            try {
                b = M().register(N().b, 0, this);
                return;
            }
            catch (CancelledKeyException cancelledkeyexception) {
                if (!flag) {
                    N().k();
                    flag = true;
                } else {
                    throw cancelledkeyexception;
                }
            }
        while (true);
    }

    protected void v() {
        Object obj = i;
        if (obj != null) {
            ((w) (obj)).b(e);
            i = null;
        }
        obj = j;
        if (obj != null) {
            ((ScheduledFuture) (obj)).cancel(false);
            j = null;
        }
    }

    protected void w() {
        N().a(O());
    }

    protected void x() {
        if (!g) goto _L2; else goto _L1
_L1:
        return;
_L2:
        SelectionKey selectionkey = b;
        if (selectionkey.isValid()) {
            h = true;
            int l = selectionkey.interestOps();
            if ((a & l) == 0)
                selectionkey.interestOps(l | a);
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    static  {
        boolean flag;
        if (!io/netty/channel/a/b.desiredAssertionStatus())
            flag = true;
        else
            flag = false;
        c = flag;
    }

    // Unreferenced inner class io/netty/channel/a/b$a$1

/* anonymous class */
    class a._cls1
        implements Runnable {

        final SocketAddress a;
        final a b;

        public void run() {
            w w1 = io.netty.channel.a.b.a(b.e);
            ConnectTimeoutException connecttimeoutexception = new ConnectTimeoutException((new StringBuilder()).append("connection timed out: ").append(a).toString());
            if (w1 != null && w1.b(connecttimeoutexception))
                b.b(b.h());
        }

             {
                b = a1;
                a = socketaddress;
                super();
            }
    }


    // Unreferenced inner class io/netty/channel/a/b$a$2

/* anonymous class */
    class a._cls2
        implements io.netty.channel.h {

        final a a;

        public void a(g g1) {
            if (g1.isCancelled()) {
                if (io.netty.channel.a.b.b(a.e) != null)
                    io.netty.channel.a.b.b(a.e).cancel(false);
                io.netty.channel.a.b.a(a.e, null);
                a.b(a.h());
            }
        }

        public volatile void a(n n) {
            a((g)n);
        }

             {
                a = a1;
                super();
            }
    }

}
