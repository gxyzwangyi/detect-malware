// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.channel.c.a;

import com.barchart.udt.SocketUDT;
import com.barchart.udt.StatusUDT;
import com.barchart.udt.TypeUDT;
import com.barchart.udt.nio.e;
import com.barchart.udt.nio.k;
import io.netty.buffer.h;
import io.netty.channel.ChannelException;
import io.netty.channel.a.a;
import io.netty.channel.aj;
import io.netty.channel.c.d;
import io.netty.channel.o;
import io.netty.util.internal.logging.b;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;

// Referenced classes of package io.netty.channel.c.a:
//            h

public class c extends a
    implements io.netty.channel.c.c {

    private static final b d = io.netty.util.internal.logging.c.a(io/netty/channel/c/a/c);
    private static final o e = new o(false);
    private final d f;

    public c() {
        this(TypeUDT.a);
    }

    public c(TypeUDT typeudt) {
        this(io.netty.channel.c.a.h.b(typeudt));
    }

    public c(k k1) {
        this(null, k1);
    }

    public c(io.netty.channel.d d1, k k1) {
        super(d1, k1);
        k1.configureBlocking(false);
        static class _cls1 {

            static final int a[];

            static  {
                a = new int[StatusUDT.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    a[StatusUDT.a.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                a[StatusUDT.b.ordinal()] = 2;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        switch (io.netty.channel.c.a._cls1.a[k1.c().u().ordinal()]) {
        default:
            d1 = JVM INSTR new #85  <Class io.netty.channel.c.a>;
            d1.io.netty.channel.c.a(this, k1, false);
            f = d1;
            break;

        case 1: // '\001'
        case 2: // '\002'
            break MISSING_BLOCK_LABEL_65;
        }
_L2:
        return;
        d1 = JVM INSTR new #85  <Class io.netty.channel.c.a>;
        d1.io.netty.channel.c.a(this, k1, true);
        f = d1;
        if (true) goto _L2; else goto _L1
_L1:
        d1;
        k1.close();
_L4:
        throw new ChannelException("Failed to configure channel.", d1);
        k1;
        if (d.c())
            d.b("Failed to close channel.", k1);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public io.netty.channel.e E() {
        return S();
    }

    public boolean G() {
        k k1 = T();
        boolean flag;
        if (k1.isOpen() && k1.a())
            flag = true;
        else
            flag = false;
        return flag;
    }

    public o H() {
        return e;
    }

    protected SelectableChannel M() {
        return T();
    }

    protected void R() {
        if (T().finishConnect()) {
            O().interestOps(O().interestOps() & -9);
            return;
        } else {
            throw new Error("Provider error: failed to finish connect. Provider library should be upgraded.");
        }
    }

    public d S() {
        return f;
    }

    protected k T() {
        return (k)super.M();
    }

    public InetSocketAddress U() {
        return (InetSocketAddress)super.f();
    }

    public InetSocketAddress V() {
        return (InetSocketAddress)super.g();
    }

    protected int a(h h1) {
        return h1.a(T(), h1.g());
    }

    protected long a(aj aj) {
        throw new UnsupportedOperationException();
    }

    protected void a(SocketAddress socketaddress) {
        T().a(socketaddress);
    }

    protected boolean a(SocketAddress socketaddress, SocketAddress socketaddress1) {
        boolean flag;
        if (socketaddress1 == null)
            socketaddress1 = new InetSocketAddress(0);
        a(socketaddress1);
        flag = T().connect(socketaddress);
        if (flag)
            break MISSING_BLOCK_LABEL_40;
        O().interestOps(O().interestOps() | 8);
        return flag;
        socketaddress;
        v();
        throw socketaddress;
    }

    protected int b(h h1) {
        int i = h1.f();
        return h1.a(T(), i);
    }

    public SocketAddress f() {
        return U();
    }

    public SocketAddress g() {
        return V();
    }

    protected SocketAddress r() {
        return T().f().getLocalSocketAddress();
    }

    protected SocketAddress s() {
        return T().f().getRemoteSocketAddress();
    }

    protected void u() {
        v();
    }

    protected void v() {
        T().close();
    }

}
