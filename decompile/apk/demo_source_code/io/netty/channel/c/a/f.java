// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.channel.c.a;

import com.barchart.udt.SocketUDT;
import com.barchart.udt.StatusUDT;
import com.barchart.udt.TypeUDT;
import com.barchart.udt.nio.e;
import com.barchart.udt.nio.k;
import io.netty.buffer.h;
import io.netty.buffer.i;
import io.netty.channel.ChannelException;
import io.netty.channel.a.c;
import io.netty.channel.c.a;
import io.netty.channel.c.d;
import io.netty.channel.o;
import io.netty.channel.q;
import io.netty.util.internal.logging.b;
import io.netty.util.internal.m;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.util.List;

// Referenced classes of package io.netty.channel.c.a:
//            h

public class f extends c
    implements io.netty.channel.c.c {

    private static final b d = io.netty.util.internal.logging.c.a(io/netty/channel/c/a/f);
    private static final o e = new o(false);
    private static final String f = (new StringBuilder()).append(" (expected: ").append(m.a(io/netty/channel/c/f)).append(')').toString();
    private final d g;

    public f() {
        this(TypeUDT.b);
    }

    public f(TypeUDT typeudt) {
        this(io.netty.channel.c.a.h.b(typeudt));
    }

    public f(k k1) {
        this(null, k1);
    }

    public f(io.netty.channel.d d1, k k1) {
        super(d1, k1, 1);
        k1.configureBlocking(false);
        static class _cls1 {

            static final int a[];

            static  {
                a = new int[StatusUDT.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    a[StatusUDT.a.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                a[StatusUDT.b.ordinal()] = 2;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        switch (io.netty.channel.c.a._cls1.a[k1.c().u().ordinal()]) {
        default:
            d1 = JVM INSTR new #113 <Class a>;
            d1.a(this, k1, false);
            g = d1;
            break;

        case 1: // '\001'
        case 2: // '\002'
            break MISSING_BLOCK_LABEL_65;
        }
_L2:
        return;
        d1 = JVM INSTR new #113 <Class a>;
        d1.a(this, k1, true);
        g = d1;
        if (true) goto _L2; else goto _L1
_L1:
        d1;
        k1.close();
_L4:
        throw new ChannelException("Failed to configure channel.", d1);
        k1;
        if (d.c())
            d.b("Failed to close channel.", k1);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public io.netty.channel.e E() {
        return K();
    }

    public boolean G() {
        k k1 = S();
        boolean flag;
        if (k1.isOpen() && k1.a())
            flag = true;
        else
            flag = false;
        return flag;
    }

    public o H() {
        return e;
    }

    public d K() {
        return g;
    }

    protected SelectableChannel M() {
        return S();
    }

    protected void R() {
        if (S().finishConnect()) {
            O().interestOps(O().interestOps() & -9);
            return;
        } else {
            throw new Error("Provider error: failed to finish connect. Provider library should be upgraded.");
        }
    }

    protected k S() {
        return (k)super.M();
    }

    public InetSocketAddress T() {
        return (InetSocketAddress)super.f();
    }

    public InetSocketAddress U() {
        return (InetSocketAddress)super.g();
    }

    protected int a(List list) {
        int j = g.m();
        h h1 = g.d().d(j);
        int l = h1.a(S(), j);
        if (l <= 0) {
            h1.B();
            j = 0;
        } else {
            if (l >= j) {
                S().close();
                throw new ChannelException("Invalid config : increase receive buffer size to avoid message truncation");
            }
            list.add(new io.netty.channel.c.f(h1));
            j = 1;
        }
        return j;
    }

    protected void a(SocketAddress socketaddress) {
        S().a(socketaddress);
    }

    protected boolean a(Object obj, q q) {
        int j;
        boolean flag;
        flag = true;
        obj = ((io.netty.channel.c.f)obj).a();
        j = ((h) (obj)).f();
        if (j != 0) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        long l;
        if (((h) (obj)).h_() == 1)
            l = S().write(((h) (obj)).v());
        else
            l = S().write(((h) (obj)).w());
        if (l > 0L && l != (long)j)
            throw new Error("Provider error: failed to write message. Provider library should be upgraded.");
        if (l <= 0L)
            flag = false;
        if (true) goto _L1; else goto _L3
_L3:
    }

    protected boolean a(SocketAddress socketaddress, SocketAddress socketaddress1) {
        boolean flag;
        if (socketaddress1 == null)
            socketaddress1 = new InetSocketAddress(0);
        a(socketaddress1);
        flag = S().connect(socketaddress);
        if (flag)
            break MISSING_BLOCK_LABEL_40;
        O().interestOps(O().interestOps() | 8);
        return flag;
        socketaddress;
        v();
        throw socketaddress;
    }

    protected final Object c(Object obj) {
        if (obj instanceof io.netty.channel.c.f)
            return obj;
        else
            throw new UnsupportedOperationException((new StringBuilder()).append("unsupported message type: ").append(m.a(obj)).append(f).toString());
    }

    public SocketAddress f() {
        return T();
    }

    public SocketAddress g() {
        return U();
    }

    protected SocketAddress r() {
        return S().f().getLocalSocketAddress();
    }

    protected SocketAddress s() {
        return S().f().getRemoteSocketAddress();
    }

    protected void u() {
        v();
    }

    protected void v() {
        S().close();
    }

}
