// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.util.internal;

import io.netty.util.internal.logging.c;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;

// Referenced classes of package io.netty.util.internal:
//            l

final class b {

    static final boolean a;
    private static final long b;
    private static final Method c;
    private static final io.netty.util.internal.logging.b d;

    private b() {
    }

    static void a(ByteBuffer bytebuffer) {
        if (b != -1L && bytebuffer.isDirect()) goto _L2; else goto _L1
_L1:
        return;
_L2:
        if (!a && c == null)
            throw new AssertionError("CLEANER_FIELD_OFFSET != -1 implies CLEAN_METHOD != null");
        bytebuffer = ((ByteBuffer) (l.a(bytebuffer, b)));
        if (bytebuffer != null)
            try {
                c.invoke(bytebuffer, new Object[0]);
            }
            // Misplaced declaration of an exception variable
            catch (ByteBuffer bytebuffer) { }
        if (true) goto _L1; else goto _L3
_L3:
    }

    static  {
        ByteBuffer bytebuffer;
        boolean flag = false;
        if (!io/netty/util/internal/b.desiredAssertionStatus())
            flag = true;
        a = flag;
        d = io.netty.util.internal.logging.c.a(io/netty/util/internal/b);
        bytebuffer = ByteBuffer.allocateDirect(1);
        if (!l.b())
            break MISSING_BLOCK_LABEL_172;
        long l1;
        Object obj1;
        Field field = bytebuffer.getClass().getDeclaredField("cleaner");
        field.setAccessible(true);
        l1 = l.a(field);
        obj1 = field.get(bytebuffer);
        Object obj;
        obj = (Runnable)obj1;
        obj = java/lang/Runnable.getDeclaredMethod("run", new Class[0]);
_L1:
        ((Method) (obj)).invoke(obj1, new Object[0]);
_L2:
        io.netty.util.internal.logging.b b1 = d;
        if (l1 != -1L)
            obj1 = "available";
        else
            obj1 = "unavailable";
        b1.b("java.nio.ByteBuffer.cleaner(): {}", obj1);
        b = l1;
        c = ((Method) (obj));
        a(bytebuffer);
        return;
        obj;
        obj = obj1.getClass().getDeclaredMethod("clean", new Class[0]);
          goto _L1
        obj;
        obj = null;
        l1 = -1L;
          goto _L2
        obj = null;
        l1 = -1L;
          goto _L2
    }
}
