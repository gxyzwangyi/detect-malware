// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.util.internal;

import io.netty.util.internal.logging.b;
import io.netty.util.internal.logging.c;
import java.lang.reflect.*;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.concurrent.atomic.*;
import sun.misc.Unsafe;

// Referenced classes of package io.netty.util.internal:
//            n, t, k, b, 
//            r, s

final class l {

    static final Unsafe a;
    private static final b b;
    private static final long c;
    private static final long d;
    private static final Constructor e;
    private static final boolean f;

    private l() {
    }

    static byte a(long l1) {
        return a.getByte(l1);
    }

    static byte a(byte abyte0[], int i) {
        return a.getByte(abyte0, d + (long)i);
    }

    static long a(Field field) {
        return a.objectFieldOffset(field);
    }

    static ClassLoader a(Class class1) {
        if (System.getSecurityManager() == null)
            class1 = class1.getClassLoader();
        else
            class1 = (ClassLoader)AccessController.doPrivileged(new PrivilegedAction(class1) {

                final Class a;

                public ClassLoader a() {
                    return a.getClassLoader();
                }

                public Object run() {
                    return a();
                }

             {
                a = class1;
                super();
            }
            }
);
        return class1;
    }

    static Object a(Object obj, long l1) {
        return a.getObject(obj, l1);
    }

    static ByteBuffer a(int i) {
        return b(a.allocateMemory(i), i);
    }

    static ByteBuffer a(ByteBuffer bytebuffer, int i) {
        return b(a.reallocateMemory(b(bytebuffer), i), i);
    }

    static AtomicReferenceFieldUpdater a(Class class1, String s1) {
        return new t(a, class1, s1);
    }

    static void a(long l1, byte byte0) {
        a.putByte(l1, byte0);
    }

    static void a(long l1, int i) {
        a.putInt(l1, i);
    }

    static void a(long l1, long l2) {
        a.putLong(l1, l2);
    }

    static void a(long l1, long l2, byte byte0) {
        a.setMemory(l1, l2, byte0);
    }

    static void a(long l1, long l2, long l3) {
        long l4 = l2;
        l2 = l1;
        for (l1 = l4; l3 > 0L; l1 += l4) {
            l4 = Math.min(l3, 0x100000L);
            a.copyMemory(l2, l1, l4);
            l3 -= l4;
            l2 += l4;
        }

    }

    static void a(long l1, short word0) {
        a.putShort(l1, word0);
    }

    static void a(Object obj, long l1, long l2, byte byte0) {
        a.setMemory(obj, l1, l2, byte0);
    }

    static void a(Object obj, long l1, Object obj1, long l2, long l3) {
        long l4 = l2;
        l2 = l1;
        for (l1 = l4; l3 > 0L; l1 += l4) {
            l4 = Math.min(l3, 0x100000L);
            a.copyMemory(obj, l2, obj1, l1, l4);
            l3 -= l4;
            l2 += l4;
        }

    }

    static void a(Throwable throwable) {
        a.throwException((Throwable)k.a(throwable, "cause"));
    }

    static void a(ByteBuffer bytebuffer) {
        io.netty.util.internal.b.a(bytebuffer);
    }

    static void a(byte abyte0[], int i, byte byte0) {
        a.putByte(abyte0, d + (long)i, byte0);
    }

    static void a(byte abyte0[], int i, int j) {
        a.putInt(abyte0, d + (long)i, j);
    }

    static void a(byte abyte0[], int i, long l1) {
        a.putLong(abyte0, d + (long)i, l1);
    }

    static void a(byte abyte0[], int i, short word0) {
        a.putShort(abyte0, d + (long)i, word0);
    }

    static boolean a() {
        return f;
    }

    private static long b(Object obj, long l1) {
        return a.getLong(obj, l1);
    }

    static long b(ByteBuffer bytebuffer) {
        return b(bytebuffer, c);
    }

    private static ByteBuffer b(long l1, int i) {
        ByteBuffer bytebuffer;
        try {
            bytebuffer = (ByteBuffer)e.newInstance(new Object[] {
                Long.valueOf(l1), Integer.valueOf(i)
            });
        }
        catch (Throwable throwable) {
            if (throwable instanceof Error)
                throw (Error)throwable;
            else
                throw new Error(throwable);
        }
        return bytebuffer;
    }

    static AtomicIntegerFieldUpdater b(Class class1, String s1) {
        return new r(a, class1, s1);
    }

    static short b(long l1) {
        return a.getShort(l1);
    }

    static short b(byte abyte0[], int i) {
        return a.getShort(abyte0, d + (long)i);
    }

    static boolean b() {
        boolean flag;
        if (a != null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    static int c(long l1) {
        return a.getInt(l1);
    }

    static int c(byte abyte0[], int i) {
        return a.getInt(abyte0, d + (long)i);
    }

    static AtomicLongFieldUpdater c(Class class1, String s1) {
        return new s(a, class1, s1);
    }

    static boolean c() {
        boolean flag;
        if (e != null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    static long d() {
        return (long)a.arrayBaseOffset([B);
    }

    static long d(long l1) {
        return a.getLong(l1);
    }

    static long d(byte abyte0[], int i) {
        return a.getLong(abyte0, d + (long)i);
    }

    static ClassLoader e() {
        ClassLoader classloader;
        if (System.getSecurityManager() == null)
            classloader = Thread.currentThread().getContextClassLoader();
        else
            classloader = (ClassLoader)AccessController.doPrivileged(new PrivilegedAction() {

                public ClassLoader a() {
                    return Thread.currentThread().getContextClassLoader();
                }

                public Object run() {
                    return a();
                }

            }
);
        return classloader;
    }

    static void e(long l1) {
        a.freeMemory(l1);
    }

    static ClassLoader f() {
        ClassLoader classloader;
        if (System.getSecurityManager() == null)
            classloader = ClassLoader.getSystemClassLoader();
        else
            classloader = (ClassLoader)AccessController.doPrivileged(new PrivilegedAction() {

                public ClassLoader a() {
                    return ClassLoader.getSystemClassLoader();
                }

                public Object run() {
                    return a();
                }

            }
);
        return classloader;
    }

    static int g() {
        return a.addressSize();
    }

    static  {
        Object obj2;
        ByteBuffer bytebuffer;
        obj2 = null;
        b = io.netty.util.internal.logging.c.a(io/netty/util/internal/l);
        bytebuffer = ByteBuffer.allocateDirect(1);
        long l1;
        Object obj;
        obj = java/nio/Buffer.getDeclaredField("address");
        ((Field) (obj)).setAccessible(true);
        l1 = ((Field) (obj)).getLong(bytebuffer);
        Object obj1;
        if (l1 == 0L)
            obj = null;
        obj1 = obj;
_L5:
        Object obj3 = b;
        b b1;
        if (obj1 != null)
            obj = "available";
        else
            obj = "unavailable";
        ((b) (obj3)).b("java.nio.Buffer.address: {}", obj);
        if (obj1 == null) goto _L2; else goto _L1
_L1:
        obj = sun/misc/Unsafe.getDeclaredField("theUnsafe");
        ((Field) (obj)).setAccessible(true);
        obj3 = (Unsafe)((Field) (obj)).get(null);
        b1 = b;
        if (obj3 != null)
            obj = "available";
        else
            obj = "unavailable";
        b1.b("sun.misc.Unsafe.theUnsafe: {}", obj);
        obj = obj3;
        if (obj3 == null)
            break MISSING_BLOCK_LABEL_186;
        obj3.getClass().getDeclaredMethod("copyMemory", new Class[] {
            java/lang/Object, Long.TYPE, java/lang/Object, Long.TYPE, Long.TYPE
        });
        b.a("sun.misc.Unsafe.copyMemory: available");
        obj = obj3;
_L6:
        a = ((Unsafe) (obj));
        if (obj != null) goto _L4; else goto _L3
_L3:
        d = -1L;
        c = -1L;
        f = false;
        e = null;
_L7:
        obj1 = b;
        boolean flag;
        long l2;
        if (e != null)
            obj = "available";
        else
            obj = "unavailable";
        ((b) (obj1)).b("java.nio.DirectByteBuffer.<init>(long, int): {}", obj);
        a(bytebuffer);
        return;
        obj;
        obj1 = null;
          goto _L5
        obj;
        try {
            b.a("sun.misc.Unsafe.copyMemory: unavailable");
            throw obj;
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            obj = null;
        }
          goto _L6
        obj;
        b.a("sun.misc.Unsafe.copyMemory: unavailable");
        throw obj;
_L2:
        obj = null;
          goto _L6
_L4:
        obj = bytebuffer.getClass().getDeclaredConstructor(new Class[] {
            Long.TYPE, Integer.TYPE
        });
        ((Constructor) (obj)).setAccessible(true);
        l2 = a.allocateMemory(1L);
        ((Constructor) (obj)).newInstance(new Object[] {
            Long.valueOf(l2), Integer.valueOf(1)
        });
        if (l2 != -1L)
            a.freeMemory(l2);
_L8:
        e = ((Constructor) (obj));
        c = a(((Field) (obj1)));
        try {
            obj = Class.forName("java.nio.Bits", false, ClassLoader.getSystemClassLoader()).getDeclaredMethod("unaligned", new Class[0]);
            ((Method) (obj)).setAccessible(true);
            flag = Boolean.TRUE.equals(((Method) (obj)).invoke(null, new Object[0]));
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            flag = n.a("os.arch", "").matches("^(i[3-6]86|x86(_64)?|x64|amd64)$");
        }
        f = flag;
        b.b("java.nio.Bits.unaligned: {}", Boolean.valueOf(f));
        d = d();
          goto _L7
        obj;
        l2 = -1L;
_L11:
        obj = obj2;
        if (l2 != -1L) {
            a.freeMemory(l2);
            obj = obj2;
        }
          goto _L8
        obj;
        l2 = -1L;
_L10:
        if (l2 != -1L)
            a.freeMemory(l2);
        throw obj;
        obj;
        if (true) goto _L10; else goto _L9
_L9:
        Throwable throwable;
        throwable;
          goto _L11
    }
}
