// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.util.internal.chmv8;

import java.lang.reflect.Field;
import java.security.*;
import java.util.Random;
import sun.misc.Unsafe;

abstract class Striped64 extends Number {
    static final class a {

        private static final Unsafe b;
        private static final long c;
        volatile long a;

        final boolean a(long l, long l1) {
            return b.compareAndSwapLong(this, c, l, l1);
        }

        static  {
            try {
                b = Striped64.d();
                c = b.objectFieldOffset(io/netty/util/internal/chmv8/Striped64$a.getDeclaredField("value"));
            }
            catch (Exception exception) {
                throw new Error(exception);
            }
        }

        a(long l) {
            a = l;
        }
    }


    static final ThreadLocal a = new ThreadLocal();
    static final Random b = new Random();
    static final int c = Runtime.getRuntime().availableProcessors();
    private static final Unsafe g;
    private static final long h;
    private static final long i;
    volatile transient a d[];
    volatile transient long e;
    volatile transient int f;

    Striped64() {
    }

    private static Unsafe a() {
        Object obj;
        try {
            obj = Unsafe.getUnsafe();
        }
        catch (SecurityException securityexception) {
            try {
                securityexception = JVM INSTR new #6   <Class Striped64$1>;
                securityexception._cls1();
                securityexception = (Unsafe)AccessController.doPrivileged(securityexception);
            }
            catch (PrivilegedActionException privilegedactionexception) {
                throw new RuntimeException("Could not initialize intrinsics", privilegedactionexception.getCause());
            }
        }
        return ((Unsafe) (obj));
    }

    static Unsafe d() {
        return a();
    }

    abstract long a(long l, long l1);

    final void a(long l, int ai[], boolean flag) {
        int j1;
        int k1;
        int l1;
        boolean flag1;
        Object obj;
        Object obj1;
        int j;
        int i2;
        if (ai == null) {
            ThreadLocal threadlocal = a;
            ai = new int[1];
            threadlocal.set(ai);
            int i1 = b.nextInt();
            j = i1;
            if (i1 == 0)
                j = 1;
            ai[0] = j;
        } else {
            j = ai[0];
        }
        j1 = 0;
        flag1 = flag;
        k1 = j;
_L10:
        obj = d;
        if (obj == null) goto _L2; else goto _L1
_L1:
        l1 = obj.length;
        if (l1 <= 0) goto _L2; else goto _L3
_L3:
        obj1 = obj[l1 - 1 & k1];
        if (obj1 != null) goto _L5; else goto _L4
_L4:
        if (f != 0) goto _L7; else goto _L6
_L6:
        obj = new a(l);
        if (f != 0 || !c()) goto _L7; else goto _L8
_L8:
        l1 = 0;
        obj1 = d;
        j = l1;
        if (obj1 == null)
            break MISSING_BLOCK_LABEL_187;
        i2 = obj1.length;
        j = l1;
        if (i2 > 0) {
            i2 = i2 - 1 & k1;
            j = l1;
            if (obj1[i2] == null) {
                obj1[i2] = obj;
                j = 1;
            }
        }
        f = 0;
        if (j == 0) goto _L10; else goto _L9
_L9:
        return;
        ai;
        f = 0;
        throw ai;
_L7:
        int k;
        k = 0;
        flag = flag1;
_L11:
        j1 = k1 ^ k1 << 13;
        j1 ^= j1 >>> 17;
        k1 = j1 ^ j1 << 5;
        ai[0] = k1;
        j1 = k;
        flag1 = flag;
        break; /* Loop/switch isn't completed */
_L5:
label0:
        {
            if (flag1)
                break label0;
            flag = true;
            k = j1;
        }
          goto _L11
        long l2 = ((a) (obj1)).a;
        if (((a) (obj1)).a(l2, a(l2, l))) goto _L9; else goto _L12
_L12:
        if (l1 >= c || d != obj) {
            k = 0;
            flag = flag1;
        } else {
label1:
            {
                if (j1 != 0)
                    break label1;
                k = 1;
                flag = flag1;
            }
        }
          goto _L11
        k = j1;
        flag = flag1;
        if (f != 0) goto _L11; else goto _L13
_L13:
        k = j1;
        flag = flag1;
        if (!c()) goto _L11; else goto _L14
_L14:
        a aa[];
        if (d != obj)
            break MISSING_BLOCK_LABEL_427;
        aa = new a[l1 << 1];
        for (k = 0; k < l1; k++)
            aa[k] = obj[k];

        d = aa;
        f = 0;
        j1 = 0;
        break; /* Loop/switch isn't completed */
        ai;
        f = 0;
        throw ai;
_L2:
        if (f != 0 || d != obj || !c())
            break MISSING_BLOCK_LABEL_537;
        k = 0;
        if (d != obj)
            break MISSING_BLOCK_LABEL_516;
        aa = new a[2];
        obj = JVM INSTR new #8   <Class Striped64$a>;
        ((a) (obj)).a(l);
        aa[k1 & 1] = ((a) (obj));
        d = aa;
        k = 1;
        f = 0;
        if (!k) goto _L15; else goto _L9
_L15:
        break; /* Loop/switch isn't completed */
        ai;
        f = 0;
        throw ai;
        l2 = e;
        if (!b(l2, a(l2, l))) goto _L10; else goto _L9
    }

    final boolean b(long l, long l1) {
        return g.compareAndSwapLong(this, h, l, l1);
    }

    final boolean c() {
        return g.compareAndSwapInt(this, i, 0, 1);
    }

    static  {
        try {
            g = a();
            h = g.objectFieldOffset(io/netty/util/internal/chmv8/Striped64.getDeclaredField("base"));
            i = g.objectFieldOffset(io/netty/util/internal/chmv8/Striped64.getDeclaredField("busy"));
        }
        catch (Exception exception) {
            throw new Error(exception);
        }
    }

    // Unreferenced inner class io/netty/util/internal/chmv8/Striped64$1

/* anonymous class */
    static final class _cls1
        implements PrivilegedExceptionAction {

        public Unsafe a() {
            Field afield[] = sun/misc/Unsafe.getDeclaredFields();
            int k = afield.length;
            for (int j = 0; j < k; j++) {
                Object obj = afield[j];
                ((Field) (obj)).setAccessible(true);
                obj = ((Field) (obj)).get(null);
                if (sun/misc/Unsafe.isInstance(obj))
                    return (Unsafe)sun/misc/Unsafe.cast(obj);
            }

            throw new NoSuchFieldError("the Unsafe");
        }

        public Object run() {
            return a();
        }

    }

}
