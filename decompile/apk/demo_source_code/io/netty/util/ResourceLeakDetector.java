// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.util;

import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.h;
import io.netty.util.internal.logging.b;
import io.netty.util.internal.logging.c;
import io.netty.util.internal.m;
import io.netty.util.internal.n;
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicBoolean;

// Referenced classes of package io.netty.util:
//            j

public class ResourceLeakDetector {
    public static final class Level extends Enum {

        public static final Level a;
        public static final Level b;
        public static final Level c;
        public static final Level d;
        private static final Level e[];

        public static Level valueOf(String s) {
            return (Level)Enum.valueOf(io/netty/util/ResourceLeakDetector$Level, s);
        }

        public static Level[] values() {
            return (Level[])e.clone();
        }

        static  {
            a = new Level("DISABLED", 0);
            b = new Level("SIMPLE", 1);
            c = new Level("ADVANCED", 2);
            d = new Level("PARANOID", 3);
            e = (new Level[] {
                a, b, c, d
            });
        }

        private Level(String s, int i1) {
            super(s, i1);
        }
    }

    private final class a extends PhantomReference
        implements j {

        final ResourceLeakDetector a;
        private final String b;
        private final Deque c;
        private final AtomicBoolean d;
        private a e;
        private a f;
        private int g;

        static a a(a a1, a a2) {
            a1.f = a2;
            return a2;
        }

        static a b(a a1, a a2) {
            a1.e = a2;
            return a2;
        }

        public void a() {
            if (b == null) goto _L2; else goto _L1
_L1:
            String s = ResourceLeakDetector.a(2);
            Deque deque = c;
            deque;
            JVM INSTR monitorenter ;
            int i1 = c.size();
            if (i1 == 0)
                break MISSING_BLOCK_LABEL_52;
            if (((String)c.getLast()).equals(s))
                break MISSING_BLOCK_LABEL_63;
            c.add(s);
            if (i1 > io.netty.util.ResourceLeakDetector.b()) {
                c.removeFirst();
                g = g + 1;
            }
            deque;
            JVM INSTR monitorexit ;
_L2:
            return;
            Exception exception;
            exception;
            deque;
            JVM INSTR monitorexit ;
            throw exception;
        }

        public boolean b() {
            boolean flag = true;
            if (d.compareAndSet(false, true))
                synchronized (io.netty.util.ResourceLeakDetector.b(a)) {
                    ResourceLeakDetector.d(a);
                    e.f = f;
                    f.e = e;
                    e = null;
                    f = null;
                }
            else
                flag = false;
            return flag;
            exception;
            a1;
            JVM INSTR monitorexit ;
            throw exception;
        }

        public String toString() {
            if (b != null) goto _L2; else goto _L1
_L1:
            obj = "";
_L4:
            return ((String) (obj));
_L2:
            int i1;
            synchronized (c) {
                obj = ((Object) (c.toArray()));
                i1 = g;
            }
            obj1 = (new StringBuilder(16384)).append(m.a);
            if (i1 > 0)
                ((StringBuilder) (obj1)).append("WARNING: ").append(i1).append(" leak records were discarded because the leak record count is limited to ").append(io.netty.util.ResourceLeakDetector.b()).append(". Use system property ").append("io.netty.leakDetection.maxRecords").append(" to increase the limit.").append(m.a);
            ((StringBuilder) (obj1)).append("Recent access records: ").append(obj.length).append(m.a);
            if (obj.length > 0) {
                for (int j1 = obj.length - 1; j1 >= 0; j1--)
                    ((StringBuilder) (obj1)).append('#').append(j1 + 1).append(':').append(m.a).append(obj[j1]);

            }
            break MISSING_BLOCK_LABEL_173;
            obj;
            obj1;
            JVM INSTR monitorexit ;
            throw obj;
            ((StringBuilder) (obj1)).append("Created at:").append(m.a).append(b);
            ((StringBuilder) (obj1)).setLength(((StringBuilder) (obj1)).length() - m.a.length());
            obj = ((StringBuilder) (obj1)).toString();
            if (true) goto _L4; else goto _L3
_L3:
        }

        a(Object obj) {
            a = ResourceLeakDetector.this;
            ReferenceQueue referencequeue;
            if (Object.this != null)
                referencequeue = ResourceLeakDetector.a(ResourceLeakDetector.this);
            else
                referencequeue = null;
            super(Object.this, referencequeue);
            c = new ArrayDeque();
            if (Object.this != null) {
                if (ResourceLeakDetector.a().ordinal() >= io.netty.util.Level.c.ordinal())
                    b = ResourceLeakDetector.a(3);
                else
                    b = null;
                synchronized (io.netty.util.ResourceLeakDetector.b(ResourceLeakDetector.this)) {
                    e = io.netty.util.ResourceLeakDetector.b(ResourceLeakDetector.this);
                    f = io.netty.util.ResourceLeakDetector.b(ResourceLeakDetector.this).f;
                    io.netty.util.ResourceLeakDetector.b(ResourceLeakDetector.this).f.e = this;
                    io.netty.util.ResourceLeakDetector.b(ResourceLeakDetector.this).f = this;
                    io.netty.util.ResourceLeakDetector.c(ResourceLeakDetector.this);
                }
                d = new AtomicBoolean();
            } else {
                b = null;
                d = new AtomicBoolean(true);
            }
            return;
            resourceleakdetector;
            Object.this;
            JVM INSTR monitorexit ;
            throw ResourceLeakDetector.this;
        }
    }


    private static final Level a;
    private static final int b;
    private static Level c;
    private static final b d;
    private static final String p[] = {
        "io.netty.buffer.AbstractByteBufAllocator.toLeakAwareBuffer(", "io.netty.buffer.AdvancedLeakAwareByteBuf.recordLeakNonRefCountingOperation("
    };
    private final a e;
    private final a f;
    private final ReferenceQueue g;
    private final ConcurrentMap h;
    private final String i;
    private final int j;
    private final int k;
    private final long l;
    private long m;
    private final AtomicBoolean n;
    private long o;

    public ResourceLeakDetector(Class class1, int i1, long l1) {
        this(io.netty.util.internal.m.a(class1), i1, l1);
    }

    public ResourceLeakDetector(String s, int i1, long l1) {
        e = new a(null);
        f = new a(null);
        g = new ReferenceQueue();
        h = PlatformDependent.k();
        n = new AtomicBoolean();
        if (s == null)
            throw new NullPointerException("resourceType");
        if (i1 <= 0)
            throw new IllegalArgumentException((new StringBuilder()).append("samplingInterval: ").append(i1).append(" (expected: 1+)").toString());
        if (l1 <= 0L) {
            throw new IllegalArgumentException((new StringBuilder()).append("maxActive: ").append(l1).append(" (expected: 1+)").toString());
        } else {
            i = s;
            j = io.netty.util.internal.h.a(i1);
            k = j - 1;
            l = l1;
            a.a(e, f);
            io.netty.util.a.b(f, e);
            return;
        }
    }

    public static Level a() {
        return c;
    }

    static String a(int i1) {
        int j1;
        int i2;
        StringBuilder stringbuilder;
        StackTraceElement astacktraceelement[];
        stringbuilder = new StringBuilder(4096);
        astacktraceelement = (new Throwable()).getStackTrace();
        i2 = astacktraceelement.length;
        boolean flag = false;
        j1 = i1;
        i1 = ((flag) ? 1 : 0);
_L5:
        if (i1 >= i2) goto _L2; else goto _L1
_L1:
        Object obj = astacktraceelement[i1];
        if (j1 <= 0) goto _L4; else goto _L3
_L3:
        int k1 = j1 - 1;
_L8:
        i1++;
        j1 = k1;
          goto _L5
_L4:
        int l1;
        String as[];
        obj = ((StackTraceElement) (obj)).toString();
        as = p;
        l1 = as.length;
        k1 = 0;
_L9:
        if (k1 >= l1)
            break MISSING_BLOCK_LABEL_148;
        if (!((String) (obj)).startsWith(as[k1])) goto _L7; else goto _L6
_L6:
        boolean flag1 = true;
_L10:
        k1 = j1;
        if (!flag1) {
            stringbuilder.append('\t');
            stringbuilder.append(((String) (obj)));
            stringbuilder.append(m.a);
            k1 = j1;
        }
          goto _L8
_L7:
        k1++;
          goto _L9
_L2:
        return stringbuilder.toString();
        flag1 = false;
          goto _L10
    }

    static ReferenceQueue a(ResourceLeakDetector resourceleakdetector) {
        return resourceleakdetector.g;
    }

    private void a(Level level) {
        if (d.d()) goto _L2; else goto _L1
_L1:
        level = (a)g.poll();
        if (level != null) goto _L4; else goto _L3
_L3:
        return;
_L4:
        level.b();
          goto _L1
_L2:
        int i1;
        if (level == Level.d)
            i1 = 1;
        else
            i1 = j;
        if (m * (long)i1 > l && n.compareAndSet(false, true))
            b(i);
        level = (a)g.poll();
        if (level == null) goto _L3; else goto _L5
_L5:
        level.clear();
        if (level.b()) {
            level = level.toString();
            if (h.putIfAbsent(level, Boolean.TRUE) == null)
                if (level.isEmpty())
                    a(i);
                else
                    a(i, ((String) (level)));
        }
        break MISSING_BLOCK_LABEL_79;
    }

    static int b() {
        return b;
    }

    static a b(ResourceLeakDetector resourceleakdetector) {
        return resourceleakdetector.e;
    }

    static long c(ResourceLeakDetector resourceleakdetector) {
        long l1 = resourceleakdetector.m;
        resourceleakdetector.m = 1L + l1;
        return l1;
    }

    static long d(ResourceLeakDetector resourceleakdetector) {
        long l1 = resourceleakdetector.m;
        resourceleakdetector.m = l1 - 1L;
        return l1;
    }

    public final j a(Object obj) {
        Object obj1;
        Level level;
        obj1 = null;
        level = c;
        if (level != Level.a) goto _L2; else goto _L1
_L1:
        return ((j) (obj1));
_L2:
        if (level.ordinal() < Level.d.ordinal()) {
            long l1 = o;
            o = 1L + l1;
            if ((l1 & (long)k) == 0L) {
                a(level);
                obj1 = new a(obj);
            }
        } else {
            a(level);
            obj1 = new a(obj);
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    protected void a(String s) {
        d.c("LEAK: {}.release() was not called before it's garbage-collected. Enable advanced leak reporting to find out where the leak occurred. To enable advanced leak reporting, specify the JVM option '-D{}={}' or call {}.setLevel() See http://netty.io/wiki/reference-counted-objects.html for more information.", new Object[] {
            s, "io.netty.leakDetection.level", io.netty.util.Level.c.name().toLowerCase(), io.netty.util.internal.m.a(this)
        });
    }

    protected void a(String s, String s1) {
        d.e("LEAK: {}.release() was not called before it's garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.{}", s, s1);
    }

    protected void b(String s) {
        d.d((new StringBuilder()).append("LEAK: You are creating too many ").append(s).append(" instances.  ").append(s).append(" is a shared resource that must be reused across the JVM,").append("so that only a few instances are created.").toString());
    }

    static  {
        a = io.netty.util.Level.b;
        d = io.netty.util.internal.logging.c.a(io/netty/util/ResourceLeakDetector);
        boolean flag;
        Level level;
        Iterator iterator;
        String s;
        if (io.netty.util.internal.n.b("io.netty.noResourceLeakDetection") != null) {
            flag = io.netty.util.internal.n.a("io.netty.noResourceLeakDetection", false);
            d.b("-Dio.netty.noResourceLeakDetection: {}", Boolean.valueOf(flag));
            d.d("-Dio.netty.noResourceLeakDetection is deprecated. Use '-D{}={}' instead.", "io.netty.leakDetection.level", a.name().toLowerCase());
        } else {
            flag = false;
        }
        if (flag)
            level = Level.a;
        else
            level = a;
        s = io.netty.util.internal.n.a("io.netty.leakDetection.level", io.netty.util.internal.n.a("io.netty.leakDetectionLevel", level.name()).trim().toUpperCase()).trim().toUpperCase();
        level = a;
        iterator = EnumSet.allOf(io/netty/util/ResourceLeakDetector$Level).iterator();
        while (iterator.hasNext())  {
            Level level2 = (Level)iterator.next();
            Level level1 = level2;
            if (!s.equals(level2.name()))
                if (s.equals(String.valueOf(level2.ordinal())))
                    level1 = level2;
                else
                    level1 = level;
            level = level1;
        }
        b = io.netty.util.internal.n.a("io.netty.leakDetection.maxRecords", 4);
        c = level;
        if (d.b()) {
            d.b("-D{}: {}", "io.netty.leakDetection.level", level.name().toLowerCase());
            d.b("-D{}: {}", "io.netty.leakDetection.maxRecords", Integer.valueOf(b));
        }
    }
}
