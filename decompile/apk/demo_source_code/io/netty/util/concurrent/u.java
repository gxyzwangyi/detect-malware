// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.util.concurrent;

import java.util.*;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

// Referenced classes of package io.netty.util.concurrent:
//            b, g, r, ag, 
//            i, n, h, y, 
//            o

public abstract class u extends io.netty.util.concurrent.b {
    private static interface a {

        public abstract i a();
    }

    private final class b
        implements a {

        final u a;

        public i a() {
            return u.b(a)[Math.abs(u.d(a).getAndIncrement() % u.b(a).length)];
        }

        private b() {
            a = u.this;
            super();
        }

    }

    private final class c
        implements a {

        final u a;

        public i a() {
            return u.b(a)[u.d(a).getAndIncrement() & u.b(a).length - 1];
        }

        private c() {
            a = u.this;
            super();
        }

    }


    private final i a[];
    private final AtomicInteger b;
    private final AtomicInteger c;
    private final y d;
    private final a e;

    protected transient u(int j, ThreadFactory threadfactory, Object aobj[]) {
        int k;
        boolean flag;
        flag = false;
        super();
        b = new AtomicInteger();
        c = new AtomicInteger();
        d = new g(r.a);
        if (j <= 0)
            throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", new Object[] {
                Integer.valueOf(j)
            }));
        ThreadFactory threadfactory1 = threadfactory;
        if (threadfactory == null)
            threadfactory1 = a();
        a = new ag[j];
        if (a(a.length))
            e = new c();
        else
            e = new b();
        k = 0;
        if (k >= j)
            break; /* Loop/switch isn't completed */
        a[k] = a(threadfactory1, aobj);
        k++;
        if (true) goto _L2; else goto _L1
_L2:
        break MISSING_BLOCK_LABEL_119;
        aobj;
        threadfactory = JVM INSTR new #92  <Class IllegalStateException>;
        threadfactory.IllegalStateException("failed to create a child event loop", ((Throwable) (aobj)));
        throw threadfactory;
        threadfactory;
        int i1 = 0;
        do {
            j = ((flag) ? 1 : 0);
            if (i1 >= k)
                break;
            a[i1].l();
            i1++;
        } while (true);
          goto _L3
_L5:
        j++;
_L3:
        if (j >= k)
            break; /* Loop/switch isn't completed */
        aobj = a[j];
        while (!((i) (aobj)).isTerminated()) 
            ((i) (aobj)).awaitTermination(0x7fffffffL, TimeUnit.SECONDS);
        if (true) goto _L5; else goto _L4
        aobj;
        Thread.currentThread().interrupt();
_L4:
        throw threadfactory;
_L1:
        aobj = new o() {

            final u a;

            public void a(n n1) {
                if (u.a(a).incrementAndGet() == u.b(a).length)
                    u.c(a).a(null);
            }

             {
                a = u.this;
                super();
            }
        }
;
        threadfactory = a;
        int l = threadfactory.length;
        for (j = 0; j < l; j++)
            threadfactory[j].e().d(((p) (aobj)));

        return;
    }

    static AtomicInteger a(u u1) {
        return u1.c;
    }

    private static boolean a(int j) {
        boolean flag;
        if ((-j & j) == j)
            flag = true;
        else
            flag = false;
        return flag;
    }

    static i[] b(u u1) {
        return u1.a;
    }

    static y c(u u1) {
        return u1.d;
    }

    static AtomicInteger d(u u1) {
        return u1.b;
    }

    protected transient abstract i a(ThreadFactory threadfactory, Object aobj[]);

    public n a(long l, long l1, TimeUnit timeunit) {
        i ai[] = a;
        int k = ai.length;
        for (int j = 0; j < k; j++)
            ai[j].a(l, l1, timeunit);

        return e();
    }

    protected ThreadFactory a() {
        return new h(getClass());
    }

    public boolean awaitTermination(long l, TimeUnit timeunit) {
        int j;
        int k;
        long l1;
        long l2;
        l1 = System.nanoTime();
        l2 = timeunit.toNanos(l);
        timeunit = a;
        k = timeunit.length;
        j = 0;
_L6:
        if (j >= k) goto _L2; else goto _L1
_L1:
        i i1 = timeunit[j];
_L4:
        l = (l2 + l1) - System.nanoTime();
        if (l > 0L)
            continue; /* Loop/switch isn't completed */
_L2:
        return isTerminated();
        if (!i1.awaitTermination(l, TimeUnit.NANOSECONDS)) goto _L4; else goto _L3
_L3:
        j++;
        if (true) goto _L6; else goto _L5
_L5:
    }

    public i c() {
        return e.a();
    }

    protected Set d() {
        Set set = Collections.newSetFromMap(new LinkedHashMap());
        Collections.addAll(set, a);
        return set;
    }

    public n e() {
        return d;
    }

    public boolean isShutdown() {
        int j;
        int k;
        boolean flag;
        i ai[];
        flag = false;
        ai = a;
        k = ai.length;
        j = 0;
_L3:
        if (j >= k)
            break MISSING_BLOCK_LABEL_39;
        if (ai[j].isShutdown()) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        j++;
          goto _L3
        flag = true;
          goto _L1
    }

    public boolean isTerminated() {
        int j;
        int k;
        boolean flag;
        i ai[];
        flag = false;
        ai = a;
        k = ai.length;
        j = 0;
_L3:
        if (j >= k)
            break MISSING_BLOCK_LABEL_39;
        if (ai[j].isTerminated()) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        j++;
          goto _L3
        flag = true;
          goto _L1
    }

    public Iterator iterator() {
        return d().iterator();
    }

    public void shutdown() {
        i ai[] = a;
        int k = ai.length;
        for (int j = 0; j < k; j++)
            ai[j].shutdown();

    }
}
