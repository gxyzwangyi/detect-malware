// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.util.concurrent;

import io.netty.util.Signal;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.e;
import io.netty.util.internal.k;
import io.netty.util.internal.logging.b;
import io.netty.util.internal.logging.c;
import io.netty.util.internal.m;
import io.netty.util.internal.n;
import io.netty.util.internal.o;
import java.util.concurrent.CancellationException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

// Referenced classes of package io.netty.util.concurrent:
//            c, y, i, f, 
//            p, BlockingOperationException, n

public class g extends io.netty.util.concurrent.c
    implements y {
    private static final class a {

        final Throwable a;

        a(Throwable throwable) {
            a = throwable;
        }
    }


    private static final b a = io.netty.util.internal.logging.c.a(io/netty/util/concurrent/g);
    private static final b b = io.netty.util.internal.logging.c.a((new StringBuilder()).append(io/netty/util/concurrent/g.getName()).append(".rejectedExecution").toString());
    private static final int c = Math.min(8, io.netty.util.internal.n.a("io.netty.defaultPromise.maxListenerStackDepth", 8));
    private static final AtomicReferenceFieldUpdater d;
    private static final Signal e = Signal.a((new StringBuilder()).append(io/netty/util/concurrent/g.getName()).append(".SUCCESS").toString());
    private static final Signal f = Signal.a((new StringBuilder()).append(io/netty/util/concurrent/g.getName()).append(".UNCANCELLABLE").toString());
    private static final a g = new a(io.netty.util.internal.o.a(new CancellationException(), io/netty/util/concurrent/g, "cancel(...)"));
    private volatile Object h;
    private final i i;
    private Object j;
    private short k;
    private boolean l;

    protected g() {
        i = null;
    }

    public g(i i1) {
        i = (i)io.netty.util.internal.k.a(i1, "executor");
    }

    private void a(f f1) {
        p ap[] = f1.a();
        int j1 = f1.b();
        for (int i1 = 0; i1 < j1; i1++)
            b(this, ap[i1]);

    }

    static void a(g g1) {
        g1.c();
    }

    protected static void a(i i1, io.netty.util.concurrent.n n1, p p1) {
        io.netty.util.internal.k.a(i1, "eventExecutor");
        io.netty.util.internal.k.a(n1, "future");
        io.netty.util.internal.k.a(p1, "listener");
        b(i1, n1, p1);
    }

    private static void a(i i1, Runnable runnable) {
        i1.execute(runnable);
_L1:
        return;
        i1;
        b.c("Failed to submit a listener notification task. Event loop shut down?", i1);
          goto _L1
    }

    static void a(io.netty.util.concurrent.n n1, p p1) {
        b(n1, p1);
    }

    private void a(p p1) {
        if (j == null)
            j = p1;
        else
        if (j instanceof f)
            ((f)j).a(p1);
        else
            j = new f((p)j, p1);
    }

    private boolean a(long l1, boolean flag) {
        if (!isDone()) goto _L2; else goto _L1
_L1:
        flag = true;
_L8:
        return flag;
_L2:
        boolean flag1;
        long l2;
        long l4;
        if (l1 <= 0L) {
            flag = isDone();
            continue; /* Loop/switch isn't completed */
        }
        if (flag && Thread.interrupted())
            throw new InterruptedException(toString());
        m();
        l4 = System.nanoTime();
        flag1 = false;
        l2 = l1;
_L6:
        boolean flag3 = flag1;
        this;
        JVM INSTR monitorenter ;
        flag3 = flag1;
        if (!isDone())
            break MISSING_BLOCK_LABEL_108;
        boolean flag4;
        flag4 = true;
        flag3 = flag1;
        this;
        JVM INSTR monitorexit ;
        flag = flag4;
        if (flag1) {
            Thread.currentThread().interrupt();
            flag = flag4;
        }
        continue; /* Loop/switch isn't completed */
        flag3 = flag1;
        e();
        wait(l2 / 0xf4240L, (int)(l2 % 0xf4240L));
        flag3 = flag1;
        f();
        boolean flag2 = flag1;
_L4:
        flag3 = flag2;
        this;
        JVM INSTR monitorexit ;
        flag3 = flag2;
        flag4 = isDone();
        if (!flag4)
            break; /* Loop/switch isn't completed */
        flag4 = true;
        flag = flag4;
        if (flag2) {
            Thread.currentThread().interrupt();
            flag = flag4;
        }
        continue; /* Loop/switch isn't completed */
        Object obj;
        obj;
        if (!flag)
            break MISSING_BLOCK_LABEL_238;
        throw obj;
        obj;
        flag3 = flag1;
        f();
        flag3 = flag1;
        throw obj;
        obj;
        this;
        JVM INSTR monitorexit ;
        throw obj;
        obj;
        if (flag3)
            Thread.currentThread().interrupt();
        throw obj;
        flag3 = true;
        flag2 = true;
        f();
        if (true) goto _L4; else goto _L3
_L3:
        flag3 = flag2;
        long l3 = l1 - (System.nanoTime() - l4);
        flag1 = flag2;
        l2 = l3;
        if (l3 > 0L) goto _L6; else goto _L5
_L5:
        flag3 = flag2;
        flag4 = isDone();
        flag = flag4;
        if (flag2) {
            Thread.currentThread().interrupt();
            flag = flag4;
        }
        if (true) goto _L8; else goto _L7
_L7:
    }

    private boolean a(Throwable throwable) {
        return d(new a((Throwable)io.netty.util.internal.k.a(throwable, "cause")));
    }

    private void b() {
        Object obj = a();
        if (!((i) (obj)).f()) goto _L2; else goto _L1
_L1:
        int i1;
        e e1;
        e1 = io.netty.util.internal.e.b();
        i1 = e1.i();
        if (i1 >= c) goto _L2; else goto _L3
_L3:
        e1.b(i1 + 1);
        c();
        e1.b(i1);
_L5:
        return;
        obj;
        e1.b(i1);
        throw obj;
_L2:
        a(((i) (obj)), new Runnable() {

            final g a;

            public void run() {
                g.a(a);
            }

             {
                a = g.this;
                super();
            }
        }
);
        if (true) goto _L5; else goto _L4
_L4:
    }

    private static void b(i i1, io.netty.util.concurrent.n n1, p p1) {
        if (!i1.f()) goto _L2; else goto _L1
_L1:
        int j1;
        e e1;
        e1 = io.netty.util.internal.e.b();
        j1 = e1.i();
        if (j1 >= c) goto _L2; else goto _L3
_L3:
        e1.b(j1 + 1);
        b(n1, p1);
        e1.b(j1);
_L5:
        return;
        i1;
        e1.b(j1);
        throw i1;
_L2:
        a(i1, new Runnable(n1, p1) {

            final io.netty.util.concurrent.n a;
            final p b;

            public void run() {
                g.a(a, b);
            }

             {
                a = n1;
                b = p1;
                super();
            }
        }
);
        if (true) goto _L5; else goto _L4
_L4:
    }

    private static void b(io.netty.util.concurrent.n n1, p p1) {
        p1.a(n1);
_L1:
        return;
        n1;
        a.b((new StringBuilder()).append("An exception was thrown by ").append(p1.getClass().getName()).append(".operationComplete()").toString(), n1);
          goto _L1
    }

    private void b(p p1) {
        if (!(j instanceof f)) goto _L2; else goto _L1
_L1:
        ((f)j).b(p1);
_L4:
        return;
_L2:
        if (j == p1)
            j = null;
        if (true) goto _L4; else goto _L3
_L3:
    }

    private void c() {
        this;
        JVM INSTR monitorenter ;
        if (!l && j != null) goto _L2; else goto _L1
_L1:
        this;
        JVM INSTR monitorexit ;
_L3:
        return;
_L2:
        Object obj;
        l = true;
        obj = j;
        j = null;
        this;
        JVM INSTR monitorexit ;
_L4:
        if (obj instanceof f)
            a((f)obj);
        else
            b(this, (p)obj);
        this;
        JVM INSTR monitorenter ;
        if (j != null)
            break MISSING_BLOCK_LABEL_91;
        l = false;
        this;
        JVM INSTR monitorexit ;
          goto _L3
        obj;
        this;
        JVM INSTR monitorexit ;
        throw obj;
        obj;
        this;
        JVM INSTR monitorexit ;
        throw obj;
        obj = j;
        j = null;
        this;
        JVM INSTR monitorexit ;
          goto _L4
    }

    private boolean c(Object obj) {
        Object obj1 = obj;
        if (obj == null)
            obj1 = e;
        return d(obj1);
    }

    private void d() {
        this;
        JVM INSTR monitorenter ;
        if (k > 0)
            notifyAll();
        this;
        JVM INSTR monitorexit ;
        return;
        Exception exception;
        exception;
        throw exception;
    }

    private boolean d(Object obj) {
        boolean flag;
        if (d.compareAndSet(this, null, obj) || d.compareAndSet(this, f, obj)) {
            d();
            flag = true;
        } else {
            flag = false;
        }
        return flag;
    }

    private void e() {
        if (k == 32767) {
            throw new IllegalStateException((new StringBuilder()).append("too many waiters: ").append(this).toString());
        } else {
            k = (short)(k + 1);
            return;
        }
    }

    private static boolean e(Object obj) {
        boolean flag;
        if ((obj instanceof a) && (((a)obj).a instanceof CancellationException))
            flag = true;
        else
            flag = false;
        return flag;
    }

    private void f() {
        k = (short)(k - 1);
    }

    private static boolean f(Object obj) {
        boolean flag;
        if (obj != null && obj != f)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private void r() {
        Throwable throwable = j();
        if (throwable != null)
            PlatformDependent.a(throwable);
    }

    protected i a() {
        return i;
    }

    public y a(Object obj) {
        if (c(obj)) {
            b();
            return this;
        } else {
            throw new IllegalStateException((new StringBuilder()).append("complete already: ").append(this).toString());
        }
    }

    public boolean a(long l1, TimeUnit timeunit) {
        return a(timeunit.toNanos(l1), true);
    }

    public boolean b(Object obj) {
        boolean flag;
        if (c(obj)) {
            b();
            flag = true;
        } else {
            flag = false;
        }
        return flag;
    }

    public boolean b(Throwable throwable) {
        boolean flag;
        if (a(throwable)) {
            b();
            flag = true;
        } else {
            flag = false;
        }
        return flag;
    }

    public y c(Throwable throwable) {
        if (a(throwable)) {
            b();
            return this;
        } else {
            throw new IllegalStateException((new StringBuilder()).append("complete already: ").append(this).toString(), throwable);
        }
    }

    public boolean cancel(boolean flag) {
        if (d.compareAndSet(this, null, g)) {
            d();
            b();
            flag = true;
        } else {
            flag = false;
        }
        return flag;
    }

    public io.netty.util.concurrent.n d(p p1) {
        return g(p1);
    }

    public y f(p p1) {
        io.netty.util.internal.k.a(p1, "listener");
        this;
        JVM INSTR monitorenter ;
        b(p1);
        this;
        JVM INSTR monitorexit ;
        return this;
        p1;
        this;
        JVM INSTR monitorexit ;
        throw p1;
    }

    public boolean f_() {
        boolean flag1 = true;
        if (!d.compareAndSet(this, null, f)) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        Object obj = h;
        flag = flag1;
        if (f(obj)) {
            flag = flag1;
            if (e(obj))
                flag = false;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public io.netty.util.concurrent.n g() {
        return n();
    }

    public y g(p p1) {
        io.netty.util.internal.k.a(p1, "listener");
        this;
        JVM INSTR monitorenter ;
        a(p1);
        this;
        JVM INSTR monitorexit ;
        if (isDone())
            b();
        return this;
        p1;
        this;
        JVM INSTR monitorexit ;
        throw p1;
    }

    public boolean g_() {
        Object obj = h;
        boolean flag;
        if (obj != null && obj != f && !(obj instanceof a))
            flag = true;
        else
            flag = false;
        return flag;
    }

    public io.netty.util.concurrent.n h() {
        return p();
    }

    public Object i() {
        Object obj;
label0:
        {
            Object obj1 = h;
            if (!(obj1 instanceof a)) {
                obj = obj1;
                if (obj1 != e)
                    break label0;
            }
            obj = null;
        }
        return obj;
    }

    public boolean isCancelled() {
        return e(h);
    }

    public boolean isDone() {
        return f(h);
    }

    public Throwable j() {
        Object obj = h;
        if (obj instanceof a)
            obj = ((a)obj).a;
        else
            obj = null;
        return ((Throwable) (obj));
    }

    protected void m() {
        i i1 = a();
        if (i1 != null && i1.f())
            throw new BlockingOperationException(toString());
        else
            return;
    }

    public y n() {
        o();
        r();
        return this;
    }

    public y o() {
        if (!isDone()) goto _L2; else goto _L1
_L1:
        return this;
_L2:
        m();
        boolean flag = false;
        this;
        JVM INSTR monitorenter ;
_L4:
        if (isDone())
            break; /* Loop/switch isn't completed */
        e();
        wait();
        f();
        continue; /* Loop/switch isn't completed */
        Object obj;
        obj;
        this;
        JVM INSTR monitorexit ;
        throw obj;
        obj;
        flag = true;
        f();
        if (true) goto _L4; else goto _L3
        obj;
        f();
        throw obj;
_L3:
        this;
        JVM INSTR monitorexit ;
        if (flag)
            Thread.currentThread().interrupt();
        if (true) goto _L1; else goto _L5
_L5:
    }

    public y p() {
        if (!isDone()) goto _L2; else goto _L1
_L1:
        return this;
_L2:
        if (Thread.interrupted())
            throw new InterruptedException(toString());
        m();
        this;
        JVM INSTR monitorenter ;
_L3:
        if (isDone())
            break MISSING_BLOCK_LABEL_67;
        e();
        wait();
        f();
          goto _L3
        Exception exception;
        exception;
        this;
        JVM INSTR monitorexit ;
        throw exception;
        exception;
        f();
        throw exception;
        this;
        JVM INSTR monitorexit ;
          goto _L1
    }

    protected StringBuilder q() {
        StringBuilder stringbuilder = (new StringBuilder(64)).append(io.netty.util.internal.m.a(this)).append('@').append(Integer.toHexString(hashCode()));
        Object obj = h;
        if (obj == e)
            stringbuilder.append("(success)");
        else
        if (obj == f)
            stringbuilder.append("(uncancellable)");
        else
        if (obj instanceof a)
            stringbuilder.append("(failure: ").append(((a)obj).a).append(')');
        else
        if (obj != null)
            stringbuilder.append("(success: ").append(obj).append(')');
        else
            stringbuilder.append("(incomplete)");
        return stringbuilder;
    }

    public String toString() {
        return q().toString();
    }

    static  {
        AtomicReferenceFieldUpdater atomicreferencefieldupdater1 = PlatformDependent.a(io/netty/util/concurrent/g, "h");
        AtomicReferenceFieldUpdater atomicreferencefieldupdater = atomicreferencefieldupdater1;
        if (atomicreferencefieldupdater1 == null)
            atomicreferencefieldupdater = AtomicReferenceFieldUpdater.newUpdater(io/netty/util/concurrent/g, java/lang/Object, "h");
        d = atomicreferencefieldupdater;
    }
}
