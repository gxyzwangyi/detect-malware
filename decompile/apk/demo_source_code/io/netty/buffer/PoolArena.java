// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.buffer;

import io.netty.util.internal.*;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

// Referenced classes of package io.netty.buffer:
//            u, x, w, t, 
//            y, z, ac, aa, 
//            ad, ab

abstract class PoolArena {
    static final class SizeClass extends Enum {

        public static final SizeClass a;
        public static final SizeClass b;
        public static final SizeClass c;
        private static final SizeClass d[];

        public static SizeClass valueOf(String s1) {
            return (SizeClass)Enum.valueOf(io/netty/buffer/PoolArena$SizeClass, s1);
        }

        public static SizeClass[] values() {
            return (SizeClass[])d.clone();
        }

        static  {
            a = new SizeClass("Tiny", 0);
            b = new SizeClass("Small", 1);
            c = new SizeClass("Normal", 2);
            d = (new SizeClass[] {
                a, b, c
            });
        }

        private SizeClass(String s1, int i1) {
            super(s1, i1);
        }
    }

    static final class a extends PoolArena {

        private static ByteBuffer i(int i1) {
            ByteBuffer bytebuffer;
            if (PlatformDependent.m())
                bytebuffer = PlatformDependent.a(i1);
            else
                bytebuffer = ByteBuffer.allocateDirect(i1);
            return bytebuffer;
        }

        protected t a(int i1, int j1, int k1, int l1) {
            return new t(this, i(l1), i1, j1, k1, l1);
        }

        protected void a(t t1) {
            if (PlatformDependent.m())
                PlatformDependent.c((ByteBuffer)t1.b);
            else
                PlatformDependent.a((ByteBuffer)t1.b);
        }

        protected volatile void a(Object obj, int i1, Object obj1, int j1, int k1) {
            a((ByteBuffer)obj, i1, (ByteBuffer)obj1, j1, k1);
        }

        protected void a(ByteBuffer bytebuffer, int i1, ByteBuffer bytebuffer1, int j1, int k1) {
            if (k1 != 0)
                if (a) {
                    PlatformDependent.a(PlatformDependent.b(bytebuffer) + (long)i1, PlatformDependent.b(bytebuffer1) + (long)j1, k1);
                } else {
                    bytebuffer = bytebuffer.duplicate();
                    bytebuffer1 = bytebuffer1.duplicate();
                    bytebuffer.position(i1).limit(i1 + k1);
                    bytebuffer1.position(j1);
                    bytebuffer1.put(bytebuffer);
                }
        }

        boolean a() {
            return true;
        }

        protected t g(int i1) {
            return new t(this, i(i1), i1);
        }

        protected y h(int i1) {
            Object obj;
            if (a)
                obj = ac.z(i1);
            else
                obj = aa.z(i1);
            return ((y) (obj));
        }

        a(z z1, int i1, int j1, int k1, int l1) {
            super(z1, i1, j1, k1, l1);
        }
    }

    static final class b extends PoolArena {

        protected t a(int i1, int j1, int k1, int l1) {
            return new t(this, new byte[l1], i1, j1, k1, l1);
        }

        protected void a(t t1) {
        }

        protected volatile void a(Object obj, int i1, Object obj1, int j1, int k1) {
            a((byte[])obj, i1, (byte[])obj1, j1, k1);
        }

        protected void a(byte abyte0[], int i1, byte abyte1[], int j1, int k1) {
            if (k1 != 0)
                System.arraycopy(abyte0, i1, abyte1, j1, k1);
        }

        boolean a() {
            return false;
        }

        protected t g(int i1) {
            return new t(this, new byte[i1], i1);
        }

        protected y h(int i1) {
            Object obj;
            if (a)
                obj = ad.A(i1);
            else
                obj = ab.z(i1);
            return ((y) (obj));
        }

        b(z z1, int i1, int j1, int k1, int l1) {
            super(z1, i1, j1, k1, l1);
        }
    }


    static final boolean a = PlatformDependent.f();
    static final boolean i;
    private long A;
    private final g B = PlatformDependent.l();
    final z b;
    final int c;
    final int d;
    final int e;
    final int f;
    final int g;
    final AtomicInteger h = new AtomicInteger();
    private final int j;
    private final w k[] = j(32);
    private final w l[];
    private final u m;
    private final u n;
    private final u o;
    private final u p;
    private final u q;
    private final u r;
    private final List s;
    private long t;
    private final g u = PlatformDependent.l();
    private final g v = PlatformDependent.l();
    private final g w = PlatformDependent.l();
    private final g x = PlatformDependent.l();
    private long y;
    private long z;

    protected PoolArena(z z1, int i1, int j1, int k1, int l1) {
        boolean flag = false;
        super();
        b = z1;
        c = i1;
        j = j1;
        d = k1;
        e = l1;
        f = ~(i1 - 1);
        for (j1 = 0; j1 < k.length; j1++)
            k[j1] = i(i1);

        g = k1 - 9;
        l = j(g);
        for (j1 = ((flag) ? 1 : 0); j1 < l.length; j1++)
            l[j1] = i(i1);

        r = new u(null, 100, 0x7fffffff, l1);
        q = new u(r, 75, 100, l1);
        m = new u(q, 50, 100, l1);
        n = new u(m, 25, 75, l1);
        o = new u(n, 1, 50, l1);
        p = new u(o, 0x80000000, 25, l1);
        r.a(q);
        q.a(m);
        m.a(n);
        n.a(o);
        o.a(null);
        p.a(p);
        z1 = new ArrayList(6);
        z1.add(p);
        z1.add(o);
        z1.add(n);
        z1.add(m);
        z1.add(q);
        z1.add(r);
        s = Collections.unmodifiableList(z1);
    }

    static int a(int i1) {
        return i1 >>> 4;
    }

    private void a(x x1, y y1, int i1) {
        int k1 = f(i1);
        if (!c(k1)) goto _L2; else goto _L1
_L1:
        boolean flag = d(k1);
        if (!flag) goto _L4; else goto _L3
_L3:
        if (!x1.a(this, y1, i1, k1)) goto _L6; else goto _L5
_L5:
        return;
_L6:
        int j1;
        j1 = a(k1);
        x1 = k;
_L10:
        x1 = x1[j1];
        x1;
        JVM INSTR monitorenter ;
        w w1 = ((w) (x1)).c;
        if (w1 == x1) goto _L8; else goto _L7
_L7:
        if (!i && (!w1.d || w1.e != k1)) {
            y1 = JVM INSTR new #184 <Class AssertionError>;
            y1.AssertionError();
            throw y1;
        }
          goto _L9
        y1;
        x1;
        JVM INSTR monitorexit ;
        throw y1;
_L4:
        if (x1.b(this, y1, i1, k1))
            continue; /* Loop/switch isn't completed */
        j1 = b(k1);
        x1 = l;
          goto _L10
_L9:
        long l1 = w1.a();
        if (i || l1 >= 0L)
            break MISSING_BLOCK_LABEL_168;
        y1 = JVM INSTR new #184 <Class AssertionError>;
        y1.AssertionError();
        throw y1;
        w1.a.b(y1, l1, i1);
        if (!flag)
            break MISSING_BLOCK_LABEL_199;
        u.a();
_L11:
        x1;
        JVM INSTR monitorexit ;
        continue; /* Loop/switch isn't completed */
        v.a();
          goto _L11
_L8:
        x1;
        JVM INSTR monitorexit ;
        a(y1, i1, k1);
        continue; /* Loop/switch isn't completed */
_L2:
        if (k1 <= e) {
            if (!x1.c(this, y1, i1, k1))
                a(y1, i1, k1);
        } else {
            a(y1, i1);
        }
        if (true) goto _L5; else goto _L12
_L12:
    }

    private void a(y y1, int i1) {
        t t1 = g(i1);
        x.a(t1.b());
        y1.a(t1, i1);
        w.a();
    }

    private void a(y y1, int i1, int j1) {
        this;
        JVM INSTR monitorenter ;
        if (!m.a(y1, i1, j1) && !n.a(y1, i1, j1) && !o.a(y1, i1, j1) && !p.a(y1, i1, j1) && !q.a(y1, i1, j1)) goto _L2; else goto _L1
_L1:
        t = t + 1L;
_L3:
        this;
        JVM INSTR monitorexit ;
        return;
_L2:
        long l1;
        t t1;
        t1 = a(c, j, d, e);
        l1 = t1.a(j1);
        t = t + 1L;
        if (i || l1 > 0L)
            break MISSING_BLOCK_LABEL_148;
        y1 = JVM INSTR new #184 <Class AssertionError>;
        y1.AssertionError();
        throw y1;
        y1;
        this;
        JVM INSTR monitorexit ;
        throw y1;
        t1.a(y1, l1, i1);
        p.a(t1);
          goto _L3
    }

    private static void a(StringBuilder stringbuilder, w aw[]) {
        int i1 = 0;
        while (i1 < aw.length)  {
            w w3 = aw[i1];
            if (w3.c != w3) {
                stringbuilder.append(m.a).append(i1).append(": ");
                w w1 = w3.c;
                w w2;
                do {
                    stringbuilder.append(w1);
                    w2 = w1.c;
                    w1 = w2;
                } while (w2 != w3);
            }
            i1++;
        }
    }

    static int b(int i1) {
        boolean flag = false;
        int j1 = i1 >>> 10;
        for (i1 = ((flag) ? 1 : 0); j1 != 0; i1++)
            j1 >>>= 1;

        return i1;
    }

    static boolean d(int i1) {
        boolean flag;
        if ((i1 & 0xfffffe00) == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private w i(int i1) {
        w w1 = new w(i1);
        w1.b = w1;
        w1.c = w1;
        return w1;
    }

    private w[] j(int i1) {
        return new w[i1];
    }

    private SizeClass k(int i1) {
        SizeClass sizeclass;
        if (!c(i1))
            sizeclass = SizeClass.c;
        else
        if (d(i1))
            sizeclass = SizeClass.a;
        else
            sizeclass = SizeClass.b;
        return sizeclass;
    }

    protected abstract t a(int i1, int j1, int k1, int l1);

    y a(x x1, int i1, int j1) {
        y y1 = h(j1);
        a(x1, y1, i1);
        return y1;
    }

    protected abstract void a(t t1);

    void a(t t1, long l1, int i1, x x1) {
        if (!t1.c) goto _L2; else goto _L1
_L1:
        i1 = t1.b();
        a(t1);
        x.a(-i1);
        B.a();
_L4:
        return;
_L2:
        SizeClass sizeclass = k(i1);
        if (x1 == null || !x1.a(this, t1, l1, i1, sizeclass))
            a(t1, l1, sizeclass);
        if (true) goto _L4; else goto _L3
_L3:
    }

    void a(t t1, long l1, SizeClass sizeclass) {
        this;
        JVM INSTR monitorenter ;
        static class _cls1 {

            static final int a[];

            static  {
                a = new int[SizeClass.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    a[SizeClass.c.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror2) { }
                try {
                    a[SizeClass.b.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                a[SizeClass.a.ordinal()] = 3;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        _cls1.a[sizeclass.ordinal()];
        JVM INSTR tableswitch 1 3: default 36
    //                   1 51
    //                   2 89
    //                   3 102;
           goto _L1 _L2 _L3 _L4
_L4:
        break MISSING_BLOCK_LABEL_102;
_L1:
        t1 = JVM INSTR new #308 <Class Error>;
        t1.Error();
        throw t1;
        t1;
        this;
        JVM INSTR monitorexit ;
        throw t1;
_L2:
        A = A + 1L;
_L5:
        boolean flag;
        if (!t1.d.a(t1, l1))
            flag = true;
        else
            flag = false;
        this;
        JVM INSTR monitorexit ;
        if (flag)
            a(t1);
        return;
_L3:
        z = z + 1L;
          goto _L5
        y = y + 1L;
          goto _L5
    }

    void a(y y1, int i1, boolean flag) {
        int j2;
        if (i1 < 0 || i1 > y1.a())
            throw new IllegalArgumentException((new StringBuilder()).append("newCapacity: ").append(i1).toString());
        j2 = y1.h;
        if (j2 != i1) goto _L2; else goto _L1
_L1:
        return;
_L2:
        t t1 = y1.d;
        long l2 = y1.e;
        Object obj = y1.f;
        int i2 = y1.g;
        int l1 = y1.i;
        int j1 = y1.b();
        int k1 = y1.c();
        a(b.e(), y1, i1);
        if (i1 > j2) {
            a(obj, i2, y1.f, y1.g, j2);
            i1 = j1;
            j1 = k1;
        } else
        if (i1 < j2) {
            if (j1 < i1) {
                if (k1 <= i1)
                    i1 = k1;
                a(obj, i2 + j1, y1.f, y1.g + j1, i1 - j1);
                k1 = i1;
                i1 = j1;
                j1 = k1;
            } else {
                j1 = i1;
            }
        } else {
            i1 = j1;
            j1 = k1;
        }
        y1.a(i1, j1);
        if (flag)
            a(t1, l2, l1, y1.j);
        if (true) goto _L1; else goto _L3
_L3:
    }

    protected abstract void a(Object obj, int i1, Object obj1, int j1, int k1);

    abstract boolean a();

    boolean c(int i1) {
        boolean flag;
        if ((f & i1) == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    w e(int i1) {
        w aw[];
        if (d(i1)) {
            i1 >>>= 4;
            aw = k;
        } else {
            boolean flag = false;
            int j1 = i1 >>> 10;
            for (i1 = ((flag) ? 1 : 0); j1 != 0; i1++)
                j1 >>>= 1;

            aw = l;
        }
        return aw[i1];
    }

    int f(int i1) {
        if (i1 < 0)
            throw new IllegalArgumentException((new StringBuilder()).append("capacity: ").append(i1).append(" (expected: 0+)").toString());
        if (i1 < e) goto _L2; else goto _L1
_L1:
        int j1 = i1;
_L4:
        return j1;
_L2:
        if (!d(i1)) {
            i1 = --i1 | i1 >>> 1;
            i1 |= i1 >>> 2;
            i1 |= i1 >>> 4;
            i1 |= i1 >>> 8;
            j1 = (i1 | i1 >>> 16) + 1;
            i1 = j1;
            if (j1 < 0)
                i1 = j1 >>> 1;
            j1 = i1;
        } else {
            j1 = i1;
            if ((i1 & 0xf) != 0)
                j1 = (i1 & 0xfffffff0) + 16;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected abstract t g(int i1);

    protected abstract y h(int i1);

    public String toString() {
        this;
        JVM INSTR monitorenter ;
        Object obj;
        obj = JVM INSTR new #254 <Class StringBuilder>;
        ((StringBuilder) (obj)).StringBuilder();
        obj = ((StringBuilder) (obj)).append("Chunk(s) at 0~25%:").append(m.a).append(p).append(m.a).append("Chunk(s) at 0~50%:").append(m.a).append(o).append(m.a).append("Chunk(s) at 25~75%:").append(m.a).append(n).append(m.a).append("Chunk(s) at 50~100%:").append(m.a).append(m).append(m.a).append("Chunk(s) at 75~100%:").append(m.a).append(q).append(m.a).append("Chunk(s) at 100%:").append(m.a).append(r).append(m.a).append("tiny subpages:");
        a(((StringBuilder) (obj)), k);
        ((StringBuilder) (obj)).append(m.a).append("small subpages:");
        a(((StringBuilder) (obj)), l);
        ((StringBuilder) (obj)).append(m.a);
        obj = ((StringBuilder) (obj)).toString();
        this;
        JVM INSTR monitorexit ;
        return ((String) (obj));
        Exception exception;
        exception;
        throw exception;
    }

    static  {
        boolean flag;
        if (!io/netty/buffer/PoolArena.desiredAssertionStatus())
            flag = true;
        else
            flag = false;
        i = flag;
    }
}
