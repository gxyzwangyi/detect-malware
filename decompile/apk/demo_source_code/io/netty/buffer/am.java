// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.buffer;

import io.netty.util.internal.PlatformDependent;
import java.nio.*;
import java.nio.channels.*;

// Referenced classes of package io.netty.buffer:
//            d, h, i

public class am extends d {

    private final i d;
    private ByteBuffer e;
    private ByteBuffer f;
    private int g;
    private boolean h;

    protected am(i k, int i1, int j1) {
        super(j1);
        if (k == null)
            throw new NullPointerException("alloc");
        if (i1 < 0)
            throw new IllegalArgumentException((new StringBuilder()).append("initialCapacity: ").append(i1).toString());
        if (j1 < 0)
            throw new IllegalArgumentException((new StringBuilder()).append("maxCapacity: ").append(j1).toString());
        if (i1 > j1) {
            throw new IllegalArgumentException(String.format("initialCapacity(%d) > maxCapacity(%d)", new Object[] {
                Integer.valueOf(i1), Integer.valueOf(j1)
            }));
        } else {
            d = k;
            c(ByteBuffer.allocateDirect(i1));
            return;
        }
    }

    private ByteBuffer E() {
        ByteBuffer bytebuffer1 = f;
        ByteBuffer bytebuffer = bytebuffer1;
        if (bytebuffer1 == null) {
            bytebuffer = e.duplicate();
            f = bytebuffer;
        }
        return bytebuffer;
    }

    private int a(int k, GatheringByteChannel gatheringbytechannel, int i1, boolean flag) {
        x();
        if (i1 == 0) {
            k = 0;
        } else {
            ByteBuffer bytebuffer;
            if (flag)
                bytebuffer = E();
            else
                bytebuffer = e.duplicate();
            bytebuffer.clear().position(k).limit(k + i1);
            k = gatheringbytechannel.write(bytebuffer);
        }
        return k;
    }

    private void a(int k, ByteBuffer bytebuffer, boolean flag) {
        u(k);
        if (bytebuffer == null)
            throw new NullPointerException("dst");
        int i1 = Math.min(H() - k, bytebuffer.remaining());
        ByteBuffer bytebuffer1;
        if (flag)
            bytebuffer1 = E();
        else
            bytebuffer1 = e.duplicate();
        bytebuffer1.clear().position(k).limit(i1 + k);
        bytebuffer.put(bytebuffer1);
    }

    private void a(int k, byte abyte0[], int i1, int j1, boolean flag) {
        b(k, j1, i1, abyte0.length);
        ByteBuffer bytebuffer;
        if (flag)
            bytebuffer = E();
        else
            bytebuffer = e.duplicate();
        bytebuffer.clear().position(k).limit(k + j1);
        bytebuffer.get(abyte0, i1, j1);
    }

    private void c(ByteBuffer bytebuffer) {
        ByteBuffer bytebuffer1 = e;
        if (bytebuffer1 != null)
            if (h)
                h = false;
            else
                b(bytebuffer1);
        e = bytebuffer;
        f = null;
        g = bytebuffer.remaining();
    }

    protected void D() {
        ByteBuffer bytebuffer = e;
        if (bytebuffer != null) goto _L2; else goto _L1
_L1:
        return;
_L2:
        e = null;
        if (!h)
            b(bytebuffer);
        if (true) goto _L1; else goto _L3
_L3:
    }

    public int H() {
        return g;
    }

    public i I() {
        return d;
    }

    public ByteOrder J() {
        return ByteOrder.BIG_ENDIAN;
    }

    public h K() {
        return null;
    }

    public boolean L() {
        return true;
    }

    public boolean M() {
        return false;
    }

    public byte[] N() {
        throw new UnsupportedOperationException("direct buffer");
    }

    public int O() {
        throw new UnsupportedOperationException("direct buffer");
    }

    public boolean P() {
        return false;
    }

    public long Q() {
        throw new UnsupportedOperationException();
    }

    public int a(int k, GatheringByteChannel gatheringbytechannel, int i1) {
        return a(k, gatheringbytechannel, i1, false);
    }

    public int a(int k, ScatteringByteChannel scatteringbytechannel, int i1) {
        x();
        E().clear().position(k).limit(k + i1);
        try {
            k = scatteringbytechannel.read(f);
        }
        // Misplaced declaration of an exception variable
        catch (ScatteringByteChannel scatteringbytechannel) {
            k = -1;
        }
        return k;
    }

    public int a(GatheringByteChannel gatheringbytechannel, int k) {
        v(k);
        k = a(b, gatheringbytechannel, k, true);
        b = b + k;
        return k;
    }

    public h a(int k) {
        int i1;
        int j1;
        int k1;
        x();
        if (k < 0 || k > a())
            throw new IllegalArgumentException((new StringBuilder()).append("newCapacity: ").append(k).toString());
        j1 = b();
        i1 = c();
        k1 = g;
        if (k <= k1) goto _L2; else goto _L1
_L1:
        ByteBuffer bytebuffer = e;
        ByteBuffer bytebuffer2 = x(k);
        bytebuffer.position(0).limit(bytebuffer.capacity());
        bytebuffer2.position(0).limit(bytebuffer.capacity());
        bytebuffer2.put(bytebuffer);
        bytebuffer2.clear();
        c(bytebuffer2);
_L4:
        return this;
_L2:
        if (k < k1) {
            ByteBuffer bytebuffer1 = e;
            ByteBuffer bytebuffer3 = x(k);
            if (j1 < k) {
                if (i1 > k)
                    c(k);
                else
                    k = i1;
                bytebuffer1.position(j1).limit(k);
                bytebuffer3.position(j1).limit(k);
                bytebuffer3.put(bytebuffer1);
                bytebuffer3.clear();
            } else {
                a(k, k);
            }
            c(bytebuffer3);
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public h a(int k, long l1) {
        x();
        b(k, l1);
        return this;
    }

    public h a(int k, h h1, int i1, int j1) {
        b(k, j1, i1, h1.H());
        if (h1.M())
            a(k, h1.N(), h1.O() + i1, j1);
        else
        if (h1.h_() > 0) {
            h1 = h1.b_(i1, j1);
            int k1 = h1.length;
            j1 = 0;
            i1 = k;
            k = j1;
            while (k < k1)  {
                ByteBuffer bytebuffer = h1[k];
                j1 = bytebuffer.remaining();
                a(i1, bytebuffer);
                i1 += j1;
                k++;
            }
        } else {
            h1.b(i1, this, k, j1);
        }
        return this;
    }

    public h a(int k, ByteBuffer bytebuffer) {
        a(k, bytebuffer, false);
        return this;
    }

    public h a(int k, byte abyte0[], int i1, int j1) {
        a(k, abyte0, i1, j1, false);
        return this;
    }

    public h a(byte abyte0[], int k, int i1) {
        v(i1);
        a(b, abyte0, k, i1, true);
        b = b + i1;
        return this;
    }

    public h a_(int k, int i1) {
        x();
        ByteBuffer bytebuffer;
        try {
            bytebuffer = (ByteBuffer)e.duplicate().clear().position(k).limit(k + i1);
        }
        catch (IllegalArgumentException illegalargumentexception) {
            throw new IndexOutOfBoundsException((new StringBuilder()).append("Too many bytes to read - Need ").append(k + i1).toString());
        }
        return I().c(i1, a()).a(bytebuffer);
    }

    public h b(int k, int i1) {
        x();
        c(k, i1);
        return this;
    }

    public h b(int k, h h1, int i1, int j1) {
        a(k, j1, i1, h1.H());
        if (h1.h_() > 0) {
            ByteBuffer abytebuffer[] = h1.b_(i1, j1);
            j1 = abytebuffer.length;
            for (i1 = 0; i1 < j1; i1++) {
                h1 = abytebuffer[i1];
                int k1 = h1.remaining();
                b(k, ((ByteBuffer) (h1)));
                k += k1;
            }

        } else {
            h1.a(i1, this, k, j1);
        }
        return this;
    }

    public h b(int k, ByteBuffer bytebuffer) {
        x();
        ByteBuffer bytebuffer2 = E();
        ByteBuffer bytebuffer1 = bytebuffer;
        if (bytebuffer == bytebuffer2)
            bytebuffer1 = bytebuffer.duplicate();
        bytebuffer2.clear().position(k).limit(bytebuffer1.remaining() + k);
        bytebuffer2.put(bytebuffer1);
        return this;
    }

    public h b(int k, byte abyte0[], int i1, int j1) {
        a(k, j1, i1, abyte0.length);
        ByteBuffer bytebuffer = E();
        bytebuffer.clear().position(k).limit(k + j1);
        bytebuffer.put(abyte0, i1, j1);
        return this;
    }

    protected void b(int k, long l1) {
        e.putLong(k, l1);
    }

    protected void b(ByteBuffer bytebuffer) {
        PlatformDependent.a(bytebuffer);
    }

    public ByteBuffer[] b_(int k, int i1) {
        return (new ByteBuffer[] {
            n(k, i1)
        });
    }

    protected void c(int k, int i1) {
        e.put(k, (byte)i1);
    }

    public h d(int k, int i1) {
        x();
        e(k, i1);
        return this;
    }

    protected void e(int k, int i1) {
        e.putShort(k, (short)i1);
    }

    public byte f(int k) {
        x();
        return g(k);
    }

    public h f(int k, int i1) {
        x();
        g(k, i1);
        return this;
    }

    protected byte g(int k) {
        return e.get(k);
    }

    protected void g(int k, int i1) {
        e.putInt(k, i1);
    }

    public int h_() {
        return 1;
    }

    public short i(int k) {
        x();
        return j(k);
    }

    protected short j(int k) {
        return e.getShort(k);
    }

    public int l(int k) {
        x();
        return m(k);
    }

    protected int m(int k) {
        return e.getInt(k);
    }

    public ByteBuffer m(int k, int i1) {
        j(k, i1);
        return (ByteBuffer)E().clear().position(k).limit(k + i1);
    }

    public ByteBuffer n(int k, int i1) {
        j(k, i1);
        return ((ByteBuffer)e.duplicate().position(k).limit(k + i1)).slice();
    }

    public long o(int k) {
        x();
        return p(k);
    }

    protected long p(int k) {
        return e.getLong(k);
    }

    protected ByteBuffer x(int k) {
        return ByteBuffer.allocateDirect(k);
    }
}
