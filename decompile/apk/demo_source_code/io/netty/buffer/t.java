// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.buffer;


// Referenced classes of package io.netty.buffer:
//            w, PoolArena, z, y, 
//            u

final class t {

    static final boolean g;
    final PoolArena a;
    final Object b;
    final boolean c;
    u d;
    t e;
    t f;
    private final byte h[];
    private final byte i[];
    private final w j[];
    private final int k;
    private final int l;
    private final int m;
    private final int n;
    private final int o;
    private final int p;
    private final int q;
    private final byte r;
    private int s;

    t(PoolArena poolarena, Object obj, int i1) {
        c = true;
        a = poolarena;
        b = obj;
        h = null;
        i = null;
        j = null;
        k = 0;
        l = 0;
        m = 0;
        n = 0;
        r = (byte)(n + 1);
        o = i1;
        p = j(o);
        q = 0;
    }

    t(PoolArena poolarena, Object obj, int i1, int j1, int k1, int l1) {
        c = false;
        a = poolarena;
        b = obj;
        l = i1;
        m = k1;
        n = j1;
        o = l1;
        r = (byte)(j1 + 1);
        p = j(l1);
        k = ~(i1 - 1);
        s = l1;
        if (!g && j1 >= 30)
            throw new AssertionError((new StringBuilder()).append("maxOrder should be < 30, but is: ").append(j1).toString());
        q = 1 << j1;
        h = new byte[q << 1];
        i = new byte[h.length];
        k1 = 0;
        i1 = 1;
        for (; k1 <= j1; k1++)
            for (l1 = 0; l1 < 1 << k1; l1++) {
                h[i1] = (byte)k1;
                i[i1] = (byte)k1;
                i1++;
            }


        j = b(q);
    }

    private void a(int i1, byte byte0) {
        h[i1] = byte0;
    }

    private void a(y y1, long l1, int i1, int j1) {
        if (!g && i1 == 0)
            throw new AssertionError();
        int k1 = b(l1);
        w w1 = j[m(k1)];
        if (!g && !w1.d)
            throw new AssertionError();
        if (!g && j1 > w1.e) {
            throw new AssertionError();
        } else {
            y1.a(this, l1, l(k1) + (0x3fffffff & i1) * w1.e, j1, w1.e, a.b.e());
            return;
        }
    }

    private static int b(long l1) {
        return (int)l1;
    }

    private w[] b(int i1) {
        return new w[i1];
    }

    private static int c(long l1) {
        return (int)(l1 >>> 32);
    }

    private void c(int i1) {
        while (i1 > 1)  {
            int j1 = i1 >>> 1;
            byte byte0 = h(i1);
            byte byte1 = h(i1 ^ 1);
            if (byte0 >= byte1)
                byte0 = byte1;
            a(j1, byte0);
            i1 = j1;
        }
    }

    private void d(int i1) {
        int j1 = i(i1) + 1;
        while (i1 > 1)  {
            int k1 = i1 >>> 1;
            byte byte0 = h(i1);
            byte byte1 = h(i1 ^ 1);
            j1--;
            if (byte0 == j1 && byte1 == j1) {
                a(k1, (byte)(j1 - 1));
            } else {
                if (byte0 >= byte1)
                    byte0 = byte1;
                a(k1, byte0);
            }
            i1 = k1;
        }
    }

    private int e(int i1) {
        int k1 = -(1 << i1);
        byte byte1 = h(1);
        int j1;
        if (byte1 > i1)
            j1 = -1;
        else
            while (false)  {
                j1 = 1;
                while (byte1 < i1 || (j1 & k1) == 0)  {
                    j1 <<= 1;
                    byte1 = h(j1);
                    if (byte1 > i1) {
                        j1 ^= 1;
                        byte1 = h(j1);
                    }
                }
                byte0 = h(j1);
                if (!g && (byte0 != i1 || (j1 & k1) != 1 << i1))
                    throw new AssertionError(String.format("val = %d, id & initial = %d, d = %d", new Object[] {
                        Byte.valueOf(byte0), Integer.valueOf(j1 & k1), Integer.valueOf(i1)
                    }));
                a(j1, r);
                c(j1);
            }
        return j1;
    }

    private long f(int i1) {
        i1 = e(n - (j(i1) - m));
        long l1;
        if (i1 < 0) {
            l1 = i1;
        } else {
            s = s - k(i1);
            l1 = i1;
        }
        return l1;
    }

    private long g(int i1) {
        w w2 = a.e(i1);
        w2;
        JVM INSTR monitorenter ;
        int l1 = e(n);
        if (l1 >= 0) goto _L2; else goto _L1
_L1:
        long l2 = l1;
        w2;
        JVM INSTR monitorexit ;
_L5:
        return l2;
_L2:
        int j1;
        int k1;
        w aw[];
        aw = j;
        j1 = l;
        s = s - j1;
        k1 = m(l1);
        w w1;
        w1 = aw[k1];
        if (w1 != null)
            break MISSING_BLOCK_LABEL_120;
        w1 = JVM INSTR new #124 <Class w>;
        w1.w(w2, this, l1, l(l1), j1, i1);
        aw[k1] = w1;
_L3:
        l2 = w1.a();
        w2;
        JVM INSTR monitorexit ;
        continue; /* Loop/switch isn't completed */
        w1.a(w2, i1);
          goto _L3
        Exception exception;
        exception;
        w2;
        JVM INSTR monitorexit ;
        throw exception;
        if (true) goto _L5; else goto _L4
_L4:
    }

    private byte h(int i1) {
        return h[i1];
    }

    private byte i(int i1) {
        return i[i1];
    }

    private static int j(int i1) {
        return 31 - Integer.numberOfLeadingZeros(i1);
    }

    private int k(int i1) {
        return 1 << p - i(i1);
    }

    private int l(int i1) {
        return (1 << i(i1) ^ i1) * k(i1);
    }

    private int m(int i1) {
        return q ^ i1;
    }

    public int a() {
        int i1 = s;
        if (i1 == 0) {
            i1 = 100;
        } else {
            i1 = (int)(((long)i1 * 100L) / (long)o);
            if (i1 == 0)
                i1 = 99;
            else
                i1 = 100 - i1;
        }
        return i1;
    }

    long a(int i1) {
        long l1;
        if ((k & i1) != 0)
            l1 = f(i1);
        else
            l1 = g(i1);
        return l1;
    }

    void a(long l1) {
        int i1;
        int j1;
        w w2;
        j1 = b(l1);
        i1 = c(l1);
        if (i1 == 0)
            break MISSING_BLOCK_LABEL_92;
        w2 = j[m(j1)];
        if (!g && (w2 == null || !w2.d))
            throw new AssertionError();
        w w1 = a.e(w2.e);
        w1;
        JVM INSTR monitorenter ;
        if (!w2.b(w1, i1 & 0x3fffffff))
            break MISSING_BLOCK_LABEL_92;
_L1:
        return;
        s = s + k(j1);
        a(j1, i(j1));
        d(j1);
          goto _L1
        Exception exception;
        exception;
        w1;
        JVM INSTR monitorexit ;
        throw exception;
    }

    void a(y y1, long l1, int i1) {
        int j1 = b(l1);
        int k1 = c(l1);
        if (k1 == 0) {
            k1 = h(j1);
            if (!g && k1 != r)
                throw new AssertionError(String.valueOf(k1));
            y1.a(this, l1, l(j1), i1, k(j1), a.b.e());
        } else {
            a(y1, l1, k1, i1);
        }
    }

    public int b() {
        return o;
    }

    void b(y y1, long l1, int i1) {
        a(y1, l1, c(l1), i1);
    }

    public String toString() {
        return (new StringBuilder()).append("Chunk(").append(Integer.toHexString(System.identityHashCode(this))).append(": ").append(a()).append("%, ").append(o - s).append('/').append(o).append(')').toString();
    }

    static  {
        boolean flag;
        if (!io/netty/buffer/t.desiredAssertionStatus())
            flag = true;
        else
            flag = false;
        g = flag;
    }
}
