// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.buffer;

import io.netty.util.i;
import io.netty.util.internal.c;
import io.netty.util.internal.k;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.GatheringByteChannel;
import java.nio.channels.ScatteringByteChannel;
import java.util.*;

// Referenced classes of package io.netty.buffer:
//            d, ak, h, i

public class n extends d
    implements Iterable {
    private static final class a {

        final h a;
        final int b;
        int c;
        int d;

        void a() {
            a.B();
        }

        a(h h1) {
            a = h1;
            b = h1.f();
        }
    }

    private final class b
        implements Iterator {

        final n a;
        private final int b;
        private int c;

        public h a() {
            if (b != n.a(a).size())
                throw new ConcurrentModificationException();
            if (!hasNext())
                throw new NoSuchElementException();
            Object obj;
            try {
                obj = n.a(a);
                int i1 = c;
                c = i1 + 1;
                obj = ((a)((List) (obj)).get(i1)).a;
            }
            catch (IndexOutOfBoundsException indexoutofboundsexception) {
                throw new ConcurrentModificationException();
            }
            return ((h) (obj));
        }

        public boolean hasNext() {
            boolean flag;
            if (b > c)
                flag = true;
            else
                flag = false;
            return flag;
        }

        public Object next() {
            return a();
        }

        public void remove() {
            throw new UnsupportedOperationException("Read-Only");
        }

        private b() {
            a = n.this;
            super();
            b = n.a(a).size();
        }

    }


    static final boolean d;
    private static final ByteBuffer e;
    private static final Iterator f = Collections.emptyList().iterator();
    private final io.netty.buffer.i g;
    private final boolean h;
    private final List i;
    private final int j;
    private boolean k;

    n(io.netty.buffer.i i1) {
        super(0x7fffffff);
        g = i1;
        h = false;
        j = 0;
        i = Collections.emptyList();
    }

    public n(io.netty.buffer.i i1, boolean flag, int j1) {
        super(0x7fffffff);
        if (i1 == null) {
            throw new NullPointerException("alloc");
        } else {
            g = i1;
            h = flag;
            j = j1;
            i = E(j1);
            return;
        }
    }

    private static List E(int i1) {
        return new ArrayList(Math.min(16, i1));
    }

    private void F(int i1) {
        x();
        if (i1 < 0 || i1 > i.size())
            throw new IndexOutOfBoundsException(String.format("cIndex: %d (expected: >= 0 && <= numComponents(%d))", new Object[] {
                Integer.valueOf(i1), Integer.valueOf(i.size())
            }));
        else
            return;
    }

    private void G(int i1) {
        int k1 = i.size();
        if (k1 > i1) {
            a a1 = (a)i.get(i1);
            int j1 = i1;
            if (i1 == 0) {
                a1.c = 0;
                a1.d = a1.b;
                j1 = i1 + 1;
            }
            while (j1 < k1)  {
                a a2 = (a)i.get(j1 - 1);
                a a3 = (a)i.get(j1);
                a3.c = a2.d;
                a3.d = a3.c + a3.b;
                j1++;
            }
        }
    }

    private a H(int i1) {
        u(i1);
        int j1 = 0;
        int k1 = i.size();
        while (j1 <= k1)  {
            int l1 = j1 + k1 >>> 1;
            a a1 = (a)i.get(l1);
            if (i1 >= a1.d) {
                l1++;
                j1 = k1;
                k1 = l1;
            } else
            if (i1 < a1.c) {
                l1--;
                k1 = j1;
                j1 = l1;
            } else
            if (!d && a1.b == 0)
                throw new AssertionError();
            else
                return a1;
            l1 = k1;
            k1 = j1;
            j1 = l1;
        }
        throw new Error("should not reach here");
    }

    private h I(int i1) {
        h h1;
        if (h)
            h1 = I().d(i1);
        else
            h1 = I().c(i1);
        return h1;
    }

    private void W() {
        int j1 = i.size();
        if (j1 > j) {
            h h1 = I(((a)i.get(j1 - 1)).d);
            for (int i1 = 0; i1 < j1; i1++) {
                a a1 = (a)i.get(i1);
                h1.a(a1.a);
                a1.a();
            }

            a a2 = new a(h1);
            a2.d = a2.b;
            i.clear();
            i.add(a2);
        }
    }

    private int a(boolean flag, int i1, h h1) {
        boolean flag1;
        boolean flag2;
        if (!d && h1 == null)
            throw new AssertionError();
        flag2 = false;
        flag1 = flag2;
        F(i1);
        flag1 = flag2;
        int j1 = h1.f();
        flag1 = flag2;
        Object obj = JVM INSTR new #11  <Class n$a>;
        flag1 = flag2;
        ((a) (obj)).a(h1.a(ByteOrder.BIG_ENDIAN).u());
        flag1 = flag2;
        if (i1 != i.size()) goto _L2; else goto _L1
_L1:
        flag1 = flag2;
        flag2 = i.add(obj);
        if (i1 != 0) goto _L4; else goto _L3
_L3:
        flag1 = flag2;
        obj.d = j1;
_L6:
        if (!flag)
            break MISSING_BLOCK_LABEL_139;
        flag1 = flag2;
        D(c() + h1.f());
        if (!flag2)
            h1.B();
        return i1;
_L4:
        flag1 = flag2;
        obj.c = ((a)i.get(i1 - 1)).d;
        flag1 = flag2;
        obj.d = ((a) (obj)).c + j1;
        continue; /* Loop/switch isn't completed */
        obj;
        if (!flag1)
            h1.B();
        throw obj;
_L2:
        flag1 = flag2;
        i.add(i1, obj);
        boolean flag3;
        flag1 = true;
        flag3 = true;
        flag2 = flag3;
        if (j1 == 0)
            continue; /* Loop/switch isn't completed */
        G(i1);
        flag2 = flag3;
        if (true) goto _L6; else goto _L5
_L5:
    }

    static List a(n n1) {
        return n1.i;
    }

    private void a(int i1, int j1, int k1, h h1) {
        int i2 = 0;
        int l1 = i1;
        for (i1 = i2; j1 > 0; i1 += i2) {
            a a1 = (a)i.get(k1);
            h h2 = a1.a;
            int j2 = a1.c;
            i2 = Math.min(j1, h2.H() - (l1 - j2));
            h2.a(l1 - j2, h1, i1, i2);
            l1 += i2;
            j1 -= i2;
            k1++;
        }

        h1.c(h1.H());
    }

    public h A() {
        return G();
    }

    public n A(int i1) {
        int j1;
        x();
        if (i1 < 0 || i1 > a())
            throw new IllegalArgumentException((new StringBuilder()).append("newCapacity: ").append(i1).toString());
        j1 = H();
        if (i1 <= j1) goto _L2; else goto _L1
_L1:
        i1 -= j1;
        if (i.size() < j) {
            h h1 = I(i1);
            h1.a(0, i1);
            a(false, i.size(), h1);
        } else {
            h h2 = I(i1);
            h2.a(0, i1);
            a(false, i.size(), h2);
            W();
        }
_L4:
        return this;
_L2:
label0:
        {
            if (i1 >= j1)
                continue; /* Loop/switch isn't completed */
            ListIterator listiterator = i.listIterator(i.size());
            j1 -= i1;
            a a1;
            do {
                if (!listiterator.hasPrevious())
                    break label0;
                a1 = (a)listiterator.previous();
                if (j1 < a1.b)
                    break;
                int k1 = a1.b;
                listiterator.remove();
                j1 -= k1;
            } while (true);
            a a2 = new a(a1.a.i(0, a1.b - j1));
            a2.c = a1.c;
            a2.d = a2.c + a2.b;
            listiterator.set(a2);
        }
        if (b() > i1)
            s(i1, i1);
        else
        if (c() > i1)
            D(i1);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public int B(int i1) {
        u(i1);
        int k1 = 0;
        for (int j1 = i.size(); k1 <= j1;) {
            int l1 = k1 + j1 >>> 1;
            a a1 = (a)i.get(l1);
            if (i1 >= a1.d)
                k1 = l1 + 1;
            else
            if (i1 < a1.c)
                j1 = l1 - 1;
            else
                return l1;
        }

        throw new Error("should not reach here");
    }

    public n C(int i1) {
        return (n)super.b(i1);
    }

    public i C() {
        return G();
    }

    public n D(int i1) {
        return (n)super.c(i1);
    }

    protected void D() {
        if (!k) {
            k = true;
            int j1 = i.size();
            int i1 = 0;
            while (i1 < j1)  {
                ((a)i.get(i1)).a();
                i1++;
            }
        }
    }

    public n E() {
        return F();
    }

    public n F() {
        x();
        int k1 = b();
        if (k1 != 0) {
            int l1 = c();
            if (k1 == l1 && l1 == H()) {
                for (Iterator iterator1 = i.iterator(); iterator1.hasNext(); ((a)iterator1.next()).a());
                i.clear();
                s(0, 0);
                d(k1);
            } else {
                int i2 = B(k1);
                for (int i1 = 0; i1 < i2; i1++)
                    ((a)i.get(i1)).a();

                i.subList(0, i2).clear();
                int j1 = ((a)i.get(0)).c;
                G(0);
                s(k1 - j1, l1 - j1);
                d(j1);
            }
        }
        return this;
    }

    public n G() {
        return (n)super.A();
    }

    public int H() {
        int i1 = i.size();
        if (i1 == 0)
            i1 = 0;
        else
            i1 = ((a)i.get(i1 - 1)).d;
        return i1;
    }

    public io.netty.buffer.i I() {
        return g;
    }

    public ByteOrder J() {
        return ByteOrder.BIG_ENDIAN;
    }

    public h K() {
        return null;
    }

    public boolean L() {
        int j1 = i.size();
        if (j1 != 0) goto _L2; else goto _L1
_L1:
        boolean flag = false;
_L4:
        return flag;
_L2:
        int i1 = 0;
        do {
            if (i1 >= j1)
                break;
            if (!((a)i.get(i1)).a.L()) {
                flag = false;
                continue; /* Loop/switch isn't completed */
            }
            i1++;
        } while (true);
        flag = true;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public boolean M() {
        boolean flag = false;
        i.size();
        JVM INSTR tableswitch 0 1: default 32
    //                   0 34
    //                   1 39;
           goto _L1 _L2 _L3
_L1:
        return flag;
_L2:
        flag = true;
        continue; /* Loop/switch isn't completed */
_L3:
        flag = ((a)i.get(0)).a.M();
        if (true) goto _L1; else goto _L4
_L4:
    }

    public byte[] N() {
        i.size();
        JVM INSTR tableswitch 0 1: default 32
    //                   0 40
    //                   1 46;
           goto _L1 _L2 _L3
_L1:
        throw new UnsupportedOperationException();
_L2:
        byte abyte0[] = c.a;
_L5:
        return abyte0;
_L3:
        abyte0 = ((a)i.get(0)).a.N();
        if (true) goto _L5; else goto _L4
_L4:
    }

    public int O() {
        int i1 = 0;
        switch (i.size()) {
        default:
            throw new UnsupportedOperationException();

        case 1: // '\001'
            i1 = ((a)i.get(0)).a.O();
            // fall through

        case 0: // '\0'
            return i1;
        }
    }

    public boolean P() {
        boolean flag = false;
        i.size();
        JVM INSTR tableswitch 0 1: default 32
    //                   0 34
    //                   1 44;
           goto _L1 _L2 _L3
_L1:
        return flag;
_L2:
        flag = io.netty.buffer.ak.c.P();
        continue; /* Loop/switch isn't completed */
_L3:
        flag = ((a)i.get(0)).a.P();
        if (true) goto _L1; else goto _L4
_L4:
    }

    public long Q() {
        i.size();
        JVM INSTR tableswitch 0 1: default 32
    //                   0 40
    //                   1 49;
           goto _L1 _L2 _L3
_L1:
        throw new UnsupportedOperationException();
_L2:
        long l1 = io.netty.buffer.ak.c.Q();
_L5:
        return l1;
_L3:
        l1 = ((a)i.get(0)).a.Q();
        if (true) goto _L5; else goto _L4
_L4:
    }

    public n R() {
        return (n)super.d();
    }

    public n S() {
        return (n)super.h();
    }

    public n T() {
        return (n)super.i();
    }

    public n U() {
        return (n)super.j();
    }

    public n V() {
        return (n)super.k();
    }

    public int a(int i1, GatheringByteChannel gatheringbytechannel, int j1) {
        if (h_() == 1) {
            i1 = gatheringbytechannel.write(m(i1, j1));
        } else {
            long l1 = gatheringbytechannel.write(b_(i1, j1));
            if (l1 > 0x7fffffffL)
                i1 = 0x7fffffff;
            else
                i1 = (int)l1;
        }
        return i1;
    }

    public int a(int i1, ScatteringByteChannel scatteringbytechannel, int j1) {
        j(i1, j1);
        if (j1 != 0) goto _L2; else goto _L1
_L1:
        i1 = scatteringbytechannel.read(e);
_L4:
        return i1;
_L2:
        int k1;
        int l1;
        int i2;
        int j2 = B(i1);
        k1 = 0;
        l1 = j1;
        i2 = i1;
        j1 = j2;
_L6:
        int k2;
        int l2;
        a a1 = (a)i.get(j1);
        h h1 = a1.a;
        i1 = a1.c;
        k2 = Math.min(l1, h1.H() - (i2 - i1));
        l2 = h1.a(i2 - i1, scatteringbytechannel, k2);
        i1 = k1;
        if (l2 != 0) {
label0:
            {
                if (l2 >= 0)
                    break label0;
                i1 = k1;
                if (k1 == 0)
                    i1 = -1;
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
        if (l2 == k2) {
            i2 += k2;
            l1 -= k2;
            i1 = k1 + k2;
            j1++;
        } else {
            i2 += l2;
            l1 -= l2;
            i1 = l2 + k1;
        }
        if (l1 > 0) goto _L5; else goto _L4
_L5:
        k1 = i1;
          goto _L6
    }

    public h a(int i1) {
        return A(i1);
    }

    public h a(int i1, int j1) {
        return s(i1, j1);
    }

    public h a(int i1, long l1) {
        return c(i1, l1);
    }

    public h a(int i1, h h1, int j1, int k1) {
        return c(i1, h1, j1, k1);
    }

    public h a(int i1, ByteBuffer bytebuffer) {
        return c(i1, bytebuffer);
    }

    public h a(int i1, byte abyte0[]) {
        return b(i1, abyte0);
    }

    public h a(int i1, byte abyte0[], int j1, int k1) {
        return c(i1, abyte0, j1, k1);
    }

    public h a(h h1) {
        return c(h1);
    }

    public h a(h h1, int i1) {
        return b(h1, i1);
    }

    public h a(h h1, int i1, int j1) {
        return b(h1, i1, j1);
    }

    public h a(ByteBuffer bytebuffer) {
        return b(bytebuffer);
    }

    public h a(byte abyte0[]) {
        return c(abyte0);
    }

    public h a(byte abyte0[], int i1, int j1) {
        return c(abyte0, i1, j1);
    }

    public n a(boolean flag, h h1) {
        io.netty.util.internal.k.a(h1, "buffer");
        a(flag, i.size(), h1);
        W();
        return this;
    }

    public h a_(int i1, int j1) {
        j(i1, j1);
        h h1 = ak.a(j1);
        if (j1 != 0)
            a(i1, j1, B(i1), h1);
        return h1;
    }

    public h b(int i1) {
        return C(i1);
    }

    public h b(int i1, int j1) {
        return o(i1, j1);
    }

    public h b(int i1, h h1, int j1, int k1) {
        return d(i1, h1, j1, k1);
    }

    public h b(int i1, ByteBuffer bytebuffer) {
        return d(i1, bytebuffer);
    }

    public h b(int i1, byte abyte0[], int j1, int k1) {
        return d(i1, abyte0, j1, k1);
    }

    public h b(byte abyte0[]) {
        return d(abyte0);
    }

    public h b(byte abyte0[], int i1, int j1) {
        return d(abyte0, i1, j1);
    }

    public n b(int i1, byte abyte0[]) {
        return (n)super.a(i1, abyte0);
    }

    public n b(h h1, int i1) {
        return (n)super.a(h1, i1);
    }

    public n b(h h1, int i1, int j1) {
        return (n)super.a(h1, i1, j1);
    }

    public n b(ByteBuffer bytebuffer) {
        return (n)super.a(bytebuffer);
    }

    protected void b(int i1, long l1) {
        a a1 = H(i1);
        if (i1 + 8 <= a1.d)
            a1.a.a(i1 - a1.c, l1);
        else
        if (J() == ByteOrder.BIG_ENDIAN) {
            g(i1, (int)(l1 >>> 32));
            g(i1 + 4, (int)l1);
        } else {
            g(i1, (int)l1);
            g(i1 + 4, (int)(l1 >>> 32));
        }
    }

    public ByteBuffer[] b_(int i1, int j1) {
        j(i1, j1);
        if (j1 != 0) goto _L2; else goto _L1
_L1:
        Object obj;
        obj = new ByteBuffer[1];
        obj[0] = e;
_L7:
        return ((ByteBuffer []) (obj));
_L2:
        int k1;
        ArrayList arraylist;
        arraylist = new ArrayList(i.size());
        k1 = B(i1);
_L4:
        int l1;
        int i2;
        h h1;
        if (j1 <= 0)
            break MISSING_BLOCK_LABEL_191;
        obj = (a)i.get(k1);
        h1 = ((a) (obj)).a;
        i2 = ((a) (obj)).c;
        l1 = Math.min(j1, h1.H() - (i1 - i2));
        switch (h1.h_()) {
        default:
            Collections.addAll(arraylist, h1.b_(i1 - i2, l1));
            break;

        case 0: // '\0'
            break; /* Loop/switch isn't completed */

        case 1: // '\001'
            break MISSING_BLOCK_LABEL_169;
        }
_L5:
        i1 += l1;
        j1 -= l1;
        k1++;
        if (true) goto _L4; else goto _L3
_L3:
        throw new UnsupportedOperationException();
        arraylist.add(h1.n(i1 - i2, l1));
          goto _L5
        obj = (ByteBuffer[])arraylist.toArray(new ByteBuffer[arraylist.size()]);
        if (true) goto _L7; else goto _L6
_L6:
    }

    public h c(int i1) {
        return D(i1);
    }

    public n c(int i1, long l1) {
        return (n)super.a(i1, l1);
    }

    public n c(int i1, h h1, int j1, int k1) {
        b(i1, k1, j1, h1.H());
        if (k1 != 0) {
            int i2 = B(i1);
            int l1 = i1;
            i1 = i2;
            while (k1 > 0)  {
                a a1 = (a)i.get(i1);
                h h2 = a1.a;
                int k2 = a1.c;
                int j2 = Math.min(k1, h2.H() - (l1 - k2));
                h2.a(l1 - k2, h1, j1, j2);
                l1 += j2;
                j1 += j2;
                k1 -= j2;
                i1++;
            }
        }
        return this;
    }

    public n c(int i1, ByteBuffer bytebuffer) {
        int j1;
        int l1;
        l1 = bytebuffer.limit();
        j1 = bytebuffer.remaining();
        j(i1, j1);
        if (j1 != 0) goto _L2; else goto _L1
_L1:
        return this;
_L2:
        int k1 = B(i1);
_L4:
        if (j1 <= 0)
            break; /* Loop/switch isn't completed */
        int i2;
        a a1 = (a)i.get(k1);
        h h1 = a1.a;
        int j2 = a1.c;
        i2 = Math.min(j1, h1.H() - (i1 - j2));
        bytebuffer.limit(bytebuffer.position() + i2);
        h1.a(i1 - j2, bytebuffer);
        i1 += i2;
        j1 -= i2;
        k1++;
        if (true) goto _L4; else goto _L3
_L3:
        bytebuffer.limit(l1);
        if (true) goto _L1; else goto _L5
_L5:
        Exception exception;
        exception;
        bytebuffer.limit(l1);
        throw exception;
    }

    public n c(int i1, byte abyte0[], int j1, int k1) {
        b(i1, k1, j1, abyte0.length);
        if (k1 != 0) {
            int i2 = B(i1);
            int l1 = i1;
            i1 = i2;
            while (k1 > 0)  {
                a a1 = (a)i.get(i1);
                h h1 = a1.a;
                int k2 = a1.c;
                int j2 = Math.min(k1, h1.H() - (l1 - k2));
                h1.a(l1 - k2, abyte0, j1, j2);
                l1 += j2;
                j1 += j2;
                k1 -= j2;
                i1++;
            }
        }
        return this;
    }

    public n c(h h1) {
        return (n)super.a(h1);
    }

    public n c(byte abyte0[]) {
        return (n)super.a(abyte0);
    }

    public n c(byte abyte0[], int i1, int j1) {
        return (n)super.a(abyte0, i1, j1);
    }

    protected void c(int i1, int j1) {
        o(i1, j1);
    }

    public h d() {
        return R();
    }

    public h d(int i1, int j1) {
        return p(i1, j1);
    }

    public n d(int i1, h h1, int j1, int k1) {
        a(i1, k1, j1, h1.H());
        if (k1 != 0) {
            int l1 = B(i1);
            while (k1 > 0)  {
                a a1 = (a)i.get(l1);
                h h2 = a1.a;
                int j2 = a1.c;
                int i2 = Math.min(k1, h2.H() - (i1 - j2));
                h2.b(i1 - j2, h1, j1, i2);
                i1 += i2;
                j1 += i2;
                k1 -= i2;
                l1++;
            }
        }
        return this;
    }

    public n d(int i1, ByteBuffer bytebuffer) {
        int j1;
        int l1;
        l1 = bytebuffer.limit();
        j1 = bytebuffer.remaining();
        j(i1, j1);
        if (j1 != 0) goto _L2; else goto _L1
_L1:
        return this;
_L2:
        int k1 = B(i1);
_L4:
        if (j1 <= 0)
            break; /* Loop/switch isn't completed */
        int i2;
        a a1 = (a)i.get(k1);
        h h1 = a1.a;
        int j2 = a1.c;
        i2 = Math.min(j1, h1.H() - (i1 - j2));
        bytebuffer.limit(bytebuffer.position() + i2);
        h1.b(i1 - j2, bytebuffer);
        i1 += i2;
        j1 -= i2;
        k1++;
        if (true) goto _L4; else goto _L3
_L3:
        bytebuffer.limit(l1);
        if (true) goto _L1; else goto _L5
_L5:
        Exception exception;
        exception;
        bytebuffer.limit(l1);
        throw exception;
    }

    public n d(int i1, byte abyte0[], int j1, int k1) {
        a(i1, k1, j1, abyte0.length);
        if (k1 != 0) {
            int i2 = B(i1);
            int l1 = i1;
            i1 = i2;
            while (k1 > 0)  {
                a a1 = (a)i.get(i1);
                h h1 = a1.a;
                int k2 = a1.c;
                int j2 = Math.min(k1, h1.H() - (l1 - k2));
                h1.b(l1 - k2, abyte0, j1, j2);
                l1 += j2;
                j1 += j2;
                k1 -= j2;
                i1++;
            }
        }
        return this;
    }

    public n d(h h1) {
        return a(false, h1);
    }

    public n d(byte abyte0[]) {
        return (n)super.b(abyte0);
    }

    public n d(byte abyte0[], int i1, int j1) {
        return (n)super.b(abyte0, i1, j1);
    }

    public h e(int i1) {
        return x(i1);
    }

    protected void e(int i1, int j1) {
        a a1 = H(i1);
        if (i1 + 2 <= a1.d)
            a1.a.d(i1 - a1.c, j1);
        else
        if (J() == ByteOrder.BIG_ENDIAN) {
            c(i1, (byte)(j1 >>> 8));
            c(i1 + 1, (byte)j1);
        } else {
            c(i1, (byte)j1);
            c(i1 + 1, (byte)(j1 >>> 8));
        }
    }

    public byte f(int i1) {
        return g(i1);
    }

    public h f(int i1, int j1) {
        return q(i1, j1);
    }

    protected byte g(int i1) {
        a a1 = H(i1);
        return a1.a.f(i1 - a1.c);
    }

    protected void g(int i1, int j1) {
        a a1 = H(i1);
        if (i1 + 4 <= a1.d)
            a1.a.f(i1 - a1.c, j1);
        else
        if (J() == ByteOrder.BIG_ENDIAN) {
            e(i1, (short)(j1 >>> 16));
            e(i1 + 2, (short)j1);
        } else {
            e(i1, (short)j1);
            e(i1 + 2, (short)(j1 >>> 16));
        }
    }

    public h h() {
        return S();
    }

    public h h(int i1, int j1) {
        return r(i1, j1);
    }

    public int h_() {
        i.size();
        JVM INSTR tableswitch 0 1: default 32
    //                   0 79
    //                   1 83;
           goto _L1 _L2 _L3
_L1:
        int i1;
        int k1 = i.size();
        int j1 = 0;
        i1 = 0;
        for (; j1 < k1; j1++)
            i1 += ((a)i.get(j1)).a.h_();

        break; /* Loop/switch isn't completed */
_L2:
        i1 = 1;
_L5:
        return i1;
_L3:
        i1 = ((a)i.get(0)).a.h_();
        if (true) goto _L5; else goto _L4
_L4:
    }

    public h i() {
        return T();
    }

    public Iterator iterator() {
        x();
        Object obj;
        if (i.isEmpty())
            obj = f;
        else
            obj = new b();
        return ((Iterator) (obj));
    }

    public h j() {
        return U();
    }

    protected short j(int i1) {
        a a1 = H(i1);
        short word0;
        if (i1 + 2 <= a1.d)
            word0 = a1.a.i(i1 - a1.c);
        else
        if (J() == ByteOrder.BIG_ENDIAN)
            word0 = (short)((g(i1) & 0xff) << 8 | g(i1 + 1) & 0xff);
        else
            word0 = (short)(g(i1) & 0xff | (g(i1 + 1) & 0xff) << 8);
        return word0;
    }

    public h k() {
        return V();
    }

    public h l() {
        return E();
    }

    protected int m(int i1) {
        a a1 = H(i1);
        if (i1 + 4 <= a1.d)
            i1 = a1.a.l(i1 - a1.c);
        else
        if (J() == ByteOrder.BIG_ENDIAN)
            i1 = (j(i1) & 0xffff) << 16 | j(i1 + 2) & 0xffff;
        else
            i1 = j(i1) & 0xffff | (j(i1 + 2) & 0xffff) << 16;
        return i1;
    }

    public ByteBuffer m(int i1, int j1) {
        i.size();
        JVM INSTR tableswitch 0 1: default 32
    //                   0 40
    //                   1 46;
           goto _L1 _L2 _L3
_L1:
        throw new UnsupportedOperationException();
_L2:
        ByteBuffer bytebuffer = e;
_L5:
        return bytebuffer;
_L3:
        bytebuffer = ((a)i.get(0)).a.m(i1, j1);
        if (true) goto _L5; else goto _L4
_L4:
    }

    public ByteBuffer n(int i1, int j1) {
        boolean flag;
        flag = false;
        j(i1, j1);
        i.size();
        JVM INSTR tableswitch 0 1: default 40
    //                   0 88
    //                   1 96;
           goto _L1 _L2 _L3
_L1:
        ByteBuffer bytebuffer;
        bytebuffer = ByteBuffer.allocate(j1).order(J());
        ByteBuffer abytebuffer[] = b_(i1, j1);
        j1 = abytebuffer.length;
        for (i1 = ((flag) ? 1 : 0); i1 < j1; i1++)
            bytebuffer.put(abytebuffer[i1]);

        break; /* Loop/switch isn't completed */
_L2:
        bytebuffer = e;
_L5:
        return bytebuffer;
_L3:
        if (((a)i.get(0)).a.h_() != 1) goto _L1; else goto _L4
_L4:
        bytebuffer = ((a)i.get(0)).a.n(i1, j1);
          goto _L5
        bytebuffer.flip();
          goto _L5
    }

    public n o(int i1, int j1) {
        a a1 = H(i1);
        a1.a.b(i1 - a1.c, j1);
        return this;
    }

    protected long p(int i1) {
        a a1 = H(i1);
        long l1;
        if (i1 + 8 <= a1.d)
            l1 = a1.a.o(i1 - a1.c);
        else
        if (J() == ByteOrder.BIG_ENDIAN)
            l1 = ((long)m(i1) & 0xffffffffL) << 32 | (long)m(i1 + 4) & 0xffffffffL;
        else
            l1 = (long)m(i1) & 0xffffffffL | ((long)m(i1 + 4) & 0xffffffffL) << 32;
        return l1;
    }

    public n p(int i1, int j1) {
        return (n)super.d(i1, j1);
    }

    public n q(int i1, int j1) {
        return (n)super.f(i1, j1);
    }

    public n r(int i1, int j1) {
        return (n)super.h(i1, j1);
    }

    public h s(int i1) {
        return y(i1);
    }

    public n s(int i1, int j1) {
        return (n)super.a(i1, j1);
    }

    public h t(int i1) {
        return z(i1);
    }

    public String toString() {
        String s1 = super.toString();
        s1 = s1.substring(0, s1.length() - 1);
        return (new StringBuilder()).append(s1).append(", components=").append(i.size()).append(')').toString();
    }

    public ByteBuffer[] w() {
        return b_(b(), f());
    }

    public n x(int i1) {
        return (n)super.e(i1);
    }

    public n y(int i1) {
        return (n)super.s(i1);
    }

    public n z(int i1) {
        return (n)super.t(i1);
    }

    static  {
        boolean flag;
        if (!io/netty/buffer/n.desiredAssertionStatus())
            flag = true;
        else
            flag = false;
        d = flag;
        e = io.netty.buffer.ak.c.v();
    }
}
