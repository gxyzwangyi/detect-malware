// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.buffer;

import java.io.*;

// Referenced classes of package io.netty.buffer:
//            h

public class k extends InputStream
    implements DataInput {

    private final h a;
    private final int b;
    private final int c;
    private final StringBuilder d;

    public k(h h1) {
        this(h1, h1.f());
    }

    public k(h h1, int i) {
        d = new StringBuilder();
        if (h1 == null)
            throw new NullPointerException("buffer");
        if (i < 0)
            throw new IllegalArgumentException((new StringBuilder()).append("length: ").append(i).toString());
        if (i > h1.f()) {
            throw new IndexOutOfBoundsException((new StringBuilder()).append("Too many bytes to be read - Needs ").append(i).append(", maximum is ").append(h1.f()).toString());
        } else {
            a = h1;
            b = h1.b();
            c = b + i;
            h1.h();
            return;
        }
    }

    private void a(int i) {
        if (i < 0)
            throw new IndexOutOfBoundsException("fieldSize cannot be a negative number");
        if (i > available())
            throw new EOFException((new StringBuilder()).append("fieldSize is too long! Length is ").append(i).append(", but maximum is ").append(available()).toString());
        else
            return;
    }

    public int available() {
        return c - a.b();
    }

    public void mark(int i) {
        a.h();
    }

    public boolean markSupported() {
        return true;
    }

    public int read() {
        int i;
        if (!a.e())
            i = -1;
        else
            i = a.n() & 0xff;
        return i;
    }

    public int read(byte abyte0[], int i, int j) {
        int l = available();
        if (l == 0) {
            i = -1;
        } else {
            j = Math.min(l, j);
            a.a(abyte0, i, j);
            i = j;
        }
        return i;
    }

    public boolean readBoolean() {
        boolean flag = true;
        a(1);
        if (read() == 0)
            flag = false;
        return flag;
    }

    public byte readByte() {
        if (!a.e())
            throw new EOFException();
        else
            return a.n();
    }

    public char readChar() {
        return (char)readShort();
    }

    public double readDouble() {
        return Double.longBitsToDouble(readLong());
    }

    public float readFloat() {
        return Float.intBitsToFloat(readInt());
    }

    public void readFully(byte abyte0[]) {
        readFully(abyte0, 0, abyte0.length);
    }

    public void readFully(byte abyte0[], int i, int j) {
        a(j);
        a.a(abyte0, i, j);
    }

    public int readInt() {
        a(4);
        return a.q();
    }

    public String readLine() {
        d.setLength(0);
_L6:
        if (a.e()) goto _L2; else goto _L1
_L1:
        String s;
        if (d.length() > 0)
            s = d.toString();
        else
            s = null;
_L7:
        return s;
_L2:
        short word0 = a.o();
        word0;
        JVM INSTR tableswitch 10 13: default 84
    //                   10 136
    //                   11 84
    //                   12 84
    //                   13 97;
           goto _L3 _L4 _L3 _L3 _L5
_L3:
        d.append((char)word0);
          goto _L6
_L5:
        if (a.e() && (char)a.h(a.b()) == '\n')
            a.s(1);
_L4:
        s = d.toString();
          goto _L7
    }

    public long readLong() {
        a(8);
        return a.r();
    }

    public short readShort() {
        a(2);
        return a.p();
    }

    public String readUTF() {
        return DataInputStream.readUTF(this);
    }

    public int readUnsignedByte() {
        return readByte() & 0xff;
    }

    public int readUnsignedShort() {
        return readShort() & 0xffff;
    }

    public void reset() {
        a.i();
    }

    public long skip(long l) {
        if (l > 0x7fffffffL)
            l = skipBytes(0x7fffffff);
        else
            l = skipBytes((int)l);
        return l;
    }

    public int skipBytes(int i) {
        i = Math.min(available(), i);
        a.s(i);
        return i;
    }
}
