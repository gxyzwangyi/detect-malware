// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.handler.ssl;

import io.netty.buffer.ak;
import io.netty.buffer.h;
import io.netty.buffer.i;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.e;
import io.netty.util.internal.k;
import io.netty.util.internal.logging.b;
import io.netty.util.internal.logging.c;
import io.netty.util.internal.o;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.nio.ReadOnlyBufferException;
import java.security.Principal;
import java.security.cert.Certificate;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLPeerUnverifiedException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSessionBindingEvent;
import javax.net.ssl.SSLSessionBindingListener;
import javax.net.ssl.SSLSessionContext;
import javax.security.cert.X509Certificate;
import org.apache.tomcat.jni.Buffer;
import org.apache.tomcat.jni.SSL;

// Referenced classes of package io.netty.handler.ssl:
//            ClientAuth, r, u, s, 
//            c, w, z, al, 
//            OpenSslX509Certificate, y, ac

public final class OpenSslEngine extends SSLEngine {
    private static final class HandshakeState extends Enum {

        public static final HandshakeState a;
        public static final HandshakeState b;
        public static final HandshakeState c;
        public static final HandshakeState d;
        private static final HandshakeState e[];

        public static HandshakeState valueOf(String s1) {
            return (HandshakeState)Enum.valueOf(io/netty/handler/ssl/OpenSslEngine$HandshakeState, s1);
        }

        public static HandshakeState[] values() {
            return (HandshakeState[])e.clone();
        }

        static  {
            a = new HandshakeState("NOT_STARTED", 0);
            b = new HandshakeState("STARTED_IMPLICITLY", 1);
            c = new HandshakeState("STARTED_EXPLICITLY", 2);
            d = new HandshakeState("FINISHED", 3);
            e = (new HandshakeState[] {
                a, b, c, d
            });
        }

        private HandshakeState(String s1, int i1) {
            super(s1, i1);
        }
    }

    private final class a
        implements SSLSession {

        static final boolean a;
        final OpenSslEngine b;
        private final ac c;
        private X509Certificate d[];
        private String e;
        private String f;
        private Certificate g[];
        private String h;
        private byte i[];
        private long j;
        private Map k;

        private String a(List list, ApplicationProtocolConfig.SelectedListenerFailureBehavior selectedlistenerfailurebehavior, String s1) {
            if (selectedlistenerfailurebehavior != ApplicationProtocolConfig.SelectedListenerFailureBehavior.a) goto _L2; else goto _L1
_L1:
            String s2 = s1;
_L4:
            return s2;
_L2:
            int i1 = list.size();
            if (!a && i1 <= 0)
                throw new AssertionError();
            s2 = s1;
            if (!list.contains(s1))
                if (selectedlistenerfailurebehavior == io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior.c)
                    s2 = (String)list.get(i1 - 1);
                else
                    throw new SSLException((new StringBuilder()).append("unknown protocol ").append(s1).toString());
            if (true) goto _L4; else goto _L3
_L3:
        }

        private void a(Object obj, String s1) {
            if (obj instanceof SSLSessionBindingListener)
                ((SSLSessionBindingListener)obj).valueUnbound(new SSLSessionBindingEvent(this, s1));
        }

        private void b() {
            boolean flag = false;
            byte abyte0[][] = SSL.getPeerCertChain(io.netty.handler.ssl.OpenSslEngine.b(b));
            Object aobj[];
            if (!OpenSslEngine.d(b))
                aobj = SSL.getPeerCertificate(io.netty.handler.ssl.OpenSslEngine.b(b));
            else
                aobj = null;
            if (abyte0 == null && aobj == null) {
                g = io.netty.handler.ssl.OpenSslEngine.c();
                d = OpenSslEngine.d();
            } else {
                int i1;
                if (abyte0 != null)
                    i1 = abyte0.length;
                else
                    i1 = 0;
                if (aobj != null) {
                    Certificate acertificate[] = new Certificate[i1 + 1];
                    acertificate[0] = new OpenSslX509Certificate(((byte []) (aobj)));
                    i1 = 1;
                    aobj = acertificate;
                } else {
                    aobj = new Certificate[i1];
                    i1 = 0;
                }
                if (abyte0 != null) {
                    X509Certificate ax509certificate[] = new X509Certificate[abyte0.length];
                    int j1 = i1;
                    for (i1 = ((flag) ? 1 : 0); i1 < ax509certificate.length; i1++) {
                        byte abyte1[] = abyte0[i1];
                        ax509certificate[i1] = new y(abyte1);
                        aobj[j1] = new OpenSslX509Certificate(abyte1);
                        j1++;
                    }

                    d = ax509certificate;
                } else {
                    d = OpenSslEngine.d();
                }
                g = ((Certificate []) (aobj));
            }
        }

        private void c() {
            List list;
            ApplicationProtocolConfig.SelectedListenerFailureBehavior selectedlistenerfailurebehavior;
            selectedlistenerfailurebehavior = io.netty.handler.ssl.OpenSslEngine.e(b).d();
            list = io.netty.handler.ssl.OpenSslEngine.e(b).a();
            static class _cls1 {

                static final int a[];
                static final int b[];
                static final int c[];

                static  {
                    c = new int[ApplicationProtocolConfig.Protocol.values().length];
                    NoSuchFieldError nosuchfielderror;
                    try {
                        c[ApplicationProtocolConfig.Protocol.a.ordinal()] = 1;
                    }
                    catch (NoSuchFieldError nosuchfielderror10) { }
                    try {
                        c[io.netty.handler.ssl.ApplicationProtocolConfig.Protocol.c.ordinal()] = 2;
                    }
                    catch (NoSuchFieldError nosuchfielderror9) { }
                    try {
                        c[io.netty.handler.ssl.ApplicationProtocolConfig.Protocol.b.ordinal()] = 3;
                    }
                    catch (NoSuchFieldError nosuchfielderror8) { }
                    try {
                        c[ApplicationProtocolConfig.Protocol.d.ordinal()] = 4;
                    }
                    catch (NoSuchFieldError nosuchfielderror7) { }
                    b = new int[ClientAuth.values().length];
                    try {
                        b[ClientAuth.a.ordinal()] = 1;
                    }
                    catch (NoSuchFieldError nosuchfielderror6) { }
                    try {
                        b[io.netty.handler.ssl.ClientAuth.c.ordinal()] = 2;
                    }
                    catch (NoSuchFieldError nosuchfielderror5) { }
                    try {
                        b[io.netty.handler.ssl.ClientAuth.b.ordinal()] = 3;
                    }
                    catch (NoSuchFieldError nosuchfielderror4) { }
                    a = new int[HandshakeState.values().length];
                    try {
                        a[HandshakeState.a.ordinal()] = 1;
                    }
                    catch (NoSuchFieldError nosuchfielderror3) { }
                    try {
                        a[HandshakeState.d.ordinal()] = 2;
                    }
                    catch (NoSuchFieldError nosuchfielderror2) { }
                    try {
                        a[io.netty.handler.ssl.HandshakeState.b.ordinal()] = 3;
                    }
                    catch (NoSuchFieldError nosuchfielderror1) { }
                    a[io.netty.handler.ssl.HandshakeState.c.ordinal()] = 4;
_L2:
                    return;
                    nosuchfielderror;
                    if (true) goto _L2; else goto _L1
_L1:
                }
            }

            io.netty.handler.ssl._cls1.c[io.netty.handler.ssl.OpenSslEngine.e(b).b().ordinal()];
            JVM INSTR tableswitch 1 4: default 76
        //                       1 111
        //                       2 84
        //                       3 112
        //                       4 142;
               goto _L1 _L2 _L3 _L4 _L5
_L2:
            break MISSING_BLOCK_LABEL_111;
_L1:
            throw new Error();
_L3:
            String s1 = SSL.getAlpnSelected(io.netty.handler.ssl.OpenSslEngine.b(b));
            if (s1 != null)
                f = a(list, selectedlistenerfailurebehavior, s1);
_L7:
            return;
_L4:
            String s2 = SSL.getNextProtoNegotiated(io.netty.handler.ssl.OpenSslEngine.b(b));
            if (s2 != null)
                f = a(list, selectedlistenerfailurebehavior, s2);
            continue; /* Loop/switch isn't completed */
_L5:
            String s4 = SSL.getAlpnSelected(io.netty.handler.ssl.OpenSslEngine.b(b));
            String s3 = s4;
            if (s4 == null)
                s3 = SSL.getNextProtoNegotiated(io.netty.handler.ssl.OpenSslEngine.b(b));
            if (s3 != null)
                f = a(list, selectedlistenerfailurebehavior, s3);
            if (true) goto _L7; else goto _L6
_L6:
        }

        void a() {
label0:
            {
                synchronized (b) {
                    if (OpenSslEngine.a(b))
                        break label0;
                    i = SSL.getSessionId(io.netty.handler.ssl.OpenSslEngine.b(b));
                    h = OpenSslEngine.a(b, SSL.getCipherForSSL(io.netty.handler.ssl.OpenSslEngine.b(b)));
                    e = SSL.getVersion(io.netty.handler.ssl.OpenSslEngine.b(b));
                    b();
                    c();
                    OpenSslEngine.a(b, HandshakeState.d);
                }
                return;
            }
            SSLException sslexception = JVM INSTR new #77  <Class SSLException>;
            sslexception.SSLException("Already closed");
            throw sslexception;
            exception;
            opensslengine;
            JVM INSTR monitorexit ;
            throw exception;
        }

        public int getApplicationBufferSize() {
            return 16384;
        }

        public String getCipherSuite() {
            OpenSslEngine opensslengine = b;
            opensslengine;
            JVM INSTR monitorenter ;
            if (h != null) goto _L2; else goto _L1
_L1:
            String s1 = "SSL_NULL_WITH_NULL_NULL";
            opensslengine;
            JVM INSTR monitorexit ;
_L4:
            return s1;
_L2:
            s1 = h;
            opensslengine;
            JVM INSTR monitorexit ;
            if (true) goto _L4; else goto _L3
_L3:
            Exception exception;
            exception;
            opensslengine;
            JVM INSTR monitorexit ;
            throw exception;
        }

        public long getCreationTime() {
            synchronized (b) {
                if (j == 0L && !OpenSslEngine.a(b))
                    j = SSL.getTime(io.netty.handler.ssl.OpenSslEngine.b(b)) * 1000L;
            }
            return j;
            exception;
            opensslengine;
            JVM INSTR monitorexit ;
            throw exception;
        }

        public byte[] getId() {
            OpenSslEngine opensslengine = b;
            opensslengine;
            JVM INSTR monitorenter ;
            if (i != null) goto _L2; else goto _L1
_L1:
            byte abyte0[] = io.netty.util.internal.c.a;
_L4:
            return abyte0;
_L2:
            abyte0 = (byte[])i.clone();
            opensslengine;
            JVM INSTR monitorexit ;
            if (true) goto _L4; else goto _L3
_L3:
            Exception exception;
            exception;
            opensslengine;
            JVM INSTR monitorexit ;
            throw exception;
        }

        public long getLastAccessedTime() {
            long l2 = io.netty.handler.ssl.OpenSslEngine.c(b);
            long l1 = l2;
            if (l2 == -1L)
                l1 = getCreationTime();
            return l1;
        }

        public Certificate[] getLocalCertificates() {
            Certificate acertificate[];
            if (OpenSslEngine.f(b) == null)
                acertificate = null;
            else
                acertificate = (Certificate[])OpenSslEngine.f(b).clone();
            return acertificate;
        }

        public Principal getLocalPrincipal() {
            Object obj = OpenSslEngine.f(b);
            if (obj == null || obj.length == 0)
                obj = null;
            else
                obj = ((java.security.cert.X509Certificate)obj[0]).getIssuerX500Principal();
            return ((Principal) (obj));
        }

        public int getPacketBufferSize() {
            return 18713;
        }

        public X509Certificate[] getPeerCertificateChain() {
            OpenSslEngine opensslengine = b;
            opensslengine;
            JVM INSTR monitorenter ;
            if (d == null || d.length == 0) {
                SSLPeerUnverifiedException sslpeerunverifiedexception = JVM INSTR new #267 <Class SSLPeerUnverifiedException>;
                sslpeerunverifiedexception.SSLPeerUnverifiedException("peer not verified");
                throw sslpeerunverifiedexception;
            }
            break MISSING_BLOCK_LABEL_40;
            Exception exception;
            exception;
            opensslengine;
            JVM INSTR monitorexit ;
            throw exception;
            X509Certificate ax509certificate[] = d;
            opensslengine;
            JVM INSTR monitorexit ;
            return ax509certificate;
        }

        public Certificate[] getPeerCertificates() {
            OpenSslEngine opensslengine = b;
            opensslengine;
            JVM INSTR monitorenter ;
            if (g == null || g.length == 0) {
                SSLPeerUnverifiedException sslpeerunverifiedexception = JVM INSTR new #267 <Class SSLPeerUnverifiedException>;
                sslpeerunverifiedexception.SSLPeerUnverifiedException("peer not verified");
                throw sslpeerunverifiedexception;
            }
            break MISSING_BLOCK_LABEL_40;
            Exception exception;
            exception;
            opensslengine;
            JVM INSTR monitorexit ;
            throw exception;
            Certificate acertificate[] = g;
            opensslengine;
            JVM INSTR monitorexit ;
            return acertificate;
        }

        public String getPeerHost() {
            return b.getPeerHost();
        }

        public int getPeerPort() {
            return b.getPeerPort();
        }

        public Principal getPeerPrincipal() {
            return ((java.security.cert.X509Certificate)getPeerCertificates()[0]).getSubjectX500Principal();
        }

        public String getProtocol() {
            String s1;
            String s2 = e;
            s1 = s2;
            if (s2 != null)
                break MISSING_BLOCK_LABEL_40;
            OpenSslEngine opensslengine = b;
            opensslengine;
            JVM INSTR monitorenter ;
            if (OpenSslEngine.a(b))
                break MISSING_BLOCK_LABEL_43;
            s1 = SSL.getVersion(io.netty.handler.ssl.OpenSslEngine.b(b));
_L2:
            return s1;
            s1 = "";
            if (true) goto _L2; else goto _L1
_L1:
            Exception exception;
            exception;
            opensslengine;
            JVM INSTR monitorexit ;
            throw exception;
        }

        public SSLSessionContext getSessionContext() {
            return c;
        }

        public Object getValue(String s1) {
            if (s1 == null)
                throw new NullPointerException("name");
            if (k == null)
                s1 = null;
            else
                s1 = ((String) (k.get(s1)));
            return s1;
        }

        public String[] getValueNames() {
            String as[] = k;
            if (as == null || as.isEmpty())
                as = io.netty.util.internal.c.k;
            else
                as = (String[])as.keySet().toArray(new String[as.size()]);
            return as;
        }

        public void invalidate() {
            synchronized (b) {
                if (!OpenSslEngine.a(b))
                    SSL.setTimeout(io.netty.handler.ssl.OpenSslEngine.b(b), 0L);
            }
            return;
            exception;
            opensslengine;
            JVM INSTR monitorexit ;
            throw exception;
        }

        public boolean isValid() {
            boolean flag;
            boolean flag1;
            flag1 = false;
            flag = false;
            OpenSslEngine opensslengine = b;
            opensslengine;
            JVM INSTR monitorenter ;
            if (OpenSslEngine.a(b)) goto _L2; else goto _L1
_L1:
            if (System.currentTimeMillis() - SSL.getTimeout(io.netty.handler.ssl.OpenSslEngine.b(b)) * 1000L < SSL.getTime(io.netty.handler.ssl.OpenSslEngine.b(b)) * 1000L)
                flag = true;
            opensslengine;
            JVM INSTR monitorexit ;
_L4:
            return flag;
_L2:
            opensslengine;
            JVM INSTR monitorexit ;
            flag = flag1;
            if (true) goto _L4; else goto _L3
_L3:
            Exception exception;
            exception;
            opensslengine;
            JVM INSTR monitorexit ;
            throw exception;
        }

        public void putValue(String s1, Object obj) {
            if (s1 == null)
                throw new NullPointerException("name");
            if (obj == null)
                throw new NullPointerException("value");
            Map map = k;
            Object obj1 = map;
            if (map == null) {
                obj1 = new HashMap(2);
                k = ((Map) (obj1));
            }
            obj1 = ((Map) (obj1)).put(s1, obj);
            if (obj instanceof SSLSessionBindingListener)
                ((SSLSessionBindingListener)obj).valueBound(new SSLSessionBindingEvent(this, s1));
            a(obj1, s1);
        }

        public void removeValue(String s1) {
            if (s1 == null)
                throw new NullPointerException("name");
            Map map = k;
            if (map != null)
                a(map.remove(s1), s1);
        }

        static  {
            boolean flag;
            if (!io/netty/handler/ssl/OpenSslEngine.desiredAssertionStatus())
                flag = true;
            else
                flag = false;
            a = flag;
        }

        a(ac ac) {
            b = OpenSslEngine.this;
            super();
            c = ac;
        }
    }


    static final boolean b;
    private static final b c;
    private static final Certificate d[];
    private static final X509Certificate e[];
    private static final SSLException f;
    private static final SSLException g;
    private static final SSLException h;
    private static final SSLException i;
    private static final Class j;
    private static final Method k;
    private static final Method l;
    private static final Method m;
    private static final Method n;
    private static final Method o;
    private static final AtomicIntegerFieldUpdater p;
    private static final long q;
    private static final SSLEngineResult r;
    private static final SSLEngineResult s;
    private static final SSLEngineResult t;
    private static final SSLEngineResult u;
    private static final SSLEngineResult v;
    private boolean A;
    private volatile int B;
    private volatile ClientAuth C;
    private volatile long D;
    private String E;
    private Object F;
    private List G;
    private boolean H;
    private boolean I;
    private boolean J;
    private final boolean K;
    private final i L;
    private final w M;
    private final s N;
    private final boolean O;
    private final a P;
    private final Certificate Q[];
    private final ByteBuffer R[] = new ByteBuffer[1];
    private final ByteBuffer S[] = new ByteBuffer[1];
    private final z T;
    SSLHandshakeException a;
    private long w;
    private long x;
    private boolean y;
    private HandshakeState z;

    OpenSslEngine(u u1, i i1, String s1, int j1) {
        super(s1, j1);
        z = HandshakeState.a;
        C = ClientAuth.a;
        D = -1L;
        io.netty.handler.ssl.r.b();
        L = (i)io.netty.util.internal.k.a(i1, "alloc");
        N = (s)u1.d();
        long l1 = u1.a;
        boolean flag;
        if (!u1.b())
            flag = true;
        else
            flag = false;
        w = SSL.newSSL(l1, flag);
        P = new a(u1.a());
        x = SSL.makeNetworkBIO(w);
        K = u1.b();
        M = u1.e;
        O = u1.f;
        Q = u1.c;
        if (K)
            i1 = ClientAuth.a;
        else
            i1 = u1.d;
        a(i1);
        if (K && s1 != null)
            SSL.setTlsExtHostName(w, s1);
        T = u1.c();
    }

    private int a(ByteBuffer bytebuffer) {
        int i1;
        int j1;
        int k1;
        k1 = bytebuffer.position();
        i1 = bytebuffer.limit();
        j1 = Math.min(i1 - k1, 16384);
        if (!bytebuffer.isDirect()) goto _L2; else goto _L1
_L1:
        long l3 = Buffer.address(bytebuffer);
        long l1 = k1;
        j1 = SSL.writeToSSL(w, l3 + l1, j1);
        i1 = j1;
        if (j1 > 0) {
            bytebuffer.position(k1 + j1);
            i1 = j1;
        }
_L4:
        return i1;
_L2:
        h h1 = L.d(j1);
        long l2 = io.netty.handler.ssl.r.a(h1);
        bytebuffer.limit(k1 + j1);
        h1.b(0, bytebuffer);
        bytebuffer.limit(i1);
        i1 = SSL.writeToSSL(w, l2, j1);
        if (i1 <= 0)
            break; /* Loop/switch isn't completed */
        bytebuffer.position(k1 + i1);
_L5:
        h1.B();
        if (true) goto _L4; else goto _L3
_L3:
        bytebuffer.position(k1);
          goto _L5
        bytebuffer;
        h1.B();
        throw bytebuffer;
    }

    private int a(ByteBuffer bytebuffer, int i1) {
        if (!bytebuffer.isDirect() || bytebuffer.remaining() < i1) goto _L2; else goto _L1
_L1:
        int l1 = bytebuffer.position();
        long l4 = Buffer.address(bytebuffer);
        long l2 = l1;
        int j1 = SSL.readFromBIO(x, l4 + l2, i1);
        i1 = j1;
        if (j1 > 0) {
            bytebuffer.position(l1 + j1);
            i1 = j1;
        }
_L4:
        return i1;
_L2:
        h h1 = L.d(i1);
        long l3 = io.netty.handler.ssl.r.a(h1);
        i1 = SSL.readFromBIO(x, l3, i1);
        if (i1 <= 0)
            break MISSING_BLOCK_LABEL_138;
        int k1 = bytebuffer.limit();
        bytebuffer.limit(bytebuffer.position() + i1);
        h1.a(0, bytebuffer);
        bytebuffer.limit(k1);
        h1.B();
        continue; /* Loop/switch isn't completed */
        h1.B();
        if (true) goto _L4; else goto _L3
_L3:
        bytebuffer;
        h1.B();
        throw bytebuffer;
    }

    static HandshakeState a(OpenSslEngine opensslengine, HandshakeState handshakestate) {
        opensslengine.z = handshakestate;
        return handshakestate;
    }

    static String a(OpenSslEngine opensslengine, String s1) {
        return opensslengine.b(s1);
    }

    private static javax.net.ssl.SSLEngineResult.HandshakeStatus a(int i1) {
        javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus;
        if (i1 > 0)
            handshakestatus = javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP;
        else
            handshakestatus = javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
        return handshakestatus;
    }

    private javax.net.ssl.SSLEngineResult.HandshakeStatus a(javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus) {
        javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus1 = handshakestatus;
        if (handshakestatus == javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
            handshakestatus1 = handshakestatus;
            if (z != HandshakeState.d)
                handshakestatus1 = j();
        }
        return handshakestatus1;
    }

    private SSLEngineResult a(int i1, int j1, int k1) {
        String s1 = SSL.getErrorString(i1);
        if (SSL.pendingWrittenBytesInBIO(x) > 0) {
            if (a == null && z != HandshakeState.d)
                a = new SSLHandshakeException(s1);
            return new SSLEngineResult(javax.net.ssl.SSLEngineResult.Status.OK, javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP, j1, k1);
        } else {
            throw a("SSL_read", s1);
        }
    }

    private SSLEngineResult a(int i1, int j1, javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus) {
        javax.net.ssl.SSLEngineResult.Status status = k();
        javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus1 = handshakestatus;
        if (handshakestatus != javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED)
            handshakestatus1 = getHandshakeStatus();
        return new SSLEngineResult(status, a(handshakestatus1), i1, j1);
    }

    private SSLEngineResult a(ByteBuffer bytebuffer, int i1, int j1, javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus) {
        int k1 = SSL.pendingWrittenBytesInBIO(x);
        if (k1 > 0) {
            if (bytebuffer.remaining() < k1) {
                javax.net.ssl.SSLEngineResult.Status status = javax.net.ssl.SSLEngineResult.Status.BUFFER_OVERFLOW;
                bytebuffer = handshakestatus;
                if (handshakestatus != javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED)
                    bytebuffer = b(k1);
                bytebuffer = new SSLEngineResult(status, a(((javax.net.ssl.SSLEngineResult.HandshakeStatus) (bytebuffer))), i1, j1);
            } else {
                int l1 = a(bytebuffer, k1);
                javax.net.ssl.SSLEngineResult.Status status1;
                if (l1 <= 0) {
                    SSL.clearError();
                } else {
                    j1 += l1;
                    k1 -= l1;
                }
                if (I)
                    b();
                status1 = k();
                bytebuffer = handshakestatus;
                if (handshakestatus != javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED)
                    bytebuffer = b(k1);
                bytebuffer = new SSLEngineResult(status1, a(((javax.net.ssl.SSLEngineResult.HandshakeStatus) (bytebuffer))), i1, j1);
            }
        } else {
            bytebuffer = null;
        }
        return bytebuffer;
    }

    private SSLException a(String s1) {
        return a(s1, SSL.getLastError());
    }

    private SSLException a(String s1, String s2) {
        if (c.b())
            c.b("{} failed: OpenSSL error: {}", s1, s2);
        b();
        if (z == HandshakeState.d)
            s1 = new SSLException(s2);
        else
            s1 = new SSLHandshakeException(s2);
        return s1;
    }

    private void a(ClientAuth clientauth) {
        if (!K) goto _L2; else goto _L1
_L1:
        return;
_L2:
        this;
        JVM INSTR monitorenter ;
        if (C != clientauth)
            break MISSING_BLOCK_LABEL_28;
        this;
        JVM INSTR monitorexit ;
          goto _L1
        clientauth;
        this;
        JVM INSTR monitorexit ;
        throw clientauth;
        io.netty.handler.ssl._cls1.b[clientauth.ordinal()];
        JVM INSTR tableswitch 1 3: default 64
    //                   1 74
    //                   2 87
    //                   3 100;
           goto _L3 _L4 _L5 _L6
_L3:
        break; /* Loop/switch isn't completed */
_L6:
        break MISSING_BLOCK_LABEL_100;
_L7:
        C = clientauth;
        this;
        JVM INSTR monitorexit ;
          goto _L1
_L4:
        SSL.setVerify(w, 0, 10);
          goto _L7
_L5:
        SSL.setVerify(w, 2, 10);
          goto _L7
        SSL.setVerify(w, 1, 10);
          goto _L7
    }

    private void a(SSLException sslexception) {
        if (J || m())
            throw sslexception;
        else
            return;
    }

    static boolean a(OpenSslEngine opensslengine) {
        return opensslengine.m();
    }

    private int b(ByteBuffer bytebuffer) {
        int i1;
        int k1;
        k1 = bytebuffer.position();
        i1 = bytebuffer.remaining();
        if (!bytebuffer.isDirect()) goto _L2; else goto _L1
_L1:
        long l1 = Buffer.address(bytebuffer);
        long l3 = k1;
        int j1 = SSL.writeToBIO(x, l1 + l3, i1);
        i1 = j1;
        if (j1 >= 0) {
            bytebuffer.position(k1 + j1);
            i1 = j1;
        }
_L4:
        return i1;
_L2:
        h h1 = L.d(i1);
        long l2 = io.netty.handler.ssl.r.a(h1);
        h1.b(0, bytebuffer);
        i1 = SSL.writeToBIO(x, l2, i1);
        if (i1 < 0)
            break; /* Loop/switch isn't completed */
        bytebuffer.position(k1 + i1);
_L5:
        h1.B();
        if (true) goto _L4; else goto _L3
_L3:
        bytebuffer.position(k1);
          goto _L5
        bytebuffer;
        h1.B();
        throw bytebuffer;
    }

    static long b(OpenSslEngine opensslengine) {
        return opensslengine.w;
    }

    private String b(String s1) {
        if (s1 == null)
            s1 = null;
        else
            s1 = io.netty.handler.ssl.c.a(s1, c(SSL.getVersion(w)));
        return s1;
    }

    private javax.net.ssl.SSLEngineResult.HandshakeStatus b(int i1) {
        javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus;
        if (l())
            handshakestatus = a(i1);
        else
            handshakestatus = javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
        return handshakestatus;
    }

    private int c(ByteBuffer bytebuffer) {
        if (!bytebuffer.isDirect()) goto _L2; else goto _L1
_L1:
        int i1;
        int l1 = bytebuffer.position();
        long l4 = Buffer.address(bytebuffer);
        long l2 = l1;
        i1 = bytebuffer.limit();
        int j1 = SSL.readFromSSL(w, l4 + l2, i1 - l1);
        i1 = j1;
        if (j1 > 0) {
            bytebuffer.position(l1 + j1);
            i1 = j1;
        }
_L4:
        return i1;
_L2:
        int k1;
        int i2;
        h h1;
        k1 = bytebuffer.position();
        i2 = bytebuffer.limit();
        i1 = Math.min(18713, i2 - k1);
        h1 = L.d(i1);
        long l3 = io.netty.handler.ssl.r.a(h1);
        i1 = SSL.readFromSSL(w, l3, i1);
        if (i1 <= 0)
            break MISSING_BLOCK_LABEL_144;
        bytebuffer.limit(k1 + i1);
        h1.a(0, bytebuffer);
        bytebuffer.limit(i2);
        h1.B();
        if (true) goto _L4; else goto _L3
_L3:
        bytebuffer;
        h1.B();
        throw bytebuffer;
    }

    static long c(OpenSslEngine opensslengine) {
        return opensslengine.D;
    }

    private static String c(String s1) {
        boolean flag = false;
        int i1 = ((flag) ? 1 : 0);
        if (s1 != null)
            if (s1.length() == 0)
                i1 = ((flag) ? 1 : 0);
            else
                i1 = s1.charAt(0);
        i1;
        JVM INSTR tableswitch 83 84: default 40
    //                   83 62
    //                   84 55;
           goto _L1 _L2 _L3
_L1:
        s1 = "UNKNOWN";
_L5:
        return s1;
_L3:
        s1 = "TLS";
        continue; /* Loop/switch isn't completed */
_L2:
        s1 = "SSL";
        if (true) goto _L5; else goto _L4
_L4:
    }

    static Certificate[] c() {
        return d;
    }

    static boolean d(OpenSslEngine opensslengine) {
        return opensslengine.K;
    }

    private ByteBuffer[] d(ByteBuffer bytebuffer) {
        R[0] = bytebuffer;
        return R;
    }

    static X509Certificate[] d() {
        return e;
    }

    private int e() {
        int i1;
        if (z == HandshakeState.d)
            i1 = SSL.pendingReadableBytesInSSL(w);
        else
            i1 = 0;
        return i1;
    }

    static s e(OpenSslEngine opensslengine) {
        return opensslengine.N;
    }

    private ByteBuffer[] e(ByteBuffer bytebuffer) {
        S[0] = bytebuffer;
        return S;
    }

    private void f() {
        A = true;
        closeOutbound();
        closeInbound();
    }

    static Certificate[] f(OpenSslEngine opensslengine) {
        return opensslengine.Q;
    }

    private void g() {
        if (O && SSL.getHandshakeCount(w) > 1) {
            b();
            throw new SSLHandshakeException("remote-initiated renegotation not allowed");
        } else {
            return;
        }
    }

    private void h() {
        R[0] = null;
    }

    private void i() {
        S[0] = null;
    }

    private javax.net.ssl.SSLEngineResult.HandshakeStatus j() {
        if (z != HandshakeState.d) goto _L2; else goto _L1
_L1:
        Object obj = javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED;
_L4:
        return ((javax.net.ssl.SSLEngineResult.HandshakeStatus) (obj));
_L2:
        a(g);
        obj = a;
        if (obj == null)
            break; /* Loop/switch isn't completed */
        if (SSL.pendingWrittenBytesInBIO(x) > 0) {
            obj = javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP;
        } else {
            a = null;
            b();
            throw obj;
        }
        if (true) goto _L4; else goto _L3
_L3:
        M.a(this);
        if (D == -1L)
            D = System.currentTimeMillis();
        if (!y && T != null) {
            y = true;
            T.a(this);
        }
        int i1 = SSL.doHandshake(w);
        if (i1 <= 0) {
            if (a != null) {
                obj = a;
                a = null;
                b();
                throw obj;
            }
            switch (SSL.getError(w, i1)) {
            default:
                throw a("SSL_do_handshake");

            case 2: // '\002'
            case 3: // '\003'
                obj = a(SSL.pendingWrittenBytesInBIO(x));
                break;
            }
        } else {
            P.a();
            M.a(w);
            obj = javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED;
        }
        if (true) goto _L4; else goto _L5
_L5:
    }

    private javax.net.ssl.SSLEngineResult.Status k() {
        javax.net.ssl.SSLEngineResult.Status status;
        if (J)
            status = javax.net.ssl.SSLEngineResult.Status.CLOSED;
        else
            status = javax.net.ssl.SSLEngineResult.Status.OK;
        return status;
    }

    private boolean l() {
        boolean flag;
        if (z != HandshakeState.a && !m() && (z != HandshakeState.d || J))
            flag = true;
        else
            flag = false;
        return flag;
    }

    private boolean m() {
        boolean flag;
        if (B != 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public long a() {
        this;
        JVM INSTR monitorenter ;
        long l1 = w;
        this;
        JVM INSTR monitorexit ;
        return l1;
        Exception exception;
        exception;
        throw exception;
    }

    public SSLEngineResult a(ByteBuffer abytebuffer[], int i1, int j1, ByteBuffer abytebuffer1[], int k1, int l1) {
        int j2;
        int k2;
        long l3;
        long l5;
        if (abytebuffer == null)
            throw new NullPointerException("srcs");
        if (i1 >= abytebuffer.length || i1 + j1 > abytebuffer.length)
            throw new IndexOutOfBoundsException((new StringBuilder()).append("offset: ").append(i1).append(", length: ").append(j1).append(" (expected: offset <= offset + length <= srcs.length (").append(abytebuffer.length).append("))").toString());
        if (abytebuffer1 == null)
            throw new IllegalArgumentException("dsts is null");
        if (k1 >= abytebuffer1.length || k1 + l1 > abytebuffer1.length)
            throw new IndexOutOfBoundsException((new StringBuilder()).append("offset: ").append(k1).append(", length: ").append(l1).append(" (expected: offset <= offset + length <= dsts.length (").append(abytebuffer1.length).append("))").toString());
        j2 = k1 + l1;
        l3 = 0L;
        for (l1 = k1; l1 < j2;) {
            ByteBuffer bytebuffer = abytebuffer1[l1];
            if (bytebuffer == null)
                throw new IllegalArgumentException((new StringBuilder()).append("dsts[").append(l1).append("] is null").toString());
            if (bytebuffer.isReadOnly())
                throw new ReadOnlyBufferException();
            long l4 = bytebuffer.remaining();
            l1++;
            l3 = l4 + l3;
        }

        k2 = i1 + j1;
        l5 = 0L;
        for (j1 = i1; j1 < k2; j1++) {
            ByteBuffer bytebuffer1 = abytebuffer[j1];
            if (bytebuffer1 == null)
                throw new IllegalArgumentException((new StringBuilder()).append("srcs[").append(j1).append("] is null").toString());
            l5 += bytebuffer1.remaining();
        }

        this;
        JVM INSTR monitorenter ;
        if (!m()) goto _L2; else goto _L1
_L1:
        abytebuffer = v;
        this;
        JVM INSTR monitorexit ;
_L7:
        return abytebuffer;
_L2:
        if (l5 <= 18713L)
            break MISSING_BLOCK_LABEL_413;
        H = true;
        I = true;
        J = true;
        b();
        throw i;
        abytebuffer;
        this;
        JVM INSTR monitorexit ;
        throw abytebuffer;
        javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus = javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
        if (z == HandshakeState.d) goto _L4; else goto _L3
_L3:
        if (z != io.netty.handler.ssl.HandshakeState.c)
            z = io.netty.handler.ssl.HandshakeState.b;
        handshakestatus = j();
        if (handshakestatus != javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP) goto _L6; else goto _L5
_L5:
        abytebuffer = t;
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L6:
        if (!J) goto _L4; else goto _L8
_L8:
        abytebuffer = u;
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L4:
        int i2;
        j1 = 0;
        i2 = 0;
        if (i1 >= k2) goto _L10; else goto _L9
_L9:
        l1 = i1;
        i1 = i2;
_L31:
        Object obj = abytebuffer[l1];
        int l2 = ((ByteBuffer) (obj)).remaining();
        if (l2 != 0) goto _L12; else goto _L11
_L11:
        j1 = l1 + 1;
_L20:
        if (j1 < k2)
            break MISSING_BLOCK_LABEL_877;
        j1 = i1;
_L10:
        i1 = 0;
        if (l3 <= 0L) goto _L14; else goto _L13
_L13:
        if (k1 >= j2) goto _L16; else goto _L15
_L15:
        abytebuffer = abytebuffer1[k1];
        if (abytebuffer.hasRemaining()) goto _L18; else goto _L17
_L17:
        k1++;
          goto _L13
_L12:
        i2 = b(((ByteBuffer) (obj)));
        if (i2 <= 0)
            break MISSING_BLOCK_LABEL_602;
        i1 += i2;
        j1 = i1;
        if (i2 != l2) goto _L10; else goto _L19
_L19:
        j1 = l1 + 1;
          goto _L20
        SSL.clearError();
        j1 = i1;
          goto _L10
_L18:
        l1 = c(abytebuffer);
        g();
        if (l1 <= 0) goto _L22; else goto _L21
_L21:
        i1 += l1;
        if (abytebuffer.hasRemaining())
            break MISSING_BLOCK_LABEL_644;
        k1++;
          goto _L13
        abytebuffer = a(j1, i1, handshakestatus);
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L22:
        SSL.getError(w, l1);
        JVM INSTR tableswitch 2 6: default 700
    //                   2 726
    //                   3 726
    //                   4 700
    //                   5 700
    //                   6 715;
           goto _L23 _L24 _L24 _L23 _L23 _L25
_L24:
        break; /* Loop/switch isn't completed */
_L23:
        abytebuffer = a(SSL.getLastErrorNumber(), j1, i1);
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L25:
        if (!A)
            f();
        abytebuffer = a(j1, i1, handshakestatus);
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L16:
        if (e() <= 0) goto _L27; else goto _L26
_L26:
        abytebuffer1 = JVM INSTR new #255 <Class SSLEngineResult>;
        obj = javax.net.ssl.SSLEngineResult.Status.BUFFER_OVERFLOW;
        abytebuffer = handshakestatus;
        if (handshakestatus != javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED)
            abytebuffer = getHandshakeStatus();
        abytebuffer1.SSLEngineResult(((javax.net.ssl.SSLEngineResult.Status) (obj)), a(((javax.net.ssl.SSLEngineResult.HandshakeStatus) (abytebuffer))), j1, i1);
        this;
        JVM INSTR monitorexit ;
        abytebuffer = abytebuffer1;
          goto _L7
_L14:
        if (SSL.readFromSSL(w, q, 0) > 0) goto _L29; else goto _L28
_L28:
        i1 = SSL.getLastErrorNumber();
        if (!io.netty.handler.ssl.r.a(i1)) goto _L29; else goto _L30
_L30:
        abytebuffer = a(i1, j1, 0);
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L27:
        if (!A && (SSL.getShutdown(w) & 2) == 2)
            f();
        abytebuffer = a(j1, i1, handshakestatus);
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L29:
        i1 = 0;
          goto _L16
        l1 = j1;
          goto _L31
    }

    public SSLEngineResult a(ByteBuffer abytebuffer[], ByteBuffer abytebuffer1[]) {
        return a(abytebuffer, 0, abytebuffer.length, abytebuffer1, 0, abytebuffer1.length);
    }

    public void b() {
        this;
        JVM INSTR monitorenter ;
        if (p.compareAndSet(this, 0, 1)) {
            M.a(w);
            SSL.freeSSL(w);
            SSL.freeBIO(x);
            x = 0L;
            w = 0L;
            J = true;
            I = true;
            H = true;
        }
        SSL.clearError();
        this;
        JVM INSTR monitorexit ;
        return;
        Exception exception;
        exception;
        throw exception;
    }

    public void beginHandshake() {
        this;
        JVM INSTR monitorenter ;
        _cls1.a[z.ordinal()];
        JVM INSTR tableswitch 1 4: default 44
    //                   1 134
    //                   2 76
    //                   3 59
    //                   4 73;
           goto _L1 _L2 _L3 _L4 _L5
_L1:
        Error error = JVM INSTR new #717 <Class Error>;
        error.Error();
        throw error;
        Exception exception;
        exception;
        this;
        JVM INSTR monitorexit ;
        throw exception;
_L4:
        a(f);
        z = io.netty.handler.ssl.HandshakeState.c;
_L5:
        this;
        JVM INSTR monitorexit ;
        return;
_L3:
        if (K)
            throw h;
        if (SSL.renegotiate(w) != 1 || SSL.doHandshake(w) != 1)
            throw a("renegotiation failed");
        SSL.setState(w, 8192);
        D = System.currentTimeMillis();
_L2:
        z = io.netty.handler.ssl.HandshakeState.c;
        j();
          goto _L5
    }

    public void closeInbound() {
        this;
        JVM INSTR monitorenter ;
        boolean flag = H;
        if (!flag) goto _L2; else goto _L1
_L1:
        this;
        JVM INSTR monitorexit ;
        return;
_L2:
        H = true;
        J = true;
        b();
        if (z == HandshakeState.a || A) goto _L1; else goto _L3
_L3:
        SSLException sslexception = JVM INSTR new #112 <Class SSLException>;
        sslexception.SSLException("Inbound closed before receiving peer's close_notify: possible truncation attack?");
        throw sslexception;
        Exception exception;
        exception;
        this;
        JVM INSTR monitorexit ;
        throw exception;
    }

    public void closeOutbound() {
        this;
        JVM INSTR monitorenter ;
        boolean flag = I;
        if (!flag) goto _L2; else goto _L1
_L1:
        this;
        JVM INSTR monitorexit ;
        return;
_L2:
        I = true;
        J = true;
        if (z == HandshakeState.a || m()) goto _L4; else goto _L3
_L3:
        if ((SSL.getShutdown(w) & 1) == 1) goto _L1; else goto _L5
_L5:
        int i1 = SSL.shutdownSSL(w);
        if (i1 >= 0) goto _L1; else goto _L6
_L6:
        SSL.getError(w, i1);
        JVM INSTR tableswitch 0 8: default 124
    //                   0 11
    //                   1 135
    //                   2 11
    //                   3 11
    //                   4 11
    //                   5 135
    //                   6 11
    //                   7 11
    //                   8 11;
           goto _L7 _L8 _L9 _L8 _L8 _L8 _L9 _L8 _L8 _L8
_L8:
        if (true) goto _L1; else goto _L10
_L10:
_L7:
        SSL.clearError();
          goto _L1
        Exception exception;
        exception;
        throw exception;
_L9:
        if (c.b())
            c.b("SSL_shutdown failed: OpenSSL error: {}", SSL.getLastError());
        b();
          goto _L1
_L4:
        b();
          goto _L1
    }

    protected void finalize() {
        super.finalize();
        b();
    }

    public Runnable getDelegatedTask() {
        return null;
    }

    public boolean getEnableSessionCreation() {
        return false;
    }

    public String[] getEnabledCipherSuites() {
        this;
        JVM INSTR monitorenter ;
        Object obj;
        if (m())
            break MISSING_BLOCK_LABEL_29;
        obj = SSL.getCiphers(w);
        this;
        JVM INSTR monitorexit ;
        if (obj == null) {
            obj = io.netty.util.internal.c.k;
        } else {
            int i1 = 0;
            while (i1 < obj.length)  {
                String s1 = b(obj[i1]);
                if (s1 != null)
                    obj[i1] = s1;
                i1++;
            }
        }
        return ((String []) (obj));
        obj = io.netty.util.internal.c.k;
        this;
        JVM INSTR monitorexit ;
        if (false)
            ;
        else
            break MISSING_BLOCK_LABEL_27;
        obj;
        this;
        JVM INSTR monitorexit ;
        throw obj;
    }

    public String[] getEnabledProtocols() {
        String as[];
        as = io.netty.util.internal.e.b().h();
        as.add("SSLv2Hello");
        this;
        JVM INSTR monitorenter ;
        if (m()) goto _L2; else goto _L1
_L1:
        int i1 = SSL.getOptions(w);
        this;
        JVM INSTR monitorexit ;
        if ((0x4000000 & i1) == 0)
            as.add("TLSv1");
        if ((0x10000000 & i1) == 0)
            as.add("TLSv1.1");
        if ((0x8000000 & i1) == 0)
            as.add("TLSv1.2");
        if ((0x1000000 & i1) == 0)
            as.add("SSLv2");
        if ((i1 & 0x2000000) == 0)
            as.add("SSLv3");
        as = (String[])as.toArray(new String[as.size()]);
_L4:
        return as;
_L2:
        as = (String[])as.toArray(new String[1]);
        this;
        JVM INSTR monitorexit ;
        if (true) goto _L4; else goto _L3
_L3:
        Exception exception;
        exception;
        this;
        JVM INSTR monitorexit ;
        throw exception;
    }

    public SSLSession getHandshakeSession() {
        this;
        JVM INSTR monitorenter ;
        _cls1.a[z.ordinal()];
        JVM INSTR tableswitch 1 2: default 36
    //                   1 45
    //                   2 45;
           goto _L1 _L2 _L2
_L1:
        a a1 = P;
_L3:
        this;
        JVM INSTR monitorexit ;
        return a1;
_L2:
        a1 = null;
          goto _L3
        Exception exception;
        exception;
        throw exception;
    }

    public javax.net.ssl.SSLEngineResult.HandshakeStatus getHandshakeStatus() {
        this;
        JVM INSTR monitorenter ;
        javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus;
        if (!l())
            break MISSING_BLOCK_LABEL_24;
        handshakestatus = a(SSL.pendingWrittenBytesInBIO(x));
_L1:
        this;
        JVM INSTR monitorexit ;
        return handshakestatus;
        handshakestatus = javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
          goto _L1
        Exception exception;
        exception;
        throw exception;
    }

    public boolean getNeedClientAuth() {
        boolean flag;
        if (C == io.netty.handler.ssl.ClientAuth.c)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public SSLParameters getSSLParameters() {
        boolean flag = true;
        this;
        JVM INSTR monitorenter ;
        int i1;
        SSLParameters sslparameters;
        sslparameters = super.getSSLParameters();
        i1 = PlatformDependent.d();
        if (i1 < 7)
            break MISSING_BLOCK_LABEL_134;
        sslparameters.setEndpointIdentificationAlgorithm(E);
        al.a(sslparameters, F);
        if (i1 < 8)
            break MISSING_BLOCK_LABEL_134;
        Object obj1;
        if (l == null)
            break MISSING_BLOCK_LABEL_81;
        obj1 = G;
        if (obj1 == null)
            break MISSING_BLOCK_LABEL_81;
        l.invoke(sslparameters, new Object[] {
            G
        });
        boolean flag1;
        if (o == null)
            break MISSING_BLOCK_LABEL_134;
        flag1 = m();
        if (flag1)
            break MISSING_BLOCK_LABEL_134;
        obj1 = o;
        Object obj;
        if ((SSL.getOptions(w) & 0x400000) == 0)
            flag = false;
        ((Method) (obj1)).invoke(sslparameters, new Object[] {
            Boolean.valueOf(flag)
        });
        this;
        JVM INSTR monitorexit ;
        return sslparameters;
        obj;
        Error error = JVM INSTR new #717 <Class Error>;
        error.Error(((Throwable) (obj)));
        throw error;
        obj;
        this;
        JVM INSTR monitorexit ;
        throw obj;
        obj;
        Error error1 = JVM INSTR new #717 <Class Error>;
        error1.Error(((Throwable) (obj)));
        throw error1;
        obj;
        Error error2 = JVM INSTR new #717 <Class Error>;
        error2.Error(((Throwable) (obj)));
        throw error2;
        obj;
        Error error3 = JVM INSTR new #717 <Class Error>;
        error3.Error(((Throwable) (obj)));
        throw error3;
    }

    public SSLSession getSession() {
        return P;
    }

    public String[] getSupportedCipherSuites() {
        return (String[])r.a.toArray(new String[r.a.size()]);
    }

    public String[] getSupportedProtocols() {
        return (String[])io.netty.handler.ssl.r.b.toArray(new String[io.netty.handler.ssl.r.b.size()]);
    }

    public boolean getUseClientMode() {
        return K;
    }

    public boolean getWantClientAuth() {
        boolean flag;
        if (C == io.netty.handler.ssl.ClientAuth.b)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean isInboundDone() {
        this;
        JVM INSTR monitorenter ;
        if (H) goto _L2; else goto _L1
_L1:
        boolean flag = J;
        if (!flag) goto _L3; else goto _L2
_L2:
        flag = true;
_L5:
        this;
        JVM INSTR monitorexit ;
        return flag;
_L3:
        flag = false;
        if (true) goto _L5; else goto _L4
_L4:
        Exception exception;
        exception;
        throw exception;
    }

    public boolean isOutboundDone() {
        this;
        JVM INSTR monitorenter ;
        boolean flag = I;
        this;
        JVM INSTR monitorexit ;
        return flag;
        Exception exception;
        exception;
        throw exception;
    }

    public void setEnableSessionCreation(boolean flag) {
        if (flag)
            throw new UnsupportedOperationException();
        else
            return;
    }

    public void setEnabledCipherSuites(String as[]) {
        StringBuilder stringbuilder2;
        io.netty.util.internal.k.a(as, "cipherSuites");
        stringbuilder2 = new StringBuilder();
        int j1 = as.length;
        int i1 = 0;
label0:
        do {
            String s2;
label1:
            {
                if (i1 < j1) {
                    s2 = as[i1];
                    if (s2 != null)
                        break label1;
                }
                if (stringbuilder2.length() == 0)
                    throw new IllegalArgumentException("empty cipher suites");
                break label0;
            }
            String s3 = io.netty.handler.ssl.c.a(s2);
            String s1 = s3;
            if (s3 == null)
                s1 = s2;
            if (!io.netty.handler.ssl.r.a(s1))
                throw new IllegalArgumentException((new StringBuilder()).append("unsupported cipher suite: ").append(s2).append('(').append(s1).append(')').toString());
            stringbuilder2.append(s1);
            stringbuilder2.append(':');
            i1++;
        } while (true);
        stringbuilder2.setLength(stringbuilder2.length() - 1);
        as = stringbuilder2.toString();
        this;
        JVM INSTR monitorenter ;
        boolean flag = m();
        if (flag)
            break MISSING_BLOCK_LABEL_240;
        SSL.setCipherSuites(w, as);
        this;
        JVM INSTR monitorexit ;
        return;
        Exception exception;
        exception;
        IllegalStateException illegalstateexception1 = JVM INSTR new #876 <Class IllegalStateException>;
        StringBuilder stringbuilder = JVM INSTR new #624 <Class StringBuilder>;
        stringbuilder.StringBuilder();
        illegalstateexception1.IllegalStateException(stringbuilder.append("failed to enable cipher suites: ").append(as).toString(), exception);
        throw illegalstateexception1;
        as;
        this;
        JVM INSTR monitorexit ;
        throw as;
        IllegalStateException illegalstateexception = JVM INSTR new #876 <Class IllegalStateException>;
        StringBuilder stringbuilder1 = JVM INSTR new #624 <Class StringBuilder>;
        stringbuilder1.StringBuilder();
        illegalstateexception.IllegalStateException(stringbuilder1.append("failed to enable cipher suites: ").append(as).toString());
        throw illegalstateexception;
    }

    public void setEnabledProtocols(String as[]) {
        boolean flag;
        boolean flag1;
        boolean flag2;
        boolean flag3;
        boolean flag4;
        if (as == null)
            throw new IllegalArgumentException();
        int l1 = as.length;
        int i1 = 0;
        flag3 = false;
        flag1 = false;
        flag2 = false;
        flag4 = false;
        flag = false;
        while (i1 < l1)  {
            String s1 = as[i1];
            if (!io.netty.handler.ssl.r.b.contains(s1))
                throw new IllegalArgumentException((new StringBuilder()).append("Protocol ").append(s1).append(" is not supported.").toString());
            boolean flag5;
            boolean flag6;
            boolean flag7;
            boolean flag8;
            if (s1.equals("SSLv2")) {
                flag8 = true;
                flag7 = flag4;
                flag6 = flag2;
                flag5 = flag1;
            } else
            if (s1.equals("SSLv3")) {
                flag7 = true;
                flag5 = flag1;
                flag6 = flag2;
                flag8 = flag;
            } else
            if (s1.equals("TLSv1")) {
                flag6 = true;
                flag5 = flag1;
                flag7 = flag4;
                flag8 = flag;
            } else
            if (s1.equals("TLSv1.1")) {
                flag5 = true;
                flag6 = flag2;
                flag7 = flag4;
                flag8 = flag;
            } else {
                flag5 = flag1;
                flag6 = flag2;
                flag7 = flag4;
                flag8 = flag;
                if (s1.equals("TLSv1.2")) {
                    flag3 = true;
                    flag5 = flag1;
                    flag6 = flag2;
                    flag7 = flag4;
                    flag8 = flag;
                }
            }
            i1++;
            flag1 = flag5;
            flag2 = flag6;
            flag4 = flag7;
            flag = flag8;
        }
        this;
        JVM INSTR monitorenter ;
        if (m())
            break MISSING_BLOCK_LABEL_367;
        SSL.setOptions(w, 4095);
        SSL.clearOptions(w, 0x1f000000);
        int j1;
        int k1;
        StringBuilder stringbuilder;
        IllegalStateException illegalstateexception;
        if (!flag)
            k1 = 0x1000000;
        else
            k1 = 0;
        j1 = k1;
        if (!flag4)
            j1 = k1 | 0x2000000;
        k1 = j1;
        if (!flag2)
            k1 = j1 | 0x4000000;
        j1 = k1;
        if (!flag1)
            j1 = k1 | 0x10000000;
        if (!flag3)
            j1 = 0x8000000 | j1;
        SSL.setOptions(w, j1);
        this;
        JVM INSTR monitorexit ;
        return;
        illegalstateexception = JVM INSTR new #876 <Class IllegalStateException>;
        stringbuilder = JVM INSTR new #624 <Class StringBuilder>;
        stringbuilder.StringBuilder();
        illegalstateexception.IllegalStateException(stringbuilder.append("failed to enable protocols: ").append(Arrays.asList(as)).toString());
        throw illegalstateexception;
        as;
        this;
        JVM INSTR monitorexit ;
        throw as;
    }

    public void setNeedClientAuth(boolean flag) {
        ClientAuth clientauth;
        if (flag)
            clientauth = io.netty.handler.ssl.ClientAuth.c;
        else
            clientauth = ClientAuth.a;
        a(clientauth);
    }

    public void setSSLParameters(SSLParameters sslparameters) {
        this;
        JVM INSTR monitorenter ;
        int i1;
        super.setSSLParameters(sslparameters);
        i1 = PlatformDependent.d();
        if (i1 < 7)
            break MISSING_BLOCK_LABEL_323;
        E = sslparameters.getEndpointIdentificationAlgorithm();
        F = sslparameters.getAlgorithmConstraints();
        if (i1 < 8)
            break MISSING_BLOCK_LABEL_323;
        if (j == null || !K || m())
            break MISSING_BLOCK_LABEL_278;
        if (!b && k == null) {
            sslparameters = JVM INSTR new #926 <Class AssertionError>;
            sslparameters.AssertionError();
            throw sslparameters;
        }
        break MISSING_BLOCK_LABEL_86;
        sslparameters;
        this;
        JVM INSTR monitorexit ;
        throw sslparameters;
        if (!b && m == null) {
            sslparameters = JVM INSTR new #926 <Class AssertionError>;
            sslparameters.AssertionError();
            throw sslparameters;
        }
        List list = (List)k.invoke(sslparameters, new Object[0]);
        if (list == null)
            break MISSING_BLOCK_LABEL_272;
        Object obj;
        Iterator iterator = list.iterator();
        do {
            if (!iterator.hasNext())
                break MISSING_BLOCK_LABEL_272;
            obj = iterator.next();
            if (!j.isInstance(obj))
                break;
            SSL.setTlsExtHostName(w, (String)m.invoke(obj, new Object[0]));
        } while (true);
        break MISSING_BLOCK_LABEL_207;
        obj;
        sslparameters = JVM INSTR new #717 <Class Error>;
        sslparameters.Error(((Throwable) (obj)));
        throw sslparameters;
        sslparameters = JVM INSTR new #646 <Class IllegalArgumentException>;
        StringBuilder stringbuilder = JVM INSTR new #624 <Class StringBuilder>;
        stringbuilder.StringBuilder();
        sslparameters.IllegalArgumentException(stringbuilder.append("Only ").append(j.getName()).append(" instances are supported, but found: ").append(obj).toString());
        throw sslparameters;
        InvocationTargetException invocationtargetexception;
        invocationtargetexception;
        sslparameters = JVM INSTR new #717 <Class Error>;
        sslparameters.Error(invocationtargetexception);
        throw sslparameters;
        G = list;
        boolean flag;
        if (n == null)
            break MISSING_BLOCK_LABEL_323;
        flag = m();
        if (flag)
            break MISSING_BLOCK_LABEL_323;
        if (!((Boolean)n.invoke(sslparameters, new Object[0])).booleanValue())
            break MISSING_BLOCK_LABEL_326;
        SSL.setOptions(w, 0x400000);
_L1:
        this;
        JVM INSTR monitorexit ;
        return;
        SSL.clearOptions(w, 0x400000);
          goto _L1
        sslparameters;
        Error error = JVM INSTR new #717 <Class Error>;
        error.Error(sslparameters);
        throw error;
        sslparameters;
        Error error1 = JVM INSTR new #717 <Class Error>;
        error1.Error(sslparameters);
        throw error1;
    }

    public void setUseClientMode(boolean flag) {
        if (flag != K)
            throw new UnsupportedOperationException();
        else
            return;
    }

    public void setWantClientAuth(boolean flag) {
        ClientAuth clientauth;
        if (flag)
            clientauth = io.netty.handler.ssl.ClientAuth.b;
        else
            clientauth = ClientAuth.a;
        a(clientauth);
    }

    public SSLEngineResult unwrap(ByteBuffer bytebuffer, ByteBuffer bytebuffer1) {
        this;
        JVM INSTR monitorenter ;
        bytebuffer = a(d(bytebuffer), e(bytebuffer1));
        h();
        i();
        this;
        JVM INSTR monitorexit ;
        return bytebuffer;
        bytebuffer;
        h();
        i();
        throw bytebuffer;
        bytebuffer;
        this;
        JVM INSTR monitorexit ;
        throw bytebuffer;
    }

    public SSLEngineResult unwrap(ByteBuffer bytebuffer, ByteBuffer abytebuffer[]) {
        this;
        JVM INSTR monitorenter ;
        bytebuffer = a(d(bytebuffer), abytebuffer);
        h();
        this;
        JVM INSTR monitorexit ;
        return bytebuffer;
        bytebuffer;
        h();
        throw bytebuffer;
        bytebuffer;
        this;
        JVM INSTR monitorexit ;
        throw bytebuffer;
    }

    public SSLEngineResult unwrap(ByteBuffer bytebuffer, ByteBuffer abytebuffer[], int i1, int j1) {
        this;
        JVM INSTR monitorenter ;
        bytebuffer = a(d(bytebuffer), 0, 1, abytebuffer, i1, j1);
        h();
        this;
        JVM INSTR monitorexit ;
        return bytebuffer;
        bytebuffer;
        h();
        throw bytebuffer;
        bytebuffer;
        this;
        JVM INSTR monitorexit ;
        throw bytebuffer;
    }

    public SSLEngineResult wrap(ByteBuffer bytebuffer, ByteBuffer bytebuffer1) {
        this;
        JVM INSTR monitorenter ;
        bytebuffer = wrap(d(bytebuffer), bytebuffer1);
        h();
        this;
        JVM INSTR monitorexit ;
        return bytebuffer;
        bytebuffer;
        h();
        throw bytebuffer;
        bytebuffer;
        this;
        JVM INSTR monitorexit ;
        throw bytebuffer;
    }

    public SSLEngineResult wrap(ByteBuffer abytebuffer[], int i1, int j1, ByteBuffer bytebuffer) {
        int i2;
        i2 = 0;
        if (abytebuffer == null)
            throw new IllegalArgumentException("srcs is null");
        if (bytebuffer == null)
            throw new IllegalArgumentException("dst is null");
        if (i1 >= abytebuffer.length || i1 + j1 > abytebuffer.length)
            throw new IndexOutOfBoundsException((new StringBuilder()).append("offset: ").append(i1).append(", length: ").append(j1).append(" (expected: offset <= offset + length <= srcs.length (").append(abytebuffer.length).append("))").toString());
        if (bytebuffer.isReadOnly())
            throw new ReadOnlyBufferException();
        this;
        JVM INSTR monitorenter ;
        if (!m()) goto _L2; else goto _L1
_L1:
        abytebuffer = v;
        this;
        JVM INSTR monitorexit ;
_L7:
        return abytebuffer;
_L2:
        javax.net.ssl.SSLEngineResult.HandshakeStatus handshakestatus = javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
        if (z == HandshakeState.d) goto _L4; else goto _L3
_L3:
        if (z != io.netty.handler.ssl.HandshakeState.c)
            z = io.netty.handler.ssl.HandshakeState.b;
        handshakestatus = j();
        if (handshakestatus != javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP) goto _L6; else goto _L5
_L5:
        abytebuffer = r;
        this;
        JVM INSTR monitorexit ;
          goto _L7
        abytebuffer;
        this;
        JVM INSTR monitorexit ;
        throw abytebuffer;
_L6:
        if (!J) goto _L4; else goto _L8
_L8:
        abytebuffer = s;
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L4:
        int k1;
        int l1;
        k1 = 0;
        l1 = i1;
_L28:
        if (l1 >= i1 + j1) goto _L10; else goto _L9
_L9:
        ByteBuffer bytebuffer1 = abytebuffer[l1];
        if (bytebuffer1 != null) goto _L12; else goto _L11
_L11:
        abytebuffer = JVM INSTR new #646 <Class IllegalArgumentException>;
        bytebuffer = JVM INSTR new #624 <Class StringBuilder>;
        bytebuffer.StringBuilder();
        abytebuffer.IllegalArgumentException(bytebuffer.append("srcs[").append(l1).append("] is null").toString());
        throw abytebuffer;
_L17:
        SSLEngineResult sslengineresult;
        k1 = sslengineresult.bytesProduced();
_L12:
        if (!bytebuffer1.hasRemaining()) goto _L14; else goto _L13
_L13:
        int j2 = a(bytebuffer1);
        if (j2 <= 0)
            break MISSING_BLOCK_LABEL_352;
        i2 = j2 + i2;
        sslengineresult = a(bytebuffer, i2, k1, handshakestatus);
        if (sslengineresult == null) goto _L12; else goto _L15
_L15:
        if (sslengineresult.getStatus() == javax.net.ssl.SSLEngineResult.Status.OK) goto _L17; else goto _L16
_L16:
        this;
        JVM INSTR monitorexit ;
        abytebuffer = sslengineresult;
          goto _L7
        SSL.getError(w, j2);
        JVM INSTR tableswitch 2 6: default 396
    //                   2 444
    //                   3 488
    //                   4 396
    //                   5 396
    //                   6 404;
           goto _L18 _L19 _L20 _L18 _L18 _L21
_L18:
        throw a("SSL_write");
_L21:
        if (!A)
            f();
        abytebuffer = a(bytebuffer, i2, k1, handshakestatus);
        if (abytebuffer == null) goto _L23; else goto _L22
_L22:
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L23:
        abytebuffer = v;
          goto _L22
_L19:
        abytebuffer = a(bytebuffer, i2, k1, handshakestatus);
        if (abytebuffer == null) goto _L25; else goto _L24
_L24:
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L25:
        abytebuffer = new SSLEngineResult(k(), javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP, i2, k1);
          goto _L24
_L20:
        abytebuffer = a(bytebuffer, i2, k1, handshakestatus);
        if (abytebuffer == null) goto _L27; else goto _L26
_L26:
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L27:
        abytebuffer = u;
          goto _L26
_L14:
        l1++;
          goto _L28
_L10:
        if (i2 != 0) goto _L30; else goto _L29
_L29:
        abytebuffer = a(bytebuffer, 0, k1, handshakestatus);
        if (abytebuffer == null) goto _L30; else goto _L31
_L31:
        this;
        JVM INSTR monitorexit ;
          goto _L7
_L30:
        abytebuffer = a(i2, k1, handshakestatus);
        this;
        JVM INSTR monitorexit ;
          goto _L7
    }

    static  {
        Object obj;
        Object obj1;
        Object obj2;
        Object obj3;
        Object obj4;
        boolean flag = true;
        Method method1 = null;
        Method method;
        Method method2;
        List list;
        if (io/netty/handler/ssl/OpenSslEngine.desiredAssertionStatus())
            flag = false;
        b = flag;
        c = io.netty.util.internal.logging.c.a(io/netty/handler/ssl/OpenSslEngine);
        d = io.netty.util.internal.c.n;
        e = io.netty.util.internal.c.p;
        f = (SSLException)io.netty.util.internal.o.a(new SSLException("engine closed"), io/netty/handler/ssl/OpenSslEngine, "beginHandshake()");
        g = (SSLException)io.netty.util.internal.o.a(new SSLException("engine closed"), io/netty/handler/ssl/OpenSslEngine, "handshake()");
        h = (SSLException)io.netty.util.internal.o.a(new SSLException("renegotiation unsupported"), io/netty/handler/ssl/OpenSslEngine, "beginHandshake()");
        i = (SSLException)io.netty.util.internal.o.a(new SSLException("encrypted packet oversized"), io/netty/handler/ssl/OpenSslEngine, "unwrap(...)");
        obj1 = PlatformDependent.b(io/netty/handler/ssl/OpenSslEngine, "B");
        obj = obj1;
        if (obj1 == null)
            obj = AtomicIntegerFieldUpdater.newUpdater(io/netty/handler/ssl/OpenSslEngine, "B");
        p = ((AtomicIntegerFieldUpdater) (obj));
        if (PlatformDependent.d() < 8) goto _L2; else goto _L1
_L1:
        try {
            obj = javax/net/ssl/SSLParameters.getDeclaredMethod("getUseCipherSuitesOrder", new Class[0]);
            obj2 = JVM INSTR new #159 <Class SSLParameters>;
            ((SSLParameters) (obj2)).SSLParameters();
            obj1 = (Boolean)((Method) (obj)).invoke(obj2, new Object[0]);
            obj1 = javax/net/ssl/SSLParameters.getDeclaredMethod("setUseCipherSuitesOrder", new Class[] {
                Boolean.TYPE
            });
            ((Method) (obj1)).invoke(obj2, new Object[] {
                Boolean.valueOf(true)
            });
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            obj1 = null;
            obj = null;
        }
        try {
            obj2 = Class.forName("javax.net.ssl.SNIHostName", false, PlatformDependent.a(io/netty/handler/ssl/OpenSslEngine));
            obj3 = ((Class) (obj2)).getConstructor(new Class[] {
                java/lang/String
            }).newInstance(new Object[] {
                "netty.io"
            });
            method2 = ((Class) (obj2)).getDeclaredMethod("getAsciiName", new Class[0]);
            obj3 = (String)method2.invoke(obj3, new Object[0]);
            obj3 = javax/net/ssl/SSLParameters.getDeclaredMethod("getServerNames", new Class[0]);
            method = javax/net/ssl/SSLParameters.getDeclaredMethod("setServerNames", new Class[] {
                java/util/List
            });
            obj4 = JVM INSTR new #159 <Class SSLParameters>;
            ((SSLParameters) (obj4)).SSLParameters();
            list = (List)((Method) (obj3)).invoke(obj4, new Object[0]);
            method.invoke(obj4, new Object[] {
                Collections.emptyList()
            });
        }
        // Misplaced declaration of an exception variable
        catch (Object obj2) {
            Object obj6 = null;
            Object obj5 = null;
            obj2 = null;
            obj3 = obj1;
            obj4 = obj;
            obj = obj6;
            obj1 = obj5;
            continue; /* Loop/switch isn't completed */
        }
        method1 = ((Method) (obj3));
        obj4 = obj;
        obj3 = obj1;
        obj1 = method2;
        obj = method;
_L4:
        n = ((Method) (obj4));
        o = ((Method) (obj3));
        j = ((Class) (obj2));
        m = ((Method) (obj1));
        k = method1;
        l = ((Method) (obj));
        q = Buffer.address(ak.c.v());
        r = new SSLEngineResult(javax.net.ssl.SSLEngineResult.Status.OK, javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP, 0, 0);
        s = new SSLEngineResult(javax.net.ssl.SSLEngineResult.Status.CLOSED, javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP, 0, 0);
        t = new SSLEngineResult(javax.net.ssl.SSLEngineResult.Status.OK, javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP, 0, 0);
        u = new SSLEngineResult(javax.net.ssl.SSLEngineResult.Status.CLOSED, javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP, 0, 0);
        v = new SSLEngineResult(javax.net.ssl.SSLEngineResult.Status.CLOSED, javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING, 0, 0);
        return;
_L2:
        obj = null;
        obj1 = null;
        obj2 = null;
        obj3 = null;
        obj4 = null;
        if (true) goto _L4; else goto _L3
_L3:
    }
}
