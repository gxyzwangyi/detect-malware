// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.handler.ssl;

import io.netty.buffer.i;
import io.netty.util.internal.k;
import io.netty.util.internal.logging.b;
import io.netty.util.internal.logging.c;
import java.util.*;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;

// Referenced classes of package io.netty.handler.ssl:
//            ah, h, ClientAuth, d, 
//            j, ApplicationProtocolConfig, f, k

public class n extends ah {

    static final String a[];
    static final List b;
    static final Set c;
    private static final b d;
    private final String e[];
    private final List f;
    private final h g;
    private final ClientAuth i;
    private final SSLContext j;
    private final boolean k;

    n(SSLContext sslcontext, boolean flag, Iterable iterable, d d1, h h1, ClientAuth clientauth) {
        g = (h)io.netty.util.internal.k.a(h1, "apn");
        i = (ClientAuth)io.netty.util.internal.k.a(clientauth, "clientAuth");
        e = ((d)io.netty.util.internal.k.a(d1, "cipherFilter")).a(iterable, b, c);
        f = Collections.unmodifiableList(Arrays.asList(e));
        j = (SSLContext)io.netty.util.internal.k.a(sslcontext, "sslContext");
        k = flag;
    }

    static h a(ApplicationProtocolConfig applicationprotocolconfig, boolean flag) {
        if (applicationprotocolconfig != null) goto _L2; else goto _L1
_L1:
        applicationprotocolconfig = j.a;
_L4:
        return applicationprotocolconfig;
_L2:
        static class _cls1 {

            static final int a[];
            static final int b[];
            static final int c[];
            static final int d[];

            static  {
                d = new int[ApplicationProtocolConfig.Protocol.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    d[ApplicationProtocolConfig.Protocol.a.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror8) { }
                try {
                    d[io.netty.handler.ssl.ApplicationProtocolConfig.Protocol.c.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror7) { }
                try {
                    d[io.netty.handler.ssl.ApplicationProtocolConfig.Protocol.b.ordinal()] = 3;
                }
                catch (NoSuchFieldError nosuchfielderror6) { }
                c = new int[ApplicationProtocolConfig.SelectedListenerFailureBehavior.values().length];
                try {
                    c[ApplicationProtocolConfig.SelectedListenerFailureBehavior.a.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror5) { }
                try {
                    c[io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior.b.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror4) { }
                b = new int[ApplicationProtocolConfig.SelectorFailureBehavior.values().length];
                try {
                    b[ApplicationProtocolConfig.SelectorFailureBehavior.a.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror3) { }
                try {
                    b[io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior.b.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror2) { }
                a = new int[ClientAuth.values().length];
                try {
                    a[io.netty.handler.ssl.ClientAuth.b.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                a[io.netty.handler.ssl.ClientAuth.c.ordinal()] = 2;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        switch (_cls1.d[applicationprotocolconfig.b().ordinal()]) {
        default:
            throw new UnsupportedOperationException((new StringBuilder("JDK provider does not support ")).append(applicationprotocolconfig.b()).append(" protocol").toString());

        case 1: // '\001'
            applicationprotocolconfig = j.a;
            break;

        case 2: // '\002'
            if (flag)
                switch (io.netty.handler.ssl._cls1.b[applicationprotocolconfig.c().ordinal()]) {
                default:
                    throw new UnsupportedOperationException((new StringBuilder("JDK provider does not support ")).append(applicationprotocolconfig.c()).append(" failure behavior").toString());

                case 1: // '\001'
                    applicationprotocolconfig = new f(true, applicationprotocolconfig.a());
                    break;

                case 2: // '\002'
                    applicationprotocolconfig = new f(false, applicationprotocolconfig.a());
                    break;
                }
            else
                switch (io.netty.handler.ssl._cls1.c[applicationprotocolconfig.d().ordinal()]) {
                default:
                    throw new UnsupportedOperationException((new StringBuilder("JDK provider does not support ")).append(applicationprotocolconfig.d()).append(" failure behavior").toString());

                case 1: // '\001'
                    applicationprotocolconfig = new f(false, applicationprotocolconfig.a());
                    break;

                case 2: // '\002'
                    applicationprotocolconfig = new f(true, applicationprotocolconfig.a());
                    break;
                }
            break; /* Loop/switch isn't completed */

        case 3: // '\003'
            if (flag)
                switch (io.netty.handler.ssl._cls1.c[applicationprotocolconfig.d().ordinal()]) {
                default:
                    throw new UnsupportedOperationException((new StringBuilder("JDK provider does not support ")).append(applicationprotocolconfig.d()).append(" failure behavior").toString());

                case 1: // '\001'
                    applicationprotocolconfig = new io.netty.handler.ssl.k(false, applicationprotocolconfig.a());
                    break;

                case 2: // '\002'
                    applicationprotocolconfig = new io.netty.handler.ssl.k(true, applicationprotocolconfig.a());
                    break;
                }
            else
                switch (io.netty.handler.ssl._cls1.b[applicationprotocolconfig.c().ordinal()]) {
                default:
                    throw new UnsupportedOperationException((new StringBuilder("JDK provider does not support ")).append(applicationprotocolconfig.c()).append(" failure behavior").toString());

                case 1: // '\001'
                    applicationprotocolconfig = new io.netty.handler.ssl.k(true, applicationprotocolconfig.a());
                    break;

                case 2: // '\002'
                    applicationprotocolconfig = new io.netty.handler.ssl.k(false, applicationprotocolconfig.a());
                    break;
                }
            break; /* Loop/switch isn't completed */
        }
        if (true) goto _L4; else goto _L3
_L3:
        if (true) goto _L4; else goto _L5
_L5:
    }

    private SSLEngine a(SSLEngine sslengine) {
        sslengine.setEnabledCipherSuites(e);
        sslengine.setEnabledProtocols(a);
        sslengine.setUseClientMode(b());
        if (!i()) goto _L2; else goto _L1
_L1:
        _cls1.a[i.ordinal()];
        JVM INSTR tableswitch 1 2: default 64
    //                   1 88
    //                   2 96;
           goto _L2 _L3 _L4
_L2:
        return g.b().a(sslengine, g, i());
_L3:
        sslengine.setWantClientAuth(true);
        continue; /* Loop/switch isn't completed */
_L4:
        sslengine.setNeedClientAuth(true);
        if (true) goto _L2; else goto _L5
_L5:
    }

    private static transient void a(Set set, List list, String as[]) {
        int i1 = as.length;
        for (int l = 0; l < i1; l++) {
            String s = as[l];
            if (set.contains(s))
                list.add(s);
        }

    }

    public final SSLContext a() {
        return j;
    }

    public final SSLEngine a(i l) {
        return a(a().createSSLEngine());
    }

    public final SSLEngine a(i l, String s, int i1) {
        return a(a().createSSLEngine(s, i1));
    }

    public final boolean b() {
        return k;
    }

    static  {
        boolean flag = false;
        d = io.netty.util.internal.logging.c.a(io/netty/handler/ssl/n);
        Object obj;
        Object obj1;
        String as2[];
        try {
            obj = SSLContext.getInstance("TLS");
            ((SSLContext) (obj)).init(null, null, null);
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            throw new Error("failed to initialize the default SSL context", ((Throwable) (obj)));
        }
        obj = ((SSLContext) (obj)).createSSLEngine();
        as2 = ((SSLEngine) (obj)).getSupportedProtocols();
        obj1 = new HashSet(as2.length);
        for (int l = 0; l < as2.length; l++)
            ((Set) (obj1)).add(as2[l]);

        ArrayList arraylist = new ArrayList();
        a(((Set) (obj1)), arraylist, new String[] {
            "TLSv1.2", "TLSv1.1", "TLSv1"
        });
        String as1[];
        if (!arraylist.isEmpty())
            a = (String[])arraylist.toArray(new String[arraylist.size()]);
        else
            a = ((SSLEngine) (obj)).getEnabledProtocols();
        as1 = ((SSLEngine) (obj)).getSupportedCipherSuites();
        c = new HashSet(as1.length);
        for (int i1 = 0; i1 < as1.length; i1++)
            c.add(as1[i1]);

        as1 = new ArrayList();
        a(c, as1, new String[] {
            "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", "TLS_RSA_WITH_AES_128_GCM_SHA256", "TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA", "SSL_RSA_WITH_3DES_EDE_CBC_SHA"
        });
        if (as1.isEmpty()) {
            String as[] = ((SSLEngine) (obj)).getEnabledCipherSuites();
            int k1 = as.length;
            int j1 = ((flag) ? 1 : 0);
            while (j1 < k1)  {
                String s = as[j1];
                if (!s.contains("_RC4_"))
                    as1.add(s);
                j1++;
            }
        }
        b = Collections.unmodifiableList(as1);
        if (d.b()) {
            d.b("Default protocols (JDK): {} ", Arrays.asList(a));
            d.b("Default cipher suites (JDK): {}", b);
        }
    }
}
