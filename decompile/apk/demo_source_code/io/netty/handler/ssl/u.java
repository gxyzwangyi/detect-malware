// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.handler.ssl;

import io.netty.buffer.h;
import io.netty.buffer.i;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.k;
import io.netty.util.internal.logging.b;
import io.netty.util.internal.logging.c;
import io.netty.util.internal.n;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.*;
import javax.net.ssl.*;
import org.apache.tomcat.jni.*;

// Referenced classes of package io.netty.handler.ssl:
//            ah, r, ClientAuth, d, 
//            s, c, ae, am, 
//            PemPrivateKey, PemX509Certificate, ApplicationProtocolConfig, v, 
//            OpenSslEngine, w, ac, z, 
//            a

public abstract class u extends ah {
    static abstract class a
        implements CertificateVerifier {

        private final w a;

        a(w w) {
            a = w;
        }
    }

    private static final class b
        implements w {

        private final Map a;

        public OpenSslEngine a(long l1) {
            return (OpenSslEngine)a.remove(Long.valueOf(l1));
        }

        public void a(OpenSslEngine opensslengine) {
            a.put(Long.valueOf(opensslengine.a()), opensslengine);
        }

        private b() {
            a = PlatformDependent.k();
        }

    }


    static final s g;
    private static final io.netty.util.internal.logging.b i;
    private static final boolean j;
    private static final List k;
    private static final Integer l;
    protected volatile long a;
    long b;
    final Certificate c[];
    final ClientAuth d;
    final w e;
    volatile boolean f;
    private final List m;
    private final long n;
    private final long o;
    private final s p;
    private final int q;

    u(Iterable iterable, d d1, ApplicationProtocolConfig applicationprotocolconfig, long l1, long l2, 
            int i1, Certificate acertificate[], ClientAuth clientauth) {
        this(iterable, d1, a(applicationprotocolconfig), l1, l2, i1, acertificate, clientauth);
    }

    u(Iterable iterable, d d1, s s1, long l1, long l2, 
            int i1, Certificate acertificate[], ClientAuth clientauth) {
        e = new b();
        io.netty.handler.ssl.r.b();
        if (i1 != 1 && i1 != 0)
            throw new IllegalArgumentException("mode most be either SSL.SSL_MODE_SERVER or SSL.SSL_MODE_CLIENT");
        q = i1;
        static class _cls3 {

            static final int a[];
            static final int b[];
            static final int c[];

            static  {
                c = new int[ApplicationProtocolConfig.SelectedListenerFailureBehavior.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    c[io.netty.handler.ssl.ApplicationProtocolConfig.SelectedListenerFailureBehavior.c.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror7) { }
                try {
                    c[ApplicationProtocolConfig.SelectedListenerFailureBehavior.a.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror6) { }
                b = new int[ApplicationProtocolConfig.SelectorFailureBehavior.values().length];
                try {
                    b[io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior.b.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror5) { }
                try {
                    b[io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior.c.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror4) { }
                a = new int[ApplicationProtocolConfig.Protocol.values().length];
                try {
                    a[io.netty.handler.ssl.ApplicationProtocolConfig.Protocol.b.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror3) { }
                try {
                    a[io.netty.handler.ssl.ApplicationProtocolConfig.Protocol.c.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror2) { }
                try {
                    a[ApplicationProtocolConfig.Protocol.d.ordinal()] = 3;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                a[ApplicationProtocolConfig.Protocol.a.ordinal()] = 4;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        if (i())
            clientauth = (ClientAuth)io.netty.util.internal.k.a(clientauth, "clientAuth");
        else
            clientauth = ClientAuth.a;
        d = clientauth;
        if (i1 == 1)
            f = j;
        if (acertificate == null)
            acertificate = null;
        else
            acertificate = (Certificate[])acertificate.clone();
        c = acertificate;
        if (iterable != null) goto _L2; else goto _L1
_L1:
        iterable = null;
_L16:
        m = Arrays.asList(((d)io.netty.util.internal.k.a(d1, "cipherFilter")).a(iterable, k, io.netty.handler.ssl.r.c()));
        p = (s)io.netty.util.internal.k.a(s1, "apn");
        b = Pool.create(0L);
        io/netty/handler/ssl/u;
        JVM INSTR monitorenter ;
        a = SSLContext.make(b, 31, i1);
        SSLContext.setOptions(a, 4095);
        SSLContext.setOptions(a, 0x1000000);
        SSLContext.setOptions(a, 0x2000000);
        SSLContext.setOptions(a, 0x400000);
        SSLContext.setOptions(a, 0x80000);
        SSLContext.setOptions(a, 0x100000);
        SSLContext.setOptions(a, 0x10000);
        SSLContext.setOptions(a, 16384);
        SSLContext.setMode(a, SSLContext.getMode(a) | 2);
        if (l != null)
            SSLContext.setTmpDHLength(a, l.intValue());
        SSLContext.setCipherSuite(a, io.netty.handler.ssl.c.a(m));
        iterable = s1.a();
        if (iterable.isEmpty()) goto _L4; else goto _L3
_L3:
        iterable = (String[])iterable.toArray(new String[iterable.size()]);
        i1 = a(s1.c());
        _cls3.a[s1.b().ordinal()];
        JVM INSTR tableswitch 1 3: default 380
    //                   1 553
    //                   2 613
    //                   3 626;
           goto _L5 _L6 _L7 _L8
_L5:
        iterable = JVM INSTR new #303 <Class Error>;
        iterable.Error();
        throw iterable;
        iterable;
        io/netty/handler/ssl/u;
        JVM INSTR monitorexit ;
        throw iterable;
        iterable;
        e();
        throw iterable;
_L2:
        acertificate = new ArrayList();
        Iterator iterator = iterable.iterator();
        do {
            if (!iterator.hasNext())
                break;
            iterable = (String)iterator.next();
            if (iterable == null) {
                iterable = acertificate;
                continue; /* Loop/switch isn't completed */
            }
            clientauth = io.netty.handler.ssl.c.a(iterable);
            if (clientauth != null)
                iterable = clientauth;
            acertificate.add(iterable);
        } while (true);
        iterable = acertificate;
        continue; /* Loop/switch isn't completed */
        d1;
        iterable = JVM INSTR new #158 <Class SSLException>;
        iterable.SSLException("failed to create an SSL_CTX", d1);
        throw iterable;
        iterable;
        throw iterable;
        iterable;
        s1 = JVM INSTR new #158 <Class SSLException>;
        d1 = JVM INSTR new #106 <Class StringBuilder>;
        d1.StringBuilder();
        s1.SSLException(d1.append("failed to set cipher suite: ").append(m).toString(), iterable);
        throw s1;
_L6:
        SSLContext.setNpnProtos(a, iterable, i1);
_L4:
        if (l1 <= 0L) goto _L10; else goto _L9
_L9:
        n = l1;
        SSLContext.setSessionCacheSize(a, l1);
_L13:
        if (l2 <= 0L) goto _L12; else goto _L11
_L11:
        o = l2;
        SSLContext.setSessionCacheTimeout(a, l2);
_L14:
        io/netty/handler/ssl/u;
        JVM INSTR monitorexit ;
        return;
_L7:
        SSLContext.setAlpnProtos(a, iterable, i1);
          goto _L4
_L8:
        SSLContext.setNpnProtos(a, iterable, i1);
        SSLContext.setAlpnProtos(a, iterable, i1);
          goto _L4
_L10:
        l1 = SSLContext.setSessionCacheSize(a, 20480L);
        n = l1;
        SSLContext.setSessionCacheSize(a, l1);
          goto _L13
_L12:
        l1 = SSLContext.setSessionCacheTimeout(a, 300L);
        o = l1;
        SSLContext.setSessionCacheTimeout(a, l1);
          goto _L14
        if (true) goto _L16; else goto _L15
_L15:
    }

    private static int a(ApplicationProtocolConfig.SelectorFailureBehavior selectorfailurebehavior) {
        io.netty.handler.ssl._cls3.b[selectorfailurebehavior.ordinal()];
        JVM INSTR tableswitch 1 2: default 32
    //                   1 40
    //                   2 44;
           goto _L1 _L2 _L3
_L1:
        throw new Error();
_L2:
        int i1 = 0;
_L5:
        return i1;
_L3:
        i1 = 1;
        if (true) goto _L5; else goto _L4
_L4:
    }

    private static long a(h h1) {
        long l1;
        l1 = SSL.newMemBIO();
        int i1 = h1.f();
        if (SSL.writeToBIO(l1, r.a(h1), i1) != i1) {
            SSL.freeBIO(l1);
            IllegalStateException illegalstateexception = JVM INSTR new #392 <Class IllegalStateException>;
            illegalstateexception.IllegalStateException("Could not write data to memory BIO");
            throw illegalstateexception;
        }
        break MISSING_BLOCK_LABEL_52;
        Exception exception;
        exception;
        h1.B();
        throw exception;
        h1.B();
        return l1;
    }

    private static long a(i i1, ae ae1) {
        h h1 = ae1.a();
        if (!h1.L()) goto _L2; else goto _L1
_L1:
        long l1 = a(h1.u().A());
        ae1.B();
_L4:
        return l1;
_L2:
        i1 = i1.d(h1.f());
        i1.a(h1, h1.b(), h1.f());
        l1 = a(i1.u().A());
        if (ae1.b())
            am.a(i1);
        i1.B();
        ae1.B();
        if (true) goto _L4; else goto _L3
_L3:
        Exception exception;
        exception;
        i1.B();
        throw exception;
        i1;
        ae1.B();
        throw i1;
        exception;
        if (ae1.b())
            am.a(i1);
        i1.B();
        throw exception;
        exception;
        i1.B();
        throw exception;
    }

    static long a(PrivateKey privatekey) {
        if (privatekey != null) goto _L2; else goto _L1
_L1:
        long l1 = 0L;
_L4:
        return l1;
_L2:
        i i1;
        i1 = i.a;
        privatekey = PemPrivateKey.a(i1, true, privatekey);
        l1 = a(i1, privatekey.c());
        privatekey.B();
        if (true) goto _L4; else goto _L3
_L3:
        Exception exception;
        exception;
        privatekey.B();
        throw exception;
    }

    static transient long a(X509Certificate ax509certificate[]) {
        if (ax509certificate != null) goto _L2; else goto _L1
_L1:
        long l1 = 0L;
_L4:
        return l1;
_L2:
        i i1;
        if (ax509certificate.length == 0)
            throw new IllegalArgumentException("certChain can't be empty");
        i1 = i.a;
        ax509certificate = PemX509Certificate.a(i1, true, ax509certificate);
        l1 = a(i1, ax509certificate.c());
        ax509certificate.B();
        if (true) goto _L4; else goto _L3
_L3:
        Exception exception;
        exception;
        ax509certificate.B();
        throw exception;
    }

    static s a(ApplicationProtocolConfig applicationprotocolconfig) {
        if (applicationprotocolconfig != null) goto _L2; else goto _L1
_L1:
        applicationprotocolconfig = g;
_L4:
        return applicationprotocolconfig;
_L2:
        switch (_cls3.a[applicationprotocolconfig.b().ordinal()]) {
        default:
            throw new Error();

        case 4: // '\004'
            applicationprotocolconfig = g;
            break;

        case 1: // '\001'
        case 2: // '\002'
        case 3: // '\003'
            switch (io.netty.handler.ssl._cls3.c[applicationprotocolconfig.d().ordinal()]) {
            default:
                throw new UnsupportedOperationException((new StringBuilder("OpenSSL provider does not support ")).append(applicationprotocolconfig.d()).append(" behavior").toString());

            case 1: // '\001'
            case 2: // '\002'
                switch (io.netty.handler.ssl._cls3.b[applicationprotocolconfig.c().ordinal()]) {
                default:
                    throw new UnsupportedOperationException((new StringBuilder("OpenSSL provider does not support ")).append(applicationprotocolconfig.c()).append(" behavior").toString());

                case 1: // '\001'
                case 2: // '\002'
                    applicationprotocolconfig = new v(applicationprotocolconfig);
                    break;
                }
                break;
            }
            continue; /* Loop/switch isn't completed */
        }
        if (true) goto _L4; else goto _L3
_L3:
        if (true) goto _L4; else goto _L5
_L5:
    }

    protected static X509KeyManager a(KeyManager akeymanager[]) {
        int j1 = akeymanager.length;
        for (int i1 = 0; i1 < j1; i1++) {
            KeyManager keymanager = akeymanager[i1];
            if (keymanager instanceof X509KeyManager)
                return (X509KeyManager)keymanager;
        }

        throw new IllegalStateException("no X509KeyManager found");
    }

    protected static X509TrustManager a(TrustManager atrustmanager[]) {
        int j1 = atrustmanager.length;
        for (int i1 = 0; i1 < j1; i1++) {
            TrustManager trustmanager = atrustmanager[i1];
            if (trustmanager instanceof X509TrustManager)
                return (X509TrustManager)trustmanager;
        }

        throw new IllegalStateException("no X509TrustManager found");
    }

    static void a(long l1, X509Certificate ax509certificate[], PrivateKey privatekey, String s1) {
        long l2 = a(ax509certificate);
        long l4 = a(privatekey);
        long l3;
        long l5;
        if (s1 == null)
            ax509certificate = "";
        else
            ax509certificate = s1;
        l3 = l2;
        l5 = l4;
        SSLContext.setCertificateBio(l1, l2, l4, ax509certificate, 0);
        l3 = l2;
        l5 = l4;
        SSLContext.setCertificateChainBio(l1, l2, false);
        if (l4 != 0L)
            SSL.freeBIO(l4);
        if (l2 != 0L)
            SSL.freeBIO(l2);
        return;
        ax509certificate;
        l2 = 0L;
        l4 = 0L;
_L4:
        l3 = l2;
        l5 = l4;
        throw ax509certificate;
        ax509certificate;
        l2 = l3;
_L1:
        if (l5 != 0L)
            SSL.freeBIO(l5);
        if (l2 != 0L)
            SSL.freeBIO(l2);
        throw ax509certificate;
        ax509certificate;
        l2 = 0L;
        l4 = 0L;
_L2:
        l3 = l2;
        l5 = l4;
        privatekey = JVM INSTR new #158 <Class SSLException>;
        l3 = l2;
        l5 = l4;
        privatekey.SSLException("failed to set certificate and key", ax509certificate);
        l3 = l2;
        l5 = l4;
        throw privatekey;
        ax509certificate;
        l2 = 0L;
        l5 = 0L;
          goto _L1
        ax509certificate;
        l5 = 0L;
          goto _L1
        ax509certificate;
        l4 = 0L;
          goto _L2
        ax509certificate;
          goto _L2
        ax509certificate;
        l4 = 0L;
        continue; /* Loop/switch isn't completed */
        ax509certificate;
        if (true) goto _L4; else goto _L3
_L3:
    }

    static boolean a(X509KeyManager x509keymanager) {
        boolean flag;
        if (PlatformDependent.d() >= 7 && (x509keymanager instanceof X509ExtendedKeyManager))
            flag = true;
        else
            flag = false;
        return flag;
    }

    static boolean a(X509TrustManager x509trustmanager) {
        boolean flag;
        if (PlatformDependent.d() >= 7 && (x509trustmanager instanceof X509ExtendedTrustManager))
            flag = true;
        else
            flag = false;
        return flag;
    }

    public abstract ac a();

    public final SSLEngine a(i i1) {
        return a(i1, null, -1);
    }

    public final SSLEngine a(i i1, String s1, int j1) {
        return new OpenSslEngine(this, i1, s1, j1);
    }

    public final boolean b() {
        boolean flag;
        if (q == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    abstract z c();

    public io.netty.handler.ssl.a d() {
        return p;
    }

    final void e() {
        io/netty/handler/ssl/u;
        JVM INSTR monitorenter ;
        if (a != 0L) {
            SSLContext.free(a);
            a = 0L;
        }
        if (b != 0L) {
            Pool.destroy(b);
            b = 0L;
        }
        io/netty/handler/ssl/u;
        JVM INSTR monitorexit ;
        return;
        Exception exception;
        exception;
        io/netty/handler/ssl/u;
        JVM INSTR monitorexit ;
        throw exception;
    }

    protected final void finalize() {
        super.finalize();
        e();
    }

    static  {
        i = io.netty.util.internal.logging.c.a(io/netty/handler/ssl/u);
        j = io.netty.util.internal.n.a("jdk.tls.rejectClientInitiatedRenegotiation", false);
        g = new s() {

            public List a() {
                return Collections.emptyList();
            }

            public ApplicationProtocolConfig.Protocol b() {
                return ApplicationProtocolConfig.Protocol.a;
            }

            public ApplicationProtocolConfig.SelectorFailureBehavior c() {
                return io.netty.handler.ssl.ApplicationProtocolConfig.SelectorFailureBehavior.c;
            }

            public ApplicationProtocolConfig.SelectedListenerFailureBehavior d() {
                return ApplicationProtocolConfig.SelectedListenerFailureBehavior.a;
            }

        }
;
        ArrayList arraylist = new ArrayList();
        Collections.addAll(arraylist, new String[] {
            "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-SHA", "ECDHE-RSA-AES256-SHA", "AES128-GCM-SHA256", "AES128-SHA", "AES256-SHA", "DES-CBC3-SHA"
        });
        k = Collections.unmodifiableList(arraylist);
        if (i.b())
            i.a((new StringBuilder()).append("Default cipher suite (OpenSSL): ").append(arraylist).toString());
        Object obj;
        obj = JVM INSTR new #8   <Class u$2>;
        ((_cls2) (obj))._cls2();
        obj = (String)AccessController.doPrivileged(((PrivilegedAction) (obj)));
        if (obj == null) goto _L2; else goto _L1
_L1:
        int i1 = Integer.parseInt(((String) (obj)));
        obj = Integer.valueOf(i1);
_L4:
        l = ((Integer) (obj));
        return;
        NumberFormatException numberformatexception;
        numberformatexception;
        io.netty.util.internal.logging.b b1 = i;
        StringBuilder stringbuilder = JVM INSTR new #106 <Class StringBuilder>;
        stringbuilder.StringBuilder();
        b1.a(stringbuilder.append("OpenSslContext only support -Djdk.tls.ephemeralDHKeySize={int}, but got: ").append(((String) (obj))).toString());
_L2:
        obj = null;
        continue; /* Loop/switch isn't completed */
        Throwable throwable;
        throwable;
        throwable = null;
        if (true) goto _L4; else goto _L3
_L3:
    }

    // Unreferenced inner class io/netty/handler/ssl/u$2

/* anonymous class */
    static final class _cls2
        implements PrivilegedAction {

        public String a() {
            return io.netty.util.internal.n.b("jdk.tls.ephemeralDHKeySize");
        }

        public Object run() {
            return a();
        }

    }

}
