// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.handler.ssl;

import io.netty.buffer.*;
import io.netty.util.internal.c;
import java.io.File;
import java.security.*;
import java.security.cert.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import javax.crypto.*;
import javax.crypto.spec.PBEKeySpec;
import javax.net.ssl.*;

// Referenced classes of package io.netty.handler.ssl:
//            r, SslProvider, m, t, 
//            p, aa, af, d, 
//            ApplicationProtocolConfig, ClientAuth

public abstract class ah {

    static final CertificateFactory h;

    public ah() {
    }

    private static SslProvider a() {
        SslProvider sslprovider;
        if (r.a())
            sslprovider = SslProvider.b;
        else
            sslprovider = SslProvider.a;
        return sslprovider;
    }

    static ah a(SslProvider sslprovider, X509Certificate ax509certificate[], TrustManagerFactory trustmanagerfactory, X509Certificate ax509certificate1[], PrivateKey privatekey, String s, KeyManagerFactory keymanagerfactory, Iterable iterable, 
            d d, ApplicationProtocolConfig applicationprotocolconfig, long l, long l1) {
        SslProvider sslprovider1;
        sslprovider1 = sslprovider;
        if (sslprovider == null)
            sslprovider1 = h();
        static class _cls1 {

            static final int a[];

            static  {
                a = new int[SslProvider.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    a[SslProvider.a.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                a[SslProvider.b.ordinal()] = 2;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        _cls1.a[sslprovider1.ordinal()];
        JVM INSTR tableswitch 1 2: default 44
    //                   1 52
    //                   2 81;
           goto _L1 _L2 _L3
_L1:
        throw new Error();
_L2:
        sslprovider = new m(ax509certificate, trustmanagerfactory, ax509certificate1, privatekey, s, keymanagerfactory, iterable, d, applicationprotocolconfig, l, l1);
_L5:
        return sslprovider;
_L3:
        sslprovider = new t(ax509certificate, trustmanagerfactory, ax509certificate1, privatekey, s, keymanagerfactory, iterable, d, applicationprotocolconfig, l, l1);
        if (true) goto _L5; else goto _L4
_L4:
    }

    static ah a(SslProvider sslprovider, X509Certificate ax509certificate[], TrustManagerFactory trustmanagerfactory, X509Certificate ax509certificate1[], PrivateKey privatekey, String s, KeyManagerFactory keymanagerfactory, Iterable iterable, 
            d d, ApplicationProtocolConfig applicationprotocolconfig, long l, long l1, ClientAuth clientauth) {
        SslProvider sslprovider1;
        sslprovider1 = sslprovider;
        if (sslprovider == null)
            sslprovider1 = g();
        _cls1.a[sslprovider1.ordinal()];
        JVM INSTR tableswitch 1 2: default 44
    //                   1 57
    //                   2 88;
           goto _L1 _L2 _L3
_L1:
        throw new Error(sslprovider1.toString());
_L2:
        sslprovider = new p(ax509certificate, trustmanagerfactory, ax509certificate1, privatekey, s, keymanagerfactory, iterable, d, applicationprotocolconfig, l, l1, clientauth);
_L5:
        return sslprovider;
_L3:
        sslprovider = new aa(ax509certificate, trustmanagerfactory, ax509certificate1, privatekey, s, keymanagerfactory, iterable, d, applicationprotocolconfig, l, l1, clientauth);
        if (true) goto _L5; else goto _L4
_L4:
    }

    static KeyStore a(X509Certificate ax509certificate[], PrivateKey privatekey, char ac[]) {
        KeyStore keystore = KeyStore.getInstance("BKS");
        keystore.load(null, null);
        keystore.setKeyEntry("key", privatekey, ac, ax509certificate);
        return keystore;
    }

    private static PrivateKey a(h h1, String s) {
        byte abyte0[] = new byte[h1.f()];
        h1.a(abyte0).B();
        if (s == null)
            h1 = null;
        else
            h1 = s.toCharArray();
        s = a(((char []) (h1)), abyte0);
        try {
            h1 = KeyFactory.getInstance("RSA").generatePrivate(s);
        }
        // Misplaced declaration of an exception variable
        catch (h h1) {
            try {
                h1 = KeyFactory.getInstance("DSA").generatePrivate(s);
            }
            // Misplaced declaration of an exception variable
            catch (h h1) {
                try {
                    h1 = KeyFactory.getInstance("EC").generatePrivate(s);
                }
                // Misplaced declaration of an exception variable
                catch (h h1) {
                    throw new InvalidKeySpecException("Neither RSA, DSA nor EC worked", h1);
                }
            }
        }
        return h1;
    }

    static PrivateKey a(File file, String s) {
        if (file == null)
            file = null;
        else
            file = a(af.b(file), s);
        return file;
    }

    protected static PKCS8EncodedKeySpec a(char ac[], byte abyte0[]) {
        if (ac == null) {
            ac = new PKCS8EncodedKeySpec(abyte0);
        } else {
            abyte0 = new EncryptedPrivateKeyInfo(abyte0);
            javax.crypto.SecretKey secretkey = SecretKeyFactory.getInstance(abyte0.getAlgName()).generateSecret(new PBEKeySpec(ac));
            ac = Cipher.getInstance(abyte0.getAlgName());
            ac.init(2, secretkey, abyte0.getAlgParameters());
            ac = abyte0.getKeySpec(ac);
        }
        return ac;
    }

    static KeyManagerFactory a(X509Certificate ax509certificate[], String s, PrivateKey privatekey, String s1, KeyManagerFactory keymanagerfactory) {
        if (s1 == null)
            s1 = c.b;
        else
            s1 = s1.toCharArray();
        privatekey = a(ax509certificate, privatekey, ((char []) (s1)));
        ax509certificate = keymanagerfactory;
        if (keymanagerfactory == null)
            ax509certificate = KeyManagerFactory.getInstance(s);
        ax509certificate.init(privatekey, s1);
        return ax509certificate;
    }

    static KeyManagerFactory a(X509Certificate ax509certificate[], PrivateKey privatekey, String s, KeyManagerFactory keymanagerfactory) {
        String s2 = Security.getProperty("ssl.KeyManagerFactory.algorithm");
        String s1 = s2;
        if (s2 == null)
            s1 = "SunX509";
        return a(ax509certificate, s1, privatekey, s, keymanagerfactory);
    }

    static TrustManagerFactory a(X509Certificate ax509certificate[], TrustManagerFactory trustmanagerfactory) {
        KeyStore keystore = KeyStore.getInstance("BKS");
        keystore.load(null, null);
        int j = 1;
        int i1 = ax509certificate.length;
        for (int l = 0; l < i1; l++) {
            X509Certificate x509certificate = ax509certificate[l];
            keystore.setCertificateEntry(Integer.toString(j), x509certificate);
            j++;
        }

        ax509certificate = trustmanagerfactory;
        if (trustmanagerfactory == null)
            ax509certificate = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        ax509certificate.init(keystore);
        return ax509certificate;
    }

    static X509Certificate[] a(File file) {
        if (file == null)
            file = null;
        else
            file = a(af.a(file));
        return file;
    }

    private static X509Certificate[] a(h ah1[]) {
        int j;
        boolean flag;
        int k1;
        CertificateFactory certificatefactory;
        X509Certificate ax509certificate[];
        k1 = 0;
        flag = false;
        certificatefactory = CertificateFactory.getInstance("X.509");
        ax509certificate = new X509Certificate[ah1.length];
        j = 0;
_L2:
        if (j >= ah1.length)
            break; /* Loop/switch isn't completed */
        k k2 = JVM INSTR new #261 <Class k>;
        k2.k(ah1[j]);
        ax509certificate[j] = (X509Certificate)certificatefactory.generateCertificate(k2);
        j++;
        if (true) goto _L2; else goto _L1
_L1:
        k1 = ah1.length;
        for (int l = ((flag) ? 1 : 0); l < k1; l++)
            ah1[l].B();

        break MISSING_BLOCK_LABEL_110;
        Exception exception;
        exception;
        int j1 = ah1.length;
        for (int i1 = k1; i1 < j1; i1++)
            ah1[i1].B();

        throw exception;
        return ax509certificate;
    }

    static PrivateKey b(File file, String s) {
        try {
            file = a(file, s);
        }
        // Misplaced declaration of an exception variable
        catch (File file) {
            throw new SSLException(file);
        }
        return file;
    }

    static X509Certificate[] b(File file) {
        try {
            file = a(file);
        }
        // Misplaced declaration of an exception variable
        catch (File file) {
            throw new SSLException(file);
        }
        return file;
    }

    public static SslProvider g() {
        return a();
    }

    public static SslProvider h() {
        return a();
    }

    public abstract SSLEngine a(i j);

    public abstract SSLEngine a(i j, String s, int l);

    public abstract boolean b();

    public final boolean i() {
        boolean flag;
        if (!b())
            flag = true;
        else
            flag = false;
        return flag;
    }

    static  {
        try {
            h = CertificateFactory.getInstance("X.509");
        }
        catch (CertificateException certificateexception) {
            throw new IllegalStateException("unable to instance X.509 CertificateFactory", certificateexception);
        }
    }
}
