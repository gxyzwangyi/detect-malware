// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.handler.ssl;

import io.netty.buffer.ak;
import io.netty.buffer.h;
import io.netty.buffer.i;
import io.netty.buffer.m;
import io.netty.buffer.n;
import io.netty.channel.ChannelException;
import io.netty.channel.am;
import io.netty.channel.d;
import io.netty.channel.e;
import io.netty.channel.g;
import io.netty.channel.k;
import io.netty.channel.r;
import io.netty.channel.w;
import io.netty.channel.x;
import io.netty.handler.codec.UnsupportedMessageTypeException;
import io.netty.handler.codec.a;
import io.netty.util.concurrent.t;
import io.netty.util.concurrent.y;
import io.netty.util.internal.PlatformDependent;
import io.netty.util.internal.logging.b;
import io.netty.util.internal.logging.c;
import io.netty.util.internal.o;
import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.DatagramChannel;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLSession;

// Referenced classes of package io.netty.handler.ssl:
//            OpenSslEngine, am, ak, NotSslRecordException

public class aj extends io.netty.handler.codec.a
    implements r {
    private final class a extends io.netty.util.concurrent.g {

        final aj a;

        protected io.netty.util.concurrent.i a() {
            if (io.netty.handler.ssl.aj.b(a) == null)
                throw new IllegalStateException();
            else
                return io.netty.handler.ssl.aj.b(a).d();
        }

        protected void m() {
            if (io.netty.handler.ssl.aj.b(a) != null)
                super.m();
        }

        private a() {
            a = aj.this;
            super();
        }

    }


    static final boolean d;
    private static final b e = io.netty.util.internal.logging.c.a(io/netty/handler/ssl/aj);
    private static final Pattern g = Pattern.compile("^.*(?:Socket|Datagram|Sctp|Udt)Channel.*$");
    private static final Pattern h = Pattern.compile("^.*(?:connection.*(?:reset|closed|abort|broken)|broken.*pipe).*$", 2);
    private static final SSLException i = (SSLException)io.netty.util.internal.o.a(new SSLException("SSLEngine closed already"), io/netty/handler/ssl/aj, "wrap(...)");
    private static final SSLException j = (SSLException)io.netty.util.internal.o.a(new SSLException("handshake timed out"), io/netty/handler/ssl/aj, "handshake(...)");
    private static final ClosedChannelException k = (ClosedChannelException)io.netty.util.internal.o.a(new ClosedChannelException(), io/netty/handler/ssl/aj, "channelInactive(...)");
    private boolean A;
    private int B;
    private boolean C;
    private volatile long D;
    private volatile long E;
    private volatile k l;
    private final SSLEngine m;
    private final int n;
    private final Executor o;
    private final ByteBuffer p[];
    private final boolean q;
    private final boolean r;
    private final boolean s;
    private boolean t;
    private boolean u;
    private boolean v;
    private am w;
    private y x;
    private final a y;
    private boolean z;

    public aj(SSLEngine sslengine) {
        this(sslengine, false);
    }

    public aj(SSLEngine sslengine, boolean flag) {
        this(sslengine, flag, ((Executor) (t.a)));
    }

    public aj(SSLEngine sslengine, boolean flag, Executor executor) {
        boolean flag1 = true;
        super();
        p = new ByteBuffer[1];
        x = new a();
        y = new a();
        D = 10000L;
        E = 3000L;
        if (sslengine == null)
            throw new NullPointerException("engine");
        if (executor == null)
            throw new NullPointerException("delegatedTaskExecutor");
        m = sslengine;
        o = executor;
        s = flag;
        n = sslengine.getSession().getPacketBufferSize();
        boolean flag2 = sslengine instanceof OpenSslEngine;
        q = flag2;
        if (!flag2)
            flag = flag1;
        else
            flag = false;
        r = flag;
        if (flag2)
            sslengine = b;
        else
            sslengine = a;
        a(sslengine);
    }

    private h a(k k1, int i1) {
        k1 = k1.c();
        if (q)
            k1 = k1.d(i1);
        else
            k1 = k1.a(i1);
        return k1;
    }

    private static ByteBuffer a(h h1, int i1, int j1) {
        if (h1.h_() == 1)
            h1 = h1.m(i1, j1);
        else
            h1 = h1.n(i1, j1);
        return h1;
    }

    static SSLEngine a(aj aj1) {
        return aj1.m;
    }

    private SSLEngineResult a(i i1, SSLEngine sslengine, h h1, h h2) {
        int j1;
        int k1;
        j1 = h1.b();
        k1 = h1.f();
        if (!h1.L() && q) goto _L2; else goto _L1
_L1:
        if ((h1 instanceof n) || h1.h_() != 1) goto _L4; else goto _L3
_L3:
        ByteBuffer abytebuffer[];
        abytebuffer = p;
        abytebuffer[0] = h1.m(j1, k1);
        i1 = null;
_L6:
        i l1 = i1;
        SSLEngineResult sslengineresult = sslengine.wrap(abytebuffer, h2.n(h2.c(), h2.g()));
        l1 = i1;
        h1.s(sslengineresult.bytesConsumed());
        l1 = i1;
        h2.c(h2.c() + sslengineresult.bytesProduced());
        l1 = i1;
        static class _cls8 {

            static final int a[];
            static final int b[];

            static  {
                b = new int[javax.net.ssl.SSLEngineResult.Status.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    b[javax.net.ssl.SSLEngineResult.Status.BUFFER_OVERFLOW.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror6) { }
                try {
                    b[javax.net.ssl.SSLEngineResult.Status.CLOSED.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror5) { }
                a = new int[javax.net.ssl.SSLEngineResult.HandshakeStatus.values().length];
                try {
                    a[javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_TASK.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror4) { }
                try {
                    a[javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror3) { }
                try {
                    a[javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING.ordinal()] = 3;
                }
                catch (NoSuchFieldError nosuchfielderror2) { }
                try {
                    a[javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP.ordinal()] = 4;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                a[javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP.ordinal()] = 5;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        j1 = io.netty.handler.ssl._cls8.b[sslengineresult.getStatus().ordinal()];
        switch (j1) {
        default:
            p[0] = null;
            if (i1 != null)
                i1.B();
            return sslengineresult;

        case 1: // '\001'
            l1 = i1;
            break;
        }
          goto _L5
_L4:
        abytebuffer = h1.w();
        i1 = null;
          goto _L6
_L2:
        i1 = i1.d(k1);
        l1 = i1;
        i1.a(h1, j1, k1);
        l1 = i1;
        abytebuffer = p;
        l1 = i1;
        abytebuffer[0] = i1.m(0, k1);
          goto _L6
        i1;
_L7:
        p[0] = null;
        if (l1 != null)
            l1.B();
        throw i1;
_L5:
        h2.e(n);
          goto _L6
        i1;
        l1 = null;
          goto _L7
    }

    private SSLEngineResult a(SSLEngine sslengine, h h1, int i1, int j1, h h2) {
        int k1;
        int l1;
        l1 = h1.h_();
        k1 = h2.c();
        if (!(sslengine instanceof OpenSslEngine) || l1 <= 1) goto _L2; else goto _L1
_L1:
        sslengine = (OpenSslEngine)sslengine;
        p[0] = a(h2, k1, h2.g());
        sslengine = sslengine.a(h1.b_(i1, j1), p);
        h2.c(sslengine.bytesProduced() + k1);
        p[0] = null;
_L4:
        h2.c(k1 + sslengine.bytesProduced());
        return sslengine;
        sslengine;
        p[0] = null;
        throw sslengine;
_L2:
        sslengine = sslengine.unwrap(a(h1, i1, j1), a(h2, k1, h2.g()));
        if (true) goto _L4; else goto _L3
_L3:
    }

    private void a(k k1, h h1, w w1, boolean flag, boolean flag1) {
        h h2;
        if (h1 == null) {
            h2 = ak.c;
        } else {
            h2 = h1;
            if (!h1.e()) {
                h1.B();
                h2 = ak.c;
            }
        }
        if (w1 != null)
            k1.a(h2, w1);
        else
            k1.c(h2);
        if (flag)
            z = true;
        if (flag1)
            l(k1);
    }

    private void a(k k1, g g1, w w1) {
        if (!k1.a().G()) {
            k1.b(w1);
        } else {
            io.netty.util.concurrent.ae ae;
            if (E > 0L)
                ae = k1.d().a(new Runnable(k1, w1) {

                    final k a;
                    final w b;
                    final aj c;

                    public void run() {
                        io.netty.handler.ssl.aj.e().c("{} Last write attempt timed out; force-closing the connection.", a.a());
                        a.b(a.o()).a(new x(new w[] {
                            b
                        }));
                    }

             {
                c = aj.this;
                a = k1;
                b = w1;
                super();
            }
                }
, E, TimeUnit.MILLISECONDS);
            else
                ae = null;
            g1.a(new io.netty.channel.h(ae, k1, w1) {

                final ScheduledFuture a;
                final k b;
                final w c;
                final aj d;

                public void a(g g2) {
                    if (a != null)
                        a.cancel(false);
                    b.b(b.o()).a(new x(new w[] {
                        c
                    }));
                }

                public volatile void a(io.netty.util.concurrent.n n1) {
                    a((g)n1);
                }

             {
                d = aj.this;
                a = scheduledfuture;
                b = k1;
                c = w1;
                super();
            }
            }
);
        }
    }

    private void a(k k1, w w1, boolean flag) {
        if (!k1.a().G()) {
            if (flag)
                k1.a(w1);
            else
                k1.b(w1);
        } else {
            A = true;
            m.closeOutbound();
            w w2 = k1.o();
            a(k1, ak.c, w2);
            b(k1);
            a(k1, ((g) (w2)), w1);
        }
    }

    private void a(k k1, Throwable throwable, boolean flag) {
        m.closeOutbound();
        if (!flag)
            break MISSING_BLOCK_LABEL_18;
        m.closeInbound();
_L2:
        b(throwable);
        w.a(throwable);
        return;
        SSLException sslexception;
        sslexception;
        String s1 = sslexception.getMessage();
        if (s1 == null || !s1.contains("possible truncation attack"))
            e.b("{} SSLEngine.closeInbound() raised an exception.", k1.a(), sslexception);
        if (true) goto _L2; else goto _L1
_L1:
    }

    private void a(k k1, boolean flag) {
        Object obj;
        Object obj1;
        Object obj7;
        obj7 = k1.c();
        obj = null;
        obj1 = null;
_L11:
        Object obj3;
        Object obj4;
        Object obj5;
        Object obj6;
        obj5 = obj1;
        obj6 = obj;
        obj4 = obj1;
        obj3 = obj;
        Object obj2 = w.e();
        if (obj2 != null) goto _L2; else goto _L1
_L1:
        a(k1, ((h) (obj1)), ((w) (obj)), flag, false);
_L3:
        return;
_L2:
        obj5 = obj1;
        obj6 = obj;
        obj4 = obj1;
        obj3 = obj;
        Object obj8 = (h)obj2;
        obj2 = obj1;
        if (obj1 != null)
            break MISSING_BLOCK_LABEL_108;
        obj5 = obj1;
        obj6 = obj;
        obj4 = obj1;
        obj3 = obj;
        obj2 = b(k1, ((h) (obj8)).f());
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        obj1 = a(((i) (obj7)), m, ((h) (obj8)), ((h) (obj2)));
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        if (((h) (obj8)).e())
            break MISSING_BLOCK_LABEL_244;
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        obj = w.d();
_L4:
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        if (((SSLEngineResult) (obj1)).getStatus() != javax.net.ssl.SSLEngineResult.Status.CLOSED)
            break MISSING_BLOCK_LABEL_249;
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        w.a(i);
        a(k1, ((h) (obj2)), ((w) (obj)), flag, false);
          goto _L3
        obj = null;
          goto _L4
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        io.netty.handler.ssl._cls8.a[((SSLEngineResult) (obj1)).getHandshakeStatus().ordinal()];
        JVM INSTR tableswitch 1 5: default 308
    //                   1 459
    //                   2 484
    //                   3 502
    //                   4 521
    //                   5 553;
           goto _L5 _L6 _L7 _L8 _L9 _L10
_L5:
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        obj7 = JVM INSTR new #435 <Class IllegalStateException>;
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        obj8 = JVM INSTR new #437 <Class StringBuilder>;
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        ((StringBuilder) (obj8)).StringBuilder();
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        ((IllegalStateException) (obj7)).IllegalStateException(((StringBuilder) (obj8)).append("Unknown handshake status: ").append(((SSLEngineResult) (obj1)).getHandshakeStatus()).toString());
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        try {
            throw obj7;
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            obj4 = obj5;
        }
        obj3 = obj6;
        b(k1, ((Throwable) (obj)));
        obj4 = obj5;
        obj3 = obj6;
        throw obj;
        obj;
        a(k1, ((h) (obj4)), ((w) (obj3)), flag, false);
        throw obj;
_L6:
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        g();
        obj1 = obj2;
          goto _L11
_L7:
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        i();
_L8:
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        h();
_L9:
        obj5 = obj2;
        obj6 = obj;
        obj4 = obj2;
        obj3 = obj;
        a(k1, ((h) (obj2)), ((w) (obj)), flag, false);
        obj = null;
        obj1 = null;
          goto _L11
_L10:
        a(k1, ((h) (obj2)), ((w) (obj)), flag, true);
          goto _L3
    }

    static void a(aj aj1, Throwable throwable) {
        aj1.b(throwable);
    }

    private void a(y y1) {
        if (y1 == null) goto _L2; else goto _L1
_L1:
        y y2 = x;
        if (y2.isDone()) goto _L4; else goto _L3
_L3:
        y2.g(new io.netty.util.concurrent.o(y1) {

            final y a;
            final aj b;

            public void a(io.netty.util.concurrent.n n1) {
                if (n1.g_())
                    a.a(n1.i());
                else
                    a.c(n1.j());
            }

             {
                b = aj.this;
                a = y1;
                super();
            }
        }
);
_L9:
        return;
_L4:
        x = y1;
_L6:
        k k1 = l;
        long l1;
        y y3;
        try {
            m.beginHandshake();
            b(k1, false);
            k1.n();
        }
        catch (Exception exception) {
            b(exception);
        }
        l1 = D;
        if (l1 > 0L && !y1.isDone())
            y1.g(new io.netty.util.concurrent.o(k1.d().a(new Runnable(y1) {

                final y a;
                final aj b;

                public void run() {
                    if (!a.isDone())
                        io.netty.handler.ssl.aj.a(b, aj.f());
                }

             {
                b = aj.this;
                a = y1;
                super();
            }
            }
, l1, TimeUnit.MILLISECONDS)) {

                final ScheduledFuture a;
                final aj b;

                public void a(io.netty.util.concurrent.n n1) {
                    a.cancel(false);
                }

             {
                b = aj.this;
                a = scheduledfuture;
                super();
            }
            }
);
        continue; /* Loop/switch isn't completed */
_L2:
        if (m.getHandshakeStatus() != javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING)
            continue; /* Loop/switch isn't completed */
        y3 = x;
        y1 = y3;
        if (d) goto _L6; else goto _L5
_L5:
        y1 = y3;
        if (!y3.isDone()) goto _L6; else goto _L7
_L7:
        throw new AssertionError();
        if (true) goto _L9; else goto _L8
_L8:
    }

    private boolean a(k k1, h h1, int i1, int j1) {
        int l1;
        int i2;
        boolean flag2;
        Object obj;
        flag2 = false;
        boolean flag = false;
        boolean flag1 = false;
        obj = a(k1, j1);
        l1 = j1;
        i2 = i1;
        j1 = ((flag1) ? 1 : 0);
        i1 = ((flag) ? 1 : 0);
_L12:
        int j2;
        int k2;
        Object obj1;
        Object obj2;
        SSLEngineResult sslengineresult = a(m, h1, i2, l1, ((h) (obj)));
        obj2 = sslengineresult.getStatus();
        obj1 = sslengineresult.getHandshakeStatus();
        j2 = sslengineresult.bytesProduced();
        k2 = sslengineresult.bytesConsumed();
        i2 += k2;
        l1 -= k2;
        io.netty.handler.ssl._cls8.b[((javax.net.ssl.SSLEngineResult.Status) (obj2)).ordinal()];
        JVM INSTR tableswitch 1 2: default 124
    //                   1 233
    //                   2 295;
           goto _L1 _L2 _L3
_L1:
        io.netty.handler.ssl._cls8.a[((javax.net.ssl.SSLEngineResult.HandshakeStatus) (obj1)).ordinal()];
        JVM INSTR tableswitch 1 5: default 168
    //                   1 393
    //                   2 400
    //                   3 409
    //                   4 384
    //                   5 301;
           goto _L4 _L5 _L6 _L7 _L8 _L9
_L4:
        h1 = JVM INSTR new #435 <Class IllegalStateException>;
        obj2 = JVM INSTR new #437 <Class StringBuilder>;
        ((StringBuilder) (obj2)).StringBuilder();
        h1.IllegalStateException(((StringBuilder) (obj2)).append("unknown handshake status: ").append(obj1).toString());
        throw h1;
        h1;
        b(k1, h1);
        throw h1;
        h1;
        if (((h) (obj)).e())
            k1.b(obj);
        else
            ((h) (obj)).B();
        throw h1;
_L2:
        j2 = ((h) (obj)).f();
        if (j2 <= 0) goto _L11; else goto _L10
_L10:
        flag2 = true;
        k1.b(obj);
_L13:
        obj1 = a(k1, m.getSession().getApplicationBufferSize() - j2);
        obj = obj1;
          goto _L12
_L11:
        ((h) (obj)).B();
          goto _L13
_L3:
        j1 = 1;
          goto _L1
_L9:
        if (obj2 != javax.net.ssl.SSLEngineResult.Status.BUFFER_UNDERFLOW && (k2 != 0 || j2 != 0)) goto _L12; else goto _L14
_L14:
        if (obj1 == javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP)
            l(k1);
        if (i1 == 0) goto _L16; else goto _L15
_L15:
        a(k1, true);
_L16:
        if (j1 == 0) goto _L18; else goto _L17
_L17:
        y.b(k1.a());
_L18:
        if (((h) (obj)).e()) {
            flag2 = true;
            k1.b(obj);
        } else {
            ((h) (obj)).B();
        }
        return flag2;
_L8:
        b(k1, true);
          goto _L9
_L5:
        g();
          goto _L9
_L6:
        i();
        i1 = 1;
          goto _L9
_L7:
        if (!h()) goto _L20; else goto _L19
_L19:
        i1 = 1;
          goto _L12
_L20:
        if (!u) goto _L9; else goto _L21
_L21:
        u = false;
        i1 = 1;
          goto _L9
    }

    static boolean a(aj aj1, boolean flag) {
        aj1.A = flag;
        return flag;
    }

    private boolean a(Throwable throwable) {
        boolean flag1 = true;
        if ((throwable instanceof SSLException) || !(throwable instanceof IOException) || !y.isDone()) goto _L2; else goto _L1
_L1:
        Object obj = String.valueOf(throwable.getMessage()).toLowerCase();
        if (!h.matcher(((CharSequence) (obj))).matches()) goto _L4; else goto _L3
_L3:
        boolean flag = flag1;
_L10:
        return flag;
_L4:
        int i1;
        int j1;
        throwable = throwable.getStackTrace();
        j1 = throwable.length;
        i1 = 0;
_L6:
        Object obj1;
        if (i1 >= j1)
            break; /* Loop/switch isn't completed */
        obj1 = throwable[i1];
        obj = ((StackTraceElement) (obj1)).getClassName();
        obj1 = ((StackTraceElement) (obj1)).getMethodName();
          goto _L5
_L8:
        i1++;
        if (true) goto _L6; else goto _L2
_L5:
        if (((String) (obj)).startsWith("io.netty.") || !"read".equals(obj1)) goto _L8; else goto _L7
_L7:
        flag = flag1;
        if (g.matcher(((CharSequence) (obj))).matches()) goto _L10; else goto _L9
_L9:
        obj = PlatformDependent.a(getClass()).loadClass(((String) (obj)));
        flag = flag1;
        if (java/nio/channels/SocketChannel.isAssignableFrom(((Class) (obj)))) goto _L10; else goto _L11
_L11:
        flag = flag1;
        if (java/nio/channels/DatagramChannel.isAssignableFrom(((Class) (obj)))) goto _L10; else goto _L12
_L12:
        if (PlatformDependent.d() < 7) goto _L8; else goto _L13
_L13:
        flag = "com.sun.nio.sctp.SctpChannel".equals(((Class) (obj)).getSuperclass().getName());
        if (!flag) goto _L8; else goto _L14
_L14:
        flag = flag1;
          goto _L10
_L2:
        flag = false;
          goto _L10
        ClassNotFoundException classnotfoundexception;
        classnotfoundexception;
          goto _L8
    }

    private h b(k k1, int i1) {
        if (r)
            k1 = a(k1, n);
        else
            k1 = a(k1, Math.min(i1 + 2329, n));
        return k1;
    }

    static k b(aj aj1) {
        return aj1.l;
    }

    private void b(k k1, Throwable throwable) {
        a(k1, throwable, true);
    }

    private void b(k k1, boolean flag) {
        Object obj1;
        i j1;
        j1 = k1.c();
        obj1 = null;
_L11:
        Object obj2;
        Object obj3;
        Object obj4;
        obj2 = obj1;
        if (obj1 != null)
            break MISSING_BLOCK_LABEL_36;
        obj4 = obj1;
        obj3 = obj1;
        obj2 = b(k1, 0);
        obj4 = obj2;
        obj3 = obj2;
        Object obj5 = a(j1, m, ak.c, ((h) (obj2)));
        Object obj;
        obj = obj2;
        obj4 = obj2;
        obj3 = obj2;
        if (((SSLEngineResult) (obj5)).bytesProduced() <= 0)
            break MISSING_BLOCK_LABEL_118;
        obj4 = obj2;
        obj3 = obj2;
        k1.c(obj2);
        if (!flag)
            break MISSING_BLOCK_LABEL_115;
        obj4 = obj2;
        obj3 = obj2;
        z = true;
        obj = null;
        obj4 = obj;
        obj3 = obj;
        io.netty.handler.ssl._cls8.a[((SSLEngineResult) (obj5)).getHandshakeStatus().ordinal()];
        JVM INSTR tableswitch 1 5: default 172
    //                   1 339
    //                   2 297
    //                   3 374
    //                   4 309
    //                   5 354;
           goto _L1 _L2 _L3 _L4 _L5 _L6
_L1:
        obj4 = obj;
        obj3 = obj;
        obj1 = JVM INSTR new #435 <Class IllegalStateException>;
        obj4 = obj;
        obj3 = obj;
        obj2 = JVM INSTR new #437 <Class StringBuilder>;
        obj4 = obj;
        obj3 = obj;
        ((StringBuilder) (obj2)).StringBuilder();
        obj4 = obj;
        obj3 = obj;
        ((IllegalStateException) (obj1)).IllegalStateException(((StringBuilder) (obj2)).append("Unknown handshake status: ").append(((SSLEngineResult) (obj5)).getHandshakeStatus()).toString());
        obj4 = obj;
        obj3 = obj;
        try {
            throw obj1;
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            obj3 = obj4;
        }
        b(k1, ((Throwable) (obj)));
        obj3 = obj4;
        m(k1);
        obj3 = obj4;
        throw obj;
        k1;
        if (obj3 != null)
            ((h) (obj3)).B();
        throw k1;
_L3:
        obj4 = obj;
        obj3 = obj;
        i();
_L5:
        obj4 = obj;
        obj3 = obj;
        int i1 = ((SSLEngineResult) (obj5)).bytesProduced();
        if (i1 != 0) goto _L8; else goto _L7
_L7:
        if (obj != null)
            ((h) (obj)).B();
        return;
_L2:
        obj4 = obj;
        obj3 = obj;
        g();
          goto _L5
_L6:
        if (flag) goto _L5; else goto _L9
_L9:
        obj4 = obj;
        obj3 = obj;
        n(k1);
          goto _L5
_L4:
        obj4 = obj;
        obj3 = obj;
        h();
        if (flag) goto _L5; else goto _L10
_L10:
        obj4 = obj;
        obj3 = obj;
        n(k1);
          goto _L5
_L8:
        obj1 = obj;
        obj4 = obj;
        obj3 = obj;
        if (((SSLEngineResult) (obj5)).bytesConsumed() != 0)
            break; /* Loop/switch isn't completed */
        obj4 = obj;
        obj3 = obj;
        obj5 = ((SSLEngineResult) (obj5)).getHandshakeStatus();
        obj4 = obj;
        obj3 = obj;
        obj2 = javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
        obj1 = obj;
        if (obj5 != obj2) goto _L11; else goto _L7
    }

    private void b(Throwable throwable) {
        if (x.b(throwable))
            io.netty.handler.ssl.am.a(l, throwable);
    }

    static b e() {
        return e;
    }

    static SSLException f() {
        return j;
    }

    private void g() {
        if (o != t.a) goto _L2; else goto _L1
_L1:
        Object obj = m.getDelegatedTask();
        if (obj != null) goto _L4; else goto _L3
_L3:
        return;
_L4:
        ((Runnable) (obj)).run();
          goto _L1
_L2:
        obj = new ArrayList(2);
_L5:
        boolean flag;
        Object obj1;
label0:
        {
            obj1 = m.getDelegatedTask();
            if (obj1 != null)
                break label0;
            if (!((List) (obj)).isEmpty()) {
                obj1 = new CountDownLatch(1);
                o.execute(new Runnable(((List) (obj)), ((CountDownLatch) (obj1))) {

                    final List a;
                    final CountDownLatch b;
                    final aj c;

                    public void run() {
                        for (Iterator iterator = a.iterator(); iterator.hasNext(); ((Runnable)iterator.next()).run());
                          goto _L1
                        Object obj2;
                        obj2;
                        io.netty.handler.ssl.aj.b(c).a(((Throwable) (obj2)));
                        b.countDown();
_L3:
                        return;
_L1:
                        b.countDown();
                        if (true) goto _L3; else goto _L2
_L2:
                        obj2;
                        b.countDown();
                        throw obj2;
                    }

             {
                c = aj.this;
                a = list;
                b = countdownlatch;
                super();
            }
                }
);
                flag = false;
                while (((CountDownLatch) (obj1)).getCount() != 0L) 
                    try {
                        ((CountDownLatch) (obj1)).await();
                    }
                    // Misplaced declaration of an exception variable
                    catch (Object obj) {
                        flag = true;
                    }
                break MISSING_BLOCK_LABEL_125;
            }
        }
          goto _L3
        ((List) (obj)).add(obj1);
          goto _L5
        if (flag)
            Thread.currentThread().interrupt();
          goto _L3
    }

    private boolean h() {
        boolean flag;
        if (!x.isDone()) {
            i();
            flag = true;
        } else {
            flag = false;
        }
        return flag;
    }

    private void i() {
        x.b(l.a());
        if (e.b())
            e.b("{} HANDSHAKEN: {}", l.a(), m.getSession().getCipherSuite());
        l.a(io.netty.handler.ssl.ak.a);
        if (v && !l.a().E().f()) {
            v = false;
            l.m();
        }
    }

    private void l(k k1) {
        if (!k1.a().E().f() && (!C || !x.isDone()))
            k1.m();
    }

    private void m(k k1) {
        if (z) {
            z = false;
            k1.n();
        }
    }

    private void n(k k1) {
        a(k1, ak.c, 0, 0);
    }

    public void a(k k1) {
        if (!x.isDone())
            v = true;
        k1.m();
    }

    public void a(k k1, w w1) {
        a(k1, w1, true);
    }

    public void a(k k1, Object obj, w w1) {
        if (!(obj instanceof h))
            w1.a(new UnsupportedMessageTypeException(obj, new Class[] {
                io/netty/buffer/h
            }));
        else
            w.a(obj, w1);
    }

    public void a(k k1, Throwable throwable) {
        if (a(throwable)) {
            if (e.b())
                e.b("{} Swallowing a harmless 'connection reset by peer / broken pipe' error that occurred while writing close_notify in response to the peer's close_notify", k1.a(), throwable);
            if (k1.a().G())
                k1.l();
        } else {
            k1.a(throwable);
        }
    }

    public void a(k k1, SocketAddress socketaddress, w w1) {
        k1.a(socketaddress, w1);
    }

    public void a(k k1, SocketAddress socketaddress, SocketAddress socketaddress1, w w1) {
        k1.a(socketaddress, socketaddress1, w1);
    }

    public void b(k k1) {
        if (!s || t) goto _L2; else goto _L1
_L1:
        t = true;
        w.b();
        k1.n();
_L4:
        return;
_L2:
        if (w.a())
            w.a(ak.c, k1.o());
        if (!x.isDone())
            u = true;
        a(k1, false);
        k1.n();
        if (true) goto _L4; else goto _L3
_L3:
        Exception exception;
        exception;
        k1.n();
        throw exception;
    }

    protected void b(k k1, h h1, List list) {
        int i2;
        boolean flag;
        int k2;
        flag = false;
        i2 = h1.b();
        k2 = h1.c();
        if (B <= 0)
            break MISSING_BLOCK_LABEL_275;
        if (k2 - i2 >= B) goto _L2; else goto _L1
_L1:
        return;
_L2:
        int i1;
        int j1;
        j1 = i2 + B;
        i1 = B;
        B = 0;
_L5:
        int l1;
        int l2;
        l1 = ((flag) ? 1 : 0);
        if (i1 < 18713) {
            l1 = k2 - j1;
            boolean flag1;
            if (l1 < 5) {
                l1 = ((flag) ? 1 : 0);
            } else {
                l2 = io.netty.handler.ssl.am.a(h1, j1);
                if (l2 == -1) {
                    l1 = 1;
                } else {
label0:
                    {
                        if (!d && l2 <= 0)
                            throw new AssertionError();
                        if (l2 <= l1)
                            break label0;
                        B = l2;
                        l1 = ((flag) ? 1 : 0);
                    }
                }
            }
        }
_L4:
        if (i1 > 0) {
            h1.s(i1);
            flag1 = a(k1, h1, i2, i1);
            if (!C)
                C = flag1;
        }
        if (l1 != 0) {
            list = new NotSslRecordException((new StringBuilder()).append("not an SSL/TLS record: ").append(io.netty.buffer.m.a(h1)).toString());
            h1.s(h1.f());
            k1.a(list);
            b(k1, ((Throwable) (list)));
        }
          goto _L1
        int j2;
        j2 = i1 + l2;
        l1 = ((flag) ? 1 : 0);
        if (j2 > 18713) goto _L4; else goto _L3
_L3:
        j1 += l2;
        i1 = j2;
          goto _L5
        i1 = 0;
        j1 = i2;
          goto _L5
    }

    public void b(k k1, w w1) {
        a(k1, w1, false);
    }

    public void c(k k1) {
        l = k1;
        w = new am(k1);
        if (k1.a().G() && m.getUseClientMode())
            a(((y) (null)));
    }

    public io.netty.util.concurrent.n d() {
        return x;
    }

    public void g(k k1) {
        if (!s && m.getUseClientMode())
            a(((y) (null)));
        k1.h();
    }

    public void h(k k1) {
        ClosedChannelException closedchannelexception = k;
        boolean flag;
        if (!A)
            flag = true;
        else
            flag = false;
        a(k1, closedchannelexception, flag);
        super.h(k1);
    }

    public void i(k k1) {
        c();
        m(k1);
        l(k1);
        C = false;
        k1.j();
    }

    public void k(k k1) {
        if (!w.a())
            w.a(new ChannelException("Pending write on removal of SslHandler"));
        if (m instanceof OpenSslEngine)
            ((OpenSslEngine)m).b();
    }

    static  {
        boolean flag;
        if (!io/netty/handler/ssl/aj.desiredAssertionStatus())
            flag = true;
        else
            flag = false;
        d = flag;
    }

    // Unreferenced inner class io/netty/handler/ssl/aj$1

/* anonymous class */
    class _cls1
        implements Runnable {

        final k a;
        final w b;
        final aj c;

        public void run() {
            io.netty.handler.ssl.aj.a(c, true);
            io.netty.handler.ssl.aj.a(c).closeOutbound();
            c.a(a, ak.c, b);
            c.b(a);
_L1:
            return;
            Exception exception;
            exception;
            if (!b.b(exception))
                io.netty.handler.ssl.aj.e().d("{} flush() raised a masked exception.", a.a(), exception);
              goto _L1
        }
    }

}
