// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.handler.ssl;

import io.netty.buffer.h;
import io.netty.util.internal.i;
import io.netty.util.internal.logging.b;
import io.netty.util.internal.logging.c;
import io.netty.util.internal.n;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Set;
import org.apache.tomcat.jni.Buffer;
import org.apache.tomcat.jni.Library;
import org.apache.tomcat.jni.Pool;
import org.apache.tomcat.jni.SSL;
import org.apache.tomcat.jni.SSLContext;

// Referenced classes of package io.netty.handler.ssl:
//            OpenSslEngine, c, u

public final class r {

    static final Set a;
    static final Set b;
    static final boolean c;
    private static final b d;
    private static final Throwable e;
    private static final Set f;
    private static final Set g;
    private static final boolean h;
    private static final String i[];

    private r() {
    }

    static long a(h h1) {
        if (!c && !h1.L())
            throw new AssertionError();
        long l;
        if (h1.P())
            l = h1.Q();
        else
            l = Buffer.address(h1.v());
        return l;
    }

    public static boolean a() {
        boolean flag;
        if (e == null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    static boolean a(long l) {
        boolean flag;
        if (l != 0L)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public static boolean a(String s) {
        String s1 = io.netty.handler.ssl.c.a(s);
        if (s1 != null)
            s = s1;
        return f.contains(s);
    }

    private static String b(String s) {
        s = d(s);
        if (s.startsWith("aix"))
            s = "aix";
        else
        if (s.startsWith("hpux"))
            s = "hpux";
        else
        if (s.startsWith("os400") && (s.length() <= 5 || !Character.isDigit(s.charAt(5))))
            s = "os400";
        else
        if (s.startsWith("linux"))
            s = "linux";
        else
        if (s.startsWith("macosx") || s.startsWith("osx"))
            s = "osx";
        else
        if (s.startsWith("freebsd"))
            s = "freebsd";
        else
        if (s.startsWith("openbsd"))
            s = "openbsd";
        else
        if (s.startsWith("netbsd"))
            s = "netbsd";
        else
        if (s.startsWith("solaris") || s.startsWith("sunos"))
            s = "sunos";
        else
        if (s.startsWith("windows"))
            s = "windows";
        else
            s = "unknown";
        return s;
    }

    public static void b() {
        if (e != null)
            throw (Error)(new UnsatisfiedLinkError("failed to load the required native library")).initCause(e);
        else
            return;
    }

    private static String c(String s) {
        s = d(s);
        if (s.matches("^(x8664|amd64|ia32e|em64t|x64)$"))
            s = "x86_64";
        else
        if (s.matches("^(x8632|x86|i[3-6]86|ia32|x32)$"))
            s = "x86_32";
        else
        if (s.matches("^(ia64|itanium64)$"))
            s = "itanium_64";
        else
        if (s.matches("^(sparc|sparc32)$"))
            s = "sparc_32";
        else
        if (s.matches("^(sparcv9|sparc64)$"))
            s = "sparc_64";
        else
        if (s.matches("^(arm|arm32)$"))
            s = "arm_32";
        else
        if ("aarch64".equals(s))
            s = "aarch_64";
        else
        if (s.matches("^(ppc|ppc32)$"))
            s = "ppc_32";
        else
        if ("ppc64".equals(s))
            s = "ppc_64";
        else
        if ("ppc64le".equals(s))
            s = "ppcle_64";
        else
        if ("s390".equals(s))
            s = "s390_32";
        else
        if ("s390x".equals(s))
            s = "s390_64";
        else
            s = "unknown";
        return s;
    }

    public static Set c() {
        return d();
    }

    private static String d(String s) {
        return s.toLowerCase(Locale.US).replaceAll("[^a-z0-9]+", "");
    }

    public static Set d() {
        return f;
    }

    public static boolean e() {
        return h;
    }

    private static void f() {
        String s = b(n.a("os.name", ""));
        String s1 = c(n.a("os.arch", ""));
        LinkedHashSet linkedhashset = new LinkedHashSet(3);
        linkedhashset.add((new StringBuilder()).append("netty-tcnative-").append(s).append('-').append(s1).toString());
        if ("linux".equalsIgnoreCase(s))
            linkedhashset.add((new StringBuilder()).append("netty-tcnative-").append(s).append('-').append(s1).append("-fedora").toString());
        linkedhashset.add("netty-tcnative");
        io.netty.util.internal.i.a(org/apache/tomcat/jni/SSL.getClassLoader(), (String[])linkedhashset.toArray(new String[linkedhashset.size()]));
    }

    private static void g() {
        Library.initialize("provided");
        SSL.initialize(null);
    }

    static  {
        long l4;
        Object obj;
        Object obj2;
        int j;
        int k;
        boolean flag;
        if (!io/netty/handler/ssl/r.desiredAssertionStatus())
            flag = true;
        else
            flag = false;
        c = flag;
        d = io.netty.util.internal.logging.c.a(io/netty/handler/ssl/r);
        i = (new String[] {
            "SSLv2Hello", "SSLv2", "SSLv3", "TLSv1", "TLSv1.1", "TLSv1.2"
        });
        b = Collections.unmodifiableSet(new HashSet(Arrays.asList(i)));
        obj = null;
        try {
            Class.forName("org.apache.tomcat.jni.SSL", false, io/netty/handler/ssl/r.getClassLoader());
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            d.a((new StringBuilder()).append("netty-tcnative not in the classpath; ").append(io/netty/handler/ssl/OpenSslEngine.getSimpleName()).append(" will be unavailable.").toString());
        }
        obj2 = obj;
        if (obj != null)
            break MISSING_BLOCK_LABEL_114;
        try {
            f();
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            d.a((new StringBuilder()).append("Failed to load netty-tcnative; ").append(io/netty/handler/ssl/OpenSslEngine.getSimpleName()).append(" will be unavailable, unless the ").append("application has already loaded the symbols by some other means. ").append("See http://netty.io/wiki/forked-tomcat-native.html for more information.").toString(), ((Throwable) (obj)));
        }
        g();
        obj2 = null;
_L10:
        e = ((Throwable) (obj2));
        if (obj2 != null) goto _L2; else goto _L1
_L1:
        obj2 = new LinkedHashSet(128);
        l4 = Pool.create(0L);
        Object obj1;
        long l;
        long l1;
        long l2;
        long l3;
        long l5;
        boolean flag1;
        Object obj3;
        try {
            l3 = SSLContext.make(l4, 31, 1);
        }
        // Misplaced declaration of an exception variable
        catch (Object obj1) {
            flag1 = false;
            continue; /* Loop/switch isn't completed */
        }
_L13:
        l2 = 0L;
        SSLContext.setOptions(l3, 4095);
        SSLContext.setCipherSuite(l3, "ALL");
        l5 = SSL.newSSL(l3, true);
        l1 = l2;
        obj = SSL.getCiphers(l5);
        l1 = l2;
        k = obj.length;
        j = 0;
_L9:
        if (j >= k) goto _L4; else goto _L3
_L3:
        obj3 = obj[j];
        if (obj3 == null) goto _L6; else goto _L5
_L5:
        l1 = l2;
        if (((String) (obj3)).length() == 0) goto _L6; else goto _L7
_L7:
        l1 = l2;
        flag = ((Set) (obj2)).contains(obj3);
        if (!flag) goto _L8; else goto _L6
_L6:
        j++;
          goto _L9
        obj3;
        obj2 = obj;
        if (obj == null)
            obj2 = obj3;
        d.a((new StringBuilder()).append("Failed to initialize netty-tcnative; ").append(io/netty/handler/ssl/OpenSslEngine.getSimpleName()).append(" will be unavailable. ").append("See http://netty.io/wiki/forked-tomcat-native.html for more information.").toString(), ((Throwable) (obj3)));
          goto _L10
_L8:
        l1 = l2;
        ((Set) (obj2)).add(obj3);
          goto _L6
        obj1;
        SSL.freeSSL(l5);
        if (0L == 0L)
            break MISSING_BLOCK_LABEL_449;
        SSL.freeBIO(0L);
        if (l1 == 0L)
            break MISSING_BLOCK_LABEL_461;
        SSL.freeBIO(l1);
        throw obj1;
        obj1;
        flag1 = false;
_L17:
        try {
            SSLContext.free(l3);
            throw obj1;
        }
        // Misplaced declaration of an exception variable
        catch (Object obj1) { }
_L16:
        d.b("Failed to get the list of available OpenSSL cipher suites.", ((Throwable) (obj1)));
        Pool.destroy(l4);
        break MISSING_BLOCK_LABEL_497;
_L4:
        l1 = l2;
        l = l2;
        obj1 = JVM INSTR new #232 <Class io.netty.handler.ssl.util.c>;
        l1 = l2;
        l = l2;
        ((io.netty.handler.ssl.util.c) (obj1)).io.netty.handler.ssl.util.c();
        l1 = l2;
        l = l2;
        l2 = u.a(new X509Certificate[] {
            ((io.netty.handler.ssl.util.c) (obj1)).a()
        });
        l1 = l2;
        l = l2;
        SSL.setCertificateChainBio(l5, l2, false);
        l = l2;
        flag1 = true;
_L12:
        SSL.freeSSL(l5);
        if (0L == 0L)
            break MISSING_BLOCK_LABEL_673;
        SSL.freeBIO(0L);
        if (l == 0L)
            break MISSING_BLOCK_LABEL_683;
        SSL.freeBIO(l);
        SSLContext.free(l3);
        Pool.destroy(l4);
          goto _L11
        obj1;
        l1 = l;
        d.a("KeyManagerFactory not supported.");
        flag1 = false;
          goto _L12
        obj1;
        Pool.destroy(l4);
        throw obj1;
_L11:
        f = Collections.unmodifiableSet(((Set) (obj2)));
        obj3 = new LinkedHashSet(f.size() * 2);
        for (obj1 = f.iterator(); ((Iterator) (obj1)).hasNext(); ((Set) (obj3)).add(io.netty.handler.ssl.c.a(((String) (obj2)), "SSL"))) {
            obj2 = (String)((Iterator) (obj1)).next();
            ((Set) (obj3)).add(io.netty.handler.ssl.c.a(((String) (obj2)), "TLS"));
        }

        g = Collections.unmodifiableSet(((Set) (obj3)));
        obj1 = new LinkedHashSet(f.size() + g.size());
        for (obj2 = f.iterator(); ((Iterator) (obj2)).hasNext(); ((Set) (obj1)).add((String)((Iterator) (obj2)).next()));
        for (obj2 = g.iterator(); ((Iterator) (obj2)).hasNext(); ((Set) (obj1)).add((String)((Iterator) (obj2)).next()));
        a = ((Set) (obj1));
        h = flag1;
_L14:
        return;
_L2:
        f = Collections.emptySet();
        g = Collections.emptySet();
        a = Collections.emptySet();
        h = false;
        if (true) goto _L14; else goto _L13
        obj1;
        if (true) goto _L16; else goto _L15
_L15:
        obj1;
          goto _L17
    }
}
