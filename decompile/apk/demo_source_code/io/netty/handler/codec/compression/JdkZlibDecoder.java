// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.handler.codec.compression;

import io.netty.buffer.h;
import io.netty.buffer.i;
import io.netty.channel.k;
import java.util.List;
import java.util.zip.*;

// Referenced classes of package io.netty.handler.codec.compression:
//            c, ZlibWrapper, DecompressionException

public class JdkZlibDecoder extends c {
    private static final class GzipState extends Enum {

        public static final GzipState a;
        public static final GzipState b;
        public static final GzipState c;
        public static final GzipState d;
        public static final GzipState e;
        public static final GzipState f;
        public static final GzipState g;
        public static final GzipState h;
        private static final GzipState i[];

        public static GzipState valueOf(String s) {
            return (GzipState)Enum.valueOf(io/netty/handler/codec/compression/JdkZlibDecoder$GzipState, s);
        }

        public static GzipState[] values() {
            return (GzipState[])i.clone();
        }

        static  {
            a = new GzipState("HEADER_START", 0);
            b = new GzipState("HEADER_END", 1);
            c = new GzipState("FLG_READ", 2);
            d = new GzipState("XLEN_READ", 3);
            e = new GzipState("SKIP_FNAME", 4);
            f = new GzipState("SKIP_COMMENT", 5);
            g = new GzipState("PROCESS_FHCRC", 6);
            h = new GzipState("FOOTER_START", 7);
            i = (new GzipState[] {
                a, b, c, d, e, f, g, h
            });
        }

        private GzipState(String s, int i1) {
            super(s, i1);
        }
    }


    private Inflater d;
    private final byte e[];
    private final CRC32 g;
    private GzipState h;
    private int i;
    private int j;
    private volatile boolean k;
    private boolean l;

    public JdkZlibDecoder() {
        this(ZlibWrapper.a, null);
    }

    public JdkZlibDecoder(ZlibWrapper zlibwrapper) {
        this(zlibwrapper, null);
    }

    private JdkZlibDecoder(ZlibWrapper zlibwrapper, byte abyte0[]) {
        h = GzipState.a;
        i = -1;
        j = -1;
        if (zlibwrapper == null)
            throw new NullPointerException("wrapper");
        static class _cls1 {

            static final int a[];
            static final int b[];

            static  {
                b = new int[GzipState.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    b[io.netty.handler.codec.compression.GzipState.h.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror11) { }
                try {
                    b[GzipState.a.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror10) { }
                try {
                    b[GzipState.c.ordinal()] = 3;
                }
                catch (NoSuchFieldError nosuchfielderror9) { }
                try {
                    b[GzipState.d.ordinal()] = 4;
                }
                catch (NoSuchFieldError nosuchfielderror8) { }
                try {
                    b[GzipState.e.ordinal()] = 5;
                }
                catch (NoSuchFieldError nosuchfielderror7) { }
                try {
                    b[GzipState.f.ordinal()] = 6;
                }
                catch (NoSuchFieldError nosuchfielderror6) { }
                try {
                    b[GzipState.g.ordinal()] = 7;
                }
                catch (NoSuchFieldError nosuchfielderror5) { }
                try {
                    b[GzipState.b.ordinal()] = 8;
                }
                catch (NoSuchFieldError nosuchfielderror4) { }
                a = new int[ZlibWrapper.values().length];
                try {
                    a[ZlibWrapper.b.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror3) { }
                try {
                    a[ZlibWrapper.c.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror2) { }
                try {
                    a[ZlibWrapper.a.ordinal()] = 3;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                a[ZlibWrapper.d.ordinal()] = 4;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        _cls1.a[zlibwrapper.ordinal()];
        JVM INSTR tableswitch 1 4: default 72
    //                   1 99
    //                   2 128
    //                   3 148
    //                   4 167;
           goto _L1 _L2 _L3 _L4 _L5
_L1:
        throw new IllegalArgumentException((new StringBuilder()).append("Only GZIP or ZLIB is supported, but you used ").append(zlibwrapper).toString());
_L2:
        d = new Inflater(true);
        g = new CRC32();
_L7:
        e = abyte0;
        return;
_L3:
        d = new Inflater(true);
        g = null;
        continue; /* Loop/switch isn't completed */
_L4:
        d = new Inflater();
        g = null;
        continue; /* Loop/switch isn't completed */
_L5:
        l = true;
        g = null;
        if (true) goto _L7; else goto _L6
_L6:
    }

    private boolean a(h h1) {
        boolean flag1 = false;
        _cls1.b[h.ordinal()];
        JVM INSTR tableswitch 2 8: default 56
    //                   2 64
    //                   3 286
    //                   4 355
    //                   5 409
    //                   6 454
    //                   7 499
    //                   8 539;
           goto _L1 _L2 _L3 _L4 _L5 _L6 _L7 _L8
_L1:
        throw new IllegalStateException();
_L2:
        if (h1.f() >= 10) goto _L10; else goto _L9
_L9:
        boolean flag = flag1;
_L12:
        return flag;
_L10:
        byte byte0 = h1.n();
        short word0 = h1.n();
        if (byte0 != 31)
            throw new DecompressionException("Input is not in the GZIP format");
        g.update(byte0);
        g.update(word0);
        word0 = h1.o();
        if (word0 != 8)
            throw new DecompressionException((new StringBuilder()).append("Unsupported compression method ").append(word0).append(" in the GZIP header").toString());
        g.update(word0);
        i = h1.o();
        g.update(i);
        if ((i & 0xe0) != 0)
            throw new DecompressionException("Reserved flags are set in the GZIP header");
        g.update(h1.n());
        g.update(h1.n());
        g.update(h1.n());
        g.update(h1.n());
        g.update(h1.o());
        g.update(h1.o());
        h = GzipState.c;
_L3:
        if ((i & 4) == 0)
            break MISSING_BLOCK_LABEL_348;
        flag = flag1;
        if (h1.f() < 2) goto _L12; else goto _L11
_L11:
        short word1 = h1.o();
        short word3 = h1.o();
        g.update(word1);
        g.update(word3);
        j = word1 << 8 | word3 | j;
        h = GzipState.d;
_L4:
        if (j == -1)
            break MISSING_BLOCK_LABEL_402;
        flag = flag1;
        if (h1.f() < j) goto _L12; else goto _L13
_L13:
        byte abyte0[] = new byte[j];
        h1.a(abyte0);
        g.update(abyte0);
        h = GzipState.e;
_L5:
        if ((i & 8) == 0) goto _L15; else goto _L14
_L14:
        flag = flag1;
        if (!h1.e()) goto _L12; else goto _L16
_L16:
        short word2;
        word2 = h1.o();
        g.update(word2);
        continue; /* Loop/switch isn't completed */
_L15:
        h = GzipState.f;
_L6:
        if ((i & 0x10) == 0) goto _L18; else goto _L17
_L17:
        flag = flag1;
        if (!h1.e()) goto _L12; else goto _L19
_L19:
        word2 = h1.o();
        g.update(word2);
        continue; /* Loop/switch isn't completed */
_L18:
        h = GzipState.g;
_L7:
        if ((i & 2) == 0)
            break MISSING_BLOCK_LABEL_525;
        flag = flag1;
        if (h1.f() < 4) goto _L12; else goto _L20
_L20:
        c(h1);
        g.reset();
        h = GzipState.b;
_L8:
        flag = true;
          goto _L12
        if (word2 != 0 && h1.e()) goto _L16; else goto _L15
        if (word2 != 0 && h1.e()) goto _L19; else goto _L18
    }

    private static boolean a(short word0) {
        boolean flag;
        if ((word0 & 0x7800) == 30720 && word0 % 31 == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private boolean b(h h1) {
        int j1 = 0;
        boolean flag = false;
        if (h1.f() >= 8) {
            c(h1);
            int i1 = 0;
            for (; j1 < 4; j1++)
                i1 |= h1.o() << j1 * 8;

            j1 = d.getTotalOut();
            if (i1 != j1)
                throw new DecompressionException((new StringBuilder()).append("Number of bytes mismatch. Expected: ").append(i1).append(", Got: ").append(j1).toString());
            flag = true;
        }
        return flag;
    }

    private void c(h h1) {
        long l1 = 0L;
        for (int i1 = 0; i1 < 4; i1++)
            l1 |= (long)h1.o() << i1 * 8;

        long l2 = g.getValue();
        if (l1 != l2)
            throw new DecompressionException((new StringBuilder()).append("CRC value missmatch. Expected: ").append(l1).append(", Got: ").append(l2).toString());
        else
            return;
    }

    protected void b(k k1, h h1, List list) {
        boolean flag = false;
        if (!k) goto _L2; else goto _L1
_L1:
        h1.s(h1.f());
_L4:
        return;
_L2:
        int i1 = h1.f();
        if (i1 == 0) goto _L4; else goto _L3
_L3:
        if (!l)
            break MISSING_BLOCK_LABEL_79;
        if (i1 < 2) goto _L4; else goto _L5
_L5:
        int j1;
        int i2;
        int j2;
        Object obj;
        Object obj1;
        h h2;
        byte abyte0[];
        int l1;
        boolean flag1;
        if (!a(h1.i(h1.b())))
            flag1 = true;
        else
            flag1 = false;
        d = new Inflater(flag1);
        l = false;
        if (g == null) goto _L7; else goto _L6
_L6:
        _cls1.b[h.ordinal()];
        JVM INSTR tableswitch 1 1: default 116
    //                   1 349;
           goto _L8 _L9
_L8:
        if (h != GzipState.b && !a(h1)) goto _L4; else goto _L10
_L10:
        i1 = h1.f();
_L7:
        if (h1.M()) {
            d.setInput(h1.N(), h1.O() + h1.b(), i1);
        } else {
            obj = new byte[i1];
            h1.a(h1.b(), ((byte []) (obj)));
            d.setInput(((byte []) (obj)));
        }
        l1 = d.getRemaining() << 1;
        h2 = k1.c().c(l1);
        obj = h2;
        obj1 = h2;
        abyte0 = h2.N();
_L15:
        j1 = ((flag) ? 1 : 0);
        obj = h2;
        obj1 = h2;
        if (d.needsInput()) goto _L12; else goto _L11
_L11:
        obj = h2;
        obj1 = h2;
        j1 = h2.c();
        obj = h2;
        obj1 = h2;
        i2 = h2.O() + j1;
        obj = h2;
        obj1 = h2;
        j2 = h2.g();
        if (j2 != 0) goto _L14; else goto _L13
_L13:
        obj = h2;
        obj1 = h2;
        list.add(h2);
        obj = h2;
        obj1 = h2;
        h2 = k1.c().c(l1);
        obj = h2;
        obj1 = h2;
        abyte0 = h2.N();
          goto _L15
_L9:
        if (b(h1))
            k = true;
          goto _L4
_L14:
        obj = h2;
        obj1 = h2;
        j2 = d.inflate(abyte0, i2, j2);
        if (j2 <= 0) goto _L17; else goto _L16
_L16:
        obj = h2;
        obj1 = h2;
        h2.c(j1 + j2);
        obj = h2;
        obj1 = h2;
        if (g == null)
            break MISSING_BLOCK_LABEL_477;
        obj = h2;
        obj1 = h2;
        g.update(abyte0, i2, j2);
_L22:
        obj = h2;
        obj1 = h2;
        if (!d.finished()) goto _L15; else goto _L18
_L18:
        obj = h2;
        obj1 = h2;
        if (g != null) goto _L20; else goto _L19
_L19:
        obj = h2;
        obj1 = h2;
        k = true;
        j1 = ((flag) ? 1 : 0);
_L12:
        obj = h2;
        obj1 = h2;
        h1.s(i1 - d.getRemaining());
        if (j1 == 0)
            break MISSING_BLOCK_LABEL_599;
        obj = h2;
        obj1 = h2;
        h = io.netty.handler.codec.compression.GzipState.h;
        obj = h2;
        obj1 = h2;
        if (!b(h1))
            break MISSING_BLOCK_LABEL_599;
        obj = h2;
        obj1 = h2;
        k = true;
        if (h2.e())
            list.add(h2);
        else
            h2.B();
          goto _L4
_L17:
        obj = h2;
        obj1 = h2;
        if (!d.needsDictionary()) goto _L22; else goto _L21
_L21:
        obj = h2;
        obj1 = h2;
        if (e != null) goto _L24; else goto _L23
_L23:
        obj = h2;
        obj1 = h2;
        k1 = JVM INSTR new #115 <Class DecompressionException>;
        obj = h2;
        obj1 = h2;
        k1.DecompressionException("decompression failure, unable to set dictionary as non was specified");
        obj = h2;
        obj1 = h2;
        try {
            throw k1;
        }
        // Misplaced declaration of an exception variable
        catch (k k1) { }
        h1 = JVM INSTR new #115 <Class DecompressionException>;
        h1.DecompressionException("decompression failure", k1);
        throw h1;
        k1;
        obj1 = obj;
_L25:
        if (((h) (obj1)).e())
            list.add(obj1);
        else
            ((h) (obj1)).B();
        throw k1;
_L24:
        obj = h2;
        obj1 = h2;
        d.setDictionary(e);
          goto _L22
        k1;
          goto _L25
_L20:
        j1 = 1;
          goto _L12
    }

    protected void k(k k1) {
        super.k(k1);
        if (d != null)
            d.end();
    }
}
