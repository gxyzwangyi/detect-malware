// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package io.netty.handler.codec.http;

import io.netty.buffer.h;
import java.util.*;

// Referenced classes of package io.netty.handler.codec.http:
//            t, e, HttpHeaderDateFormat, ag, 
//            r, z, v, ac, 
//            af

public abstract class s
    implements Iterable {

    private static final byte a[] = {
        58, 32
    };
    public static final s b = new s() {

        public s a() {
            throw new UnsupportedOperationException("read only");
        }

        public s a(String s1) {
            throw new UnsupportedOperationException("read only");
        }

        public s a(String s1, Iterable iterable) {
            throw new UnsupportedOperationException("read only");
        }

        public s a(String s1, Object obj) {
            throw new UnsupportedOperationException("read only");
        }

        public s b(String s1, Object obj) {
            throw new UnsupportedOperationException("read only");
        }

        public String b(String s1) {
            return null;
        }

        public List b() {
            return Collections.emptyList();
        }

        public List c(String s1) {
            return Collections.emptyList();
        }

        public boolean c() {
            return true;
        }

        public Set d() {
            return Collections.emptySet();
        }

        public boolean d(String s1) {
            return false;
        }

        public Iterator iterator() {
            return b().iterator();
        }

    }
;
    private static final byte c[] = {
        13, 10
    };
    private static final CharSequence d = e("Content-Length");
    private static final CharSequence e = e("Connection");
    private static final CharSequence f = e("close");
    private static final CharSequence g = e("keep-alive");
    private static final CharSequence h = e("Host");
    private static final CharSequence i = e("Date");
    private static final CharSequence j = e("Expect");
    private static final CharSequence k = e("100-continue");
    private static final CharSequence l = e("Transfer-Encoding");
    private static final CharSequence m = e("chunked");
    private static final CharSequence n = e("Sec-WebSocket-Key1");
    private static final CharSequence o = e("Sec-WebSocket-Key2");
    private static final CharSequence p = e("Sec-WebSocket-Origin");
    private static final CharSequence q = e("Sec-WebSocket-Location");

    protected s() {
    }

    private static byte a(char c1) {
        byte byte0;
        if (c1 > '\377')
            byte0 = 63;
        else
            byte0 = (byte)c1;
        return byte0;
    }

    public static long a(t t1, long l1) {
        String s1 = t1.j().c(d);
        if (s1 == null) goto _L2; else goto _L1
_L1:
        long l2 = Long.parseLong(s1);
        l1 = l2;
_L4:
        return l1;
_L2:
        long l3 = g(t1);
        if (l3 >= 0L)
            l1 = l3;
        continue; /* Loop/switch isn't completed */
        t1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public static String a(t t1, String s1) {
        return t1.j().b(s1);
    }

    static void a(s s1, h h1) {
        if (s1 instanceof e) {
            ((e)s1).a(h1);
        } else {
            s1 = s1.iterator();
            while (s1.hasNext())  {
                java.util.Map.Entry entry = (java.util.Map.Entry)s1.next();
                a((CharSequence)entry.getKey(), (CharSequence)entry.getValue(), h1);
            }
        }
    }

    public static void a(t t1, CharSequence charsequence) {
        t1.j().b(charsequence);
    }

    public static void a(t t1, CharSequence charsequence, Object obj) {
        t1.j().a(charsequence, obj);
    }

    public static void a(t t1, String s1, Object obj) {
        t1.j().a(s1, obj);
    }

    public static void a(t t1, Date date) {
        if (date != null)
            t1.j().b(i, HttpHeaderDateFormat.a().format(date));
        else
            t1.j().a(i, ((Iterable) (null)));
    }

    public static void a(t t1, boolean flag) {
        s s1 = t1.j();
        if (t1.k().e()) {
            if (flag)
                s1.b(e);
            else
                s1.b(e, f);
        } else
        if (flag)
            s1.b(e, g);
        else
            s1.b(e);
    }

    static void a(CharSequence charsequence, CharSequence charsequence1, h h1) {
        if (!a(charsequence, h1))
            h1.b(a);
        if (!a(charsequence1, h1))
            h1.b(c);
    }

    public static boolean a(t t1) {
        boolean flag;
        String s1;
        flag = false;
        s1 = t1.j().c(e);
        if (s1 == null || !a(f, ((CharSequence) (s1)))) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        if (t1.k().e()) {
            if (!a(f, ((CharSequence) (s1))))
                flag = true;
        } else {
            flag = a(g, ((CharSequence) (s1)));
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    public static boolean a(CharSequence charsequence, h h1) {
        boolean flag;
        if (charsequence instanceof r) {
            flag = ((r)charsequence).a(h1);
        } else {
            b(charsequence, h1);
            flag = false;
        }
        return flag;
    }

    public static boolean a(CharSequence charsequence, CharSequence charsequence1) {
        boolean flag1 = true;
        if (charsequence != charsequence1) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        int i1;
        if (charsequence == null || charsequence1 == null) {
            flag = false;
            continue; /* Loop/switch isn't completed */
        }
        i1 = charsequence.length();
        if (i1 != charsequence1.length()) {
            flag = false;
            continue; /* Loop/switch isn't completed */
        }
        i1--;
_L5:
        flag = flag1;
        if (i1 >= 0) {
label0:
            {
                char c2 = charsequence.charAt(i1);
                char c3 = charsequence1.charAt(i1);
                if (c2 == c3)
                    break label0;
                char c1 = c2;
                if (c2 >= 'A') {
                    c1 = c2;
                    if (c2 <= 'Z')
                        c1 = (char)(c2 + 32);
                }
                c2 = c3;
                if (c3 >= 'A') {
                    c2 = c3;
                    if (c3 <= 'Z')
                        c2 = (char)(c3 + 32);
                }
                if (c1 == c2)
                    break label0;
                flag = false;
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
        i1--;
          goto _L5
        if (true) goto _L4; else goto _L6
_L6:
    }

    public static void b(t t1, long l1) {
        t1.j().b(d, Long.valueOf(l1));
    }

    public static void b(t t1, String s1) {
        t1.j().b(h, s1);
    }

    static void b(CharSequence charsequence, h h1) {
        int j1 = charsequence.length();
        for (int i1 = 0; i1 < j1; i1++)
            h1.t(a(charsequence.charAt(i1)));

    }

    public static boolean b(t t1) {
        boolean flag1 = false;
        if (t1 instanceof z) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        flag = flag1;
        if (t1.k().a(ag.b) >= 0) {
            String s1 = t1.j().c(j);
            flag = flag1;
            if (s1 != null)
                if (a(k, s1))
                    flag = true;
                else
                    flag = t1.j().a(j, k, true);
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public static boolean c(t t1) {
        return t1.j().a(l, m, true);
    }

    public static void d(t t1) {
        List list = t1.j().d(l);
        if (!list.isEmpty()) {
            Iterator iterator = list.iterator();
            do {
                if (!iterator.hasNext())
                    break;
                if (a((String)iterator.next(), m))
                    iterator.remove();
            } while (true);
            if (list.isEmpty())
                t1.j().b(l);
            else
                t1.j().a(l, list);
        }
    }

    public static CharSequence e(String s1) {
        if (s1 == null)
            throw new NullPointerException("name");
        else
            return new r(s1);
    }

    public static void e(t t1) {
        a(t1, l, m);
        a(t1, d);
    }

    static void f(CharSequence charsequence) {
        if (charsequence == null)
            throw new NullPointerException("Header names cannot be null");
        int i1 = 0;
        do {
            if (i1 >= charsequence.length())
                break;
            char c1 = charsequence.charAt(i1);
            if (c1 > '\177')
                throw new IllegalArgumentException((new StringBuilder()).append("Header name cannot contain non-ASCII characters: ").append(charsequence).toString());
            switch (c1) {
            default:
                i1++;
                break;

            case 9: // '\t'
            case 10: // '\n'
            case 11: // '\013'
            case 12: // '\f'
            case 13: // '\r'
            case 32: // ' '
            case 44: // ','
            case 58: // ':'
            case 59: // ';'
            case 61: // '='
                throw new IllegalArgumentException((new StringBuilder()).append("Header name cannot contain the following prohibited characters: =,;: \\t\\r\\n\\v\\f: ").append(charsequence).toString());
            }
        } while (true);
    }

    public static boolean f(t t1) {
        return t1.j().e(d);
    }

    private static int g(t t1) {
        s s1 = t1.j();
        if (!(t1 instanceof z)) goto _L2; else goto _L1
_L1:
        t1 = (z)t1;
        if (!v.b.equals(t1.l()) || !s1.e(n) || !s1.e(o)) goto _L4; else goto _L3
_L3:
        byte byte0 = 8;
_L6:
        return byte0;
_L2:
        if ((t1 instanceof ac) && ((ac)t1).h().a() == 101 && s1.e(p) && s1.e(q)) {
            byte0 = 16;
            continue; /* Loop/switch isn't completed */
        }
_L4:
        byte0 = -1;
        if (true) goto _L6; else goto _L5
_L5:
    }

    static void g(CharSequence charsequence) {
        int i1;
        int j1;
        if (charsequence == null)
            throw new NullPointerException("Header values cannot be null");
        j1 = 0;
        i1 = 0;
_L3:
        if (j1 >= charsequence.length())
            break; /* Loop/switch isn't completed */
        char c1 = charsequence.charAt(j1);
        switch (c1) {
        default:
            switch (i1) {
            case 0: // '\0'
                switch (c1) {
                case 10: // '\n'
                    i1 = 2;
                    break;

                case 13: // '\r'
                    i1 = 1;
                    break;
                }
                // fall through

            default:
                if (false)
                    ;
                break;

            case 1: // '\001'
                switch (c1) {
                default:
                    throw new IllegalArgumentException((new StringBuilder()).append("Only '\\n' is allowed after '\\r': ").append(charsequence).toString());

                case 10: // '\n'
                    i1 = 2;
                    break;
                }
                if (false)
                    ;
                break;

            case 2: // '\002'
                switch (c1) {
                default:
                    throw new IllegalArgumentException((new StringBuilder()).append("Only ' ' and '\\t' are allowed after '\\n': ").append(charsequence).toString());

                case 9: // '\t'
                case 32: // ' '
                    i1 = 0;
                    break;
                }
                break;
            }
            break;

        case 11: // '\013'
            throw new IllegalArgumentException((new StringBuilder()).append("Header value contains a prohibited character '\\v': ").append(charsequence).toString());

        case 12: // '\f'
            throw new IllegalArgumentException((new StringBuilder()).append("Header value contains a prohibited character '\\f': ").append(charsequence).toString());
        }
          goto _L1
_L5:
        j1++;
        if (true) goto _L3; else goto _L2
_L2:
        if (i1 != 0)
            throw new IllegalArgumentException((new StringBuilder()).append("Header value must not end with '\\r' or '\\n':").append(charsequence).toString());
        break; /* Loop/switch isn't completed */
_L1:
        if (true) goto _L5; else goto _L4
_L4:
    }

    static int h(CharSequence charsequence) {
        if (!(charsequence instanceof r)) goto _L2; else goto _L1
_L1:
        int i1 = ((r)charsequence).a();
_L4:
        return i1;
_L2:
        i1 = 0;
        for (int j1 = charsequence.length() - 1; j1 >= 0; j1--) {
            char c2 = charsequence.charAt(j1);
            char c1 = c2;
            if (c2 >= 'A') {
                c1 = c2;
                if (c2 <= 'Z')
                    c1 = (char)(c2 + 32);
            }
            i1 = i1 * 31 + c1;
        }

        if (i1 <= 0)
            if (i1 == 0x80000000)
                i1 = 0x7fffffff;
            else
                i1 = -i1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public abstract s a();

    public s a(s s1) {
        if (s1 == null)
            throw new NullPointerException("headers");
        java.util.Map.Entry entry;
        for (s1 = s1.iterator(); s1.hasNext(); a((String)entry.getKey(), entry.getValue()))
            entry = (java.util.Map.Entry)s1.next();

        return this;
    }

    public s a(CharSequence charsequence, Iterable iterable) {
        return a(charsequence.toString(), iterable);
    }

    public s a(CharSequence charsequence, Object obj) {
        return a(charsequence.toString(), obj);
    }

    public abstract s a(String s1);

    public abstract s a(String s1, Iterable iterable);

    public abstract s a(String s1, Object obj);

    public boolean a(CharSequence charsequence, CharSequence charsequence1, boolean flag) {
        return a(charsequence.toString(), charsequence1.toString(), flag);
    }

    public boolean a(String s1, String s2, boolean flag) {
        s1 = c(s1);
        if (!s1.isEmpty()) goto _L2; else goto _L1
_L1:
        flag = false;
_L4:
        return flag;
_L2:
label0:
        {
            Iterator iterator = s1.iterator();
label1:
            do {
                do {
                    if (!iterator.hasNext())
                        break label0;
                    s1 = (String)iterator.next();
                    if (!flag)
                        continue label1;
                } while (!a(((CharSequence) (s1)), ((CharSequence) (s2))));
                flag = true;
                continue; /* Loop/switch isn't completed */
            } while (!s1.equals(s2));
            flag = true;
            continue; /* Loop/switch isn't completed */
        }
        flag = false;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public s b(s s1) {
        if (s1 == null)
            throw new NullPointerException("headers");
        if (s1 != this) {
            a();
            for (Iterator iterator = s1.iterator(); iterator.hasNext(); a((String)s1.getKey(), s1.getValue()))
                s1 = (java.util.Map.Entry)iterator.next();

        }
        return this;
    }

    public s b(CharSequence charsequence) {
        return a(charsequence.toString());
    }

    public s b(CharSequence charsequence, Object obj) {
        return b(charsequence.toString(), obj);
    }

    public abstract s b(String s1, Object obj);

    public abstract String b(String s1);

    public abstract List b();

    public String c(CharSequence charsequence) {
        return b(charsequence.toString());
    }

    public abstract List c(String s1);

    public abstract boolean c();

    public List d(CharSequence charsequence) {
        return c(charsequence.toString());
    }

    public abstract Set d();

    public abstract boolean d(String s1);

    public boolean e(CharSequence charsequence) {
        return d(charsequence.toString());
    }

}
