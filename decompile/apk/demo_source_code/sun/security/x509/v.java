// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package sun.security.x509;

import java.io.IOException;
import java.net.InetAddress;
import java.util.Arrays;
import sun.misc.HexDumpEncoder;
import sun.security.util.a;
import sun.security.util.i;

// Referenced classes of package sun.security.x509:
//            t

public class v
    implements t {

    private byte a[];
    private boolean b;
    private String c;

    public int a() {
        return 7;
    }

    public int a(t t1) {
        int k;
        byte byte0;
        boolean flag;
        int i1;
        boolean flag1;
        byte0 = 3;
        k = 1;
        flag1 = true;
        i1 = 0;
        flag = false;
        if (t1 != null) goto _L2; else goto _L1
_L1:
        int j = -1;
_L4:
        return j;
_L2:
        if (t1.a() != 7) {
            j = -1;
            continue; /* Loop/switch isn't completed */
        }
        if (((v)t1).equals(this)) {
            j = 0;
            continue; /* Loop/switch isn't completed */
        }
        t1 = ((v)t1).c();
        if (t1.length == 4) {
            j = byte0;
            if (a.length == 4)
                continue; /* Loop/switch isn't completed */
        }
        if (t1.length == 8 && a.length == 8 || t1.length == 32 && a.length == 32) {
            int j1 = a.length / 2;
            j = 0;
            i1 = 0;
            flag = false;
            k = 1;
            byte0 = 1;
            for (; j < j1; j++) {
                if ((byte)(a[j] & a[j + j1]) != a[j])
                    flag = true;
                if ((byte)(t1[j] & t1[j + j1]) != t1[j])
                    i1 = 1;
                if ((byte)(a[j + j1] & t1[j + j1]) != a[j + j1] || (byte)(a[j] & a[j + j1]) != (byte)(t1[j] & a[j + j1]))
                    byte0 = 0;
                if ((byte)(t1[j + j1] & a[j + j1]) != t1[j + j1] || (byte)(t1[j] & t1[j + j1]) != (byte)(a[j] & t1[j + j1]))
                    k = 0;
            }

            if (flag || i1 != 0) {
                if (flag && i1 != 0) {
                    j = 0;
                } else {
                    j = ((flag1) ? 1 : 0);
                    if (flag)
                        j = 2;
                }
            } else {
                j = ((flag1) ? 1 : 0);
                if (byte0 == 0)
                    if (k != 0)
                        j = 2;
                    else
                        j = 3;
            }
            continue; /* Loop/switch isn't completed */
        }
        if (t1.length == 8 || t1.length == 32) {
            i1 = t1.length / 2;
            k = ((flag) ? 1 : 0);
            do {
                if (k >= i1 || (a[k] & t1[k + i1]) != t1[k]) {
                    j = byte0;
                    if (k == i1)
                        j = 2;
                    continue; /* Loop/switch isn't completed */
                }
                k++;
            } while (true);
        }
        if (a.length != 8) {
            j = byte0;
            if (a.length != 32)
                continue; /* Loop/switch isn't completed */
        }
label0:
        {
            int l = a.length / 2;
            for (j = i1; j < l && (t1[j] & a[j + l]) == a[j]; j++)
                break label0;

            if (j == l)
                j = k;
            else
                j = 3;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void a(i j) {
        j.b(a);
    }

    public String b() {
        int j;
        boolean flag;
        j = 16;
        flag = false;
        if (c == null) goto _L2; else goto _L1
_L1:
        Object obj = c;
_L4:
        return ((String) (obj));
_L2:
        if (!b)
            break; /* Loop/switch isn't completed */
        obj = new byte[4];
        System.arraycopy(a, 0, obj, 0, 4);
        c = InetAddress.getByAddress(((byte []) (obj))).getHostAddress();
        if (a.length == 8) {
            obj = new byte[4];
            System.arraycopy(a, 4, obj, 0, 4);
            c = (new StringBuilder()).append(c).append("/").append(InetAddress.getByAddress(((byte []) (obj))).getHostAddress()).toString();
        }
_L6:
        obj = c;
        if (true) goto _L4; else goto _L3
_L3:
        byte abyte0[] = new byte[16];
        System.arraycopy(a, 0, abyte0, 0, 16);
        c = InetAddress.getByAddress(abyte0).getHostAddress();
        if (a.length != 32) goto _L6; else goto _L5
_L5:
        byte abyte1[] = new byte[16];
        for (; j < 32; j++)
            abyte1[j - 16] = a[j];

        abyte1 = new a(128, abyte1);
        j = ((flag) ? 1 : 0);
_L9:
        if (j < 128 && abyte1.a(j)) goto _L8; else goto _L7
_L7:
        c = (new StringBuilder()).append(c).append("/").append(j).toString();
_L10:
        if (j < 128) {
            if (abyte1.a(j))
                throw new IOException((new StringBuilder()).append("Invalid IPv6 subdomain - set bit ").append(j).append(" not contiguous").toString());
            break MISSING_BLOCK_LABEL_300;
        }
          goto _L6
_L8:
        j++;
          goto _L9
        j++;
          goto _L10
    }

    public byte[] c() {
        return (byte[])a.clone();
    }

    public boolean equals(Object obj) {
        if (this != obj) goto _L2; else goto _L1
_L1:
        boolean flag = true;
_L9:
        return flag;
_L2:
        byte abyte1[];
        if (!(obj instanceof v)) {
            flag = false;
            continue; /* Loop/switch isn't completed */
        }
        abyte1 = ((v)obj).c();
        if (abyte1.length != a.length) {
            flag = false;
            continue; /* Loop/switch isn't completed */
        }
        if (a.length != 8 && a.length != 32) goto _L4; else goto _L3
_L3:
        int k;
        int l = a.length / 2;
        byte abyte0[] = new byte[l];
        obj = new byte[l];
        int j = 0;
        do {
            k = l;
            if (j >= l)
                break;
            abyte0[j] = (byte)(a[j] & a[j + l]);
            obj[j] = (byte)(abyte1[j] & abyte1[j + l]);
            if (abyte0[j] != obj[j]) {
                flag = false;
                continue; /* Loop/switch isn't completed */
            }
            j++;
        } while (true);
_L7:
        if (k < a.length) {
            if (a[k] != abyte1[k]) {
                flag = false;
                continue; /* Loop/switch isn't completed */
            }
        } else {
            flag = true;
            continue; /* Loop/switch isn't completed */
        }
        if (true) goto _L6; else goto _L5
_L5:
        break; /* Loop/switch isn't completed */
_L6:
        k++;
        if (true) goto _L7; else goto _L4
_L4:
        flag = Arrays.equals(abyte1, a);
        if (true) goto _L9; else goto _L8
_L8:
    }

    public int hashCode() {
        int j = 0;
        int k = 0;
        for (; j < a.length; j++)
            k += a[j] * j;

        return k;
    }

    public String toString() {
        Object obj;
        try {
            obj = JVM INSTR new #54  <Class StringBuilder>;
            ((StringBuilder) (obj)).StringBuilder();
            obj = ((StringBuilder) (obj)).append("IPAddress: ").append(b()).toString();
        }
        catch (IOException ioexception) {
            ioexception = new HexDumpEncoder();
            ioexception = (new StringBuilder()).append("IPAddress: ").append(ioexception.encodeBuffer(a)).toString();
        }
        return ((String) (obj));
    }
}
