// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package sun.security.x509;

import java.io.IOException;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.*;
import java.security.cert.*;
import java.util.*;
import javax.security.auth.x500.X500Principal;
import sun.misc.HexDumpEncoder;
import sun.security.util.*;

// Referenced classes of package sun.security.x509:
//            u, s, t, ac, 
//            p, ah, af, v, 
//            z, ai, aj, g, 
//            r, AlgorithmId, ad, aa, 
//            q, m, w, ae, 
//            y, d, ag, x

public class X509CertImpl extends X509Certificate
    implements e {

    protected aj a;
    protected AlgorithmId b;
    protected byte c[];
    private boolean d;
    private byte e[];
    private Collection f;
    private Collection g;
    private List h;
    private PublicKey i;
    private String j;
    private boolean k;

    public X509CertImpl() {
        d = false;
        e = null;
        a = null;
        b = null;
        c = null;
    }

    public X509CertImpl(aj aj1) {
        d = false;
        e = null;
        a = null;
        b = null;
        c = null;
        a = aj1;
    }

    private static Collection a(Collection collection) {
        Object obj = collection.iterator();
        boolean flag = false;
        do {
            if (!((Iterator) (obj)).hasNext())
                break;
            if (((List)((Iterator) (obj)).next()).get(1) instanceof byte[])
                flag = true;
        } while (true);
        obj = collection;
        if (flag) {
            obj = new HashSet();
            for (collection = collection.iterator(); collection.hasNext();) {
                Object obj2 = (List)collection.next();
                Object obj1 = ((List) (obj2)).get(1);
                if (obj1 instanceof byte[]) {
                    obj2 = new ArrayList(((Collection) (obj2)));
                    ((List) (obj2)).set(1, ((byte[])(byte[])obj1).clone());
                    ((Set) (obj)).add(Collections.unmodifiableList(((List) (obj2))));
                } else {
                    ((Set) (obj)).add(obj2);
                }
            }

            obj = Collections.unmodifiableCollection(((Collection) (obj)));
        }
        return ((Collection) (obj));
    }

    private static Collection a(u u1) {
        if (!u1.a()) goto _L2; else goto _L1
_L1:
        u1 = Collections.emptySet();
_L4:
        return u1;
_L2:
        HashSet hashset;
label0:
        {
label1:
            {
label2:
                {
label3:
                    {
label4:
                        {
label5:
                            {
                                hashset = new HashSet();
                                Iterator iterator = u1.b().iterator();
label6:
                                do {
                                    {
                                        if (!iterator.hasNext())
                                            break label0;
                                        u1 = ((s)iterator.next()).a();
                                        ArrayList arraylist = new ArrayList(2);
                                        arraylist.add(Integer.valueOf(u1.a()));
                                        switch (u1.a()) {
                                        case 3: // '\003'
                                        case 5: // '\005'
                                        default:
                                            i l = new i();
                                            try {
                                                u1.a(l);
                                            }
                                            // Misplaced declaration of an exception variable
                                            catch (u u1) {
                                                throw new RuntimeException("name cannot be encoded", u1);
                                            }
                                            arraylist.add(l.toByteArray());
                                            break;

                                        case 1: // '\001'
                                            break label6;

                                        case 2: // '\002'
                                            break label5;

                                        case 4: // '\004'
                                            break label4;

                                        case 6: // '\006'
                                            break label3;

                                        case 7: // '\007'
                                            break label2;

                                        case 8: // '\b'
                                            break label1;
                                        }
                                    }
                                    hashset.add(Collections.unmodifiableList(arraylist));
                                } while (true);
                                arraylist.add(((ac)u1).b());
                                break MISSING_BLOCK_LABEL_158;
                            }
                            arraylist.add(((p)u1).b());
                            break MISSING_BLOCK_LABEL_158;
                        }
                        arraylist.add(((ah)u1).b());
                        break MISSING_BLOCK_LABEL_158;
                    }
                    arraylist.add(((af)u1).c());
                    break MISSING_BLOCK_LABEL_158;
                }
                try {
                    arraylist.add(((v)u1).b());
                }
                // Misplaced declaration of an exception variable
                catch (u u1) {
                    throw new RuntimeException("IPAddress cannot be parsed", u1);
                }
                break MISSING_BLOCK_LABEL_158;
            }
            arraylist.add(((z)u1).b().toString());
            break MISSING_BLOCK_LABEL_158;
        }
        u1 = Collections.unmodifiableCollection(hashset);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public Object a(String s1) {
        Object obj;
        String s2;
        obj = null;
        s1 = new ai(s1);
        s2 = s1.a();
        if (!s2.equalsIgnoreCase("x509"))
            throw new CertificateParsingException((new StringBuilder()).append("Invalid root of attribute name, expected [x509], received [").append(s2).append("]").toString());
        s1 = new ai(s1.b());
        s2 = s1.a();
        if (!s2.equalsIgnoreCase("info")) goto _L2; else goto _L1
_L1:
        if (a == null)
            s1 = obj;
        else
        if (s1.b() != null)
            try {
                s1 = ((String) (a.a(s1.b())));
            }
            // Misplaced declaration of an exception variable
            catch (String s1) {
                throw new CertificateParsingException(s1.toString());
            }
            // Misplaced declaration of an exception variable
            catch (String s1) {
                throw new CertificateParsingException(s1.toString());
            }
        else
            s1 = a;
_L4:
        return s1;
_L2:
        if (s2.equalsIgnoreCase("algorithm")) {
            s1 = b;
            continue; /* Loop/switch isn't completed */
        }
        if (s2.equalsIgnoreCase("signature")) {
            s1 = obj;
            if (c != null)
                s1 = ((String) (c.clone()));
            continue; /* Loop/switch isn't completed */
        }
        if (!s2.equalsIgnoreCase("signed_cert"))
            break; /* Loop/switch isn't completed */
        s1 = obj;
        if (e != null)
            s1 = ((String) (e.clone()));
        if (true) goto _L4; else goto _L3
_L3:
        throw new CertificateParsingException((new StringBuilder()).append("Attribute name not recognized or get() not allowed for the same: ").append(s2).toString());
    }

    public r a(ObjectIdentifier objectidentifier) {
        if (a != null) goto _L2; else goto _L1
_L1:
        objectidentifier = null;
_L5:
        return objectidentifier;
_L2:
        Object obj = (g)a.a("extensions");
        if (obj == null) {
            objectidentifier = null;
            continue; /* Loop/switch isn't completed */
        }
        break MISSING_BLOCK_LABEL_39;
        objectidentifier;
        objectidentifier = null;
        continue; /* Loop/switch isn't completed */
        Iterator iterator = ((g) (obj)).b().iterator();
_L3:
        boolean flag;
        if (!iterator.hasNext())
            break MISSING_BLOCK_LABEL_89;
        obj = (r)iterator.next();
        flag = ((r) (obj)).d().a(objectidentifier);
        if (flag) {
            objectidentifier = ((ObjectIdentifier) (obj));
            continue; /* Loop/switch isn't completed */
        }
          goto _L3
        objectidentifier = null;
        continue; /* Loop/switch isn't completed */
        objectidentifier;
        objectidentifier = null;
        if (true) goto _L5; else goto _L4
_L4:
    }

    public void a(OutputStream outputstream) {
        if (e == null) {
            throw new IOException("Null certificate to encode");
        } else {
            outputstream.write((byte[])e.clone());
            return;
        }
    }

    public void a(PrivateKey privatekey, String s1) {
        a(privatekey, s1, null);
    }

    public void a(PrivateKey privatekey, String s1, String s2) {
        try {
            if (d) {
                privatekey = JVM INSTR new #263 <Class CertificateEncodingException>;
                privatekey.CertificateEncodingException("cannot over-write existing certificate");
                throw privatekey;
            }
        }
        // Misplaced declaration of an exception variable
        catch (PrivateKey privatekey) {
            throw new CertificateEncodingException(privatekey.toString());
        }
        if (s2 == null)
            break MISSING_BLOCK_LABEL_44;
        if (s2.length() != 0)
            break MISSING_BLOCK_LABEL_150;
        s1 = Signature.getInstance(s1);
_L2:
        s1.initSign(privatekey);
        b = AlgorithmId.a(s1.getAlgorithm());
        s2 = JVM INSTR new #136 <Class i>;
        s2.i();
        privatekey = JVM INSTR new #136 <Class i>;
        privatekey.i();
        a.a(privatekey);
        byte abyte0[] = privatekey.toByteArray();
        b.a(privatekey);
        s1.update(abyte0, 0, abyte0.length);
        c = s1.sign();
        privatekey.a(c);
        s2.a((byte)48, privatekey);
        e = s2.toByteArray();
        d = true;
        return;
        s1 = Signature.getInstance(s1, s2);
        if (true) goto _L2; else goto _L1
_L1:
    }

    public byte[] a() {
        if (e == null)
            throw new CertificateEncodingException("Null certificate to encode");
        else
            return e;
    }

    public ad b() {
        ad ad1;
        if (a == null)
            ad1 = null;
        else
            try {
                ad1 = (ad)a.a("serialNumber.number");
            }
            catch (Exception exception) {
                exception = null;
            }
        return ad1;
    }

    public q c() {
        return (q)a(aa.t);
    }

    public void checkValidity() {
        checkValidity(new Date());
    }

    public void checkValidity(Date date) {
        m m1;
        try {
            m1 = (m)a.a("validity");
        }
        // Misplaced declaration of an exception variable
        catch (Date date) {
            throw new CertificateNotYetValidException("Incorrect validity period");
        }
        if (m1 == null) {
            throw new CertificateNotYetValidException("Null validity period");
        } else {
            m1.a(date);
            return;
        }
    }

    public w d() {
        return (w)a(aa.h);
    }

    public ae e() {
        return (ae)a(aa.g);
    }

    public int getBasicConstraints() {
        Object obj = y.a(aa.j);
        if (obj != null) goto _L2; else goto _L1
_L1:
        int l = -1;
_L4:
        return l;
_L2:
        obj = (d)a(((String) (obj)));
        if (obj == null) {
            l = -1;
            continue; /* Loop/switch isn't completed */
        }
        if (((Boolean)((d) (obj)).a("is_ca")).booleanValue()) {
            l = ((Integer)((d) (obj)).a("path_len")).intValue();
            continue; /* Loop/switch isn't completed */
        }
        l = -1;
        continue; /* Loop/switch isn't completed */
        Exception exception;
        exception;
        l = -1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public Set getCriticalExtensionOIDs() {
        if (a != null) goto _L2; else goto _L1
_L1:
        Object obj = null;
_L4:
        return ((Set) (obj));
_L2:
        Object obj1 = (g)a.a("extensions");
        if (obj1 == null) {
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        try {
            obj = JVM INSTR new #69  <Class HashSet>;
            ((HashSet) (obj)).HashSet();
            obj1 = ((g) (obj1)).b().iterator();
            do {
                r r1;
                do {
                    if (!((Iterator) (obj1)).hasNext())
                        continue; /* Loop/switch isn't completed */
                    r1 = (r)((Iterator) (obj1)).next();
                } while (!r1.c());
                ((Set) (obj)).add(r1.d().toString());
            } while (true);
        }
        catch (Exception exception) {
            exception = null;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public byte[] getEncoded() {
        return (byte[])a().clone();
    }

    public List getExtendedKeyUsage() {
        this;
        JVM INSTR monitorenter ;
        if (!d || h == null) goto _L2; else goto _L1
_L1:
        Object obj = h;
_L3:
        this;
        JVM INSTR monitorexit ;
        return ((List) (obj));
_L2:
        obj = c();
label0:
        {
            if (obj != null)
                break label0;
            obj = null;
        }
          goto _L3
        h = Collections.unmodifiableList(((q) (obj)).b());
        obj = h;
          goto _L3
        Exception exception;
        exception;
        throw exception;
    }

    public byte[] getExtensionValue(String s1) {
        Object obj1 = null;
        Object obj;
        g g1;
        ObjectIdentifier objectidentifier;
        objectidentifier = JVM INSTR new #176 <Class ObjectIdentifier>;
        objectidentifier.ObjectIdentifier(s1);
        obj = y.a(objectidentifier);
        g1 = (g)a.a("extensions");
        if (obj != null) goto _L2; else goto _L1
_L1:
        if (g1 != null) goto _L4; else goto _L3
_L3:
        obj = obj1;
_L10:
        return ((byte []) (obj));
_L4:
        Iterator iterator = g1.b().iterator();
        do {
            if (!iterator.hasNext())
                break MISSING_BLOCK_LABEL_187;
            obj = (r)iterator.next();
        } while (!((r) (obj)).d().a(objectidentifier));
_L11:
        if (obj != null) goto _L6; else goto _L5
_L5:
        if (g1 == null) goto _L8; else goto _L7
_L7:
        s1 = (r)g1.c().get(s1);
_L12:
        obj = obj1;
        if (s1 == null) goto _L10; else goto _L9
_L9:
        s1 = s1.e();
        obj = obj1;
        if (s1 != null)
            try {
                obj = JVM INSTR new #136 <Class i>;
                ((i) (obj)).i();
                ((i) (obj)).b(s1);
                obj = ((i) (obj)).toByteArray();
            }
            // Misplaced declaration of an exception variable
            catch (String s1) {
                obj = obj1;
            }
          goto _L10
_L2:
        obj = (r)a(((String) (obj)));
          goto _L11
        obj;
        obj = null;
          goto _L11
_L8:
        s1 = ((String) (obj));
          goto _L12
_L6:
        s1 = ((String) (obj));
          goto _L9
        obj = null;
          goto _L11
    }

    public Collection getIssuerAlternativeNames() {
        this;
        JVM INSTR monitorenter ;
        if (!d || g == null) goto _L2; else goto _L1
_L1:
        Object obj = a(g);
_L3:
        this;
        JVM INSTR monitorexit ;
        return ((Collection) (obj));
_L2:
        obj = d();
label0:
        {
            if (obj != null)
                break label0;
            obj = null;
        }
          goto _L3
        obj = (u)((w) (obj)).a("issuer_name");
        g = a(((u) (obj)));
        obj = g;
          goto _L3
        Object obj1;
        obj1;
        obj1 = Collections.emptySet();
          goto _L3
        obj1;
        throw obj1;
    }

    public Principal getIssuerDN() {
        Principal principal;
        if (a == null)
            principal = null;
        else
            try {
                principal = (Principal)a.a("issuer.dname");
            }
            catch (Exception exception) {
                exception = null;
            }
        return principal;
    }

    public boolean[] getIssuerUniqueID() {
        if (a != null) goto _L2; else goto _L1
_L1:
        Object obj = null;
_L4:
        return ((boolean []) (obj));
_L2:
        obj = (ag)a.a("issuerID.id");
        if (obj == null)
            obj = null;
        else
            try {
                obj = ((ag) (obj)).a();
            }
            catch (Exception exception) {
                exception = null;
            }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public X500Principal getIssuerX500Principal() {
        X500Principal x500principal;
        if (a == null)
            x500principal = null;
        else
            try {
                x500principal = (X500Principal)a.a("issuer.x500principal");
            }
            catch (Exception exception) {
                exception = null;
            }
        return x500principal;
    }

    public boolean[] getKeyUsage() {
        Object obj = y.a(aa.c);
        if (obj != null) goto _L2; else goto _L1
_L1:
        obj = null;
_L4:
        return ((boolean []) (obj));
_L2:
        obj = (x)a(((String) (obj)));
        if (obj == null) {
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        boolean aflag[];
        obj = ((x) (obj)).b();
        if (obj.length >= 9)
            continue; /* Loop/switch isn't completed */
        aflag = new boolean[9];
        System.arraycopy(obj, 0, aflag, 0, obj.length);
        obj = aflag;
        continue; /* Loop/switch isn't completed */
        Exception exception;
        exception;
        exception = null;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public Set getNonCriticalExtensionOIDs() {
        if (a != null) goto _L2; else goto _L1
_L1:
        Object obj = null;
_L4:
        return ((Set) (obj));
_L2:
        g g1 = (g)a.a("extensions");
        if (g1 == null) {
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        obj = JVM INSTR new #69  <Class HashSet>;
        ((HashSet) (obj)).HashSet();
        Iterator iterator = g1.b().iterator();
        do {
            if (!iterator.hasNext())
                break;
            r r1 = (r)iterator.next();
            if (!r1.c())
                ((Set) (obj)).add(r1.d().toString());
        } while (true);
        try {
            ((Set) (obj)).addAll(g1.c().keySet());
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            obj = null;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public Date getNotAfter() {
        Date date;
        if (a == null)
            date = null;
        else
            try {
                date = (Date)a.a("validity.notAfter");
            }
            catch (Exception exception) {
                exception = null;
            }
        return date;
    }

    public Date getNotBefore() {
        Date date;
        if (a == null)
            date = null;
        else
            try {
                date = (Date)a.a("validity.notBefore");
            }
            catch (Exception exception) {
                exception = null;
            }
        return date;
    }

    public PublicKey getPublicKey() {
        PublicKey publickey;
        if (a == null)
            publickey = null;
        else
            try {
                publickey = (PublicKey)a.a("key.value");
            }
            catch (Exception exception) {
                exception = null;
            }
        return publickey;
    }

    public BigInteger getSerialNumber() {
        Object obj = b();
        if (obj != null)
            obj = ((ad) (obj)).a();
        else
            obj = null;
        return ((BigInteger) (obj));
    }

    public String getSigAlgName() {
        String s1;
        if (b == null)
            s1 = null;
        else
            s1 = b.c();
        return s1;
    }

    public String getSigAlgOID() {
        String s1;
        if (b == null)
            s1 = null;
        else
            s1 = b.b().toString();
        return s1;
    }

    public byte[] getSigAlgParams() {
        byte abyte0[] = null;
        if (b != null) goto _L2; else goto _L1
_L1:
        return abyte0;
_L2:
        byte abyte1[] = b.d();
        abyte0 = abyte1;
        continue; /* Loop/switch isn't completed */
        IOException ioexception;
        ioexception;
        if (true) goto _L1; else goto _L3
_L3:
    }

    public byte[] getSignature() {
        byte abyte0[];
        if (c == null) {
            abyte0 = null;
        } else {
            abyte0 = new byte[c.length];
            System.arraycopy(c, 0, abyte0, 0, abyte0.length);
        }
        return abyte0;
    }

    public Collection getSubjectAlternativeNames() {
        this;
        JVM INSTR monitorenter ;
        if (!d || f == null) goto _L2; else goto _L1
_L1:
        Object obj = a(f);
_L3:
        this;
        JVM INSTR monitorexit ;
        return ((Collection) (obj));
_L2:
        obj = e();
label0:
        {
            if (obj != null)
                break label0;
            obj = null;
        }
          goto _L3
        obj = (u)((ae) (obj)).a("subject_name");
        f = a(((u) (obj)));
        obj = f;
          goto _L3
        Object obj1;
        obj1;
        obj1 = Collections.emptySet();
          goto _L3
        obj1;
        throw obj1;
    }

    public Principal getSubjectDN() {
        Principal principal;
        if (a == null)
            principal = null;
        else
            try {
                principal = (Principal)a.a("subject.dname");
            }
            catch (Exception exception) {
                exception = null;
            }
        return principal;
    }

    public boolean[] getSubjectUniqueID() {
        if (a != null) goto _L2; else goto _L1
_L1:
        Object obj = null;
_L4:
        return ((boolean []) (obj));
_L2:
        obj = (ag)a.a("subjectID.id");
        if (obj == null)
            obj = null;
        else
            try {
                obj = ((ag) (obj)).a();
            }
            catch (Exception exception) {
                exception = null;
            }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public X500Principal getSubjectX500Principal() {
        X500Principal x500principal;
        if (a == null)
            x500principal = null;
        else
            try {
                x500principal = (X500Principal)a.a("subject.x500principal");
            }
            catch (Exception exception) {
                exception = null;
            }
        return x500principal;
    }

    public byte[] getTBSCertificate() {
        if (a != null)
            return a.b();
        else
            throw new CertificateEncodingException("Uninitialized certificate");
    }

    public int getVersion() {
        if (a != null) goto _L2; else goto _L1
_L1:
        int l = -1;
_L4:
        return l;
_L2:
        l = ((Integer)a.a("version.number")).intValue();
        l++;
        continue; /* Loop/switch isn't completed */
        Exception exception;
        exception;
        l = -1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public boolean hasUnsupportedCriticalExtension() {
        if (a != null) goto _L2; else goto _L1
_L1:
        boolean flag = false;
_L4:
        return flag;
_L2:
        g g1 = (g)a.a("extensions");
        if (g1 == null)
            flag = false;
        else
            try {
                flag = g1.d();
            }
            catch (Exception exception) {
                flag = false;
            }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public String toString() {
        Object obj;
        if (a == null || b == null || c == null) {
            obj = "";
        } else {
            obj = new StringBuilder();
            ((StringBuilder) (obj)).append("[\n");
            ((StringBuilder) (obj)).append((new StringBuilder()).append(a.toString()).append("\n").toString());
            ((StringBuilder) (obj)).append((new StringBuilder()).append("  Algorithm: [").append(b.toString()).append("]\n").toString());
            HexDumpEncoder hexdumpencoder = new HexDumpEncoder();
            ((StringBuilder) (obj)).append((new StringBuilder()).append("  Signature:\n").append(hexdumpencoder.encodeBuffer(c)).toString());
            ((StringBuilder) (obj)).append("\n]");
            obj = ((StringBuilder) (obj)).toString();
        }
        return ((String) (obj));
    }

    public void verify(PublicKey publickey) {
        verify(publickey, "");
    }

    public void verify(PublicKey publickey, String s1) {
        this;
        JVM INSTR monitorenter ;
        String s2;
        s2 = s1;
        if (s1 == null)
            s2 = "";
        boolean flag;
        if (i == null || !i.equals(publickey) || !s2.equals(j))
            break MISSING_BLOCK_LABEL_74;
        flag = k;
        if (!flag) goto _L2; else goto _L1
_L1:
        this;
        JVM INSTR monitorexit ;
        return;
_L2:
        publickey = JVM INSTR new #557 <Class SignatureException>;
        publickey.SignatureException("Signature does not match.");
        throw publickey;
        publickey;
        this;
        JVM INSTR monitorexit ;
        throw publickey;
        if (e == null) {
            publickey = JVM INSTR new #263 <Class CertificateEncodingException>;
            publickey.CertificateEncodingException("Uninitialized certificate");
            throw publickey;
        }
        byte abyte0[];
        if (s2.length() == 0)
            s1 = Signature.getInstance(b.c());
        else
            s1 = Signature.getInstance(b.c(), s2);
        s1.initVerify(publickey);
        abyte0 = a.b();
        s1.update(abyte0, 0, abyte0.length);
        k = s1.verify(c);
        i = publickey;
        j = s2;
        if (!k) {
            publickey = JVM INSTR new #557 <Class SignatureException>;
            publickey.SignatureException("Signature does not match.");
            throw publickey;
        }
          goto _L1
    }
}
