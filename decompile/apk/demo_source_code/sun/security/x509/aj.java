// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package sun.security.x509;

import java.io.IOException;
import java.io.OutputStream;
import java.security.cert.*;
import java.util.*;
import sun.misc.HexDumpEncoder;
import sun.security.util.i;

// Referenced classes of package sun.security.x509:
//            e, n, j, f, 
//            h, m, k, o, 
//            i, l, g, ai, 
//            r, y

public class aj
    implements e {

    private static final Map l;
    protected n a;
    protected j b;
    protected f c;
    protected h d;
    protected m e;
    protected k f;
    protected o g;
    protected sun.security.x509.i h;
    protected l i;
    protected g j;
    private byte k[];

    public aj() {
        a = new n();
        b = null;
        c = null;
        d = null;
        e = null;
        f = null;
        g = null;
        h = null;
        i = null;
        j = null;
        k = null;
    }

    private void a(Object obj) {
        if (!(obj instanceof n)) {
            throw new CertificateException("Version class type invalid.");
        } else {
            a = (n)obj;
            return;
        }
    }

    private void a(i i1) {
        i j1 = new i();
        a.a(j1);
        b.a(j1);
        c.a(j1);
        if (a.a(0) == 0 && d.toString() == null)
            throw new CertificateParsingException("Null issuer DN not allowed in v1 certificate");
        d.a(j1);
        e.a(j1);
        if (a.a(0) == 0 && f.toString() == null)
            throw new CertificateParsingException("Null subject DN not allowed in v1 certificate");
        f.a(j1);
        g.a(j1);
        if (h != null)
            h.a(j1);
        if (i != null)
            i.a(j1);
        if (j != null)
            j.a(j1);
        i1.a((byte)48, j1);
    }

    private int b(String s) {
        s = (Integer)l.get(s);
        int i1;
        if (s == null)
            i1 = 0;
        else
            i1 = s.intValue();
        return i1;
    }

    private void b(Object obj) {
        if (!(obj instanceof j)) {
            throw new CertificateException("SerialNumber class type invalid.");
        } else {
            b = (j)obj;
            return;
        }
    }

    private void c(Object obj) {
        if (!(obj instanceof f)) {
            throw new CertificateException("AlgorithmId class type invalid.");
        } else {
            c = (f)obj;
            return;
        }
    }

    private void d(Object obj) {
        if (!(obj instanceof h)) {
            throw new CertificateException("Issuer class type invalid.");
        } else {
            d = (h)obj;
            return;
        }
    }

    private void e(Object obj) {
        if (!(obj instanceof m)) {
            throw new CertificateException("CertificateValidity class type invalid.");
        } else {
            e = (m)obj;
            return;
        }
    }

    private void f(Object obj) {
        if (!(obj instanceof k)) {
            throw new CertificateException("Subject class type invalid.");
        } else {
            f = (k)obj;
            return;
        }
    }

    private void g(Object obj) {
        if (!(obj instanceof o)) {
            throw new CertificateException("Key class type invalid.");
        } else {
            g = (o)obj;
            return;
        }
    }

    private void h(Object obj) {
        if (a.a(1) < 0)
            throw new CertificateException("Invalid version");
        if (!(obj instanceof sun.security.x509.i)) {
            throw new CertificateException("IssuerUniqueId class type invalid.");
        } else {
            h = (sun.security.x509.i)obj;
            return;
        }
    }

    private void i(Object obj) {
        if (a.a(1) < 0)
            throw new CertificateException("Invalid version");
        if (!(obj instanceof l)) {
            throw new CertificateException("SubjectUniqueId class type invalid.");
        } else {
            i = (l)obj;
            return;
        }
    }

    private void j(Object obj) {
        if (a.a(2) < 0)
            throw new CertificateException("Invalid version");
        if (!(obj instanceof g)) {
            throw new CertificateException("Extensions class type invalid.");
        } else {
            j = (g)obj;
            return;
        }
    }

    public Object a(String s) {
        int i1;
        Object obj;
        Object obj1;
        obj = null;
        obj1 = new ai(s);
        i1 = b(((ai) (obj1)).a());
        if (i1 == 0)
            throw new CertificateParsingException((new StringBuilder()).append("Attribute name not recognized: ").append(s).toString());
        obj1 = ((ai) (obj1)).b();
        i1;
        JVM INSTR tableswitch 1 10: default 116
    //                   1 285
    //                   2 311
    //                   3 233
    //                   4 181
    //                   5 259
    //                   6 155
    //                   7 207
    //                   8 337
    //                   9 372
    //                   10 120;
           goto _L1 _L2 _L3 _L4 _L5 _L6 _L7 _L8 _L9 _L10 _L11
_L1:
        s = obj;
_L13:
        return s;
_L11:
        if (obj1 == null) {
            s = j;
        } else {
            s = obj;
            if (j != null)
                s = ((String) (j.a(((String) (obj1)))));
        }
        continue; /* Loop/switch isn't completed */
_L7:
        if (obj1 == null)
            s = f;
        else
            s = ((String) (f.a(((String) (obj1)))));
        continue; /* Loop/switch isn't completed */
_L5:
        if (obj1 == null)
            s = d;
        else
            s = ((String) (d.a(((String) (obj1)))));
        continue; /* Loop/switch isn't completed */
_L8:
        if (obj1 == null)
            s = g;
        else
            s = ((String) (g.a(((String) (obj1)))));
        continue; /* Loop/switch isn't completed */
_L4:
        if (obj1 == null)
            s = c;
        else
            s = ((String) (c.a(((String) (obj1)))));
        continue; /* Loop/switch isn't completed */
_L6:
        if (obj1 == null)
            s = e;
        else
            s = ((String) (e.a(((String) (obj1)))));
        continue; /* Loop/switch isn't completed */
_L2:
        if (obj1 == null)
            s = a;
        else
            s = ((String) (a.a(((String) (obj1)))));
        continue; /* Loop/switch isn't completed */
_L3:
        if (obj1 == null)
            s = b;
        else
            s = ((String) (b.a(((String) (obj1)))));
        continue; /* Loop/switch isn't completed */
_L9:
        if (obj1 == null) {
            s = h;
        } else {
            s = obj;
            if (h != null)
                s = ((String) (h.a(((String) (obj1)))));
        }
        continue; /* Loop/switch isn't completed */
_L10:
        if (obj1 == null) {
            s = i;
        } else {
            s = obj;
            if (i != null)
                s = ((String) (i.a(((String) (obj1)))));
        }
        if (true) goto _L13; else goto _L12
_L12:
    }

    public String a() {
        return "info";
    }

    public void a(OutputStream outputstream) {
        if (k == null) {
            i i1 = new i();
            a(i1);
            k = i1.toByteArray();
        }
        outputstream.write((byte[])k.clone());
    }

    public void a(String s, Object obj) {
        int i1;
        ai ai1 = new ai(s);
        i1 = b(ai1.a());
        if (i1 == 0)
            throw new CertificateException((new StringBuilder()).append("Attribute name not recognized: ").append(s).toString());
        k = null;
        s = ai1.b();
        i1;
        JVM INSTR tableswitch 1 10: default 116
    //                   1 117
    //                   2 141
    //                   3 165
    //                   4 189
    //                   5 213
    //                   6 237
    //                   7 261
    //                   8 285
    //                   9 309
    //                   10 333;
           goto _L1 _L2 _L3 _L4 _L5 _L6 _L7 _L8 _L9 _L10 _L11
_L1:
        return;
_L2:
        if (s == null)
            a(obj);
        else
            a.a(s, obj);
        continue; /* Loop/switch isn't completed */
_L3:
        if (s == null)
            b(obj);
        else
            b.a(s, obj);
        continue; /* Loop/switch isn't completed */
_L4:
        if (s == null)
            c(obj);
        else
            c.a(s, obj);
        continue; /* Loop/switch isn't completed */
_L5:
        if (s == null)
            d(obj);
        else
            d.a(s, obj);
        continue; /* Loop/switch isn't completed */
_L6:
        if (s == null)
            e(obj);
        else
            e.a(s, obj);
        continue; /* Loop/switch isn't completed */
_L7:
        if (s == null)
            f(obj);
        else
            f.a(s, obj);
        continue; /* Loop/switch isn't completed */
_L8:
        if (s == null)
            g(obj);
        else
            g.a(s, obj);
        continue; /* Loop/switch isn't completed */
_L9:
        if (s == null)
            h(obj);
        else
            h.a(s, obj);
        continue; /* Loop/switch isn't completed */
_L10:
        if (s == null)
            i(obj);
        else
            i.a(s, obj);
        continue; /* Loop/switch isn't completed */
_L11:
        if (s == null) {
            j(obj);
        } else {
            if (j == null)
                j = new g();
            j.a(s, obj);
        }
        if (true) goto _L1; else goto _L12
_L12:
    }

    public boolean a(aj aj1) {
        boolean flag1 = false;
        if (this != aj1) goto _L2; else goto _L1
_L1:
        boolean flag = true;
_L4:
        return flag;
_L2:
        flag = flag1;
        if (k == null)
            continue; /* Loop/switch isn't completed */
        flag = flag1;
        if (aj1.k == null)
            continue; /* Loop/switch isn't completed */
        flag = flag1;
        if (k.length != aj1.k.length)
            continue; /* Loop/switch isn't completed */
        for (int i1 = 0; i1 < k.length; i1++) {
            flag = flag1;
            if (k[i1] != aj1.k[i1])
                continue; /* Loop/switch isn't completed */
        }

        flag = true;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public byte[] b() {
        byte abyte0[];
        try {
            if (k == null) {
                i i1 = JVM INSTR new #111 <Class i>;
                i1.i();
                a(i1);
                k = i1.toByteArray();
            }
            abyte0 = (byte[])k.clone();
        }
        catch (IOException ioexception) {
            throw new CertificateEncodingException(ioexception.toString());
        }
        catch (CertificateException certificateexception) {
            throw new CertificateEncodingException(certificateexception.toString());
        }
        return abyte0;
    }

    public boolean equals(Object obj) {
        boolean flag;
        if (obj instanceof aj)
            flag = a((aj)obj);
        else
            flag = false;
        return flag;
    }

    public int hashCode() {
        int j1 = 0;
        for (int i1 = 1; i1 < k.length; i1++)
            j1 += k[i1] * i1;

        return j1;
    }

    public String toString() {
        int i1;
        StringBuilder stringbuilder;
        Object aobj[];
        if (f == null || g == null || e == null || d == null || c == null || b == null)
            throw new NullPointerException("X.509 cert is incomplete");
        stringbuilder = new StringBuilder();
        stringbuilder.append("[\n");
        stringbuilder.append((new StringBuilder()).append("  ").append(a.toString()).append("\n").toString());
        stringbuilder.append((new StringBuilder()).append("  Subject: ").append(f.toString()).append("\n").toString());
        stringbuilder.append((new StringBuilder()).append("  Signature Algorithm: ").append(c.toString()).append("\n").toString());
        stringbuilder.append((new StringBuilder()).append("  Key:  ").append(g.toString()).append("\n").toString());
        stringbuilder.append((new StringBuilder()).append("  ").append(e.toString()).append("\n").toString());
        stringbuilder.append((new StringBuilder()).append("  Issuer: ").append(d.toString()).append("\n").toString());
        stringbuilder.append((new StringBuilder()).append("  ").append(b.toString()).append("\n").toString());
        if (h != null)
            stringbuilder.append((new StringBuilder()).append("  Issuer Id:\n").append(h.toString()).append("\n").toString());
        if (i != null)
            stringbuilder.append((new StringBuilder()).append("  Subject Id:\n").append(i.toString()).append("\n").toString());
        if (j == null)
            break MISSING_BLOCK_LABEL_777;
        aobj = j.b().toArray();
        stringbuilder.append((new StringBuilder()).append("\nCertificate Extensions: ").append(aobj.length).toString());
        i1 = 0;
_L2:
        byte abyte0[];
        if (i1 >= aobj.length)
            break MISSING_BLOCK_LABEL_652;
        stringbuilder.append((new StringBuilder()).append("\n[").append(i1 + 1).append("]: ").toString());
        abyte0 = (r)aobj[i1];
        if (y.b(abyte0.d()) != null)
            break; /* Loop/switch isn't completed */
        stringbuilder.append(abyte0.toString());
        abyte0 = abyte0.e();
        if (abyte0 != null)
            try {
                Object obj1 = JVM INSTR new #111 <Class i>;
                ((i) (obj1)).i();
                ((i) (obj1)).b(abyte0);
                abyte0 = ((i) (obj1)).toByteArray();
                HexDumpEncoder hexdumpencoder = JVM INSTR new #352 <Class HexDumpEncoder>;
                hexdumpencoder.HexDumpEncoder();
                obj1 = JVM INSTR new #199 <Class StringBuilder>;
                ((StringBuilder) (obj1)).StringBuilder();
                stringbuilder.append(((StringBuilder) (obj1)).append("Extension unknown: DER encoded OCTET string =\n").append(hexdumpencoder.encodeBuffer(abyte0)).append("\n").toString());
            }
            catch (Exception exception) {
                stringbuilder.append(", Error parsing this extension");
            }
        i1++;
        if (true) goto _L2; else goto _L1
_L1:
        stringbuilder.append(abyte0.toString());
        break MISSING_BLOCK_LABEL_620;
        Object obj = j.c();
        if (!((Map) (obj)).isEmpty()) {
            stringbuilder.append((new StringBuilder()).append("\nUnparseable certificate extensions: ").append(((Map) (obj)).size()).toString());
            obj = ((Map) (obj)).values().iterator();
            for (int j1 = 1; ((Iterator) (obj)).hasNext(); j1++) {
                r r1 = (r)((Iterator) (obj)).next();
                stringbuilder.append((new StringBuilder()).append("\n[").append(j1).append("]: ").toString());
                stringbuilder.append(r1);
            }

        }
        stringbuilder.append("\n]");
        return stringbuilder.toString();
    }

    static  {
        l = new HashMap();
        l.put("version", Integer.valueOf(1));
        l.put("serialNumber", Integer.valueOf(2));
        l.put("algorithmID", Integer.valueOf(3));
        l.put("issuer", Integer.valueOf(4));
        l.put("validity", Integer.valueOf(5));
        l.put("subject", Integer.valueOf(6));
        l.put("key", Integer.valueOf(7));
        l.put("issuerID", Integer.valueOf(8));
        l.put("subjectID", Integer.valueOf(9));
        l.put("extensions", Integer.valueOf(10));
    }
}
