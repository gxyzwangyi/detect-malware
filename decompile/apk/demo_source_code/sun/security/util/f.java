// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package sun.security.util;

import java.io.IOException;
import java.util.ArrayList;

class f {

    private byte a[];
    private byte b[];
    private int c;
    private int d;
    private int e;
    private int f;
    private ArrayList g;
    private int h;

    f() {
        g = new ArrayList();
        h = 0;
    }

    private void a() {
        if (d != e) goto _L2; else goto _L1
_L1:
        return;
_L2:
label0:
        {
            if (!c(a[d]) || a[d + 1] != 0)
                break label0;
            int j = g.size();
            int i = 0;
            j--;
            Object obj = null;
label1:
            do {
label2:
                {
                    if (j >= 0) {
                        obj = g.get(j);
                        if (!(obj instanceof Integer))
                            break label2;
                    }
                    if (j < 0)
                        throw new IOException("EOC does not have matching indefinite-length tag");
                    break label1;
                }
                i += ((byte[])(byte[])obj).length - 3;
                j--;
            } while (true);
            byte abyte0[] = e((d - ((Integer)obj).intValue()) + i);
            g.set(j, abyte0);
            i = h;
            h = (abyte0.length - 3) + i;
        }
        d = d + 1;
        if (true) goto _L1; else goto _L3
_L3:
    }

    static boolean a(int i) {
        boolean flag;
        if ((i & 0x80) == 128)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private void b() {
        if (d != e) {
            byte abyte0[] = a;
            int i = d;
            d = i + 1;
            int k = abyte0[i];
            if (c(k) && a[d] == 0) {
                d = d + 1;
                b();
            } else {
                byte abyte1[] = b;
                int j = c;
                c = j + 1;
                abyte1[j] = (byte)k;
            }
        }
    }

    static boolean b(int i) {
        boolean flag;
        if (a(i) && (i & 0x7f) == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private int c() {
        int i;
        int j;
        i = 0;
        j = 0;
        if (d != e) goto _L2; else goto _L1
_L1:
        return j;
_L2:
        byte abyte0[] = a;
        int k = d;
        d = k + 1;
        k = abyte0[k] & 0xff;
        if (b(k)) {
            g.add(new Integer(d));
            continue; /* Loop/switch isn't completed */
        }
        if (a(k)) {
            int l = k & 0x7f;
            if (l > 4)
                throw new IOException("Too much data");
            if (e - d < l + 1)
                throw new IOException("Too little data");
            k = 0;
            do {
                j = i;
                if (k >= l)
                    continue; /* Loop/switch isn't completed */
                byte abyte1[] = a;
                j = d;
                d = j + 1;
                j = abyte1[j];
                k++;
                i = (j & 0xff) + (i << 8);
            } while (true);
        }
        j = k & 0x7f;
        if (true) goto _L1; else goto _L3
_L3:
    }

    private boolean c(int i) {
        boolean flag;
        if ((i & 0x1f) == 0 && (i & 0x20) == 0 && (i & 0xc0) == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private void d() {
        int l = 0;
        if (d != e) {
            byte abyte0[] = a;
            int i = d;
            d = i + 1;
            int j1 = abyte0[i] & 0xff;
            if (b(j1)) {
                ArrayList arraylist = g;
                int j = f;
                f = j + 1;
                byte abyte1[] = (byte[])(byte[])arraylist.get(j);
                System.arraycopy(abyte1, 0, b, c, abyte1.length);
                j = c;
                c = abyte1.length + j;
            } else {
                int i1;
                if (a(j1)) {
                    int k = 0;
                    do {
                        i1 = k;
                        if (l >= (j1 & 0x7f))
                            break;
                        byte abyte2[] = a;
                        i1 = d;
                        d = i1 + 1;
                        i1 = abyte2[i1];
                        l++;
                        k = (i1 & 0xff) + (k << 8);
                    } while (true);
                } else {
                    i1 = j1 & 0x7f;
                }
                d(i1);
                g(i1);
            }
        }
    }

    private void d(int i) {
        if (i < 128) {
            byte abyte0[] = b;
            int j = c;
            c = j + 1;
            abyte0[j] = (byte)i;
        } else
        if (i < 256) {
            byte abyte1[] = b;
            int k = c;
            c = k + 1;
            abyte1[k] = -127;
            abyte1 = b;
            k = c;
            c = k + 1;
            abyte1[k] = (byte)i;
        } else
        if (i < 0x10000) {
            byte abyte2[] = b;
            int l = c;
            c = l + 1;
            abyte2[l] = -126;
            abyte2 = b;
            l = c;
            c = l + 1;
            abyte2[l] = (byte)(i >> 8);
            abyte2 = b;
            l = c;
            c = l + 1;
            abyte2[l] = (byte)i;
        } else
        if (i < 0x1000000) {
            byte abyte3[] = b;
            int i1 = c;
            c = i1 + 1;
            abyte3[i1] = -125;
            abyte3 = b;
            i1 = c;
            c = i1 + 1;
            abyte3[i1] = (byte)(i >> 16);
            abyte3 = b;
            i1 = c;
            c = i1 + 1;
            abyte3[i1] = (byte)(i >> 8);
            abyte3 = b;
            i1 = c;
            c = i1 + 1;
            abyte3[i1] = (byte)i;
        } else {
            byte abyte4[] = b;
            int j1 = c;
            c = j1 + 1;
            abyte4[j1] = -124;
            abyte4 = b;
            j1 = c;
            c = j1 + 1;
            abyte4[j1] = (byte)(i >> 24);
            abyte4 = b;
            j1 = c;
            c = j1 + 1;
            abyte4[j1] = (byte)(i >> 16);
            abyte4 = b;
            j1 = c;
            c = j1 + 1;
            abyte4[j1] = (byte)(i >> 8);
            abyte4 = b;
            j1 = c;
            c = j1 + 1;
            abyte4[j1] = (byte)i;
        }
    }

    private byte[] e(int i) {
        byte abyte0[];
        if (i < 128) {
            abyte0 = new byte[1];
            abyte0[0] = (byte)i;
        } else
        if (i < 256) {
            abyte0 = new byte[2];
            abyte0[0] = -127;
            abyte0[1] = (byte)i;
        } else
        if (i < 0x10000) {
            abyte0 = new byte[3];
            abyte0[0] = -126;
            abyte0[1] = (byte)(i >> 8);
            abyte0[2] = (byte)i;
        } else
        if (i < 0x1000000) {
            abyte0 = new byte[4];
            abyte0[0] = -125;
            abyte0[1] = (byte)(i >> 16);
            abyte0[2] = (byte)(i >> 8);
            abyte0[3] = (byte)i;
        } else {
            abyte0 = new byte[5];
            abyte0[0] = -124;
            abyte0[1] = (byte)(i >> 24);
            abyte0[2] = (byte)(i >> 16);
            abyte0[3] = (byte)(i >> 8);
            abyte0[4] = (byte)i;
        }
        return abyte0;
    }

    private void f(int i) {
        d = d + i;
    }

    private void g(int i) {
        for (int j = 0; j < i; j++) {
            byte abyte0[] = b;
            int l = c;
            c = l + 1;
            byte abyte1[] = a;
            int k = d;
            d = k + 1;
            abyte0[l] = abyte1[k];
        }

    }

    byte[] a(byte abyte0[]) {
        a = abyte0;
        d = 0;
        f = 0;
        for (e = a.length; d < e;) {
            a();
            f(c());
        }

        b = new byte[e + h];
        d = 0;
        c = 0;
        f = 0;
        while (d < e)  {
            b();
            d();
        }
        return b;
    }
}
