// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package org.littleshoot.proxy.impl;

import io.netty.buffer.ak;
import io.netty.buffer.h;
import io.netty.channel.d;
import io.netty.channel.t;
import io.netty.handler.codec.http.aa;
import io.netty.handler.codec.http.ac;
import io.netty.handler.codec.http.ae;
import io.netty.handler.codec.http.af;
import io.netty.handler.codec.http.ag;
import io.netty.handler.codec.http.c;
import io.netty.handler.codec.http.l;
import io.netty.handler.codec.http.m;
import io.netty.handler.codec.http.s;
import io.netty.handler.codec.http.v;
import io.netty.handler.codec.http.w;
import io.netty.handler.codec.http.z;
import io.netty.util.concurrent.n;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;
import java.nio.charset.Charset;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLSession;
import org.apache.commons.b.a;
import org.littleshoot.proxy.f;
import org.littleshoot.proxy.g;
import org.littleshoot.proxy.i;
import org.littleshoot.proxy.j;
import org.littleshoot.proxy.k;
import org.littleshoot.proxy.p;
import org.littleshoot.proxy.q;

// Referenced classes of package org.littleshoot.proxy.impl:
//            f, ConnectionState, g, e, 
//            i, j, d

public class b extends org.littleshoot.proxy.impl.f {

    private static final af k = new af(200, "Connection established");
    private static final String l;
    private static final Pattern m = Pattern.compile("^http://.*", 2);
    private f.b A;
    private f.f B;
    org.littleshoot.proxy.impl.d a;
    private final Map n = new ConcurrentHashMap();
    private final AtomicInteger o = new AtomicInteger(0);
    private final AtomicInteger p = new AtomicInteger(0);
    private final AtomicInteger q = new AtomicInteger(0);
    private volatile org.littleshoot.proxy.impl.i r;
    private volatile i s;
    private volatile SSLSession t;
    private volatile boolean u;
    private AtomicBoolean v;
    private final io.netty.handler.a.c w;
    private volatile z x;
    private final f.a y = new f.a() {

        final b a;

        protected void a(int i1) {
            f f1 = b.b(a);
            for (Iterator iterator = a.c.o().iterator(); iterator.hasNext(); ((org.littleshoot.proxy.a)iterator.next()).a(f1, i1));
        }

             {
                a = b.this;
                super(b.this);
            }
    }
;
    private f.c z;

    b(e e1, q q1, boolean flag, t t1, io.netty.handler.a.c c1) {
        super(org.littleshoot.proxy.impl.ConnectionState.f, e1, false);
        s = j.NOOP_FILTER;
        u = false;
        v = new AtomicBoolean();
        a = new org.littleshoot.proxy.impl.d(this, org.littleshoot.proxy.impl.ConnectionState.c) {

            final b a;

            boolean a() {
                return true;
            }

            protected n b() {
                a.b.c("Responding with CONNECT successful", new Object[0]);
                c c2 = org.littleshoot.proxy.impl.b.a(a, ag.b, org.littleshoot.proxy.impl.b.k());
                c2.j().b("Connection", "keep-alive");
                org.littleshoot.proxy.impl.j.a(c2, a.c.p());
                return a.e(c2);
            }

             {
                a = b.this;
                super(f1, connectionstate);
            }
        }
;
        z = new f.c() {

            final b a;

            protected void a(z z1) {
                f f1 = b.b(a);
                for (Iterator iterator = a.c.o().iterator(); iterator.hasNext(); ((org.littleshoot.proxy.a)iterator.next()).a(f1, z1));
            }

             {
                a = b.this;
                super(b.this);
            }
        }
;
        A = new f.b() {

            final b a;

            protected void a(int i1) {
                f f1 = b.b(a);
                for (Iterator iterator = a.c.o().iterator(); iterator.hasNext(); ((org.littleshoot.proxy.a)iterator.next()).b(f1, i1));
            }

             {
                a = b.this;
                super(b.this);
            }
        }
;
        B = new f.f() {

            final b a;

            protected void a(ac ac1) {
                f f1 = b.b(a);
                for (Iterator iterator = a.c.o().iterator(); iterator.hasNext(); ((org.littleshoot.proxy.a)iterator.next()).a(f1, ac1));
            }

             {
                a = b.this;
                super(b.this);
            }
        }
;
        a(t1);
        if (q1 != null) {
            b.c("Enabling encryption of traffic from client to proxy", new Object[0]);
            a(t1, q1.newSslEngine(), flag).d(new io.netty.util.concurrent.p() {

                final b a;

                public void a(n n1) {
                    if (n1.g_()) {
                        org.littleshoot.proxy.impl.b.a(a, a.i.getSession());
                        org.littleshoot.proxy.impl.b.a(a);
                    }
                }

             {
                a = b.this;
                super();
            }
            }
);
        }
        w = c1;
        b.c("Created ClientToProxyConnection", new Object[0]);
    }

    private c a(ag ag1, af af1) {
        return a(ag1, af1, (h)null, 0);
    }

    private c a(ag ag1, af af1, h h1, int i1) {
        if (h1 != null)
            ag1 = new c(ag.b, af1, h1);
        else
            ag1 = new c(ag.b, af1);
        if (h1 != null) {
            ag1.j().b("Content-Length", Integer.valueOf(i1));
            ag1.j().b("Content-Type", "text/html; charset=UTF-8");
        }
        return ag1;
    }

    private c a(ag ag1, af af1, String s1) {
        s1 = s1.getBytes(Charset.forName("UTF-8"));
        return a(ag1, af1, ak.b(s1), s1.length);
    }

    static c a(b b1, ag ag1, af af1) {
        return b1.a(ag1, af1);
    }

    static SSLSession a(b b1, SSLSession sslsession) {
        b1.t = sslsession;
        return sslsession;
    }

    private void a(t t1) {
        b.c("Configuring ChannelPipeline", new Object[0]);
        t1.b("bytesReadMonitor", y);
        t1.b("bytesWrittenMonitor", A);
        t1.b("encoder", new ae());
        t1.b("decoder", new aa(8192, 16384, 16384));
        int i1 = c.n().getMaximumRequestBufferSizeInBytes();
        if (i1 > 0)
            a(t1, i1);
        t1.b("requestReadMonitor", z);
        t1.b("responseWrittenMonitor", B);
        t1.b("idle", new io.netty.handler.timeout.b(0, 0, c.f()));
        t1.b("handler", this);
    }

    private void a(ac ac1) {
        String s1 = ac1.j().b("Transfer-Encoding");
        if (org.apache.commons.b.a.c(s1) && s1.equalsIgnoreCase("chunked") && ac1.k() != ag.b) {
            b.c("Fixing HTTP version.", new Object[0]);
            ac1.b(ag.b);
        }
    }

    private void a(s s1) {
        String s2 = s1.b("Accept-Encoding");
        if (org.apache.commons.b.a.c(s2)) {
            s2 = s2.replace(",sdch", "").replace("sdch", "");
            s1.b("Accept-Encoding", s2);
            b.c("Removed sdch and inserted: {}", new Object[] {
                s2
            });
        }
    }

    private void a(z z1, org.littleshoot.proxy.impl.i i1) {
        i1.l();
        n.remove(i1.h());
        if (g(z1))
            b(org.littleshoot.proxy.impl.ConnectionState.f);
        else
            b(org.littleshoot.proxy.impl.ConnectionState.h);
    }

    private void a(String s1) {
        c c1 = a(ag.b, af.z, "<!DOCTYPE HTML \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>407 Proxy Authentication Required</title>\n</head><body>\n<h1>Proxy Authentication Required</h1>\n<p>This server could not verify that you\nare authorized to access the document\nrequested.  Either you supplied the wrong\ncredentials (e.g., bad password), or your\nbrowser doesn't understand how to supply\nthe credentials required.</p>\n</body></html>\n");
        io.netty.handler.codec.http.s.a(c1, new Date());
        s s3 = c1.j();
        StringBuilder stringbuilder = (new StringBuilder()).append("Basic realm=\"");
        String s2 = s1;
        if (s1 == null)
            s2 = "Restricted Files";
        s3.b("Proxy-Authenticate", stringbuilder.append(s2).append("\"").toString());
        c(c1);
    }

    static void a(b b1) {
        b1.v();
    }

    private void a(org.littleshoot.proxy.impl.i i1, z z1, ac ac1, w w1) {
        boolean flag1 = b(z1, ac1, w1);
        boolean flag = a(z1, ac1, w1);
        if (flag1) {
            b.c("Closing remote connection after writing to client", new Object[0]);
            i1.l();
        }
        if (flag) {
            b.c("Closing connection to client after writes", new Object[0]);
            l();
        }
    }

    private boolean a(z z1, ac ac1, w w1) {
        if (!org.littleshoot.proxy.impl.j.b(ac1) || w1 == null) goto _L2; else goto _L1
_L1:
        if (org.littleshoot.proxy.impl.j.a(w1)) goto _L4; else goto _L3
_L3:
        boolean flag;
        ac1 = null;
        if (z1 != null)
            ac1 = z1.m();
        b.c("Not closing client connection on middle chunk for {}", new Object[] {
            ac1
        });
        flag = false;
_L6:
        return flag;
_L4:
        b.c("Handling last chunk. Using normal client connection closing rules.", new Object[0]);
_L2:
        if (!io.netty.handler.codec.http.s.a(z1)) {
            b.c("Closing client connection since request is not keep alive: {}", new Object[] {
                z1
            });
            flag = true;
        } else {
            b.c("Not closing client connection for request: {}", new Object[] {
                z1
            });
            flag = false;
        }
        if (true) goto _L6; else goto _L5
_L5:
    }

    static f b(b b1) {
        return b1.x();
    }

    private ConnectionState b(z z1) {
        String s1;
        x = e(z1);
        Object obj = c.n().filterRequest(x, e);
        if (obj != null)
            s = ((i) (obj));
        else
            s = j.NOOP_FILTER;
        obj = s.clientToProxyRequest(z1);
        if (obj != null) {
            b.c("Responding to client with short-circuit response from filter: {}", new Object[] {
                obj
            });
            if (c(((ac) (obj))))
                z1 = org.littleshoot.proxy.impl.ConnectionState.f;
            else
                z1 = org.littleshoot.proxy.impl.ConnectionState.h;
        } else
        if (c(z1)) {
            if (h(z1))
                z1 = org.littleshoot.proxy.impl.ConnectionState.f;
            else
                z1 = org.littleshoot.proxy.impl.ConnectionState.h;
        } else {
label0:
            {
                s1 = j(z1);
                b.c("Ensuring that hostAndPort are available in {}", new Object[] {
                    z1.m()
                });
                if (s1 != null && !org.apache.commons.b.a.b(s1))
                    break label0;
                b.a("No host and port found in {}", new Object[] {
                    z1.m()
                });
                if (g(z1))
                    z1 = org.littleshoot.proxy.impl.ConnectionState.f;
                else
                    z1 = org.littleshoot.proxy.impl.ConnectionState.h;
            }
        }
_L1:
        return z1;
        b.c("Finding ProxyToServerConnection for: {}", new Object[] {
            s1
        });
        boolean flag;
        boolean flag1;
        Object obj1;
        if (g() || j())
            obj1 = r;
        else
            obj1 = (org.littleshoot.proxy.impl.i)n.get(s1);
        r = ((org.littleshoot.proxy.impl.i) (obj1));
        UnknownHostException unknownhostexception;
        if (org.littleshoot.proxy.impl.j.c(z1)) {
            b.c("Not reusing existing ProxyToServerConnection because request is a CONNECT for: {}", new Object[] {
                s1
            });
            flag = true;
        } else
        if (r == null) {
            b.c("Didn't find existing ProxyToServerConnection for: {}", new Object[] {
                s1
            });
            flag = true;
        } else {
            flag = false;
        }
        if (!flag)
            break MISSING_BLOCK_LABEL_561;
        r = org.littleshoot.proxy.impl.i.a(c, this, s1, s, z1, w);
        if (r != null)
            break MISSING_BLOCK_LABEL_435;
        b.c("Unable to create server connection, probably no chained proxies available", new Object[0]);
        flag1 = g(z1);
        q();
        if (!flag1)
            break MISSING_BLOCK_LABEL_424;
        obj1 = org.littleshoot.proxy.impl.ConnectionState.f;
        z1 = ((z) (obj1));
          goto _L1
        obj1 = org.littleshoot.proxy.impl.ConnectionState.h;
        z1 = ((z) (obj1));
          goto _L1
        n.put(s1, r);
_L2:
        f(z1);
        obj1 = s.proxyToServerRequest(z1);
        if (obj1 != null) {
            b.c("Responding to client with short-circuit response from filter: {}", new Object[] {
                obj1
            });
            if (c(((ac) (obj1))))
                z1 = org.littleshoot.proxy.impl.ConnectionState.f;
            else
                z1 = org.littleshoot.proxy.impl.ConnectionState.h;
        } else {
            b.c("Writing request to ProxyToServerConnection", new Object[0]);
            r.a(z1, s);
            if (org.littleshoot.proxy.impl.j.c(z1))
                z1 = org.littleshoot.proxy.impl.ConnectionState.c;
            else
            if (org.littleshoot.proxy.impl.j.b(z1))
                z1 = org.littleshoot.proxy.impl.ConnectionState.g;
            else
                z1 = org.littleshoot.proxy.impl.ConnectionState.f;
        }
          goto _L1
        unknownhostexception;
        b.b("Bad Host {}", new Object[] {
            z1.m()
        });
        flag1 = g(z1);
        q();
        if (flag1)
            z1 = org.littleshoot.proxy.impl.ConnectionState.f;
        else
            z1 = org.littleshoot.proxy.impl.ConnectionState.h;
          goto _L1
        b.c("Reusing existing server connection: {}", new Object[] {
            r
        });
        q.incrementAndGet();
          goto _L2
    }

    private void b(ac ac1) {
        if (!c.e()) {
            s s1 = ac1.j();
            c(s1);
            d(s1);
            org.littleshoot.proxy.impl.j.a(ac1, c.p());
            if (!s1.d("Date"))
                io.netty.handler.codec.http.s.a(ac1, new Date());
        }
    }

    private void b(s s1) {
        if (s1.d("Proxy-Connection")) {
            String s2 = s1.b("Proxy-Connection");
            s1.a("Proxy-Connection");
            s1.b("Connection", s2);
        }
    }

    private boolean b(z z1, ac ac1, w w1) {
        if (!org.littleshoot.proxy.impl.j.b(ac1) || w1 == null) goto _L2; else goto _L1
_L1:
        if (org.littleshoot.proxy.impl.j.a(w1)) goto _L4; else goto _L3
_L3:
        boolean flag;
        ac1 = null;
        if (z1 != null)
            ac1 = z1.m();
        b.c("Not closing server connection on middle chunk for {}", new Object[] {
            ac1
        });
        flag = false;
_L6:
        return flag;
_L4:
        b.c("Handling last chunk. Using normal server connection closing rules.", new Object[0]);
_L2:
        if (!io.netty.handler.codec.http.s.a(ac1)) {
            b.c("Closing server connection since response is not keep alive: {}", new Object[] {
                ac1
            });
            flag = true;
        } else {
            b.c("Not closing server connection for response: {}", new Object[] {
                ac1
            });
            flag = false;
        }
        if (true) goto _L6; else goto _L5
_L5:
    }

    private void c(s s1) {
        if (s1.d("Connection")) {
            for (Iterator iterator = s1.c("Connection").iterator(); iterator.hasNext();) {
                Iterator iterator1 = org.littleshoot.proxy.impl.j.d((String)iterator.next()).iterator();
                while (iterator1.hasNext())  {
                    String s2 = (String)iterator1.next();
                    if (!l.equals(s2.toLowerCase(Locale.US)))
                        s1.a(s2);
                }
            }

        }
    }

    private boolean c(ac ac1) {
        x = null;
        boolean flag;
        if ((ac)s.proxyToClientResponse(ac1) == null) {
            l();
            flag = false;
        } else {
            flag = io.netty.handler.codec.http.s.a(ac1);
            int i1 = ac1.h().a();
            if (i1 != af.U.a() && i1 != af.W.a())
                b(ac1);
            io.netty.handler.codec.http.s.a(ac1, flag);
            c(ac1);
            if (org.littleshoot.proxy.impl.j.a(ac1))
                t();
            if (!io.netty.handler.codec.http.s.a(ac1)) {
                l();
                flag = false;
            } else {
                flag = true;
            }
        }
        return flag;
    }

    private boolean c(z z1) {
        boolean flag;
        boolean flag1;
        flag1 = false;
        flag = flag1;
        if (z1.l() == v.i) goto _L2; else goto _L1
_L1:
        if (!g()) goto _L4; else goto _L3
_L3:
        flag = flag1;
_L2:
        return flag;
_L4:
        z1 = z1.m();
        flag = flag1;
        if (!m.matcher(z1).matches())
            flag = true;
        if (true) goto _L2; else goto _L5
_L5:
    }

    private void d(s s1) {
        Iterator iterator = s1.d().iterator();
        do {
            if (!iterator.hasNext())
                break;
            String s2 = (String)iterator.next();
            if (org.littleshoot.proxy.impl.j.c(s2))
                s1.a(s2);
        } while (true);
    }

    private boolean d(z z1) {
        boolean flag;
        if (v.get()) {
            flag = false;
        } else {
            p p1 = c.m();
            if (p1 == null)
                flag = false;
            else
            if (!z1.j().d("Proxy-Authorization")) {
                a(p1.a());
                flag = true;
            } else {
                String s2 = new String(org.apache.commons.a.a.a.a(org.apache.commons.b.a.b((String)z1.j().c("Proxy-Authorization").iterator().next(), "Basic ").trim().getBytes(Charset.forName("UTF-8"))), Charset.forName("UTF-8"));
                if (!p1.a(org.apache.commons.b.a.a(s2, ":"), org.apache.commons.b.a.b(s2, ":"))) {
                    a(p1.a());
                    flag = true;
                } else {
                    b.c("Got proxy authorization!", new Object[0]);
                    String s1 = z1.j().b("Proxy-Authorization");
                    b.c(s1, new Object[0]);
                    z1.j().a("Proxy-Authorization");
                    v.set(true);
                    flag = false;
                }
            }
        }
        return flag;
    }

    private z e(z z1) {
        if (z1 instanceof l) {
            z1 = ((l)z1).d();
        } else {
            io.netty.handler.codec.http.h h1 = new io.netty.handler.codec.http.h(z1.k(), z1.l(), z1.m());
            h1.j().b(z1.j());
            z1 = h1;
        }
        return z1;
    }

    private void e(org.littleshoot.proxy.impl.i i1) {
        b.c("Forcing disconnect", new Object[0]);
        i1.l();
        l();
    }

    private void f(z z1) {
        if (!r.k()) {
            b.c("Modifying request for proxy chaining", new Object[0]);
            String s3 = z1.m();
            String s1 = org.littleshoot.proxy.impl.j.a(s3);
            b.c("Stripped host from uri: {}    yielding: {}", new Object[] {
                s3, s1
            });
            z1.b(s1);
        }
        if (!c.e()) {
            b.c("Modifying request headers for proxying", new Object[0]);
            s s2 = z1.j();
            a(s2);
            b(s2);
            c(s2);
            d(s2);
            org.littleshoot.proxy.impl.j.a(z1, c.p());
        }
    }

    private boolean g(z z1) {
        Object obj = (new StringBuilder()).append("Bad Gateway: ").append(z1.m()).toString();
        obj = a(ag.b, af.U, ((String) (obj)));
        if (org.littleshoot.proxy.impl.j.b(z1))
            ((c) (obj)).a().d();
        return c(((ac) (obj)));
    }

    private boolean h(z z1) {
        Object obj = (new StringBuilder()).append("Bad Request to URI: ").append(z1.m()).toString();
        obj = a(ag.b, af.s, ((String) (obj)));
        if (org.littleshoot.proxy.impl.j.b(z1))
            ((c) (obj)).a().d();
        return c(((ac) (obj)));
    }

    private boolean i(z z1) {
        c c1 = a(ag.b, af.W, "Gateway Timeout");
        if (z1 != null && org.littleshoot.proxy.impl.j.b(z1))
            c1.a().d();
        return c(c1);
    }

    private String j(z z1) {
        String s2 = org.littleshoot.proxy.impl.j.a(z1);
        String s1 = s2;
        if (org.apache.commons.b.a.b(s2)) {
            z1 = z1.j().c("Host");
            s1 = s2;
            if (z1 != null) {
                s1 = s2;
                if (!z1.isEmpty())
                    s1 = (String)z1.get(0);
            }
        }
        return s1;
    }

    static af k() {
        return k;
    }

    private void s() {
        if (o.decrementAndGet() == 0) {
            b.c("All servers have finished attempting to connect, resuming reading from client.", new Object[0]);
            q();
        }
    }

    private void t() {
        c(ak.c);
    }

    private void u() {
        try {
            InetSocketAddress inetsocketaddress = h();
            for (Iterator iterator = c.o().iterator(); iterator.hasNext(); ((org.littleshoot.proxy.a)iterator.next()).a(inetsocketaddress));
        }
        catch (Exception exception) {
            b.a("Unable to recordClientConnected", exception);
        }
    }

    private void v() {
        try {
            InetSocketAddress inetsocketaddress = h();
            for (Iterator iterator = c.o().iterator(); iterator.hasNext(); ((org.littleshoot.proxy.a)iterator.next()).a(inetsocketaddress, t));
        }
        catch (Exception exception) {
            b.a("Unable to recorClientSSLHandshakeSucceeded", exception);
        }
    }

    private void w() {
        try {
            InetSocketAddress inetsocketaddress = h();
            for (Iterator iterator = c.o().iterator(); iterator.hasNext(); ((org.littleshoot.proxy.a)iterator.next()).b(inetsocketaddress, t));
        }
        catch (Exception exception) {
            b.a("Unable to recordClientDisconnected", exception);
        }
    }

    private f x() {
        Object obj;
        if (r != null)
            obj = new g(this, r);
        else
            obj = new f(this);
        return ((f) (obj));
    }

    protected volatile ConnectionState a(w w1) {
        return a((z)w1);
    }

    protected ConnectionState a(z z1) {
        b.c("Got request: {}", new Object[] {
            z1
        });
        if (d(z1)) {
            b.c("Not authenticated!!", new Object[0]);
            z1 = ConnectionState.e;
        } else {
            z1 = b(z1);
        }
        return z1;
    }

    protected void a(h h1) {
        r.c(h1);
    }

    protected void a(io.netty.handler.codec.http.n n1) {
        s.clientToProxyRequest(n1);
        s.proxyToServerRequest(n1);
        r.c(n1);
    }

    protected void a(Throwable throwable) {
        if (!(throwable instanceof IOException)) goto _L2; else goto _L1
_L1:
        org.littleshoot.proxy.impl.g g1 = b;
        StringBuilder stringbuilder = JVM INSTR new #395 <Class StringBuilder>;
        stringbuilder.StringBuilder();
        g1.b(stringbuilder.append("An IOException occurred on ClientToProxyConnection: ").append(throwable.getMessage()).toString(), new Object[0]);
        b.d("An IOException occurred on ClientToProxyConnection", throwable);
_L3:
        l();
        return;
_L2:
        if (!(throwable instanceof RejectedExecutionException))
            break MISSING_BLOCK_LABEL_129;
        org.littleshoot.proxy.impl.g g2 = b;
        StringBuilder stringbuilder1 = JVM INSTR new #395 <Class StringBuilder>;
        stringbuilder1.StringBuilder();
        g2.b(stringbuilder1.append("An executor rejected a read or write operation on the ClientToProxyConnection (this is normal if the proxy is shutting down). Message: ").append(throwable.getMessage()).toString(), new Object[0]);
        b.d("A RejectedExecutionException occurred on ClientToProxyConnection", throwable);
          goto _L3
        throwable;
        l();
        throw throwable;
        b.a("Caught an exception on ClientToProxyConnection", throwable);
          goto _L3
    }

    protected void a(org.littleshoot.proxy.impl.i i1) {
        p();
        o.incrementAndGet();
    }

    void a(org.littleshoot.proxy.impl.i i1, i j1, z z1, ac ac1, w w1) {
        x = null;
        w1 = j1.serverToProxyResponse(w1);
        if (w1 == null) {
            e(i1);
        } else {
            w w2 = w1;
            if (w1 instanceof ac) {
                ac ac3 = (ac)w1;
                ac ac2 = ac3;
                w2 = w1;
                if (!org.littleshoot.proxy.impl.j.c(z1)) {
                    ac2 = ac3;
                    w2 = w1;
                    if (!org.littleshoot.proxy.impl.j.b(ac3)) {
                        ac2 = ac3;
                        if (!(ac3 instanceof m)) {
                            ac2 = org.littleshoot.proxy.impl.j.c(ac3);
                            w1 = ac2;
                        }
                        io.netty.handler.codec.http.s.e(ac2);
                        w2 = w1;
                    }
                }
                a(ac2);
                b(ac2);
            }
            j1 = j1.proxyToClientResponse(w2);
            if (j1 == null) {
                e(i1);
            } else {
                c(j1);
                if (org.littleshoot.proxy.impl.j.a(j1))
                    t();
                a(i1, z1, ac1, ((w) (j1)));
            }
        }
    }

    protected void a(org.littleshoot.proxy.impl.i i1, boolean flag) {
        b.c("Connection to server succeeded: {}", new Object[] {
            i1.g()
        });
        s();
        if (flag)
            i1 = o();
        else
            i1 = org.littleshoot.proxy.impl.ConnectionState.f;
        b(i1);
        p.incrementAndGet();
    }

    protected void a(boolean flag) {
        u = flag;
    }

    protected boolean a(org.littleshoot.proxy.impl.i i1, ConnectionState connectionstate, Throwable throwable) {
        boolean flag;
        z z1;
        flag = true;
        s();
        z1 = i1.u();
        if (!i1.b(throwable)) goto _L2; else goto _L1
_L1:
        b.c("Failed to connect to upstream server or chained proxy. Retrying connection. Last state before failure: {}", new Object[] {
            connectionstate, throwable
        });
_L4:
        return flag;
_L2:
        b.c("Connection to upstream server or chained proxy failed: {}.  Last state before failure: {}", new Object[] {
            i1.g(), connectionstate, throwable
        });
        a(z1, i1);
        flag = false;
        continue; /* Loop/switch isn't completed */
        connectionstate;
        a(z1, i1);
        flag = false;
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected void b() {
        super.b();
        b(org.littleshoot.proxy.impl.ConnectionState.f);
        u();
    }

    protected void b(org.littleshoot.proxy.impl.i i1) {
        p.decrementAndGet();
        if (j() || g())
            l();
    }

    protected void c() {
        boolean flag;
        if (r == null || h > r.h)
            flag = true;
        else
            flag = false;
        if (flag) {
            b.c("Server timed out: {}", new Object[] {
                r
            });
            s.serverToProxyResponseTimedOut();
            i(x);
        } else {
            super.c();
        }
    }

    protected void c(org.littleshoot.proxy.impl.i i1) {
        this;
        JVM INSTR monitorenter ;
        if (i1.m()) {
            b.b("Connection to server became saturated, stopping reading", new Object[0]);
            p();
        }
        this;
        JVM INSTR monitorexit ;
        return;
        i1;
        throw i1;
    }

    protected void d() {
        super.d();
        for (Iterator iterator = n.values().iterator(); iterator.hasNext(); ((org.littleshoot.proxy.impl.i)iterator.next()).l());
        w();
    }

    protected void d(org.littleshoot.proxy.impl.i i1) {
        this;
        JVM INSTR monitorenter ;
        i1 = n.values().iterator();
_L4:
        if (!i1.hasNext()) goto _L2; else goto _L1
_L1:
        if (!((org.littleshoot.proxy.impl.i)i1.next()).m()) goto _L4; else goto _L3
_L3:
        boolean flag = true;
_L6:
        if (flag)
            break MISSING_BLOCK_LABEL_65;
        b.b("All server connections writeable, resuming reading", new Object[0]);
        q();
        this;
        JVM INSTR monitorexit ;
        return;
        i1;
        throw i1;
_L2:
        flag = false;
        if (true) goto _L6; else goto _L5
_L5:
    }

    protected void e() {
        this;
        JVM INSTR monitorenter ;
        super.e();
        for (Iterator iterator = n.values().iterator(); iterator.hasNext();)
            synchronized ((org.littleshoot.proxy.impl.i)iterator.next()) {
                if (m())
                    i1.p();
            }

        break MISSING_BLOCK_LABEL_68;
        exception1;
        i1;
        JVM INSTR monitorexit ;
        throw exception1;
        Exception exception;
        exception;
        this;
        JVM INSTR monitorexit ;
        throw exception;
        this;
        JVM INSTR monitorexit ;
    }

    public volatile void e(io.netty.channel.k k1) {
        super.e(k1);
    }

    protected void f() {
        this;
        JVM INSTR monitorenter ;
        super.f();
        for (Iterator iterator = n.values().iterator(); iterator.hasNext();)
            synchronized ((org.littleshoot.proxy.impl.i)iterator.next()) {
                if (!m())
                    i1.q();
            }

        break MISSING_BLOCK_LABEL_68;
        exception1;
        i1;
        JVM INSTR monitorexit ;
        throw exception1;
        Exception exception;
        exception;
        this;
        JVM INSTR monitorexit ;
        throw exception;
        this;
        JVM INSTR monitorexit ;
    }

    public boolean g() {
        return u;
    }

    public InetSocketAddress h() {
        InetSocketAddress inetsocketaddress;
        if (g == null)
            inetsocketaddress = null;
        else
            inetsocketaddress = (InetSocketAddress)g.g();
        return inetsocketaddress;
    }

    public volatile void h(io.netty.channel.k k1) {
        super.h(k1);
    }

    public volatile SSLEngine i() {
        return super.i();
    }

    public volatile boolean j() {
        return super.j();
    }

    static  {
        l = "Transfer-Encoding".toLowerCase(Locale.US);
    }
}
