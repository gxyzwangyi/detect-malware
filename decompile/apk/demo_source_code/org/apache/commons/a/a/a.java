// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package org.apache.commons.a.a;


// Referenced classes of package org.apache.commons.a.a:
//            b, c

public class a extends b {

    static final byte a[] = {
        13, 10
    };
    private static final byte e[] = {
        65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 
        75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 
        85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 
        101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 
        111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 
        121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 
        56, 57, 43, 47
    };
    private static final byte f[] = {
        65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 
        75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 
        85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 
        101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 
        111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 
        121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 
        56, 57, 45, 95
    };
    private static final byte g[] = {
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
        -1, -1, -1, 62, -1, 62, -1, 63, 52, 53, 
        54, 55, 56, 57, 58, 59, 60, 61, -1, -1, 
        -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 
        5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 
        25, -1, -1, -1, -1, 63, -1, 26, 27, 28, 
        29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 
        39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 
        49, 50, 51
    };
    private final byte h[];
    private final byte i[];
    private final byte j[];
    private final int k;
    private final int l;

    public a() {
        this(0);
    }

    public a(int i1) {
        this(i1, a);
    }

    public a(int i1, byte abyte0[]) {
        this(i1, abyte0, false);
    }

    public a(int i1, byte abyte0[], boolean flag) {
        int j1;
        if (abyte0 == null)
            j1 = 0;
        else
            j1 = abyte0.length;
        super(3, 4, i1, j1);
        i = g;
        if (abyte0 != null) {
            if (c(abyte0)) {
                abyte0 = c.a(abyte0);
                throw new IllegalArgumentException((new StringBuilder()).append("lineSeparator must not contain base64 characters: [").append(abyte0).append("]").toString());
            }
            if (i1 > 0) {
                l = abyte0.length + 4;
                j = new byte[abyte0.length];
                System.arraycopy(abyte0, 0, j, 0, abyte0.length);
            } else {
                l = 4;
                j = null;
            }
        } else {
            l = 4;
            j = null;
        }
        k = l - 1;
        if (flag)
            abyte0 = f;
        else
            abyte0 = e;
        h = abyte0;
    }

    public static byte[] a(byte abyte0[]) {
        return (new a()).b(abyte0);
    }

    void a(byte abyte0[], int i1, int j1, b.a a1) {
        if (!a1.f) goto _L2; else goto _L1
_L1:
        return;
_L2:
        int k1;
        if (j1 < 0)
            a1.f = true;
        k1 = 0;
_L4:
label0:
        {
            int l1;
            byte abyte1[];
            if (k1 < j1) {
                abyte1 = a(k, a1);
                l1 = abyte0[i1];
                if (l1 != c)
                    break label0;
                a1.f = true;
            }
            if (a1.f && a1.h != 0) {
                abyte0 = a(k, a1);
                switch (a1.h) {
                default:
                    throw new IllegalStateException((new StringBuilder()).append("Impossible modulus ").append(a1.h).toString());

                case 2: // '\002'
                    a1.a = a1.a >> 4;
                    i1 = a1.d;
                    a1.d = i1 + 1;
                    abyte0[i1] = (byte)(a1.a & 0xff);
                    break;

                case 3: // '\003'
                    a1.a = a1.a >> 2;
                    i1 = a1.d;
                    a1.d = i1 + 1;
                    abyte0[i1] = (byte)(a1.a >> 8 & 0xff);
                    i1 = a1.d;
                    a1.d = i1 + 1;
                    abyte0[i1] = (byte)(a1.a & 0xff);
                    break;

                case 1: // '\001'
                    break;
                }
            }
        }
        if (true) goto _L1; else goto _L3
_L3:
        if (l1 >= 0 && l1 < g.length) {
            l1 = g[l1];
            if (l1 >= 0) {
                a1.h = (a1.h + 1) % 4;
                a1.a = l1 + (a1.a << 6);
                if (a1.h == 0) {
                    l1 = a1.d;
                    a1.d = l1 + 1;
                    abyte1[l1] = (byte)(a1.a >> 16 & 0xff);
                    l1 = a1.d;
                    a1.d = l1 + 1;
                    abyte1[l1] = (byte)(a1.a >> 8 & 0xff);
                    l1 = a1.d;
                    a1.d = l1 + 1;
                    abyte1[l1] = (byte)(a1.a & 0xff);
                }
            }
        }
        k1++;
        i1++;
          goto _L4
    }

    protected boolean a(byte byte0) {
        boolean flag;
        if (byte0 >= 0 && byte0 < i.length && i[byte0] != -1)
            flag = true;
        else
            flag = false;
        return flag;
    }

}
