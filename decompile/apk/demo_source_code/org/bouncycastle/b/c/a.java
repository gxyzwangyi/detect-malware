// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package org.bouncycastle.b.c;


// Referenced classes of package org.bouncycastle.b.c:
//            b

public abstract class a {

    private static int a(int i) {
        boolean flag = false;
        int j = i;
        for (i = ((flag) ? 1 : 0); (j & 1) == 0; i++)
            j >>>= 1;

        return i;
    }

    private static int a(int ai[], int ai1[], int i, int ai2[], int j) {
        int i1 = ai.length;
        int k;
        for (k = 0; ai1[0] == 0; k += 32)
            b.b(i, ai1, 0);

        int j1 = a(ai1[0]);
        int l = k;
        if (j1 > 0) {
            b.a(i, ai1, j1, 0);
            l = k + j1;
        }
        i = 0;
        k = j;
        j = i;
        while (j < l)  {
            i = k;
            if ((ai2[0] & 1) != 0)
                if (k < 0)
                    i = k + b.a(i1, ai, ai2);
                else
                    i = k + b.c(i1, ai, ai2);
            b.a(i1, ai2, i);
            j++;
            k = i;
        }
        return k;
    }

    private static void a(int ai[], int i, int ai1[], int ai2[]) {
        if (i < 0)
            b.a(ai.length, ai1, ai, ai2);
        else
            System.arraycopy(ai1, 0, ai2, 0, ai.length);
    }

    public static void a(int ai[], int ai1[], int ai2[]) {
        int j;
        int l;
        j = 0;
        l = ai.length;
        if (b.c(l, ai1))
            throw new IllegalArgumentException("'x' cannot be 0");
        if (!b.b(l, ai1)) goto _L2; else goto _L1
_L1:
        System.arraycopy(ai1, 0, ai2, 0, l);
_L4:
        return;
_L2:
        int ai4[] = b.a(l, ai1);
        ai1 = b.a(l);
        ai1[0] = 1;
        int i;
        int k;
        int j1;
        int ai3[];
        int ai5[];
        if ((ai4[0] & 1) == 0)
            i = a(ai, ai4, l, ai1, 0);
        else
            i = 0;
        if (b.b(l, ai4)) {
            a(ai, i, ai1, ai2);
            continue; /* Loop/switch isn't completed */
        }
        ai5 = b.a(l, ai);
        ai3 = b.a(l);
        do {
            do {
                for (k = l; ai4[k - 1] == 0 && ai5[k - 1] == 0; k--);
                if (!b.b(k, ai4, ai5))
                    break;
                b.c(k, ai5, ai4);
                int i1 = a(ai, ai4, k, ai1, i + (b.c(l, ai3, ai1) - j));
                i = i1;
                if (b.b(k, ai4)) {
                    a(ai, i1, ai1, ai2);
                    continue; /* Loop/switch isn't completed */
                }
            } while (true);
            b.c(k, ai4, ai5);
            j1 = a(ai, ai5, k, ai3, j + (b.c(l, ai1, ai3) - i));
            j = j1;
        } while (!b.b(k, ai5));
        a(ai, j1, ai3, ai2);
        if (true) goto _L4; else goto _L3
_L3:
    }
}
