// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package org.bouncycastle.b.c;

import java.math.BigInteger;
import org.bouncycastle.util.e;

public abstract class b {

    public static int a(int i, int ai[], int j) {
        while (--i >= 0)  {
            int k = ai[i];
            ai[i] = k >>> 1 | j << 31;
            j = k;
        }
        return j << 31;
    }

    public static int a(int i, int ai[], int j, int k) {
        while (--i >= 0)  {
            int l = ai[i];
            ai[i] = l >>> j | k << -j;
            k = l;
        }
        return k << -j;
    }

    public static int a(int i, int ai[], int ai1[]) {
        long l = 0L;
        for (int j = 0; j < i; j++) {
            l += ((long)ai[j] & 0xffffffffL) + ((long)ai1[j] & 0xffffffffL);
            ai1[j] = (int)l;
            l >>>= 32;
        }

        return (int)l;
    }

    public static int a(int i, int ai[], int ai1[], int ai2[]) {
        long l = 0L;
        for (int j = 0; j < i; j++) {
            l += ((long)ai[j] & 0xffffffffL) + ((long)ai1[j] & 0xffffffffL);
            ai2[j] = (int)l;
            l >>>= 32;
        }

        return (int)l;
    }

    public static int[] a(int i) {
        return new int[i];
    }

    public static int[] a(int i, BigInteger biginteger) {
        if (biginteger.signum() < 0 || biginteger.bitLength() > i)
            throw new IllegalArgumentException();
        int ai[] = a(i + 31 >> 5);
        for (i = 0; biginteger.signum() != 0; i++) {
            ai[i] = biginteger.intValue();
            biginteger = biginteger.shiftRight(32);
        }

        return ai;
    }

    public static int[] a(int i, int ai[]) {
        int ai1[] = new int[i];
        System.arraycopy(ai, 0, ai1, 0, i);
        return ai1;
    }

    public static int b(int i, int ai[], int j) {
        while (--i >= 0)  {
            int k = ai[i];
            ai[i] = j;
            j = k;
        }
        return j;
    }

    public static boolean b(int i, int ai[]) {
        boolean flag1 = false;
        if (ai[0] == 1) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        for (int j = 1; j < i; j++) {
            flag = flag1;
            if (ai[j] != 0)
                continue; /* Loop/switch isn't completed */
        }

        flag = true;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public static boolean b(int i, int ai[], int ai1[]) {
        boolean flag1;
        flag1 = true;
        i--;
_L7:
        boolean flag = flag1;
        if (i < 0) goto _L2; else goto _L1
_L1:
        int j;
        int k;
        k = ai[i] ^ 0x80000000;
        j = ai1[i] ^ 0x80000000;
        if (k >= j) goto _L4; else goto _L3
_L3:
        flag = false;
_L2:
        return flag;
_L4:
        flag = flag1;
        if (k > j) goto _L2; else goto _L5
_L5:
        i--;
        if (true) goto _L7; else goto _L6
_L6:
    }

    public static int c(int i, int ai[], int ai1[]) {
        long l = 0L;
        for (int j = 0; j < i; j++) {
            l += ((long)ai1[j] & 0xffffffffL) - ((long)ai[j] & 0xffffffffL);
            ai1[j] = (int)l;
            l >>= 32;
        }

        return (int)l;
    }

    public static boolean c(int i, int ai[]) {
        int j;
        boolean flag;
        flag = false;
        j = 0;
_L3:
        if (j >= i)
            break MISSING_BLOCK_LABEL_23;
        if (ai[j] == 0) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        j++;
          goto _L3
        flag = true;
          goto _L1
    }

    public static BigInteger d(int i, int ai[]) {
        byte abyte0[] = new byte[i << 2];
        for (int j = 0; j < i; j++) {
            int k = ai[j];
            if (k != 0)
                e.a(k, abyte0, i - 1 - j << 2);
        }

        return new BigInteger(1, abyte0);
    }
}
