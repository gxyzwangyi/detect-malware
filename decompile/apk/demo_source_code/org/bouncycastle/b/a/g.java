// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package org.bouncycastle.b.a;

import java.math.BigInteger;
import org.bouncycastle.util.a;

// Referenced classes of package org.bouncycastle.b.a:
//            b

class g
    implements Cloneable {

    static final byte a[] = {
        0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 
        4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 
        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 
        5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
        6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
        6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
        7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
        8, 8, 8, 8, 8, 8
    };
    private static final short b[] = {
        0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 
        68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 
        272, 273, 276, 277, 320, 321, 324, 325, 336, 337, 
        340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 
        1088, 1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 
        1284, 1285, 1296, 1297, 1300, 1301, 1344, 1345, 1348, 1349, 
        1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 
        4116, 4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 
        4352, 4353, 4356, 4357, 4368, 4369, 4372, 4373, 4416, 4417, 
        4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 
        5136, 5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 
        5204, 5205, 5376, 5377, 5380, 5381, 5392, 5393, 5396, 5397, 
        5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 
        16388, 16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 
        16464, 16465, 16468, 16469, 16640, 16641, 16644, 16645, 16656, 16657, 
        16660, 16661, 16704, 16705, 16708, 16709, 16720, 16721, 16724, 16725, 
        17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473, 
        17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 
        17680, 17681, 17684, 17685, 17728, 17729, 17732, 17733, 17744, 17745, 
        17748, 17749, 20480, 20481, 20484, 20485, 20496, 20497, 20500, 20501, 
        20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736, 20737, 
        20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 
        20816, 20817, 20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 
        21524, 21525, 21568, 21569, 21572, 21573, 21584, 21585, 21588, 21589, 
        21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781, 21824, 21825, 
        21828, 21829, 21840, 21841, 21844, 21845
    };
    private static final int c[] = {
        0, 1, 8, 9, 64, 65, 72, 73, 512, 513, 
        520, 521, 576, 577, 584, 585, 4096, 4097, 4104, 4105, 
        4160, 4161, 4168, 4169, 4608, 4609, 4616, 4617, 4672, 4673, 
        4680, 4681, 32768, 32769, 32776, 32777, 32832, 32833, 32840, 32841, 
        33280, 33281, 33288, 33289, 33344, 33345, 33352, 33353, 36864, 36865, 
        36872, 36873, 36928, 36929, 36936, 36937, 37376, 37377, 37384, 37385, 
        37440, 37441, 37448, 37449, 0x40000, 0x40001, 0x40008, 0x40009, 0x40040, 0x40041, 
        0x40048, 0x40049, 0x40200, 0x40201, 0x40208, 0x40209, 0x40240, 0x40241, 0x40248, 0x40249, 
        0x41000, 0x41001, 0x41008, 0x41009, 0x41040, 0x41041, 0x41048, 0x41049, 0x41200, 0x41201, 
        0x41208, 0x41209, 0x41240, 0x41241, 0x41248, 0x41249, 0x48000, 0x48001, 0x48008, 0x48009, 
        0x48040, 0x48041, 0x48048, 0x48049, 0x48200, 0x48201, 0x48208, 0x48209, 0x48240, 0x48241, 
        0x48248, 0x48249, 0x49000, 0x49001, 0x49008, 0x49009, 0x49040, 0x49041, 0x49048, 0x49049, 
        0x49200, 0x49201, 0x49208, 0x49209, 0x49240, 0x49241, 0x49248, 0x49249
    };
    private static final int d[] = {
        0, 1, 16, 17, 256, 257, 272, 273, 4096, 4097, 
        4112, 4113, 4352, 4353, 4368, 4369, 0x10000, 0x10001, 0x10010, 0x10011, 
        0x10100, 0x10101, 0x10110, 0x10111, 0x11000, 0x11001, 0x11010, 0x11011, 0x11100, 0x11101, 
        0x11110, 0x11111, 0x100000, 0x100001, 0x100010, 0x100011, 0x100100, 0x100101, 0x100110, 0x100111, 
        0x101000, 0x101001, 0x101010, 0x101011, 0x101100, 0x101101, 0x101110, 0x101111, 0x110000, 0x110001, 
        0x110010, 0x110011, 0x110100, 0x110101, 0x110110, 0x110111, 0x111000, 0x111001, 0x111010, 0x111011, 
        0x111100, 0x111101, 0x111110, 0x111111, 0x1000000, 0x1000001, 0x1000010, 0x1000011, 0x1000100, 0x1000101, 
        0x1000110, 0x1000111, 0x1001000, 0x1001001, 0x1001010, 0x1001011, 0x1001100, 0x1001101, 0x1001110, 0x1001111, 
        0x1010000, 0x1010001, 0x1010010, 0x1010011, 0x1010100, 0x1010101, 0x1010110, 0x1010111, 0x1011000, 0x1011001, 
        0x1011010, 0x1011011, 0x1011100, 0x1011101, 0x1011110, 0x1011111, 0x1100000, 0x1100001, 0x1100010, 0x1100011, 
        0x1100100, 0x1100101, 0x1100110, 0x1100111, 0x1101000, 0x1101001, 0x1101010, 0x1101011, 0x1101100, 0x1101101, 
        0x1101110, 0x1101111, 0x1110000, 0x1110001, 0x1110010, 0x1110011, 0x1110100, 0x1110101, 0x1110110, 0x1110111, 
        0x1111000, 0x1111001, 0x1111010, 0x1111011, 0x1111100, 0x1111101, 0x1111110, 0x1111111, 0x10000000, 0x10000001, 
        0x10000010, 0x10000011, 0x10000100, 0x10000101, 0x10000110, 0x10000111, 0x10001000, 0x10001001, 0x10001010, 0x10001011, 
        0x10001100, 0x10001101, 0x10001110, 0x10001111, 0x10010000, 0x10010001, 0x10010010, 0x10010011, 0x10010100, 0x10010101, 
        0x10010110, 0x10010111, 0x10011000, 0x10011001, 0x10011010, 0x10011011, 0x10011100, 0x10011101, 0x10011110, 0x10011111, 
        0x10100000, 0x10100001, 0x10100010, 0x10100011, 0x10100100, 0x10100101, 0x10100110, 0x10100111, 0x10101000, 0x10101001, 
        0x10101010, 0x10101011, 0x10101100, 0x10101101, 0x10101110, 0x10101111, 0x10110000, 0x10110001, 0x10110010, 0x10110011, 
        0x10110100, 0x10110101, 0x10110110, 0x10110111, 0x10111000, 0x10111001, 0x10111010, 0x10111011, 0x10111100, 0x10111101, 
        0x10111110, 0x10111111, 0x11000000, 0x11000001, 0x11000010, 0x11000011, 0x11000100, 0x11000101, 0x11000110, 0x11000111, 
        0x11001000, 0x11001001, 0x11001010, 0x11001011, 0x11001100, 0x11001101, 0x11001110, 0x11001111, 0x11010000, 0x11010001, 
        0x11010010, 0x11010011, 0x11010100, 0x11010101, 0x11010110, 0x11010111, 0x11011000, 0x11011001, 0x11011010, 0x11011011, 
        0x11011100, 0x11011101, 0x11011110, 0x11011111, 0x11100000, 0x11100001, 0x11100010, 0x11100011, 0x11100100, 0x11100101, 
        0x11100110, 0x11100111, 0x11101000, 0x11101001, 0x11101010, 0x11101011, 0x11101100, 0x11101101, 0x11101110, 0x11101111, 
        0x11110000, 0x11110001, 0x11110010, 0x11110011, 0x11110100, 0x11110101, 0x11110110, 0x11110111, 0x11111000, 0x11111001, 
        0x11111010, 0x11111011, 0x11111100, 0x11111101, 0x11111110, 0x11111111
    };
    private static final int e[] = {
        0, 1, 32, 33, 1024, 1025, 1056, 1057, 32768, 32769, 
        32800, 32801, 33792, 33793, 33824, 33825, 0x100000, 0x100001, 0x100020, 0x100021, 
        0x100400, 0x100401, 0x100420, 0x100421, 0x108000, 0x108001, 0x108020, 0x108021, 0x108400, 0x108401, 
        0x108420, 0x108421, 0x2000000, 0x2000001, 0x2000020, 0x2000021, 0x2000400, 0x2000401, 0x2000420, 0x2000421, 
        0x2008000, 0x2008001, 0x2008020, 0x2008021, 0x2008400, 0x2008401, 0x2008420, 0x2008421, 0x2100000, 0x2100001, 
        0x2100020, 0x2100021, 0x2100400, 0x2100401, 0x2100420, 0x2100421, 0x2108000, 0x2108001, 0x2108020, 0x2108021, 
        0x2108400, 0x2108401, 0x2108420, 0x2108421, 0x40000000, 0x40000001, 0x40000020, 0x40000021, 0x40000400, 0x40000401, 
        0x40000420, 0x40000421, 0x40008000, 0x40008001, 0x40008020, 0x40008021, 0x40008400, 0x40008401, 0x40008420, 0x40008421, 
        0x40100000, 0x40100001, 0x40100020, 0x40100021, 0x40100400, 0x40100401, 0x40100420, 0x40100421, 0x40108000, 0x40108001, 
        0x40108020, 0x40108021, 0x40108400, 0x40108401, 0x40108420, 0x40108421, 0x42000000, 0x42000001, 0x42000020, 0x42000021, 
        0x42000400, 0x42000401, 0x42000420, 0x42000421, 0x42008000, 0x42008001, 0x42008020, 0x42008021, 0x42008400, 0x42008401, 
        0x42008420, 0x42008421, 0x42100000, 0x42100001, 0x42100020, 0x42100021, 0x42100400, 0x42100401, 0x42100420, 0x42100421, 
        0x42108000, 0x42108001, 0x42108020, 0x42108021, 0x42108400, 0x42108401, 0x42108420, 0x42108421
    };
    private static final long f[] = {
        0L, 1L, 128L, 129L, 16384L, 16385L, 16512L, 16513L, 0x200000L, 0x200001L, 
        0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 
        0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 
        0x10204080L, 0x10204081L, 0x0L, 0x1L, 0x80L, 0x81L, 0x4000L, 0x4001L, 0x4080L, 0x4081L, 
        0x200000L, 0x200001L, 0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 
        0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 
        0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 0x0L, 0x1L, 0x80L, 0x81L, 0x4000L, 0x4001L, 
        0x4080L, 0x4081L, 0x200000L, 0x200001L, 0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 
        0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 
        0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 0x0L, 0x1L, 0x80L, 0x81L, 
        0x4000L, 0x4001L, 0x4080L, 0x4081L, 0x200000L, 0x200001L, 0x200080L, 0x200081L, 0x204000L, 0x204001L, 
        0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 
        0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 0x0L, 0x1L, 
        0x80L, 0x81L, 0x4000L, 0x4001L, 0x4080L, 0x4081L, 0x200000L, 0x200001L, 0x200080L, 0x200081L, 
        0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 
        0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 
        0x0L, 0x1L, 0x80L, 0x81L, 0x4000L, 0x4001L, 0x4080L, 0x4081L, 0x200000L, 0x200001L, 
        0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 
        0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 
        0x10204080L, 0x10204081L, 0x0L, 0x1L, 0x80L, 0x81L, 0x4000L, 0x4001L, 0x4080L, 0x4081L, 
        0x200000L, 0x200001L, 0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 
        0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 
        0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 0x0L, 0x1L, 0x80L, 0x81L, 0x4000L, 0x4001L, 
        0x4080L, 0x4081L, 0x200000L, 0x200001L, 0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 
        0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 
        0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 0x0L, 0x1L, 0x80L, 0x81L, 
        0x4000L, 0x4001L, 0x4080L, 0x4081L, 0x200000L, 0x200001L, 0x200080L, 0x200081L, 0x204000L, 0x204001L, 
        0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 
        0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 0x0L, 0x1L, 
        0x80L, 0x81L, 0x4000L, 0x4001L, 0x4080L, 0x4081L, 0x200000L, 0x200001L, 0x200080L, 0x200081L, 
        0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 
        0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 
        0x0L, 0x1L, 0x80L, 0x81L, 0x4000L, 0x4001L, 0x4080L, 0x4081L, 0x200000L, 0x200001L, 
        0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 
        0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 
        0x10204080L, 0x10204081L, 0x0L, 0x1L, 0x80L, 0x81L, 0x4000L, 0x4001L, 0x4080L, 0x4081L, 
        0x200000L, 0x200001L, 0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 
        0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 
        0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 0x0L, 0x1L, 0x80L, 0x81L, 0x4000L, 0x4001L, 
        0x4080L, 0x4081L, 0x200000L, 0x200001L, 0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 
        0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 
        0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 0x0L, 0x1L, 0x80L, 0x81L, 
        0x4000L, 0x4001L, 0x4080L, 0x4081L, 0x200000L, 0x200001L, 0x200080L, 0x200081L, 0x204000L, 0x204001L, 
        0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 
        0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 0x0L, 0x1L, 
        0x80L, 0x81L, 0x4000L, 0x4001L, 0x4080L, 0x4081L, 0x200000L, 0x200001L, 0x200080L, 0x200081L, 
        0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 0x10004000L, 0x10004001L, 
        0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 0x10204080L, 0x10204081L, 
        0x0L, 0x1L, 0x80L, 0x81L, 0x4000L, 0x4001L, 0x4080L, 0x4081L, 0x200000L, 0x200001L, 
        0x200080L, 0x200081L, 0x204000L, 0x204001L, 0x204080L, 0x204081L, 0x10000000L, 0x10000001L, 0x10000080L, 0x10000081L, 
        0x10004000L, 0x10004001L, 0x10004080L, 0x10004081L, 0x10200000L, 0x10200001L, 0x10200080L, 0x10200081L, 0x10204000L, 0x10204001L, 
        0x10204080L, 0x10204081L
    };
    private long g[];

    public g(int i) {
        g = new long[i];
    }

    public g(BigInteger biginteger) {
        int i = 1;
        super();
        if (biginteger == null || biginteger.signum() < 0)
            throw new IllegalArgumentException("invalid F2m field value");
        if (biginteger.signum() == 0) {
            g = (new long[] {
                0L
            });
        } else {
            biginteger = biginteger.toByteArray();
            int j = biginteger.length;
            int k;
            if (biginteger[0] == 0)
                j--;
            else
                i = 0;
            k = (j + 7) / 8;
            g = new long[k];
            k--;
            j = j % 8 + i;
            if (i < j) {
                long l = 0L;
                for (; i < j; i++)
                    l = l << 8 | (long)(biginteger[i] & 0xff);

                g[k] = l;
                j = k - 1;
            } else {
                j = k;
            }
            while (j >= 0)  {
                long l1 = 0L;
                for (k = 0; k < 8;) {
                    l1 = l1 << 8 | (long)(biginteger[i] & 0xff);
                    k++;
                    i++;
                }

                g[j] = l1;
                j--;
            }
        }
    }

    public g(long al[]) {
        g = al;
    }

    public g(long al[], int i, int j) {
        if (i == 0 && j == al.length) {
            g = al;
        } else {
            g = new long[j];
            System.arraycopy(al, i, g, 0, j);
        }
    }

    private static int a(long l) {
        int i = (int)(l >>> 32);
        int j;
        int k;
        if (i == 0) {
            i = (int)l;
            j = 0;
        } else {
            j = 32;
        }
        k = i >>> 16;
        if (k == 0) {
            k = i >>> 8;
            if (k == 0)
                i = a[i];
            else
                i = a[k] + 8;
        } else {
            i = k >>> 8;
            if (i == 0)
                i = a[k] + 16;
            else
                i = a[i] + 24;
        }
        return i + j;
    }

    private static long a(long al[], int i, long al1[], int j, int k, int l) {
        long l1 = 0L;
        for (int i1 = 0; i1 < k; i1++) {
            long l2 = al[i + i1];
            al1[j + i1] = l1 | l2 << l;
            l1 = l2 >>> 64 - l;
        }

        return l1;
    }

    private static g a(long al[], int i, int j, int k, int ai[]) {
        return new g(al, i, b(al, i, j, k, ai));
    }

    private static void a(long l, long al[], int i, long al1[], int j) {
        if ((1L & l) != 0L)
            a(al1, j, al, 0, i);
        int k = 1;
        do {
            l >>>= 1;
            if (l != 0L) {
                if ((1L & l) != 0L) {
                    long l1 = b(al1, j, al, 0, i, k);
                    if (l1 != 0L) {
                        int i1 = j + i;
                        al1[i1] = l1 ^ al1[i1];
                    }
                }
                k++;
            } else {
                return;
            }
        } while (true);
    }

    private void a(g g1, int i, int j) {
        int k;
        k = i + 63 >>> 6;
        i = j >>> 6;
        j &= 0x3f;
        if (j != 0) goto _L2; else goto _L1
_L1:
        a(g, i, g1.g, 0, k);
_L4:
        return;
_L2:
        long l = b(g, i, g1.g, 0, k, j);
        if (l != 0L) {
            g1 = g;
            i += k;
            g1[i] = l ^ g1[i];
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private static void a(long al[], int i, int j, int k, int l, int ai[]) {
        int k1 = k >>> 6;
        do {
            int i1 = j - 1;
            if (i1 <= k1)
                break;
            long l1 = al[i + i1];
            j = i1;
            if (l1 != 0L) {
                al[i + i1] = 0L;
                a(al, i, i1 << 6, l1, l, ai);
                j = i1;
            }
        } while (true);
        j = k & 0x3f;
        long l2 = al[i + k1] >>> j;
        if (l2 != 0L) {
            int j1 = k1 + i;
            al[j1] = al[j1] ^ l2 << j;
            a(al, i, k, l2, l, ai);
        }
    }

    private static void a(long al[], int i, int j, long l) {
        i = (j >>> 6) + i;
        j &= 0x3f;
        if (j != 0) goto _L2; else goto _L1
_L1:
        al[i] = al[i] ^ l;
_L4:
        return;
_L2:
        al[i] = al[i] ^ l << j;
        l >>>= 64 - j;
        if (l != 0L) {
            i++;
            al[i] = l ^ al[i];
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private static void a(long al[], int i, int j, long l, int k, int ai[]) {
        k = j - k;
        for (j = ai.length; --j >= 0;)
            a(al, i, ai[j] + k, l);

        a(al, i, k, l);
    }

    private static void a(long al[], int i, int j, int ai[]) {
        j = i << 1;
        while (--i >= 0)  {
            long l = al[i];
            j--;
            al[j] = d((int)(l >>> 32));
            j--;
            al[j] = d((int)l);
        }
    }

    private static void a(long al[], int i, long al1[], int j, int k) {
        for (int l = 0; l < k; l++) {
            int i1 = i + l;
            al[i1] = al[i1] ^ al1[j + l];
        }

    }

    private static void a(long al[], int i, long al1[], int j, long al2[], int k, int l) {
        for (int i1 = 0; i1 < l; i1++)
            al2[k + i1] = al[i + i1] ^ al1[j + i1];

    }

    private static boolean a(long al[], int i, int j) {
        boolean flag;
        if ((al[(j >>> 6) + i] & 1L << (j & 0x3f)) != 0L)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private int b(int i) {
        i = i + 62 >>> 6;
_L2:
        if (i == 0) {
            i = 0;
        } else {
            long al[] = g;
            int j = i - 1;
            long l = al[j];
            i = j;
            if (l == 0L)
                continue; /* Loop/switch isn't completed */
            i = (j << 6) + a(l);
        }
        return i;
        if (true) goto _L2; else goto _L1
_L1:
    }

    private static int b(long al[], int i, int j, int k, int ai[]) {
        int j1 = k + 63 >>> 6;
        if (j < j1) {
            i = j;
        } else {
            int k1 = Math.min(j << 6, (k << 1) - 1);
            int l;
            for (l = (j << 6) - k1; l >= 64; l -= 64)
                j--;

            int i1 = ai.length;
            int l1 = ai[i1 - 1];
            if (i1 > 1)
                i1 = ai[i1 - 2];
            else
                i1 = 0;
            l1 = Math.max(k, l1 + 64);
            l = Math.min(k1 - l1, k - i1) + l >> 6;
            if (l > 1) {
                l = j - l;
                b(al, i, j, l, k, ai);
                while (j > l)  {
                    j--;
                    al[i + j] = 0L;
                }
                l <<= 6;
            } else {
                l = k1;
            }
            i1 = l;
            if (l > l1) {
                a(al, i, j, l1, k, ai);
                i1 = l1;
            }
            if (i1 > k)
                c(al, i, i1, k, ai);
            i = j1;
        }
        return i;
    }

    private static long b(long al[], int i, long al1[], int j, int k, int l) {
        long l1 = 0L;
        for (int i1 = 0; i1 < k; i1++) {
            long l2 = al1[j + i1];
            int j1 = i + i1;
            al[j1] = (l1 | l2 << l) ^ al[j1];
            l1 = l2 >>> 64 - l;
        }

        return l1;
    }

    private static void b(long al[], int i, int j) {
        i = (j >>> 6) + i;
        al[i] = 1L << (j & 0x3f) ^ al[i];
    }

    private static void b(long al[], int i, int j, int k, int l, int ai[]) {
        int i1 = (k << 6) - l;
        for (l = ai.length; --l >= 0;)
            d(al, i, al, i + k, j - k, i1 + ai[l]);

        d(al, i, al, i + k, j - k, i1);
    }

    private static void b(long al[], int i, long al1[], int j, long al2[], int k, int l) {
        for (int i1 = 0; i1 < l; i1++) {
            int j1 = i + i1;
            al[j1] = al[j1] ^ (al1[j + i1] ^ al2[k + i1]);
        }

    }

    private static long c(long al[], int i, long al1[], int j, int k, int l) {
        long l1;
        long l2;
        for (l1 = 0L; --k >= 0; l1 = l2 << 64 - l) {
            l2 = al1[j + k];
            int i1 = i + k;
            al[i1] = (l1 | l2 >>> l) ^ al[i1];
        }

        return l1;
    }

    private static void c(long al[], int i, int j, int k, int ai[]) {
        do {
            int l = j - 1;
            if (l < k)
                break;
            j = l;
            if (a(al, i, l)) {
                d(al, i, l, k, ai);
                j = l;
            }
        } while (true);
    }

    private long[] c(int i) {
        long al[] = new long[i];
        System.arraycopy(g, 0, al, 0, Math.min(g.length, i));
        return al;
    }

    private static long d(int i) {
        short word0 = b[i & 0xff];
        short word1 = b[i >>> 8 & 0xff];
        long l = b[i >>> 16 & 0xff] | b[i >>> 24] << 16;
        return (long)(word0 | word1 << 16) & 0xffffffffL | (l & 0xffffffffL) << 32;
    }

    private static void d(long al[], int i, int j, int k, int ai[]) {
        b(al, i, j);
        k = j - k;
        for (j = ai.length; --j >= 0;)
            b(al, i, ai[j] + k);

        b(al, i, k);
    }

    private static void d(long al[], int i, long al1[], int j, int k, int l) {
        i += l >>> 6;
        l &= 0x3f;
        if (l == 0)
            a(al, i, al1, j, k);
        else
            al[i] = c(al, i + 1, al1, j, k, 64 - l) ^ al[i];
    }

    public int a(int i) {
        int j;
        long al[];
        al = g;
        j = Math.min(i, al.length);
        if (j >= 1) goto _L2; else goto _L1
_L1:
        i = 0;
_L4:
        return i;
_L2:
        i = j;
        if (al[0] != 0L) {
            do {
                i = j - 1;
                j = i;
            } while (al[i] == 0L);
            i++;
            continue; /* Loop/switch isn't completed */
        }
        do {
            j = i - 1;
            if (al[j] != 0L) {
                i = j + 1;
                continue; /* Loop/switch isn't completed */
            }
            i = j;
        } while (j > 0);
        i = 0;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public g a(int i, int j, int ai[]) {
        int k = c();
        if (k == 0) {
            ai = this;
        } else {
            long al[] = new long[(j + 63 >>> 6) << 1];
            System.arraycopy(g, 0, al, 0, k);
            while (--i >= 0)  {
                a(al, k, j, ai);
                k = b(al, 0, al.length, j, ai);
            }
            ai = new g(al, 0, k);
        }
        return ai;
    }

    public g a(g g1, int i, int ai[]) {
        int j = d();
        if (j != 0) goto _L2; else goto _L1
_L1:
        g1 = this;
_L4:
        return g1;
_L2:
        int l = g1.d();
        if (l == 0)
            continue; /* Loop/switch isn't completed */
        int k;
        int i1;
        int j1;
        int k1;
        int l1;
        long l3;
        Object obj;
        long al[];
        int ai1[];
        long al1[];
        if (j > l) {
            obj = this;
            k = l;
        } else {
            g g2 = this;
            k = j;
            j = l;
            obj = g1;
            g1 = g2;
        }
        j1 = k + 63 >>> 6;
        k1 = j + 63 >>> 6;
        i1 = k + j + 62 >>> 6;
        if (j1 == 1) {
            long l2 = g1.g[0];
            g1 = ((g) (obj));
            if (l2 != 1L) {
                g1 = new long[i1];
                a(l2, ((g) (obj)).g, k1, ((long []) (g1)), 0);
                g1 = a(((long []) (g1)), 0, i1, i, ai);
            }
            continue; /* Loop/switch isn't completed */
        }
        l = j + 7 + 63 >>> 6;
        ai1 = new int[16];
        al = new long[l << 4];
        ai1[1] = l;
        System.arraycopy(((g) (obj)).g, 0, al, l, k1);
        j = 2;
        k = l;
        while (j < 16)  {
            k += l;
            ai1[j] = k;
            if ((j & 1) == 0)
                a(al, k >>> 1, al, k, l, 1);
            else
                a(al, l, al, k - l, al, k, l);
            j++;
        }
        obj = new long[al.length];
        a(al, 0, ((long []) (obj)), 0, al.length, 4);
        g1 = g1.g;
        al1 = new long[i1 << 3];
        j = 0;
        do {
label0:
            {
                if (j >= j1)
                    break label0;
                l3 = g1[j];
                k = j;
                do {
label1:
                    {
                        k1 = (int)l3;
                        l3 >>>= 4;
                        l1 = (int)l3;
                        b(al1, k, al, ai1[k1 & 0xf], ((long []) (obj)), ai1[l1 & 0xf], l);
                        l3 >>>= 4;
                        if (l3 != 0L)
                            break label1;
                        j++;
                    }
                    if (true)
                        break MISSING_BLOCK_LABEL_298;
                    k += i1;
                } while (true);
            }
        } while (true);
        j = al1.length;
        do {
            j -= i1;
            if (j == 0)
                break;
            b(al1, j - i1, al1, j, i1, 8);
        } while (true);
        g1 = a(al1, 0, i1, i, ai);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void a(int i, int ai[]) {
        long al[] = g;
        i = b(al, 0, al.length, i, ai);
        if (i < al.length) {
            g = new long[i];
            System.arraycopy(al, 0, g, 0, i);
        }
    }

    public void a(g g1, int i) {
        int k = g1.c();
        if (k != 0) {
            int j = k + i;
            if (j > g.length)
                g = c(j);
            a(g, i, g1.g, 0, k);
        }
    }

    public boolean a() {
        boolean flag1;
        long al[];
        flag1 = true;
        al = g;
        if (al[0] == 1L) goto _L2; else goto _L1
_L1:
        boolean flag = false;
_L4:
        return flag;
_L2:
        int i = 1;
        do {
            flag = flag1;
            if (i < al.length) {
label0:
                {
                    if (al[i] == 0L)
                        break label0;
                    flag = false;
                }
            }
            if (true)
                continue;
            i++;
        } while (true);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public g b(int i, int ai[]) {
        int j = c();
        if (j == 0) {
            ai = this;
        } else {
            int l = j << 1;
            long al[] = new long[l];
            for (int k = 0; k < l;) {
                long l1 = g[k >>> 1];
                int i1 = k + 1;
                al[k] = d((int)l1);
                k = i1 + 1;
                al[i1] = d((int)(l1 >>> 32));
            }

            ai = new g(al, 0, b(al, 0, al.length, i, ai));
        }
        return ai;
    }

    public g b(g g1, int i, int ai[]) {
        i = d();
        if (i != 0) goto _L2; else goto _L1
_L1:
        g1 = this;
_L4:
        return g1;
_L2:
        int k = g1.d();
        if (k == 0)
            continue; /* Loop/switch isn't completed */
        int j;
        int l;
        int i1;
        int j1;
        int k1;
        long l2;
        long al[];
        int ai1[];
        long al1[];
        if (i > k) {
            ai = this;
            j = k;
        } else {
            g g2 = this;
            j = i;
            i = k;
            ai = g1;
            g1 = g2;
        }
        i1 = j + 63 >>> 6;
        j1 = i + 63 >>> 6;
        l = j + i + 62 >>> 6;
        if (i1 == 1) {
            long l1 = g1.g[0];
            g1 = ai;
            if (l1 != 1L) {
                g1 = new long[l];
                a(l1, ((g) (ai)).g, j1, g1, 0);
                g1 = new g(g1, 0, l);
            }
            continue; /* Loop/switch isn't completed */
        }
        k = i + 7 + 63 >>> 6;
        ai1 = new int[16];
        al = new long[k << 4];
        ai1[1] = k;
        System.arraycopy(((g) (ai)).g, 0, al, k, j1);
        i = 2;
        j = k;
        while (i < 16)  {
            j += k;
            ai1[i] = j;
            if ((i & 1) == 0)
                a(al, j >>> 1, al, j, k, 1);
            else
                a(al, k, al, j - k, al, j, k);
            i++;
        }
        ai = new long[al.length];
        a(al, 0, ai, 0, al.length, 4);
        al1 = g1.g;
        g1 = new long[l << 3];
        i = 0;
        do {
label0:
            {
                if (i >= i1)
                    break label0;
                l2 = al1[i];
                j = i;
                do {
label1:
                    {
                        k1 = (int)l2;
                        l2 >>>= 4;
                        j1 = (int)l2;
                        b(((long []) (g1)), j, al, ai1[k1 & 0xf], ((long []) (ai)), ai1[j1 & 0xf], k);
                        l2 >>>= 4;
                        if (l2 != 0L)
                            break label1;
                        i++;
                    }
                    if (true)
                        break MISSING_BLOCK_LABEL_283;
                    j += l;
                } while (true);
            }
        } while (true);
        i = g1.length;
        do {
            i -= l;
            if (i == 0)
                break;
            b(((long []) (g1)), i - l, ((long []) (g1)), i, l, 8);
        } while (true);
        g1 = new g(g1, 0, l);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public boolean b() {
        int i;
        boolean flag;
        long al[];
        flag = false;
        al = g;
        i = 0;
_L3:
        if (i >= al.length)
            break MISSING_BLOCK_LABEL_31;
        if (al[i] == 0L) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        i++;
          goto _L3
        flag = true;
          goto _L1
    }

    public int c() {
        return a(g.length);
    }

    public g c(int i, int ai[]) {
        i = c();
        if (i == 0) {
            ai = this;
        } else {
            int j = i << 1;
            ai = new long[j];
            for (i = 0; i < j;) {
                long l = g[i >>> 1];
                int k = i + 1;
                ai[i] = d((int)l);
                i = k + 1;
                ai[k] = d((int)(l >>> 32));
            }

            ai = new g(ai, 0, ai.length);
        }
        return ai;
    }

    public Object clone() {
        return new g(org.bouncycastle.util.a.a(g));
    }

    public int d() {
        int i = g.length;
_L2:
        if (i == 0) {
            i = 0;
        } else {
            long al[] = g;
            int j = i - 1;
            long l = al[j];
            i = j;
            if (l == 0L)
                continue; /* Loop/switch isn't completed */
            i = (j << 6) + a(l);
        }
        return i;
        if (true) goto _L2; else goto _L1
_L1:
    }

    public g d(int i, int ai[]) {
        int l;
        int i2;
        i2 = 1;
        l = d();
        if (l == 0)
            throw new IllegalStateException();
        if (l != 1) goto _L2; else goto _L1
_L1:
        ai = this;
_L4:
        return ai;
_L2:
        g g2 = (g)clone();
        int j = i + 63 >>> 6;
        g g3 = new g(j);
        d(g3.g, 0, i, i, ai);
        ai = new g(j);
        ((g) (ai)).g[0] = 1L;
        g g1 = new g(j);
        int ai1[] = new int[2];
        ai1[0] = l;
        ai1[1] = i + 1;
        g ag[] = new g[2];
        ag[0] = g2;
        ag[1] = g3;
        int ai2[] = new int[2];
        ai2;
        ai2[0] = 1;
        ai2[1] = 0;
        g ag1[] = new g[2];
        ag1[0] = ai;
        ag1[1] = g1;
        i = ai1[1];
        l = ai2[1];
        int i1 = i - ai1[0];
        do {
            int k;
            int j1;
            int k1;
            int l1;
label0:
            {
                l1 = i1;
                k = l;
                k1 = i;
                j1 = i2;
                if (i1 < 0) {
                    l1 = -i1;
                    ai1[i2] = i;
                    ai2[i2] = l;
                    j1 = 1 - i2;
                    k1 = ai1[j1];
                    k = ai2[j1];
                }
                ag[j1].a(ag[1 - j1], ai1[1 - j1], l1);
                l = ag[j1].b(k1);
                if (l != 0)
                    break label0;
                ai = ag1[1 - j1];
            }
            if (true)
                continue;
            i = ai2[1 - j1];
            ag1[j1].a(ag1[1 - j1], i, l1);
            i1 = i + l1;
            if (i1 > k) {
                i = i1;
            } else {
                i = k;
                if (i1 == k)
                    i = ag1[j1].b(k);
            }
            i1 = l1 + (l - k1);
            k = l;
            l = i;
            i = k;
            i2 = j1;
        } while (true);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public BigInteger e() {
        int k1 = c();
        if (k1 != 0) goto _L2; else goto _L1
_L1:
        Object obj = org.bouncycastle.b.a.b.a;
_L4:
        return ((BigInteger) (obj));
_L2:
        long l1 = g[k1 - 1];
        byte abyte0[] = new byte[8];
        int j = 7;
        boolean flag = false;
        int i;
        int i1;
        for (i = 0; j >= 0; i = i1) {
label0:
            {
                byte byte0 = (byte)(int)(l1 >>> j * 8);
                if (!flag) {
                    i1 = i;
                    if (byte0 == 0)
                        break label0;
                }
                abyte0[i] = byte0;
                i1 = i + 1;
                flag = true;
            }
            j--;
        }

        obj = new byte[(k1 - 1) * 8 + i];
        for (int k = 0; k < i; k++)
            obj[k] = abyte0[k];

        for (int l = k1 - 2; l >= 0; l--) {
            long l2 = g[l];
            for (int j1 = 7; j1 >= 0;) {
                obj[i] = (byte)(int)(l2 >>> j1 * 8);
                j1--;
                i++;
            }

        }

        obj = new BigInteger(1, ((byte []) (obj)));
        if (true) goto _L4; else goto _L3
_L3:
    }

    public boolean equals(Object obj) {
        boolean flag1 = false;
        if (obj instanceof g) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        obj = (g)obj;
        int j = c();
        flag = flag1;
        if (((g) (obj)).c() != j)
            continue; /* Loop/switch isn't completed */
        for (int i = 0; i < j; i++) {
            flag = flag1;
            if (g[i] != ((g) (obj)).g[i])
                continue; /* Loop/switch isn't completed */
        }

        flag = true;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public g f() {
        Object obj;
        if (g.length == 0) {
            obj = new g(new long[] {
                1L
            });
        } else {
            obj = c(Math.max(1, c()));
            obj[0] = obj[0] ^ 1L;
            obj = new g(((long []) (obj)));
        }
        return ((g) (obj));
    }

    public int hashCode() {
        int k = c();
        int j = 1;
        for (int i = 0; i < k; i++) {
            long l = g[i];
            j = (j * 31 ^ (int)l) * 31 ^ (int)(l >>> 32);
        }

        return j;
    }

    public String toString() {
        int i = c();
        Object obj;
        if (i == 0) {
            obj = "0";
        } else {
            obj = g;
            i--;
            StringBuffer stringbuffer = new StringBuffer(Long.toBinaryString(obj[i]));
            while (--i >= 0)  {
                obj = Long.toBinaryString(g[i]);
                int j = ((String) (obj)).length();
                if (j < 64)
                    stringbuffer.append("0000000000000000000000000000000000000000000000000000000000000000".substring(j));
                stringbuffer.append(((String) (obj)));
            }
            obj = stringbuffer.toString();
        }
        return ((String) (obj));
    }

}
