// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package org.xbill.DNS;

import java.io.EOFException;
import java.net.*;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;

// Referenced classes of package org.xbill.DNS:
//            b

final class ad extends b {

    public ad(long l) {
        super(SocketChannel.open(), l);
    }

    private byte[] a(int i) {
        int j;
        Object obj;
        ByteBuffer bytebuffer;
        SocketChannel socketchannel;
        socketchannel = (SocketChannel)b.channel();
        obj = new byte[i];
        bytebuffer = ByteBuffer.wrap(((byte []) (obj)));
        b.interestOps(1);
        j = 0;
_L2:
        if (j >= i)
            break; /* Loop/switch isn't completed */
        long l;
        if (!b.isReadable())
            break MISSING_BLOCK_LABEL_143;
        l = socketchannel.read(bytebuffer);
        if (l >= 0L)
            break MISSING_BLOCK_LABEL_104;
        obj = JVM INSTR new #48  <Class EOFException>;
        ((EOFException) (obj)).EOFException();
        throw obj;
        obj;
        if (b.isValid())
            b.interestOps(0);
        throw obj;
        int k = j + (int)l;
        j = k;
        if (k >= i)
            continue; /* Loop/switch isn't completed */
        j = k;
        if (System.currentTimeMillis() > a) {
            obj = JVM INSTR new #65  <Class SocketTimeoutException>;
            ((SocketTimeoutException) (obj)).SocketTimeoutException();
            throw obj;
        }
        continue; /* Loop/switch isn't completed */
        a(b, a);
        if (true) goto _L2; else goto _L1
_L1:
        if (b.isValid())
            b.interestOps(0);
        return ((byte []) (obj));
    }

    static byte[] a(SocketAddress socketaddress, SocketAddress socketaddress1, byte abyte0[], long l) {
        ad ad1;
        ad1 = new ad(l);
        if (socketaddress == null)
            break MISSING_BLOCK_LABEL_20;
        ad1.a(socketaddress);
        ad1.b(socketaddress1);
        ad1.a(abyte0);
        socketaddress = ad1.b();
        ad1.a();
        return socketaddress;
        socketaddress;
        ad1.a();
        throw socketaddress;
    }

    void a(SocketAddress socketaddress) {
        ((SocketChannel)b.channel()).socket().bind(socketaddress);
    }

    void a(byte abyte0[]) {
        int i;
        ByteBuffer bytebuffer;
        SocketChannel socketchannel;
        ByteBuffer bytebuffer1;
        socketchannel = (SocketChannel)b.channel();
        a("TCP write", socketchannel.socket().getLocalSocketAddress(), socketchannel.socket().getRemoteSocketAddress(), abyte0);
        bytebuffer = ByteBuffer.wrap(new byte[] {
            (byte)(abyte0.length >>> 8), (byte)(abyte0.length & 0xff)
        });
        bytebuffer1 = ByteBuffer.wrap(abyte0);
        b.interestOps(4);
        i = 0;
_L2:
        long l;
        if (i >= abyte0.length + 2)
            break; /* Loop/switch isn't completed */
        if (!b.isWritable())
            break MISSING_BLOCK_LABEL_195;
        l = socketchannel.write(new ByteBuffer[] {
            bytebuffer, bytebuffer1
        });
        if (l >= 0L)
            break MISSING_BLOCK_LABEL_156;
        abyte0 = JVM INSTR new #48  <Class EOFException>;
        abyte0.EOFException();
        throw abyte0;
        abyte0;
        if (b.isValid())
            b.interestOps(0);
        throw abyte0;
        int j;
        j = i + (int)l;
        i = j;
        if (j >= abyte0.length + 2)
            continue; /* Loop/switch isn't completed */
        i = j;
        if (System.currentTimeMillis() > a) {
            abyte0 = JVM INSTR new #65  <Class SocketTimeoutException>;
            abyte0.SocketTimeoutException();
            throw abyte0;
        }
        continue; /* Loop/switch isn't completed */
        a(b, a);
        if (true) goto _L2; else goto _L1
_L1:
        if (b.isValid())
            b.interestOps(0);
        return;
    }

    void b(SocketAddress socketaddress) {
        SocketChannel socketchannel = (SocketChannel)b.channel();
        if (!socketchannel.connect(socketaddress)) goto _L2; else goto _L1
_L1:
        return;
_L2:
        b.interestOps(8);
        do {
            if (socketchannel.finishConnect())
                break MISSING_BLOCK_LABEL_83;
            if (!b.isConnectable())
                a(b, a);
        } while (true);
        socketaddress;
        if (b.isValid())
            b.interestOps(0);
        throw socketaddress;
        if (b.isValid())
            b.interestOps(0);
        if (true) goto _L1; else goto _L3
_L3:
    }

    byte[] b() {
        byte abyte0[] = a(2);
        byte byte0 = abyte0[0];
        byte abyte1[] = a((abyte0[1] & 0xff) + ((byte0 & 0xff) << 8));
        SocketChannel socketchannel = (SocketChannel)b.channel();
        a("TCP read", socketchannel.socket().getLocalSocketAddress(), socketchannel.socket().getRemoteSocketAddress(), abyte1);
        return abyte1;
    }
}
