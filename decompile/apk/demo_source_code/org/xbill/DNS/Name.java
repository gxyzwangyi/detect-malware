// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package org.xbill.DNS;

import java.io.PrintStream;
import java.io.Serializable;
import java.text.DecimalFormat;

// Referenced classes of package org.xbill.DNS:
//            f, WireParseException, s, TextParseException, 
//            NameTooLongException, DNAMERecord, g, d

public class Name
    implements Serializable, Comparable {

    public static final Name a;
    public static final Name b;
    private static final byte f[] = {
        0
    };
    private static final byte g[] = {
        1, 42
    };
    private static final DecimalFormat h;
    private static final byte i[];
    private static final Name j;
    private byte c[] = new byte[0];
    private long d;
    private int e;

    private Name() {
    }

    public Name(String s1, Name name) {
        if (s1.equals(""))
            throw a(s1, "empty name");
        if (!s1.equals("@")) goto _L2; else goto _L1
_L1:
        if (name == null)
            b(b, this);
        else
            b(name, this);
_L11:
        return;
_L2:
        int k;
        int l;
        int i1;
        int j1;
        int k1;
        boolean flag1;
        byte abyte0[];
        if (s1.equals(".")) {
            b(a, this);
            continue; /* Loop/switch isn't completed */
        }
        j1 = -1;
        i1 = 1;
        abyte0 = new byte[64];
        flag1 = false;
        l = 0;
        k = 0;
        k1 = 0;
_L7:
        byte byte0;
        if (k1 >= s1.length())
            break MISSING_BLOCK_LABEL_329;
        byte0 = (byte)s1.charAt(k1);
        if (!flag1)
            break MISSING_BLOCK_LABEL_229;
        if (byte0 < 48 || byte0 > 57 || l >= 3) goto _L4; else goto _L3
_L3:
        l++;
        k = k * 10 + (byte0 - 48);
        if (k > 255)
            throw a(s1, "bad escape");
        if (l >= 3) goto _L6; else goto _L5
_L5:
        k1++;
          goto _L7
_L6:
        byte0 = (byte)k;
_L9:
        if (i1 > 63)
            throw a(s1, "label too long");
        break; /* Loop/switch isn't completed */
_L4:
        if (l > 0 && l < 3)
            throw a(s1, "bad escape");
        if (true) goto _L9; else goto _L8
_L8:
        abyte0[i1] = byte0;
        flag1 = false;
        j1 = i1;
        i1++;
          goto _L5
        if (byte0 == 92) {
            flag1 = true;
            l = 0;
            k = 0;
        } else
        if (byte0 == 46) {
            if (j1 == -1)
                throw a(s1, "invalid empty label");
            abyte0[0] = (byte)(i1 - 1);
            a(s1, abyte0, 0, 1);
            j1 = -1;
            i1 = 1;
        } else {
            if (j1 == -1)
                j1 = k1;
            if (i1 > 63)
                throw a(s1, "label too long");
            abyte0[i1] = byte0;
            i1++;
        }
          goto _L5
        if (l > 0 && l < 3)
            throw a(s1, "bad escape");
        if (flag1)
            throw a(s1, "bad escape");
        boolean flag;
        if (j1 == -1) {
            a(s1, f, 0, 1);
            flag = true;
        } else {
            abyte0[0] = (byte)(i1 - 1);
            a(s1, abyte0, 0, 1);
            flag = false;
        }
        if (name != null && !flag)
            a(s1, name.c, name.a(0), name.e());
        if (true) goto _L11; else goto _L10
_L10:
    }

    public Name(Name name, int k) {
        int i1 = name.c();
        if (k > i1)
            throw new IllegalArgumentException("attempted to remove too many labels");
        c = name.c;
        b(i1 - k);
        for (int l = 0; l < 7 && l < i1 - k; l++)
            a(l, name.a(l + k));

    }

    public Name(f f1) {
        byte abyte0[] = new byte[64];
        boolean flag1 = false;
        boolean flag = false;
        do {
            if (flag)
                break;
            int k = f1.g();
            switch (k & 0xc0) {
            default:
                throw new WireParseException("bad label type");

            case 0: // '\0'
                if (e() >= 128)
                    throw new WireParseException("too many labels");
                if (k == 0) {
                    a(f, 0, 1);
                    flag = true;
                } else {
                    abyte0[0] = (byte)k;
                    f1.a(abyte0, 1, k);
                    a(abyte0, 0, 1);
                }
                break;

            case 192: 
                int l = ((k & 0xffffff3f) << 8) + f1.g();
                if (s.b("verbosecompression"))
                    System.err.println("currently " + f1.a() + ", pointer to " + l);
                if (l >= f1.a() - 2)
                    throw new WireParseException("bad compression");
                k = ((flag1) ? 1 : 0);
                if (!flag1) {
                    f1.e();
                    k = 1;
                }
                f1.c(l);
                flag1 = k;
                if (s.b("verbosecompression")) {
                    System.err.println("current name '" + this + "', seeking to " + l);
                    flag1 = k;
                }
                break;
            }
        } while (true);
        if (flag1)
            f1.f();
    }

    private final int a(int k) {
        if (k != 0 || e() != 0) goto _L2; else goto _L1
_L1:
        int i1 = 0;
_L4:
        return i1;
_L2:
        if (k < 0 || k >= e())
            throw new IllegalArgumentException("label out of range");
        if (k >= 7)
            break; /* Loop/switch isn't completed */
        i1 = (int)(d >>> (7 - k) * 8) & 0xff;
        if (true) goto _L4; else goto _L3
_L3:
        int l = a(6);
        int j1 = 6;
        do {
            i1 = l;
            if (j1 >= k)
                continue;
            i1 = c[l];
            j1++;
            l = i1 + 1 + l;
        } while (true);
        if (true) goto _L4; else goto _L5
_L5:
    }

    private String a(byte abyte0[], int k) {
        StringBuffer stringbuffer = new StringBuffer();
        int l = k + 1;
        byte byte0 = abyte0[k];
        k = l;
        while (k < l + byte0)  {
            int i1 = abyte0[k] & 0xff;
            if (i1 <= 32 || i1 >= 127) {
                stringbuffer.append('\\');
                stringbuffer.append(h.format(i1));
            } else
            if (i1 == 34 || i1 == 40 || i1 == 41 || i1 == 46 || i1 == 59 || i1 == 92 || i1 == 64 || i1 == 36) {
                stringbuffer.append('\\');
                stringbuffer.append((char)i1);
            } else {
                stringbuffer.append((char)i1);
            }
            k++;
        }
        return stringbuffer.toString();
    }

    public static Name a(String s1) {
        return a(s1, ((Name) (null)));
    }

    public static Name a(String s1, Name name) {
        if (!s1.equals("@") || name == null)
            if (s1.equals("."))
                name = a;
            else
                name = new Name(s1, name);
        return name;
    }

    public static Name a(Name name, Name name1) {
        if (!name.a()) {
            Name name2 = new Name();
            b(name, name2);
            name2.a(name1.c, name1.a(0), name1.e());
            name = name2;
        }
        return name;
    }

    private static TextParseException a(String s1, String s2) {
        return new TextParseException("'" + s1 + "': " + s2);
    }

    private final void a(int k, int l) {
        if (k < 7) {
            k = (7 - k) * 8;
            d = d & ~(255L << k);
            long l1 = d;
            d = (long)l << k | l1;
        }
    }

    private final void a(String s1, byte abyte0[], int k, int l) {
        try {
            a(abyte0, k, l);
            return;
        }
        // Misplaced declaration of an exception variable
        catch (byte abyte0[]) {
            throw a(s1, "Name too long");
        }
    }

    private final void a(byte abyte0[], int k, int l) {
        boolean flag = false;
        int i1;
        int j1;
        int k1;
        int l1;
        if (c == null)
            i1 = 0;
        else
            i1 = c.length - a(0);
        l1 = k;
        k1 = 0;
        j1 = 0;
        for (; k1 < l; k1++) {
            int i2 = abyte0[l1];
            if (i2 > 63)
                throw new IllegalStateException("invalid label");
            i2++;
            l1 += i2;
            j1 += i2;
        }

        int j2 = i1 + j1;
        if (j2 > 255)
            throw new NameTooLongException();
        l1 = e();
        k1 = l1 + l;
        if (k1 > 128)
            throw new IllegalStateException("too many labels");
        byte abyte1[] = new byte[j2];
        if (i1 != 0)
            System.arraycopy(c, a(0), abyte1, 0, i1);
        System.arraycopy(abyte0, k, abyte1, i1, j1);
        c = abyte1;
        for (k = ((flag) ? 1 : 0); k < l; k++) {
            a(l1 + k, i1);
            i1 += abyte1[i1] + 1;
        }

        b(k1);
    }

    public static Name b(String s1) {
        Name name;
        try {
            name = a(s1, ((Name) (null)));
        }
        catch (TextParseException textparseexception) {
            throw new IllegalArgumentException("Invalid name '" + s1 + "'");
        }
        return name;
    }

    private final void b(int k) {
        d = d & -256L;
        d = d | (long)k;
    }

    private static final void b(Name name, Name name1) {
        int k = 0;
        if (name.a(0) == 0) {
            name1.c = name.c;
            name1.d = name.d;
        } else {
            int i1 = name.a(0);
            int j1 = name.c.length - i1;
            int l = name.c();
            name1.c = new byte[j1];
            System.arraycopy(name.c, i1, name1.c, 0, j1);
            for (; k < l && k < 7; k++)
                name1.a(k, name.a(k) - i1);

            name1.b(l);
        }
    }

    private final void b(byte abyte0[], int k, int l) {
        a(abyte0, k, l);
_L2:
        return;
        abyte0;
        if (true) goto _L2; else goto _L1
_L1:
    }

    private final boolean b(byte abyte0[], int k) {
        int l;
        int i1;
        int l1;
        boolean flag1;
        flag1 = false;
        l1 = c();
        int j1 = a(0);
        i1 = 0;
        l = k;
        k = j1;
_L6:
        if (i1 >= l1)
            break MISSING_BLOCK_LABEL_141;
        if (c[k] == abyte0[l]) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        int k1;
        byte byte0;
        byte0 = c[k];
        if (byte0 > 63)
            throw new IllegalStateException("invalid label");
        l++;
        k++;
        k1 = 0;
_L5:
        if (k1 >= byte0)
            break MISSING_BLOCK_LABEL_135;
        flag = flag1;
        if (i[c[k] & 0xff] != i[abyte0[l] & 0xff]) goto _L4; else goto _L3
_L3:
        k1++;
        l++;
        k++;
          goto _L5
        i1++;
          goto _L6
        flag = true;
          goto _L4
    }

    private final int e() {
        return (int)(d & 255L);
    }

    public String a(boolean flag) {
        int k;
        int i1;
        k = 0;
        i1 = c();
        if (i1 != 0) goto _L2; else goto _L1
_L1:
        Object obj = "@";
_L4:
        return ((String) (obj));
_L2:
        int l;
        if (i1 == 1 && c[a(0)] == 0) {
            obj = ".";
            continue; /* Loop/switch isn't completed */
        }
        obj = new StringBuffer();
        l = a(0);
_L5:
        byte byte0;
label0:
        {
            if (k < i1) {
                byte0 = c[l];
                if (byte0 > 63)
                    throw new IllegalStateException("invalid label");
                if (byte0 != 0)
                    break label0;
                if (!flag)
                    ((StringBuffer) (obj)).append('.');
            }
            obj = ((StringBuffer) (obj)).toString();
        }
        if (true) goto _L4; else goto _L3
_L3:
        if (k > 0)
            ((StringBuffer) (obj)).append('.');
        ((StringBuffer) (obj)).append(a(c, l));
        l += byte0 + 1;
        k++;
          goto _L5
        if (true) goto _L4; else goto _L6
_L6:
    }

    public Name a(DNAMERecord dnamerecord) {
        int l;
        Name name;
        l = 0;
        name = dnamerecord.j();
        dnamerecord = dnamerecord.l_();
        if (a(name)) goto _L2; else goto _L1
_L1:
        dnamerecord = null;
_L4:
        return dnamerecord;
_L2:
        int k;
        int i1;
        int j1;
        i1 = c() - name.c();
        int k1 = b() - name.b();
        int l1 = a(0);
        j1 = dnamerecord.c();
        k = dnamerecord.b();
        if (k1 + k > 255)
            throw new NameTooLongException();
        name = new Name();
        name.b(i1 + j1);
        name.c = new byte[k1 + k];
        System.arraycopy(c, l1, name.c, 0, k1);
        System.arraycopy(((Name) (dnamerecord)).c, 0, name.c, k1, k);
        k = 0;
_L6:
        dnamerecord = name;
        if (k >= 7) goto _L4; else goto _L3
_L3:
        dnamerecord = name;
        if (k >= i1 + j1) goto _L4; else goto _L5
_L5:
        name.a(k, l);
        l += name.c[l] + 1;
        k++;
          goto _L6
    }

    public void a(g g1) {
        g1.a(d());
    }

    public void a(g g1, d d1) {
        int k;
        int j1;
        if (!a())
            throw new IllegalArgumentException("toWire() called on non-absolute name");
        j1 = c();
        k = 0;
_L5:
        if (k >= j1 - 1) goto _L2; else goto _L1
_L1:
        Name name;
        int l;
        if (k == 0)
            name = this;
        else
            name = new Name(this, k);
        l = -1;
        if (d1 != null)
            l = d1.a(name);
        if (l < 0) goto _L4; else goto _L3
_L3:
        g1.c(l | 0xc000);
_L6:
        return;
_L4:
        if (d1 != null)
            d1.a(g1.a(), name);
        int i1 = a(k);
        g1.a(c, i1, c[i1] + 1);
        k++;
          goto _L5
_L2:
        g1.b(0);
          goto _L6
    }

    public void a(g g1, d d1, boolean flag) {
        if (flag)
            a(g1);
        else
            a(g1, d1);
    }

    public boolean a() {
        int k;
        boolean flag;
        flag = false;
        k = c();
        break MISSING_BLOCK_LABEL_7;
        if (k != 0 && c[a(k - 1)] == 0)
            flag = true;
        return flag;
    }

    public boolean a(Name name) {
        int k = c();
        int l = name.c();
        boolean flag;
        if (l > k)
            flag = false;
        else
        if (l == k)
            flag = equals(name);
        else
            flag = name.b(c, a(k - l));
        return flag;
    }

    public short b() {
        short word0 = 0;
        if (e() != 0)
            word0 = (short)(c.length - a(0));
        return word0;
    }

    public int c() {
        return e();
    }

    public int compareTo(Object obj) {
        obj = (Name)obj;
        if (this != obj) goto _L2; else goto _L1
_L1:
        int k = 0;
_L4:
        return k;
_L2:
        int j1 = c();
        int k1 = ((Name) (obj)).c();
        int l;
        if (j1 > k1)
            k = k1;
        else
            k = j1;
        l = 1;
        do {
            if (l > k)
                break;
            int j2 = a(j1 - l);
            int i2 = ((Name) (obj)).a(k1 - l);
            byte byte0 = c[j2];
            byte byte1 = ((Name) (obj)).c[i2];
            int i1 = 0;
            do {
                if (i1 >= byte0 || i1 >= byte1)
                    break;
                int l1 = i[c[i1 + j2 + 1] & 0xff] - i[((Name) (obj)).c[i1 + i2 + 1] & 0xff];
                if (l1 != 0) {
                    k = l1;
                    continue; /* Loop/switch isn't completed */
                }
                i1++;
            } while (true);
            if (byte0 != byte1) {
                k = byte0 - byte1;
                continue; /* Loop/switch isn't completed */
            }
            l++;
        } while (true);
        k = j1 - k1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public byte[] d() {
        int k1 = c();
        if (k1 != 0) goto _L2; else goto _L1
_L1:
        byte abyte0[] = new byte[0];
_L4:
        return abyte0;
_L2:
        byte abyte1[] = new byte[c.length - a(0)];
        int k = a(0);
        int l = 0;
        int i1 = 0;
        do {
            abyte0 = abyte1;
            if (i1 >= k1)
                continue;
            byte byte0 = c[k];
            if (byte0 > 63)
                throw new IllegalStateException("invalid label");
            abyte1[l] = c[k];
            k++;
            l++;
            for (int j1 = 0; j1 < byte0;) {
                abyte1[l] = i[c[k] & 0xff];
                j1++;
                l++;
                k++;
            }

            i1++;
        } while (true);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public boolean equals(Object obj) {
        boolean flag1 = false;
        if (obj != this) goto _L2; else goto _L1
_L1:
        boolean flag = true;
_L4:
        return flag;
_L2:
        flag = flag1;
        if (obj != null) {
            flag = flag1;
            if (obj instanceof Name) {
                obj = (Name)obj;
                if (((Name) (obj)).e == 0)
                    ((Name) (obj)).hashCode();
                if (e == 0)
                    hashCode();
                flag = flag1;
                if (((Name) (obj)).e == e) {
                    flag = flag1;
                    if (((Name) (obj)).c() == c())
                        flag = b(((Name) (obj)).c, ((Name) (obj)).a(0));
                }
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public int hashCode() {
        int k = 0;
        if (e != 0) {
            k = e;
        } else {
            for (int l = a(0); l < c.length; l++)
                k += (k << 3) + i[c[l] & 0xff];

            e = k;
            k = e;
        }
        return k;
    }

    public String toString() {
        return a(false);
    }

    static  {
        h = new DecimalFormat();
        i = new byte[256];
        h.setMinimumIntegerDigits(3);
        int k = 0;
        while (k < i.length)  {
            if (k < 65 || k > 90)
                i[k] = (byte)k;
            else
                i[k] = (byte)((k - 65) + 97);
            k++;
        }
        a = new Name();
        a.b(f, 0, 1);
        b = new Name();
        j = new Name();
        j.b(g, 0, 1);
    }
}
