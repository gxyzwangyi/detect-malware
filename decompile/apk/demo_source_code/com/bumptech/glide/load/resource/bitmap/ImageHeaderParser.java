// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.bumptech.glide.load.resource.bitmap;

import android.util.Log;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class ImageHeaderParser {
    public static final class ImageType extends Enum {

        private static final ImageType $VALUES[];
        public static final ImageType GIF;
        public static final ImageType JPEG;
        public static final ImageType PNG;
        public static final ImageType PNG_A;
        public static final ImageType UNKNOWN;
        private final boolean a;

        public static ImageType valueOf(String s) {
            return (ImageType)Enum.valueOf(com/bumptech/glide/load/resource/bitmap/ImageHeaderParser$ImageType, s);
        }

        public static ImageType[] values() {
            return (ImageType[])$VALUES.clone();
        }

        public boolean hasAlpha() {
            return a;
        }

        static  {
            GIF = new ImageType("GIF", 0, true);
            JPEG = new ImageType("JPEG", 1, false);
            PNG_A = new ImageType("PNG_A", 2, true);
            PNG = new ImageType("PNG", 3, false);
            UNKNOWN = new ImageType("UNKNOWN", 4, false);
            $VALUES = (new ImageType[] {
                GIF, JPEG, PNG_A, PNG, UNKNOWN
            });
        }

        private ImageType(String s, int i, boolean flag) {
            super(s, i);
            a = flag;
        }
    }

    private static class a {

        private final ByteBuffer a;

        public int a() {
            return a.array().length;
        }

        public int a(int i) {
            return a.getInt(i);
        }

        public void a(ByteOrder byteorder) {
            a.order(byteorder);
        }

        public short b(int i) {
            return a.getShort(i);
        }

        public a(byte abyte0[]) {
            a = ByteBuffer.wrap(abyte0);
            a.order(ByteOrder.BIG_ENDIAN);
        }
    }

    private static class b {

        private final InputStream a;

        public int a() {
            return a.read() << 8 & 0xff00 | a.read() & 0xff;
        }

        public int a(byte abyte0[]) {
            int i = abyte0.length;
            do {
                if (i <= 0)
                    break;
                int j = a.read(abyte0, abyte0.length - i, i);
                if (j == -1)
                    break;
                i -= j;
            } while (true);
            return abyte0.length - i;
        }

        public long a(long l) {
            if (l >= 0L) goto _L2; else goto _L1
_L1:
            l = 0L;
_L4:
            return l;
_L2:
            do {
label0:
                {
                    long l2;
                    for (long l1 = l; l1 <= 0L; l1--)
                        break MISSING_BLOCK_LABEL_54;

                    l2 = a.skip(l1);
                    if (l2 <= 0L)
                        break label0;
                    l1 -= l2;
                }
            } while (true);
            if (a.read() != -1)
                break MISSING_BLOCK_LABEL_61;
            l -= l1;
            if (true) goto _L4; else goto _L3
_L3:
        }

        public short b() {
            return (short)(a.read() & 0xff);
        }

        public int c() {
            return a.read();
        }

        public b(InputStream inputstream) {
            a = inputstream;
        }
    }


    private static final byte a[];
    private static final int b[];
    private final b c;

    public ImageHeaderParser(InputStream inputstream) {
        c = new b(inputstream);
    }

    private static int a(int i, int j) {
        return i + 2 + j * 12;
    }

    private static int a(a a1) {
        i = a1.b(k);
_L2:
        return i;
        int i = "Exif\000\0".length();
        short word0 = a1.b(i);
        int j;
        int k;
        ByteOrder byteorder;
        if (word0 == 19789)
            byteorder = ByteOrder.BIG_ENDIAN;
        else
        if (word0 == 18761) {
            byteorder = ByteOrder.LITTLE_ENDIAN;
        } else {
            if (Log.isLoggable("ImageHeaderParser", 3))
                Log.d("ImageHeaderParser", (new StringBuilder()).append("Unknown endianness = ").append(word0).toString());
            byteorder = ByteOrder.BIG_ENDIAN;
        }
        a1.a(byteorder);
        j = i + a1.a(i + 4);
        word0 = a1.b(j);
        i = 0;
        while (i < word0)  {
            k = a(j, i);
            short word1 = a1.b(k);
            if (word1 == 274) {
                short word2 = a1.b(k + 2);
                if (word2 < 1 || word2 > 12) {
                    if (Log.isLoggable("ImageHeaderParser", 3))
                        Log.d("ImageHeaderParser", (new StringBuilder()).append("Got invalid format code=").append(word2).toString());
                } else {
                    int l = a1.a(k + 4);
                    if (l < 0) {
                        if (Log.isLoggable("ImageHeaderParser", 3))
                            Log.d("ImageHeaderParser", "Negative tiff component count");
                    } else {
                        if (Log.isLoggable("ImageHeaderParser", 3))
                            Log.d("ImageHeaderParser", (new StringBuilder()).append("Got tagIndex=").append(i).append(" tagType=").append(word1).append(" formatCode=").append(word2).append(" componentCount=").append(l).toString());
                        l += b[word2];
                        if (l > 4) {
                            if (Log.isLoggable("ImageHeaderParser", 3))
                                Log.d("ImageHeaderParser", (new StringBuilder()).append("Got byte count > 4, not orientation, continuing, formatCode=").append(word2).toString());
                        } else
                        if ((k += 8) < 0 || k > a1.a()) {
                            if (Log.isLoggable("ImageHeaderParser", 3))
                                Log.d("ImageHeaderParser", (new StringBuilder()).append("Illegal tagValueOffset=").append(k).append(" tagType=").append(word1).toString());
                        } else {
label0:
                            {
                                if (l >= 0 && k + l <= a1.a())
                                    break label0;
                                if (Log.isLoggable("ImageHeaderParser", 3))
                                    Log.d("ImageHeaderParser", (new StringBuilder()).append("Illegal number of bytes for TI tag data tagType=").append(word1).toString());
                            }
                        }
                    }
                }
            }
            i++;
        }
        i = -1;
        if (true) goto _L2; else goto _L1
_L1:
    }

    private static boolean a(int i) {
        boolean flag;
        if ((i & 0xffd8) == 65496 || i == 19789 || i == 18761)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private byte[] d() {
        Object obj = null;
_L2:
        short word1;
        byte abyte0[];
        short word0 = c.b();
        if (word0 != 255) {
            abyte0 = obj;
            if (Log.isLoggable("ImageHeaderParser", 3)) {
                Log.d("ImageHeaderParser", (new StringBuilder()).append("Unknown segmentId=").append(word0).toString());
                abyte0 = obj;
            }
        } else {
            word1 = c.b();
            abyte0 = obj;
            if (word1 != 218) {
label0:
                {
                    if (word1 != 217)
                        break label0;
                    abyte0 = obj;
                    if (Log.isLoggable("ImageHeaderParser", 3)) {
                        Log.d("ImageHeaderParser", "Found MARKER_EOI in exif segment");
                        abyte0 = obj;
                    }
                }
            }
        }
_L3:
        return abyte0;
        int i;
        long l;
        i = c.a() - 2;
        if (word1 == 225)
            break MISSING_BLOCK_LABEL_217;
        l = c.a(i);
        if (l == (long)i) goto _L2; else goto _L1
_L1:
        abyte0 = obj;
        if (Log.isLoggable("ImageHeaderParser", 3)) {
            Log.d("ImageHeaderParser", (new StringBuilder()).append("Unable to skip enough data, type: ").append(word1).append(", wanted to skip: ").append(i).append(", but actually skipped: ").append(l).toString());
            abyte0 = obj;
        }
          goto _L3
        abyte0 = new byte[i];
        int j = c.a(abyte0);
        if (j != i) {
            abyte0 = obj;
            if (Log.isLoggable("ImageHeaderParser", 3)) {
                Log.d("ImageHeaderParser", (new StringBuilder()).append("Unable to read segment data, type: ").append(word1).append(", length: ").append(i).append(", actually read: ").append(j).toString());
                abyte0 = obj;
            }
        }
          goto _L3
    }

    public boolean a() {
        return b().hasAlpha();
    }

    public ImageType b() {
        int i = c.a();
        ImageType imagetype;
        if (i == 65496) {
            imagetype = ImageType.JPEG;
        } else {
            i = i << 16 & 0xffff0000 | c.a() & 0xffff;
            if (i == 0x89504e47) {
                c.a(21L);
                if (c.c() >= 3)
                    imagetype = ImageType.PNG_A;
                else
                    imagetype = ImageType.PNG;
            } else
            if (i >> 8 == 0x474946)
                imagetype = ImageType.GIF;
            else
                imagetype = ImageType.UNKNOWN;
        }
        return imagetype;
    }

    public int c() {
        boolean flag = false;
        if (a(c.a())) goto _L2; else goto _L1
_L1:
        int i = -1;
_L5:
        return i;
_L2:
        int j;
        byte abyte0[] = d();
        if (abyte0 != null && abyte0.length > a.length)
            i = 1;
        else
            i = 0;
        if (i == 0) goto _L4; else goto _L3
_L3:
        j = 0;
_L6:
        if (j < a.length) {
            if (abyte0[j] == a[j])
                break MISSING_BLOCK_LABEL_95;
            i = ((flag) ? 1 : 0);
        }
_L4:
        if (i != 0)
            i = a(new a(abyte0));
        else
            i = -1;
          goto _L5
        j++;
          goto _L6
    }

    static  {
        byte abyte0[];
        b = (new int[] {
            0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 
            8, 4, 8
        });
        abyte0 = new byte[0];
        byte abyte1[] = "Exif\000\0".getBytes("UTF-8");
        abyte0 = abyte1;
_L2:
        a = abyte0;
        return;
        UnsupportedEncodingException unsupportedencodingexception;
        unsupportedencodingexception;
        if (true) goto _L2; else goto _L1
_L1:
    }
}
