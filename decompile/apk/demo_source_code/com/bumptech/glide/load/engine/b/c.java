// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.bumptech.glide.load.engine.b;

import com.bumptech.glide.load.b;
import java.util.*;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

final class c {
    private static class a {

        final Lock a;
        int b;

        private a() {
            a = new ReentrantLock();
        }

    }

    private static class b {

        private final Queue a;

        a a() {
            a a1;
            synchronized (a) {
                a1 = (a)a.poll();
            }
            obj = a1;
            if (a1 == null)
                obj = new a();
            return ((a) (obj));
            exception;
            obj;
            JVM INSTR monitorexit ;
            throw exception;
        }

        void a(a a1) {
            synchronized (a) {
                if (a.size() < 10)
                    a.offer(a1);
            }
            return;
            a1;
            queue;
            JVM INSTR monitorexit ;
            throw a1;
        }

        private b() {
            a = new ArrayDeque();
        }

    }


    private final Map a = new HashMap();
    private final b b = new b();

    c() {
    }

    void a(com.bumptech.glide.load.b b1) {
        this;
        JVM INSTR monitorenter ;
        a a2 = (a)a.get(b1);
        a a1;
        a1 = a2;
        if (a2 != null)
            break MISSING_BLOCK_LABEL_42;
        a1 = b.a();
        a.put(b1, a1);
        a1.b = a1.b + 1;
        this;
        JVM INSTR monitorexit ;
        a1.a.lock();
        return;
        b1;
        this;
        JVM INSTR monitorexit ;
        throw b1;
    }

    void b(com.bumptech.glide.load.b b1) {
        this;
        JVM INSTR monitorenter ;
        a a1 = (a)a.get(b1);
        if (a1 == null)
            break MISSING_BLOCK_LABEL_27;
        if (a1.b > 0)
            break MISSING_BLOCK_LABEL_94;
        IllegalArgumentException illegalargumentexception;
        illegalargumentexception = JVM INSTR new #57  <Class IllegalArgumentException>;
        StringBuilder stringbuilder1 = JVM INSTR new #59  <Class StringBuilder>;
        stringbuilder1.StringBuilder();
        b1 = stringbuilder1.append("Cannot release a lock that is not held, key: ").append(b1).append(", interestedThreads: ");
        int i;
        if (a1 != null)
            break MISSING_BLOCK_LABEL_86;
        i = 0;
_L1:
        illegalargumentexception.IllegalArgumentException(b1.append(i).toString());
        throw illegalargumentexception;
        b1;
        this;
        JVM INSTR monitorexit ;
        throw b1;
        i = a1.b;
          goto _L1
        i = a1.b - 1;
        a1.b = i;
        if (i != 0)
            break MISSING_BLOCK_LABEL_199;
        a a2 = (a)a.remove(b1);
        if (!a2.equals(a1)) {
            IllegalStateException illegalstateexception = JVM INSTR new #90  <Class IllegalStateException>;
            StringBuilder stringbuilder = JVM INSTR new #59  <Class StringBuilder>;
            stringbuilder.StringBuilder();
            illegalstateexception.IllegalStateException(stringbuilder.append("Removed the wrong lock, expected to remove: ").append(a1).append(", but actually removed: ").append(a2).append(", key: ").append(b1).toString());
            throw illegalstateexception;
        }
        b.a(a2);
        this;
        JVM INSTR monitorexit ;
        a1.a.unlock();
        return;
    }
}
