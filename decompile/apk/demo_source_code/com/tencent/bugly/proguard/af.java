// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.tencent.bugly.proguard;

import com.tencent.bugly.b;
import java.util.concurrent.*;

// Referenced classes of package com.tencent.bugly.proguard:
//            ag

public final class af {

    private static af a;
    private ScheduledExecutorService b;

    protected af() {
        b = null;
        b = Executors.newScheduledThreadPool(3, new ThreadFactory() {

            public final Thread newThread(Runnable runnable) {
                runnable = new Thread(runnable);
                runnable.setName("BUGLY_THREAD");
                return runnable;
            }

        }
);
        if (b == null || b.isShutdown())
            ag.d("ScheduledExecutorService is not valiable!", new Object[0]);
    }

    public static af a() {
        com/tencent/bugly/proguard/af;
        JVM INSTR monitorenter ;
        af af2;
        if (a == null) {
            af af1 = JVM INSTR new #2   <Class af>;
            af1.af();
            a = af1;
        }
        af2 = a;
        com/tencent/bugly/proguard/af;
        JVM INSTR monitorexit ;
        return af2;
        Exception exception;
        exception;
        throw exception;
    }

    public final boolean a(Runnable runnable) {
        boolean flag1 = false;
        this;
        JVM INSTR monitorenter ;
        if (c()) goto _L2; else goto _L1
_L1:
        ag.d("async handler was closed , should not post task!", new Object[0]);
        boolean flag = flag1;
_L4:
        this;
        JVM INSTR monitorexit ;
        return flag;
_L2:
        if (runnable != null)
            break MISSING_BLOCK_LABEL_51;
        ag.d("async task == null", new Object[0]);
        flag = flag1;
        continue; /* Loop/switch isn't completed */
        runnable;
        throw runnable;
        ag.c("normal task %s", new Object[] {
            runnable.getClass().getName()
        });
        b.execute(runnable);
        flag = true;
        continue; /* Loop/switch isn't completed */
        runnable;
        flag = flag1;
        if (!b.b)
            continue; /* Loop/switch isn't completed */
        runnable.printStackTrace();
        flag = flag1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public final boolean a(Runnable runnable, long l) {
        boolean flag1 = false;
        this;
        JVM INSTR monitorenter ;
        if (c()) goto _L2; else goto _L1
_L1:
        ag.d("async handler was closed , should not post task!", new Object[0]);
        boolean flag = flag1;
_L4:
        this;
        JVM INSTR monitorexit ;
        return flag;
_L2:
        if (runnable != null)
            break MISSING_BLOCK_LABEL_57;
        ag.d("async task == null", new Object[0]);
        flag = flag1;
        continue; /* Loop/switch isn't completed */
        runnable;
        throw runnable;
        if (l <= 0L)
            l = 0L;
        ag.c("delay %d task %s", new Object[] {
            Long.valueOf(l), runnable.getClass().getName()
        });
        b.schedule(runnable, l, TimeUnit.MILLISECONDS);
        flag = true;
        continue; /* Loop/switch isn't completed */
        runnable;
        flag = flag1;
        if (!b.b)
            continue; /* Loop/switch isn't completed */
        runnable.printStackTrace();
        flag = flag1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public final void b() {
        this;
        JVM INSTR monitorenter ;
        if (b != null && !b.isShutdown()) {
            ag.c("close async handler", new Object[0]);
            b.shutdownNow();
        }
        this;
        JVM INSTR monitorexit ;
        return;
        Exception exception;
        exception;
        throw exception;
    }

    public final boolean c() {
        this;
        JVM INSTR monitorenter ;
        if (b == null) goto _L2; else goto _L1
_L1:
        boolean flag = b.isShutdown();
        if (flag) goto _L2; else goto _L3
_L3:
        flag = true;
_L5:
        this;
        JVM INSTR monitorexit ;
        return flag;
_L2:
        flag = false;
        if (true) goto _L5; else goto _L4
_L4:
        Exception exception;
        exception;
        throw exception;
    }
}
