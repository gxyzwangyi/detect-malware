// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.gson.internal;

import java.io.Serializable;
import java.util.*;

public final class LinkedTreeMap extends AbstractMap
    implements Serializable {
    class a extends AbstractSet {

        final LinkedTreeMap a;

        public void clear() {
            a.clear();
        }

        public boolean contains(Object obj) {
            boolean flag;
            if ((obj instanceof java.util.Map.Entry) && a.a((java.util.Map.Entry)obj) != null)
                flag = true;
            else
                flag = false;
            return flag;
        }

        public Iterator iterator() {
            return new c(this) {

                final a a;

                public java.util.Map.Entry a() {
                    return b();
                }

                public Object next() {
                    return a();
                }

             {
                a = a1;
                a1.a. super();
            }
            }
;
        }

        public boolean remove(Object obj) {
            boolean flag = false;
            if (obj instanceof java.util.Map.Entry) goto _L2; else goto _L1
_L1:
            return flag;
_L2:
            obj = a.a((java.util.Map.Entry)obj);
            if (obj != null) {
                a.a(((d) (obj)), true);
                flag = true;
            }
            if (true) goto _L1; else goto _L3
_L3:
        }

        public int size() {
            return a.c;
        }

        a() {
            a = LinkedTreeMap.this;
            super();
        }
    }

    final class b extends AbstractSet {

        final LinkedTreeMap a;

        public void clear() {
            a.clear();
        }

        public boolean contains(Object obj) {
            return a.containsKey(obj);
        }

        public Iterator iterator() {
            return new c(this) {

                final b a;

                public Object next() {
                    return b().f;
                }

             {
                a = b1;
                b1.a. super();
            }
            }
;
        }

        public boolean remove(Object obj) {
            boolean flag;
            if (a.b(obj) != null)
                flag = true;
            else
                flag = false;
            return flag;
        }

        public int size() {
            return a.c;
        }

        b() {
            a = LinkedTreeMap.this;
            super();
        }
    }

    private abstract class c
        implements Iterator {

        d b;
        d c;
        int d;
        final LinkedTreeMap e;

        final d b() {
            d d1 = b;
            if (d1 == e.e)
                throw new NoSuchElementException();
            if (e.d != d) {
                throw new ConcurrentModificationException();
            } else {
                b = d1.d;
                c = d1;
                return d1;
            }
        }

        public final boolean hasNext() {
            boolean flag;
            if (b != e.e)
                flag = true;
            else
                flag = false;
            return flag;
        }

        public final void remove() {
            if (c == null) {
                throw new IllegalStateException();
            } else {
                e.a(c, true);
                c = null;
                d = e.d;
                return;
            }
        }

        c() {
            e = LinkedTreeMap.this;
            super();
            b = e.e.d;
            c = null;
            d = e.d;
        }
    }

    static final class d
        implements java.util.Map.Entry {

        d a;
        d b;
        d c;
        d d;
        d e;
        final Object f;
        Object g;
        int h;

        public d a() {
            d d1 = b;
            d d2 = this;
            d d3;
            for (; d1 != null; d1 = d3) {
                d3 = d1.b;
                d2 = d1;
            }

            return d2;
        }

        public d b() {
            d d1 = c;
            d d2 = this;
            d d3;
            for (; d1 != null; d1 = d3) {
                d3 = d1.c;
                d2 = d1;
            }

            return d2;
        }

        public boolean equals(Object obj) {
            boolean flag;
            boolean flag1;
            flag1 = false;
            flag = flag1;
            if (!(obj instanceof java.util.Map.Entry)) goto _L2; else goto _L1
_L1:
            obj = (java.util.Map.Entry)obj;
            if (f != null) goto _L4; else goto _L3
_L3:
            flag = flag1;
            if (((java.util.Map.Entry) (obj)).getKey() != null) goto _L2; else goto _L5
_L5:
            if (g != null) goto _L7; else goto _L6
_L6:
            flag = flag1;
            if (((java.util.Map.Entry) (obj)).getValue() != null) goto _L2; else goto _L8
_L8:
            flag = true;
_L2:
            return flag;
_L4:
            flag = flag1;
            if (!f.equals(((java.util.Map.Entry) (obj)).getKey())) goto _L2; else goto _L5
_L7:
            flag = flag1;
            if (!g.equals(((java.util.Map.Entry) (obj)).getValue())) goto _L2; else goto _L8
        }

        public Object getKey() {
            return f;
        }

        public Object getValue() {
            return g;
        }

        public int hashCode() {
            int k = 0;
            int j;
            if (f == null)
                j = 0;
            else
                j = f.hashCode();
            if (g != null)
                k = g.hashCode();
            return j ^ k;
        }

        public Object setValue(Object obj) {
            Object obj1 = g;
            g = obj;
            return obj1;
        }

        public String toString() {
            return (new StringBuilder()).append(f).append("=").append(g).toString();
        }

        d() {
            f = null;
            e = this;
            d = this;
        }

        d(d d1, Object obj, d d2, d d3) {
            a = d1;
            f = obj;
            h = 1;
            d = d2;
            e = d3;
            d3.d = this;
            d2.e = this;
        }
    }


    static final boolean f;
    private static final Comparator g = new Comparator() {

        public int a(Comparable comparable, Comparable comparable1) {
            return comparable.compareTo(comparable1);
        }

        public int compare(Object obj, Object obj1) {
            return a((Comparable)obj, (Comparable)obj1);
        }

    }
;
    Comparator a;
    d b;
    int c;
    int d;
    final d e;
    private a h;
    private b i;

    public LinkedTreeMap() {
        this(g);
    }

    public LinkedTreeMap(Comparator comparator) {
        c = 0;
        d = 0;
        e = new d();
        if (comparator == null)
            comparator = g;
        a = comparator;
    }

    private void a(d d1) {
        boolean flag = false;
        d d2 = d1.b;
        d d5 = d1.c;
        d d3 = d5.b;
        d d4 = d5.c;
        d1.c = d3;
        if (d3 != null)
            d3.a = d1;
        a(d1, d5);
        d5.b = d1;
        d1.a = d5;
        int j;
        int k;
        if (d2 != null)
            j = d2.h;
        else
            j = 0;
        if (d3 != null)
            k = d3.h;
        else
            k = 0;
        d1.h = Math.max(j, k) + 1;
        k = d1.h;
        j = ((flag) ? 1 : 0);
        if (d4 != null)
            j = d4.h;
        d5.h = Math.max(k, j) + 1;
    }

    private void a(d d1, d d2) {
        d d3 = d1.a;
        d1.a = null;
        if (d2 != null)
            d2.a = d3;
        if (d3 != null) {
            if (d3.b == d1) {
                d3.b = d2;
            } else {
                if (!f && d3.c != d1)
                    throw new AssertionError();
                d3.c = d2;
            }
        } else {
            b = d2;
        }
    }

    private boolean a(Object obj, Object obj1) {
        boolean flag;
        if (obj == obj1 || obj != null && obj.equals(obj1))
            flag = true;
        else
            flag = false;
        return flag;
    }

    private void b(d d1) {
        boolean flag = false;
        d d2 = d1.b;
        d d4 = d1.c;
        d d3 = d2.b;
        d d5 = d2.c;
        d1.b = d5;
        if (d5 != null)
            d5.a = d1;
        a(d1, d2);
        d2.c = d1;
        d1.a = d2;
        int j;
        int k;
        if (d4 != null)
            j = d4.h;
        else
            j = 0;
        if (d5 != null)
            k = d5.h;
        else
            k = 0;
        d1.h = Math.max(j, k) + 1;
        k = d1.h;
        j = ((flag) ? 1 : 0);
        if (d3 != null)
            j = d3.h;
        d2.h = Math.max(k, j) + 1;
    }

    private void b(d d1, boolean flag) {
_L8:
        if (d1 == null) goto _L2; else goto _L1
_L1:
        int j;
        int k;
        int l;
        d d2;
        d d3;
        d2 = d1.b;
        d3 = d1.c;
        d d5;
        if (d2 != null)
            j = d2.h;
        else
            j = 0;
        if (d3 != null)
            k = d3.h;
        else
            k = 0;
        l = j - k;
        if (l != -2) goto _L4; else goto _L3
_L3:
        d2 = d3.b;
        d5 = d3.c;
        if (d5 != null)
            j = d5.h;
        else
            j = 0;
        if (d2 != null)
            k = d2.h;
        else
            k = 0;
        j = k - j;
        if (j == -1 || j == 0 && !flag) {
            a(d1);
        } else {
            if (!f && j != 1)
                throw new AssertionError();
            b(d3);
            a(d1);
        }
        if (!flag) goto _L5; else goto _L2
_L2:
        return;
_L4:
        if (l != 2) goto _L7; else goto _L6
_L6:
        d d6 = d2.b;
        d d4 = d2.c;
        if (d4 != null)
            j = d4.h;
        else
            j = 0;
        if (d6 != null)
            k = d6.h;
        else
            k = 0;
        j = k - j;
        if (j == 1 || j == 0 && !flag) {
            b(d1);
        } else {
            if (!f && j != -1)
                throw new AssertionError();
            a(d2);
            b(d1);
        }
        if (flag) goto _L2; else goto _L5
_L5:
        d1 = d1.a;
          goto _L8
_L7:
label0:
        {
            if (l != 0)
                break label0;
            d1.h = j + 1;
            if (flag)
                break; /* Loop/switch isn't completed */
        }
          goto _L5
        if (!f && l != -1 && l != 1)
            throw new AssertionError();
        d1.h = Math.max(j, k) + 1;
        if (flag) goto _L5; else goto _L2
    }

    d a(Object obj) {
        Object obj1 = null;
        d d1 = obj1;
        if (obj != null)
            try {
                d1 = a(obj, false);
            }
            // Misplaced declaration of an exception variable
            catch (Object obj) {
                d1 = obj1;
            }
        return d1;
    }

    d a(Object obj, boolean flag) {
        int j;
        Object obj1;
        Object obj3;
        Comparator comparator;
        obj3 = null;
        comparator = a;
        obj1 = b;
        if (obj1 == null)
            break MISSING_BLOCK_LABEL_282;
        Comparable comparable;
        if (comparator == g)
            comparable = (Comparable)obj;
        else
            comparable = null;
_L6:
        if (comparable != null)
            j = comparable.compareTo(((d) (obj1)).f);
        else
            j = comparator.compare(obj, ((d) (obj1)).f);
        if (j != 0) goto _L2; else goto _L1
_L1:
        return ((d) (obj1));
_L2:
        Object obj2;
        if (j < 0)
            obj2 = ((d) (obj1)).b;
        else
            obj2 = ((d) (obj1)).c;
        if (obj2 != null) goto _L4; else goto _L3
_L3:
        obj2 = obj1;
_L7:
        obj1 = obj3;
        if (!flag) goto _L1; else goto _L5
_L4:
        obj1 = obj2;
          goto _L6
_L5:
        obj1 = e;
        if (obj2 == null) {
            if (comparator == g && !(obj instanceof Comparable))
                throw new ClassCastException((new StringBuilder()).append(obj.getClass().getName()).append(" is not Comparable").toString());
            obj = new d(((d) (obj2)), obj, ((d) (obj1)), ((d) (obj1)).e);
            b = ((d) (obj));
        } else {
            obj = new d(((d) (obj2)), obj, ((d) (obj1)), ((d) (obj1)).e);
            if (j < 0)
                obj2.b = ((d) (obj));
            else
                obj2.c = ((d) (obj));
            b(((d) (obj2)), true);
        }
        c = c + 1;
        d = d + 1;
        obj1 = obj;
          goto _L1
        j = 0;
        obj2 = obj1;
          goto _L7
    }

    d a(java.util.Map.Entry entry) {
        d d1 = a(entry.getKey());
        boolean flag;
        if (d1 != null && a(d1.g, entry.getValue()))
            flag = true;
        else
            flag = false;
        if (flag)
            entry = d1;
        else
            entry = null;
        return entry;
    }

    void a(d d1, boolean flag) {
label0:
        {
            {
                int k = 0;
                if (flag) {
                    d1.e.d = d1.d;
                    d1.d.e = d1.e;
                }
                d d3 = d1.b;
                d d2 = d1.c;
                d d4 = d1.a;
                if (d3 == null || d2 == null)
                    break label0;
                int j;
                if (d3.h > d2.h)
                    d2 = d3.b();
                else
                    d2 = d2.a();
                a(d2, false);
                d3 = d1.b;
                if (d3 != null) {
                    j = d3.h;
                    d2.b = d3;
                    d3.a = d2;
                    d1.b = null;
                } else {
                    j = 0;
                }
                d3 = d1.c;
                if (d3 != null) {
                    k = d3.h;
                    d2.c = d3;
                    d3.a = d2;
                    d1.c = null;
                }
                d2.h = Math.max(j, k) + 1;
                a(d1, d2);
            }
            return;
        }
        if (d3 == null)
            break; /* Loop/switch isn't completed */
        a(d1, d3);
        d1.b = null;
_L4:
        b(d4, false);
        c = c - 1;
        d = d + 1;
        if (true) goto _L2; else goto _L1
_L2:
        break MISSING_BLOCK_LABEL_177;
_L1:
        if (d2 != null) {
            a(d1, d2);
            d1.c = null;
        } else {
            a(d1, ((d) (null)));
        }
        if (true) goto _L4; else goto _L3
_L3:
        if (true) goto _L6; else goto _L5
_L6:
        break MISSING_BLOCK_LABEL_177;
_L5:
    }

    d b(Object obj) {
        obj = a(obj);
        if (obj != null)
            a(((d) (obj)), true);
        return ((d) (obj));
    }

    public void clear() {
        b = null;
        c = 0;
        d = d + 1;
        d d1 = e;
        d1.e = d1;
        d1.d = d1;
    }

    public boolean containsKey(Object obj) {
        boolean flag;
        if (a(obj) != null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public Set entrySet() {
        a a1 = h;
        if (a1 == null) {
            a1 = new a();
            h = a1;
        }
        return a1;
    }

    public Object get(Object obj) {
        obj = a(obj);
        if (obj != null)
            obj = ((d) (obj)).g;
        else
            obj = null;
        return obj;
    }

    public Set keySet() {
        b b1 = i;
        if (b1 == null) {
            b1 = new b();
            i = b1;
        }
        return b1;
    }

    public Object put(Object obj, Object obj1) {
        if (obj == null) {
            throw new NullPointerException("key == null");
        } else {
            obj = a(obj, true);
            Object obj2 = ((d) (obj)).g;
            obj.g = obj1;
            return obj2;
        }
    }

    public Object remove(Object obj) {
        obj = b(obj);
        if (obj != null)
            obj = ((d) (obj)).g;
        else
            obj = null;
        return obj;
    }

    public int size() {
        return c;
    }

    static  {
        boolean flag;
        if (!com/google/gson/internal/LinkedTreeMap.desiredAssertionStatus())
            flag = true;
        else
            flag = false;
        f = flag;
    }
}
