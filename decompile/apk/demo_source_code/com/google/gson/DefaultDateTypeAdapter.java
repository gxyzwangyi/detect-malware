// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.gson;

import com.google.gson.internal.bind.a.a;
import java.lang.reflect.Type;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

// Referenced classes of package com.google.gson:
//            i, p, j, JsonSyntaxException, 
//            n, JsonParseException, o, h

final class DefaultDateTypeAdapter
    implements i, p {

    private final DateFormat a;
    private final DateFormat b;

    DefaultDateTypeAdapter() {
        this(DateFormat.getDateTimeInstance(2, 2, Locale.US), DateFormat.getDateTimeInstance(2, 2));
    }

    public DefaultDateTypeAdapter(int k, int l) {
        this(DateFormat.getDateTimeInstance(k, l, Locale.US), DateFormat.getDateTimeInstance(k, l));
    }

    DefaultDateTypeAdapter(String s) {
        this(((DateFormat) (new SimpleDateFormat(s, Locale.US))), ((DateFormat) (new SimpleDateFormat(s))));
    }

    DefaultDateTypeAdapter(DateFormat dateformat, DateFormat dateformat1) {
        a = dateformat;
        b = dateformat1;
    }

    private Date a(j j1) {
        DateFormat dateformat = b;
        dateformat;
        JVM INSTR monitorenter ;
        Object obj = b.parse(j1.b());
        j1 = ((j) (obj));
        dateformat;
        JVM INSTR monitorexit ;
_L2:
        return j1;
        ParseException parseexception;
        parseexception;
        parseexception = a.parse(j1.b());
        j1 = parseexception;
        dateformat;
        JVM INSTR monitorexit ;
        continue; /* Loop/switch isn't completed */
        j1;
        dateformat;
        JVM INSTR monitorexit ;
        throw j1;
        parseexception;
        String s = j1.b();
        parseexception = JVM INSTR new #62  <Class ParsePosition>;
        parseexception.ParsePosition(0);
        parseexception = com.google.gson.internal.bind.a.a.a(s, parseexception);
        j1 = parseexception;
        dateformat;
        JVM INSTR monitorexit ;
        if (true) goto _L2; else goto _L1
_L1:
        ParseException parseexception1;
        parseexception1;
        JsonSyntaxException jsonsyntaxexception = JVM INSTR new #72  <Class JsonSyntaxException>;
        jsonsyntaxexception.JsonSyntaxException(j1.b(), parseexception1);
        throw jsonsyntaxexception;
    }

    public volatile j a(Object obj, Type type, o o) {
        return a((Date)obj, type, o);
    }

    public j a(Date date, Type type, o o) {
        synchronized (b) {
            date = a.format(date);
            o = JVM INSTR new #87  <Class n>;
            o.n(date);
        }
        return o;
        date;
        type;
        JVM INSTR monitorexit ;
        throw date;
    }

    public Date a(j j1, Type type, h h) {
        if (!(j1 instanceof n))
            throw new JsonParseException("The date should be a string value");
        j1 = a(j1);
        if (type != java/util/Date)
            if (type == java/sql/Timestamp)
                j1 = new Timestamp(j1.getTime());
            else
            if (type == java/sql/Date)
                j1 = new java.sql.Date(j1.getTime());
            else
                throw new IllegalArgumentException((new StringBuilder()).append(getClass()).append(" cannot deserialize to ").append(type).toString());
        return j1;
    }

    public Object b(j j1, Type type, h h) {
        return a(j1, type, h);
    }

    public String toString() {
        StringBuilder stringbuilder = new StringBuilder();
        stringbuilder.append(com/google/gson/DefaultDateTypeAdapter.getSimpleName());
        stringbuilder.append('(').append(b.getClass().getSimpleName()).append(')');
        return stringbuilder.toString();
    }
}
