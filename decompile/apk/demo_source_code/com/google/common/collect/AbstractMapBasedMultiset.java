// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.common.collect;

import com.google.common.b.a;
import com.google.common.base.i;
import java.io.Serializable;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

// Referenced classes of package com.google.common.collect:
//            d, Count, Maps, g

abstract class AbstractMapBasedMultiset extends d
    implements Serializable {
    private class a
        implements Iterator {

        final Iterator a;
        java.util.Map.Entry b;
        int c;
        boolean d;
        final AbstractMapBasedMultiset e;

        public boolean hasNext() {
            boolean flag;
            if (c > 0 || a.hasNext())
                flag = true;
            else
                flag = false;
            return flag;
        }

        public Object next() {
            if (c == 0) {
                b = (java.util.Map.Entry)a.next();
                c = ((Count)b.getValue()).a();
            }
            c = c - 1;
            d = true;
            return b.getKey();
        }

        public void remove() {
            com.google.common.collect.g.a(d);
            if (((Count)b.getValue()).a() <= 0)
                throw new ConcurrentModificationException();
            if (((Count)b.getValue()).b(-1) == 0)
                a.remove();
            AbstractMapBasedMultiset.b(e);
            d = false;
        }

        a() {
            e = AbstractMapBasedMultiset.this;
            super();
            a = com.google.common.collect.AbstractMapBasedMultiset.a(AbstractMapBasedMultiset.this).entrySet().iterator();
        }
    }


    private transient Map a;
    private transient long b;

    protected AbstractMapBasedMultiset(Map map) {
        a = (Map)i.a(map);
        b = super.size();
    }

    private static int a(Count count, int j) {
        if (count == null)
            j = 0;
        else
            j = count.d(j);
        return j;
    }

    static long a(AbstractMapBasedMultiset abstractmapbasedmultiset, long l) {
        l = abstractmapbasedmultiset.b - l;
        abstractmapbasedmultiset.b = l;
        return l;
    }

    static Map a(AbstractMapBasedMultiset abstractmapbasedmultiset) {
        return abstractmapbasedmultiset.a;
    }

    static long b(AbstractMapBasedMultiset abstractmapbasedmultiset) {
        long l = abstractmapbasedmultiset.b;
        abstractmapbasedmultiset.b = l - 1L;
        return l;
    }

    public int a(Object obj) {
        obj = (Count)com.google.common.collect.Maps.a(a, obj);
        int j;
        if (obj == null)
            j = 0;
        else
            j = ((Count) (obj)).a();
        return j;
    }

    public int a(Object obj, int j) {
        int k = 0;
        if (j != 0) goto _L2; else goto _L1
_L1:
        k = a(obj);
_L4:
        return k;
_L2:
        Count count;
        boolean flag;
        if (j > 0)
            flag = true;
        else
            flag = false;
        i.a(flag, "occurrences cannot be negative: %s", new Object[] {
            Integer.valueOf(j)
        });
        count = (Count)a.get(obj);
        if (count != null)
            break; /* Loop/switch isn't completed */
        a.put(obj, new Count(j));
_L5:
        b = b + (long)j;
        if (true) goto _L4; else goto _L3
_L3:
        k = count.a();
        long l = (long)k + (long)j;
        boolean flag1;
        if (l <= 0x7fffffffL)
            flag1 = true;
        else
            flag1 = false;
        i.a(flag1, "too many occurrences: %s", new Object[] {
            Long.valueOf(l)
        });
        count.a(j);
          goto _L5
        if (true) goto _L4; else goto _L6
_L6:
    }

    public Set a() {
        return super.a();
    }

    public int b(Object obj, int j) {
        int k = 0;
        if (j != 0) goto _L2; else goto _L1
_L1:
        k = a(obj);
_L4:
        return k;
_L2:
        boolean flag;
        Count count;
        if (j > 0)
            flag = true;
        else
            flag = false;
        i.a(flag, "occurrences cannot be negative: %s", new Object[] {
            Integer.valueOf(j)
        });
        count = (Count)a.get(obj);
        if (count != null) {
            k = count.a();
            if (k <= j) {
                a.remove(obj);
                j = k;
            }
            count.b(-j);
            b = b - (long)j;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    Iterator b() {
        return new Iterator(a.entrySet().iterator()) {

            java.util.Map.Entry a;
            final Iterator b;
            final AbstractMapBasedMultiset c;

            public n.a a() {
                java.util.Map.Entry entry = (java.util.Map.Entry)b.next();
                a = entry;
                return new Multisets.a(this, entry) {

                    final java.util.Map.Entry a;
                    final _cls1 b;

                    public Object a() {
                        return a.getKey();
                    }

                    public int b() {
                        Count count1 = (Count)a.getValue();
                        if (count1 != null && count1.a() != 0) goto _L2; else goto _L1
_L1:
                        Count count = (Count)com.google.common.collect.AbstractMapBasedMultiset.a(b.c).get(a());
                        if (count == null) goto _L2; else goto _L3
_L3:
                        int j = count.a();
_L5:
                        return j;
_L2:
                        if (count1 == null)
                            j = 0;
                        else
                            j = count1.a();
                        if (true) goto _L5; else goto _L4
_L4:
                    }

             {
                b = _pcls1;
                a = entry;
                super();
            }
                }
;
            }

            public boolean hasNext() {
                return b.hasNext();
            }

            public Object next() {
                return a();
            }

            public void remove() {
                boolean flag;
                if (a != null)
                    flag = true;
                else
                    flag = false;
                com.google.common.collect.g.a(flag);
                com.google.common.collect.AbstractMapBasedMultiset.a(c, ((Count)a.getValue()).d(0));
                b.remove();
                a = null;
            }

             {
                c = AbstractMapBasedMultiset.this;
                b = iterator1;
                super();
            }
        }
;
    }

    int c() {
        return a.size();
    }

    public int c(Object obj, int j) {
        com.google.common.collect.g.a(j, "count");
        if (j != 0) goto _L2; else goto _L1
_L1:
        int k = a((Count)a.remove(obj), j);
_L4:
        b = b + (long)(j - k);
        return k;
_L2:
        Count count = (Count)a.get(obj);
        k = a(count, j);
        if (count == null)
            a.put(obj, new Count(j));
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void clear() {
        for (Iterator iterator1 = a.values().iterator(); iterator1.hasNext(); ((Count)iterator1.next()).c(0));
        a.clear();
        b = 0L;
    }

    public Iterator iterator() {
        return new a();
    }

    public int size() {
        return com.google.common.b.a.a(b);
    }
}
