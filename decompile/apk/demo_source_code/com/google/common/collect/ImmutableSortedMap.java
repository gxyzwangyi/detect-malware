// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.common.collect;

import com.google.common.base.i;
import java.util.*;

// Referenced classes of package com.google.common.collect:
//            ImmutableSortedMapFauxverideShim, p, ImmutableSortedSet, ImmutableList, 
//            RegularImmutableSortedSet, Maps, ImmutableSet, ImmutableCollection, 
//            ImmutableMapEntrySet, ImmutableMap, z, ImmutableAsList

public final class ImmutableSortedMap extends ImmutableSortedMapFauxverideShim
    implements NavigableMap {

    private static final Comparator b = p.b();
    private static final ImmutableSortedMap c = new ImmutableSortedMap(ImmutableSortedSet.a(p.b()), ImmutableList.c());
    private final transient RegularImmutableSortedSet d;
    private final transient ImmutableList e;
    private transient ImmutableSortedMap f;

    ImmutableSortedMap(RegularImmutableSortedSet regularimmutablesortedset, ImmutableList immutablelist) {
        this(regularimmutablesortedset, immutablelist, null);
    }

    ImmutableSortedMap(RegularImmutableSortedSet regularimmutablesortedset, ImmutableList immutablelist, ImmutableSortedMap immutablesortedmap) {
        d = regularimmutablesortedset;
        e = immutablelist;
        f = immutablesortedmap;
    }

    private ImmutableSortedMap a(int j, int k) {
        ImmutableSortedMap immutablesortedmap;
        if (j == 0 && k == size())
            immutablesortedmap = this;
        else
        if (j == k)
            immutablesortedmap = a(comparator());
        else
            immutablesortedmap = new ImmutableSortedMap(d.a(j, k), e.a(j, k));
        return immutablesortedmap;
    }

    static ImmutableSortedMap a(Comparator comparator1) {
        if (p.b().equals(comparator1))
            comparator1 = b();
        else
            comparator1 = new ImmutableSortedMap(ImmutableSortedSet.a(comparator1), ImmutableList.c());
        return comparator1;
    }

    static RegularImmutableSortedSet a(ImmutableSortedMap immutablesortedmap) {
        return immutablesortedmap.d;
    }

    static ImmutableList b(ImmutableSortedMap immutablesortedmap) {
        return immutablesortedmap.e;
    }

    public static ImmutableSortedMap b() {
        return c;
    }

    public ImmutableSortedMap a(Object obj) {
        return a(obj, false);
    }

    public ImmutableSortedMap a(Object obj, Object obj1) {
        return a(obj, true, obj1, false);
    }

    public ImmutableSortedMap a(Object obj, boolean flag) {
        return a(0, d.e(com.google.common.base.i.a(obj), flag));
    }

    public ImmutableSortedMap a(Object obj, boolean flag, Object obj1, boolean flag1) {
        com.google.common.base.i.a(obj);
        com.google.common.base.i.a(obj1);
        boolean flag2;
        if (comparator().compare(obj, obj1) <= 0)
            flag2 = true;
        else
            flag2 = false;
        com.google.common.base.i.a(flag2, "expected fromKey <= toKey but %s > %s", new Object[] {
            obj, obj1
        });
        return a(obj1, flag1).b(obj, flag);
    }

    public ImmutableSortedMap b(Object obj) {
        return b(obj, true);
    }

    public ImmutableSortedMap b(Object obj, boolean flag) {
        return a(d.f(com.google.common.base.i.a(obj), flag), size());
    }

    boolean c() {
        boolean flag;
        if (d.e() || e.e())
            flag = true;
        else
            flag = false;
        return flag;
    }

    public java.util.Map.Entry ceilingEntry(Object obj) {
        return b(obj, true).firstEntry();
    }

    public Object ceilingKey(Object obj) {
        return Maps.b(ceilingEntry(obj));
    }

    public Comparator comparator() {
        return l().comparator();
    }

    public ImmutableCollection d() {
        return e;
    }

    public NavigableSet descendingKeySet() {
        return o();
    }

    public NavigableMap descendingMap() {
        return m();
    }

    public Set entrySet() {
        return g();
    }

    public java.util.Map.Entry firstEntry() {
        java.util.Map.Entry entry;
        if (isEmpty())
            entry = null;
        else
            entry = (java.util.Map.Entry)g().f().get(0);
        return entry;
    }

    public Object firstKey() {
        return l().first();
    }

    public java.util.Map.Entry floorEntry(Object obj) {
        return a(obj, true).lastEntry();
    }

    public Object floorKey(Object obj) {
        return Maps.b(floorEntry(obj));
    }

    public ImmutableSet g() {
        return super.g();
    }

    public Object get(Object obj) {
        int j = d.a(obj);
        if (j == -1)
            obj = null;
        else
            obj = e.get(j);
        return obj;
    }

    ImmutableSet h() {
        class _cls1EntrySet extends ImmutableMapEntrySet {

            final ImmutableSortedMap a;

            ImmutableMap c() {
                return a;
            }

            public z d_() {
                return f().d_();
            }

            ImmutableList g() {
                return new ImmutableAsList(this) {

                    final _cls1EntrySet a;

                    ImmutableCollection b() {
                        return a;
                    }

                    public java.util.Map.Entry b(int j) {
                        return Maps.a(ImmutableSortedMap.a(a.a).f().get(j), ImmutableSortedMap.b(a.a).get(j));
                    }

                    public Object get(int j) {
                        return b(j);
                    }

             {
                a = _pcls1entryset;
                super();
            }
                }
;
            }

            public Iterator iterator() {
                return d_();
            }

            _cls1EntrySet() {
                a = ImmutableSortedMap.this;
                super();
            }
        }

        Object obj;
        if (isEmpty())
            obj = ImmutableSet.h();
        else
            obj = new _cls1EntrySet();
        return ((ImmutableSet) (obj));
    }

    public NavigableMap headMap(Object obj, boolean flag) {
        return a(obj, flag);
    }

    public SortedMap headMap(Object obj) {
        return a(obj);
    }

    public java.util.Map.Entry higherEntry(Object obj) {
        return b(obj, false).firstEntry();
    }

    public Object higherKey(Object obj) {
        return Maps.b(higherEntry(obj));
    }

    public ImmutableSet i() {
        return l();
    }

    public Set keySet() {
        return l();
    }

    public ImmutableSortedSet l() {
        return d;
    }

    public java.util.Map.Entry lastEntry() {
        java.util.Map.Entry entry;
        if (isEmpty())
            entry = null;
        else
            entry = (java.util.Map.Entry)g().f().get(size() - 1);
        return entry;
    }

    public Object lastKey() {
        return l().last();
    }

    public java.util.Map.Entry lowerEntry(Object obj) {
        return a(obj, false).lastEntry();
    }

    public Object lowerKey(Object obj) {
        return Maps.b(lowerEntry(obj));
    }

    public ImmutableSortedMap m() {
        ImmutableSortedMap immutablesortedmap1 = f;
        ImmutableSortedMap immutablesortedmap = immutablesortedmap1;
        if (immutablesortedmap1 == null)
            if (isEmpty())
                immutablesortedmap = a(p.a(comparator()).a());
            else
                immutablesortedmap = new ImmutableSortedMap((RegularImmutableSortedSet)d.b(), e.h(), this);
        return immutablesortedmap;
    }

    public ImmutableSortedSet n() {
        return d;
    }

    public NavigableSet navigableKeySet() {
        return n();
    }

    public ImmutableSortedSet o() {
        return d.b();
    }

    public final java.util.Map.Entry pollFirstEntry() {
        throw new UnsupportedOperationException();
    }

    public final java.util.Map.Entry pollLastEntry() {
        throw new UnsupportedOperationException();
    }

    public int size() {
        return e.size();
    }

    public NavigableMap subMap(Object obj, boolean flag, Object obj1, boolean flag1) {
        return a(obj, flag, obj1, flag1);
    }

    public SortedMap subMap(Object obj, Object obj1) {
        return a(obj, obj1);
    }

    public NavigableMap tailMap(Object obj, boolean flag) {
        return b(obj, flag);
    }

    public SortedMap tailMap(Object obj) {
        return b(obj);
    }

    public Collection values() {
        return d();
    }

}
