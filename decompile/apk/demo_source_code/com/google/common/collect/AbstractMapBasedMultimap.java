// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.common.collect;

import com.google.common.base.i;
import java.io.Serializable;
import java.util.*;

// Referenced classes of package com.google.common.collect:
//            c, Maps, k, h, 
//            g, t

abstract class AbstractMapBasedMultimap extends com.google.common.collect.c
    implements Serializable {
    private class a extends Maps.i {

        final transient Map a;
        final AbstractMapBasedMultimap b;

        public Collection a(Object obj) {
            Collection collection = (Collection)Maps.a(a, obj);
            if (collection == null)
                obj = null;
            else
                obj = b.a(obj, collection);
            return ((Collection) (obj));
        }

        java.util.Map.Entry a(java.util.Map.Entry entry) {
            Object obj = entry.getKey();
            return Maps.a(obj, b.a(obj, (Collection)entry.getValue()));
        }

        protected Set a() {
            return new a(this);
        }

        public Collection b(Object obj) {
            Collection collection = (Collection)a.remove(obj);
            if (collection == null) {
                obj = null;
            } else {
                obj = b.c();
                ((Collection) (obj)).addAll(collection);
                AbstractMapBasedMultimap.b(b, collection.size());
                collection.clear();
            }
            return ((Collection) (obj));
        }

        public void clear() {
            if (a == AbstractMapBasedMultimap.a(b))
                b.e();
            else
                k.c(new b(this));
        }

        public boolean containsKey(Object obj) {
            return Maps.b(a, obj);
        }

        public boolean equals(Object obj) {
            boolean flag;
            if (this == obj || a.equals(obj))
                flag = true;
            else
                flag = false;
            return flag;
        }

        public Object get(Object obj) {
            return a(obj);
        }

        public int hashCode() {
            return a.hashCode();
        }

        public Set keySet() {
            return b.l();
        }

        public Object remove(Object obj) {
            return b(obj);
        }

        public int size() {
            return a.size();
        }

        public String toString() {
            return a.toString();
        }

        a(Map map) {
            b = AbstractMapBasedMultimap.this;
            super();
            a = map;
        }
    }

    class a.a extends Maps.a {

        final a a;

        Map a() {
            return a;
        }

        public boolean contains(Object obj) {
            return com.google.common.collect.h.a(a.a.entrySet(), obj);
        }

        public Iterator iterator() {
            return new a.b(a);
        }

        public boolean remove(Object obj) {
            boolean flag;
            if (!contains(obj)) {
                flag = false;
            } else {
                obj = (java.util.Map.Entry)obj;
                AbstractMapBasedMultimap.a(a.b, ((java.util.Map.Entry) (obj)).getKey());
                flag = true;
            }
            return flag;
        }

        a.a(a a1) {
            a = a1;
            super();
        }
    }

    class a.b
        implements Iterator {

        final Iterator a;
        Collection b;
        final a c;

        public java.util.Map.Entry a() {
            java.util.Map.Entry entry = (java.util.Map.Entry)a.next();
            b = (Collection)entry.getValue();
            return c.a(entry);
        }

        public boolean hasNext() {
            return a.hasNext();
        }

        public Object next() {
            return a();
        }

        public void remove() {
            a.remove();
            AbstractMapBasedMultimap.b(c.b, b.size());
            b.clear();
        }

        a.b(a a1) {
            c = a1;
            super();
            a = c.a.entrySet().iterator();
        }
    }

    private abstract class b
        implements Iterator {

        final Iterator b;
        Object c;
        Collection d;
        Iterator e;
        final AbstractMapBasedMultimap f;

        abstract Object b(Object obj, Object obj1);

        public boolean hasNext() {
            boolean flag;
            if (b.hasNext() || e.hasNext())
                flag = true;
            else
                flag = false;
            return flag;
        }

        public Object next() {
            if (!e.hasNext()) {
                java.util.Map.Entry entry = (java.util.Map.Entry)b.next();
                c = entry.getKey();
                d = (Collection)entry.getValue();
                e = d.iterator();
            }
            return b(c, e.next());
        }

        public void remove() {
            e.remove();
            if (d.isEmpty())
                b.remove();
            AbstractMapBasedMultimap.b(f);
        }

        b() {
            f = AbstractMapBasedMultimap.this;
            super();
            b = AbstractMapBasedMultimap.a(AbstractMapBasedMultimap.this).entrySet().iterator();
            c = null;
            d = null;
            e = k.c();
        }
    }

    private class c extends Maps.d {

        final AbstractMapBasedMultimap a;

        public void clear() {
            k.c(iterator());
        }

        public boolean containsAll(Collection collection) {
            return b().keySet().containsAll(collection);
        }

        public boolean equals(Object obj) {
            boolean flag;
            if (this == obj || b().keySet().equals(obj))
                flag = true;
            else
                flag = false;
            return flag;
        }

        public int hashCode() {
            return b().keySet().hashCode();
        }

        public Iterator iterator() {
            return new Iterator(this, b().entrySet().iterator()) {

                java.util.Map.Entry a;
                final Iterator b;
                final c c;

                public boolean hasNext() {
                    return b.hasNext();
                }

                public Object next() {
                    a = (java.util.Map.Entry)b.next();
                    return a.getKey();
                }

                public void remove() {
                    boolean flag;
                    Collection collection;
                    if (a != null)
                        flag = true;
                    else
                        flag = false;
                    com.google.common.collect.g.a(flag);
                    collection = (Collection)a.getValue();
                    b.remove();
                    AbstractMapBasedMultimap.b(c.a, collection.size());
                    collection.clear();
                }

             {
                c = c1;
                b = iterator;
                super();
            }
            }
;
        }

        public boolean remove(Object obj) {
            obj = (Collection)b().remove(obj);
            int l;
            boolean flag;
            if (obj != null) {
                l = ((Collection) (obj)).size();
                ((Collection) (obj)).clear();
                AbstractMapBasedMultimap.b(a, l);
            } else {
                l = 0;
            }
            if (l > 0)
                flag = true;
            else
                flag = false;
            return flag;
        }

        c(Map map) {
            a = AbstractMapBasedMultimap.this;
            super(map);
        }
    }

    private class d extends h
        implements RandomAccess {

        final AbstractMapBasedMultimap a;

        d(Object obj, List list, g g1) {
            a = AbstractMapBasedMultimap.this;
            super(obj, list, g1);
        }
    }

    private class e extends a
        implements SortedMap {

        SortedSet c;
        final AbstractMapBasedMultimap d;

        SortedMap b() {
            return (SortedMap)a;
        }

        public SortedSet c() {
            SortedSet sortedset1 = c;
            SortedSet sortedset = sortedset1;
            if (sortedset1 == null) {
                sortedset = d();
                c = sortedset;
            }
            return sortedset;
        }

        public Comparator comparator() {
            return b().comparator();
        }

        SortedSet d() {
            return d. new f(b());
        }

        Set e() {
            return d();
        }

        public Object firstKey() {
            return b().firstKey();
        }

        public SortedMap headMap(Object obj) {
            return d. new e(b().headMap(obj));
        }

        public Set keySet() {
            return c();
        }

        public Object lastKey() {
            return b().lastKey();
        }

        public SortedMap subMap(Object obj, Object obj1) {
            return d. new e(b().subMap(obj, obj1));
        }

        public SortedMap tailMap(Object obj) {
            return d. new e(b().tailMap(obj));
        }

        e(SortedMap sortedmap) {
            d = AbstractMapBasedMultimap.this;
            super(sortedmap);
        }
    }

    private class f extends c
        implements SortedSet {

        final AbstractMapBasedMultimap b;

        SortedMap a() {
            return (SortedMap)super.b();
        }

        public Comparator comparator() {
            return a().comparator();
        }

        public Object first() {
            return a().firstKey();
        }

        public SortedSet headSet(Object obj) {
            return b. new f(a().headMap(obj));
        }

        public Object last() {
            return a().lastKey();
        }

        public SortedSet subSet(Object obj, Object obj1) {
            return b. new f(a().subMap(obj, obj1));
        }

        public SortedSet tailSet(Object obj) {
            return b. new f(a().tailMap(obj));
        }

        f(SortedMap sortedmap) {
            b = AbstractMapBasedMultimap.this;
            super(sortedmap);
        }
    }

    private class g extends AbstractCollection {

        final Object b;
        Collection c;
        final g d;
        final Collection e;
        final AbstractMapBasedMultimap f;

        void a() {
            if (d != null) {
                d.a();
                if (d.e() != e)
                    throw new ConcurrentModificationException();
            } else
            if (c.isEmpty()) {
                Collection collection = (Collection)AbstractMapBasedMultimap.a(f).get(b);
                if (collection != null)
                    c = collection;
            }
        }

        public boolean add(Object obj) {
            a();
            boolean flag = c.isEmpty();
            boolean flag1 = c.add(obj);
            if (flag1) {
                AbstractMapBasedMultimap.c(f);
                if (flag)
                    d();
            }
            return flag1;
        }

        public boolean addAll(Collection collection) {
            if (!collection.isEmpty()) goto _L2; else goto _L1
_L1:
            boolean flag = false;
_L4:
            return flag;
_L2:
            int l = size();
            boolean flag1 = c.addAll(collection);
            flag = flag1;
            if (flag1) {
                int k = c.size();
                AbstractMapBasedMultimap.a(f, k - l);
                flag = flag1;
                if (l == 0) {
                    d();
                    flag = flag1;
                }
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        void b() {
            if (d == null) goto _L2; else goto _L1
_L1:
            d.b();
_L4:
            return;
_L2:
            if (c.isEmpty())
                AbstractMapBasedMultimap.a(f).remove(b);
            if (true) goto _L4; else goto _L3
_L3:
        }

        Object c() {
            return b;
        }

        public void clear() {
            int k = size();
            if (k != 0) {
                c.clear();
                AbstractMapBasedMultimap.b(f, k);
                b();
            }
        }

        public boolean contains(Object obj) {
            a();
            return c.contains(obj);
        }

        public boolean containsAll(Collection collection) {
            a();
            return c.containsAll(collection);
        }

        void d() {
            if (d != null)
                d.d();
            else
                AbstractMapBasedMultimap.a(f).put(b, c);
        }

        Collection e() {
            return c;
        }

        public boolean equals(Object obj) {
            boolean flag;
            if (obj == this) {
                flag = true;
            } else {
                a();
                flag = c.equals(obj);
            }
            return flag;
        }

        g f() {
            return d;
        }

        public int hashCode() {
            a();
            return c.hashCode();
        }

        public Iterator iterator() {
            a();
            return new a(this);
        }

        public boolean remove(Object obj) {
            a();
            boolean flag = c.remove(obj);
            if (flag) {
                AbstractMapBasedMultimap.b(f);
                b();
            }
            return flag;
        }

        public boolean removeAll(Collection collection) {
            if (!collection.isEmpty()) goto _L2; else goto _L1
_L1:
            boolean flag = false;
_L4:
            return flag;
_L2:
            int k = size();
            boolean flag1 = c.removeAll(collection);
            flag = flag1;
            if (flag1) {
                int l = c.size();
                AbstractMapBasedMultimap.a(f, l - k);
                b();
                flag = flag1;
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        public boolean retainAll(Collection collection) {
            com.google.common.base.i.a(collection);
            int k = size();
            boolean flag = c.retainAll(collection);
            if (flag) {
                int l = c.size();
                AbstractMapBasedMultimap.a(f, l - k);
                b();
            }
            return flag;
        }

        public int size() {
            a();
            return c.size();
        }

        public String toString() {
            a();
            return c.toString();
        }

        g(Object obj, Collection collection, g g1) {
            f = AbstractMapBasedMultimap.this;
            super();
            b = obj;
            c = collection;
            d = g1;
            if (g1 == null)
                abstractmapbasedmultimap = null;
            else
                abstractmapbasedmultimap = g1.e();
            e = AbstractMapBasedMultimap.this;
        }
    }

    class g.a
        implements Iterator {

        final Iterator a;
        final Collection b;
        final g c;

        void a() {
            c.a();
            if (c.c != b)
                throw new ConcurrentModificationException();
            else
                return;
        }

        Iterator b() {
            a();
            return a;
        }

        public boolean hasNext() {
            a();
            return a.hasNext();
        }

        public Object next() {
            a();
            return a.next();
        }

        public void remove() {
            a.remove();
            AbstractMapBasedMultimap.b(c.f);
            c.b();
        }

        g.a(g g1) {
            c = g1;
            super();
            b = c.c;
            a = AbstractMapBasedMultimap.a(g1.f, g1.c);
        }

        g.a(g g1, Iterator iterator) {
            c = g1;
            super();
            b = c.c;
            a = iterator;
        }
    }

    private class h extends g
        implements List {

        final AbstractMapBasedMultimap g;

        public void add(int k, Object obj) {
            a();
            boolean flag = e().isEmpty();
            g().add(k, obj);
            AbstractMapBasedMultimap.c(g);
            if (flag)
                d();
        }

        public boolean addAll(int k, Collection collection) {
            if (!collection.isEmpty()) goto _L2; else goto _L1
_L1:
            boolean flag = false;
_L4:
            return flag;
_L2:
            int l = size();
            boolean flag1 = g().addAll(k, collection);
            flag = flag1;
            if (flag1) {
                k = e().size();
                AbstractMapBasedMultimap.a(g, k - l);
                flag = flag1;
                if (l == 0) {
                    d();
                    flag = flag1;
                }
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        List g() {
            return (List)e();
        }

        public Object get(int k) {
            a();
            return g().get(k);
        }

        public int indexOf(Object obj) {
            a();
            return g().indexOf(obj);
        }

        public int lastIndexOf(Object obj) {
            a();
            return g().lastIndexOf(obj);
        }

        public ListIterator listIterator() {
            a();
            return new a(this);
        }

        public ListIterator listIterator(int k) {
            a();
            return new a(this, k);
        }

        public Object remove(int k) {
            a();
            Object obj = g().remove(k);
            AbstractMapBasedMultimap.b(g);
            b();
            return obj;
        }

        public Object set(int k, Object obj) {
            a();
            return g().set(k, obj);
        }

        public List subList(int k, int l) {
            a();
            AbstractMapBasedMultimap abstractmapbasedmultimap = g;
            Object obj1 = c();
            List list = g().subList(k, l);
            Object obj;
            if (f() == null)
                obj = this;
            else
                obj = f();
            return AbstractMapBasedMultimap.a(abstractmapbasedmultimap, obj1, list, ((g) (obj)));
        }

        h(Object obj, List list, g g1) {
            g = AbstractMapBasedMultimap.this;
            super(obj, list, g1);
        }
    }

    private class h.a extends g.a
        implements ListIterator {

        final h d;

        private ListIterator c() {
            return (ListIterator)b();
        }

        public void add(Object obj) {
            boolean flag = d.isEmpty();
            c().add(obj);
            AbstractMapBasedMultimap.c(d.g);
            if (flag)
                d.d();
        }

        public boolean hasPrevious() {
            return c().hasPrevious();
        }

        public int nextIndex() {
            return c().nextIndex();
        }

        public Object previous() {
            return c().previous();
        }

        public int previousIndex() {
            return c().previousIndex();
        }

        public void set(Object obj) {
            c().set(obj);
        }

        h.a(h h1) {
            d = h1;
            super(h1);
        }

        public h.a(h h1, int k) {
            d = h1;
            super(h1, h1.g().listIterator(k));
        }
    }

    private class i extends g
        implements Set {

        final AbstractMapBasedMultimap a;

        public boolean removeAll(Collection collection) {
            if (!collection.isEmpty()) goto _L2; else goto _L1
_L1:
            boolean flag = false;
_L4:
            return flag;
_L2:
            int k = size();
            boolean flag1 = t.a((Set)c, collection);
            flag = flag1;
            if (flag1) {
                int l = c.size();
                AbstractMapBasedMultimap.a(a, l - k);
                b();
                flag = flag1;
            }
            if (true) goto _L4; else goto _L3
_L3:
        }

        i(Object obj, Set set) {
            a = AbstractMapBasedMultimap.this;
            super(obj, set, null);
        }
    }

    private class j extends g
        implements SortedSet {

        final AbstractMapBasedMultimap a;

        public Comparator comparator() {
            return g().comparator();
        }

        public Object first() {
            a();
            return g().first();
        }

        SortedSet g() {
            return (SortedSet)e();
        }

        public SortedSet headSet(Object obj) {
            a();
            AbstractMapBasedMultimap abstractmapbasedmultimap = a;
            Object obj1 = c();
            SortedSet sortedset = g().headSet(obj);
            if (f() == null)
                obj = this;
            else
                obj = f();
            return abstractmapbasedmultimap. new j(obj1, sortedset, ((g) (obj)));
        }

        public Object last() {
            a();
            return g().last();
        }

        public SortedSet subSet(Object obj, Object obj1) {
            a();
            AbstractMapBasedMultimap abstractmapbasedmultimap = a;
            Object obj2 = c();
            obj1 = g().subSet(obj, obj1);
            if (f() == null)
                obj = this;
            else
                obj = f();
            return abstractmapbasedmultimap. new j(obj2, ((SortedSet) (obj1)), ((g) (obj)));
        }

        public SortedSet tailSet(Object obj) {
            a();
            AbstractMapBasedMultimap abstractmapbasedmultimap = a;
            Object obj1 = c();
            SortedSet sortedset = g().tailSet(obj);
            if (f() == null)
                obj = this;
            else
                obj = f();
            return abstractmapbasedmultimap. new j(obj1, sortedset, ((g) (obj)));
        }

        j(Object obj, SortedSet sortedset, g g1) {
            a = AbstractMapBasedMultimap.this;
            super(obj, sortedset, g1);
        }
    }


    private transient Map a;
    private transient int b;

    protected AbstractMapBasedMultimap(Map map) {
        com.google.common.base.i.a(map.isEmpty());
        a = map;
    }

    static int a(AbstractMapBasedMultimap abstractmapbasedmultimap, int k) {
        k = abstractmapbasedmultimap.b + k;
        abstractmapbasedmultimap.b = k;
        return k;
    }

    static int a(AbstractMapBasedMultimap abstractmapbasedmultimap, Object obj) {
        return abstractmapbasedmultimap.a(obj);
    }

    private int a(Object obj) {
        obj = (Collection)Maps.c(a, obj);
        int k = 0;
        if (obj != null) {
            k = ((Collection) (obj)).size();
            ((Collection) (obj)).clear();
            b = b - k;
        }
        return k;
    }

    static Iterator a(AbstractMapBasedMultimap abstractmapbasedmultimap, Collection collection) {
        return abstractmapbasedmultimap.a(collection);
    }

    private Iterator a(Collection collection) {
        if (collection instanceof List)
            collection = ((List)collection).listIterator();
        else
            collection = collection.iterator();
        return collection;
    }

    static List a(AbstractMapBasedMultimap abstractmapbasedmultimap, Object obj, List list, g g1) {
        return abstractmapbasedmultimap.a(obj, list, g1);
    }

    private List a(Object obj, List list, g g1) {
        if (list instanceof RandomAccess)
            obj = new d(obj, list, g1);
        else
            obj = new h(obj, list, g1);
        return ((List) (obj));
    }

    static Map a(AbstractMapBasedMultimap abstractmapbasedmultimap) {
        return abstractmapbasedmultimap.a;
    }

    static int b(AbstractMapBasedMultimap abstractmapbasedmultimap) {
        int k = abstractmapbasedmultimap.b;
        abstractmapbasedmultimap.b = k - 1;
        return k;
    }

    static int b(AbstractMapBasedMultimap abstractmapbasedmultimap, int k) {
        k = abstractmapbasedmultimap.b - k;
        abstractmapbasedmultimap.b = k;
        return k;
    }

    static int c(AbstractMapBasedMultimap abstractmapbasedmultimap) {
        int k = abstractmapbasedmultimap.b;
        abstractmapbasedmultimap.b = k + 1;
        return k;
    }

    Collection a(Object obj, Collection collection) {
        if (collection instanceof SortedSet)
            obj = new j(obj, (SortedSet)collection, null);
        else
        if (collection instanceof Set)
            obj = new i(obj, (Set)collection);
        else
        if (collection instanceof List)
            obj = a(obj, (List)collection, null);
        else
            obj = new g(obj, collection, null);
        return ((Collection) (obj));
    }

    public boolean a(Object obj, Object obj1) {
        Collection collection = (Collection)a.get(obj);
        if (collection != null) goto _L2; else goto _L1
_L1:
        collection = c(obj);
        if (!collection.add(obj1)) goto _L4; else goto _L3
_L3:
        boolean flag;
        b = b + 1;
        a.put(obj, collection);
        flag = true;
_L6:
        return flag;
_L4:
        throw new AssertionError("New Collection violated the Collection spec");
_L2:
        if (collection.add(obj1)) {
            b = b + 1;
            flag = true;
        } else {
            flag = false;
        }
        if (true) goto _L6; else goto _L5
_L5:
    }

    public Collection b(Object obj) {
        Collection collection1 = (Collection)a.get(obj);
        Collection collection = collection1;
        if (collection1 == null)
            collection = c(obj);
        return a(obj, collection);
    }

    abstract Collection c();

    Collection c(Object obj) {
        return c();
    }

    public int d() {
        return b;
    }

    public void e() {
        for (Iterator iterator = a.values().iterator(); iterator.hasNext(); ((Collection)iterator.next()).clear());
        a.clear();
        b = 0;
    }

    Set f() {
        Object obj;
        if (a instanceof SortedMap)
            obj = new f((SortedMap)a);
        else
            obj = new c(a);
        return ((Set) (obj));
    }

    public Collection g() {
        return super.g();
    }

    Iterator h() {
        return new b() {

            final AbstractMapBasedMultimap a;

            java.util.Map.Entry a(Object obj, Object obj1) {
                return Maps.a(obj, obj1);
            }

            Object b(Object obj, Object obj1) {
                return a(obj, obj1);
            }

             {
                a = AbstractMapBasedMultimap.this;
                super();
            }
        }
;
    }

    Map i() {
        Object obj;
        if (a instanceof SortedMap)
            obj = new e((SortedMap)a);
        else
            obj = new a(a);
        return ((Map) (obj));
    }
}
