// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.common.collect;

import java.io.Serializable;
import java.util.*;

// Referenced classes of package com.google.common.collect:
//            c, ImmutableListMultimap, ImmutableMap, ImmutableCollection, 
//            m, ImmutableSet, z, MultimapBuilder, 
//            g, p, k, Maps

public abstract class ImmutableMultimap extends c
    implements Serializable {
    private static class EntryCollection extends ImmutableCollection {

        final ImmutableMultimap a;

        public boolean contains(Object obj) {
            boolean flag;
            if (obj instanceof java.util.Map.Entry) {
                obj = (java.util.Map.Entry)obj;
                flag = a.b(((java.util.Map.Entry) (obj)).getKey(), ((java.util.Map.Entry) (obj)).getValue());
            } else {
                flag = false;
            }
            return flag;
        }

        public z d_() {
            return a.r();
        }

        boolean e() {
            return a.m();
        }

        public Iterator iterator() {
            return d_();
        }

        public int size() {
            return a.d();
        }

        EntryCollection(ImmutableMultimap immutablemultimap) {
            a = immutablemultimap;
        }
    }

    public static class a {

        m a;
        Comparator b;
        Comparator c;

        public a b(Object obj, Object obj1) {
            com.google.common.collect.g.a(obj, obj1);
            a.a(obj, obj1);
            return this;
        }

        public ImmutableMultimap b() {
            if (c != null) {
                for (Iterator iterator = a.b().values().iterator(); iterator.hasNext(); Collections.sort((List)(Collection)iterator.next(), c));
            }
            if (b != null) {
                l l1 = MultimapBuilder.a().b().b();
                java.util.Map.Entry entry;
                for (Iterator iterator1 = com.google.common.collect.p.a(b).c().a(a.b().entrySet()).iterator(); iterator1.hasNext(); l1.a(entry.getKey(), (Iterable)entry.getValue()))
                    entry = (java.util.Map.Entry)iterator1.next();

                a = l1;
            }
            return ImmutableMultimap.b(a);
        }

        public a() {
            this(((m) (MultimapBuilder.a().b().b())));
        }

        a(m m1) {
            a = m1;
        }
    }

    private abstract class b extends z {

        final Iterator b;
        Object c;
        Iterator d;
        final ImmutableMultimap e;

        abstract Object b(Object obj, Object obj1);

        public boolean hasNext() {
            boolean flag;
            if (b.hasNext() || d.hasNext())
                flag = true;
            else
                flag = false;
            return flag;
        }

        public Object next() {
            if (!d.hasNext()) {
                java.util.Map.Entry entry = (java.util.Map.Entry)b.next();
                c = entry.getKey();
                d = ((Collection)entry.getValue()).iterator();
            }
            return b(c, d.next());
        }

        private b() {
            e = ImmutableMultimap.this;
            super();
            b = e.o().g().d_();
            c = null;
            d = com.google.common.collect.k.a();
        }

    }


    final transient ImmutableMap b;
    final transient int c;

    ImmutableMultimap(ImmutableMap immutablemap, int i1) {
        b = immutablemap;
        c = i1;
    }

    public static ImmutableMultimap b(m m1) {
        if (!(m1 instanceof ImmutableMultimap)) goto _L2; else goto _L1
_L1:
        ImmutableMultimap immutablemultimap = (ImmutableMultimap)m1;
        if (immutablemultimap.m()) goto _L2; else goto _L3
_L3:
        m1 = immutablemultimap;
_L5:
        return m1;
_L2:
        m1 = ImmutableListMultimap.a(m1);
        if (true) goto _L5; else goto _L4
_L4:
    }

    public boolean a(Object obj, Iterable iterable) {
        throw new UnsupportedOperationException();
    }

    public boolean a(Object obj, Object obj1) {
        throw new UnsupportedOperationException();
    }

    public Collection b(Object obj) {
        return c(obj);
    }

    public Map b() {
        return o();
    }

    public volatile boolean b(Object obj, Object obj1) {
        return super.b(obj, obj1);
    }

    public abstract ImmutableCollection c(Object obj);

    public boolean c(Object obj, Object obj1) {
        throw new UnsupportedOperationException();
    }

    public int d() {
        return c;
    }

    public void e() {
        throw new UnsupportedOperationException();
    }

    public volatile boolean equals(Object obj) {
        return super.equals(obj);
    }

    public Collection g() {
        return p();
    }

    Iterator h() {
        return r();
    }

    public volatile int hashCode() {
        return super.hashCode();
    }

    Map i() {
        throw new AssertionError("should never be called");
    }

    public volatile boolean j() {
        return super.j();
    }

    Collection k() {
        return q();
    }

    public Set l() {
        return n();
    }

    boolean m() {
        return b.c();
    }

    public ImmutableSet n() {
        return b.i();
    }

    public ImmutableMap o() {
        return b;
    }

    public ImmutableCollection p() {
        return (ImmutableCollection)super.g();
    }

    ImmutableCollection q() {
        return new EntryCollection(this);
    }

    z r() {
        return new b() {

            final ImmutableMultimap a;

            java.util.Map.Entry a(Object obj, Object obj1) {
                return Maps.a(obj, obj1);
            }

            Object b(Object obj, Object obj1) {
                return a(obj, obj1);
            }

             {
                a = ImmutableMultimap.this;
                super();
            }
        }
;
    }

    public volatile String toString() {
        return super.toString();
    }
}
