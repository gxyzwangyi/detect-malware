// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.common.util.concurrent;

import com.google.common.base.i;
import com.google.common.base.o;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public final class f {
    public static abstract class a {

        final Condition condition;
        final f monitor;
        a next;
        int waiterCount;

        public abstract boolean isSatisfied();

        protected a(f f1) {
            waiterCount = 0;
            monitor = (f)i.a(f1, "monitor");
            condition = f.a(f1).newCondition();
        }
    }


    private final boolean a;
    private final ReentrantLock b;
    private a c;

    public f() {
        this(false);
    }

    public f(boolean flag) {
        c = null;
        a = flag;
        b = new ReentrantLock(flag);
    }

    private static long a(long l) {
        if (l > 0L) goto _L2; else goto _L1
_L1:
        l = 0L;
_L4:
        return l;
_L2:
        long l1 = System.nanoTime();
        l = l1;
        if (l1 == 0L)
            l = 1L;
        if (true) goto _L4; else goto _L3
_L3:
    }

    private static long a(long l, long l1) {
        long l2 = 0L;
        if (l1 <= 0L)
            l = l2;
        else
            l = l1 - (System.nanoTime() - l);
        return l;
    }

    private static long a(long l, TimeUnit timeunit) {
        long l1;
        l1 = 0L;
        l = timeunit.toNanos(l);
        if (l > 0L) goto _L2; else goto _L1
_L1:
        l = l1;
_L4:
        return l;
_L2:
        if (l > 0xfffffffdL)
            l = 0xfffffffdL;
        if (true) goto _L4; else goto _L3
_L3:
    }

    static ReentrantLock a(f f1) {
        return f1.b;
    }

    private boolean a(a a1) {
        boolean flag;
        try {
            flag = a1.isSatisfied();
        }
        // Misplaced declaration of an exception variable
        catch (a a1) {
            d();
            throw o.b(a1);
        }
        return flag;
    }

    private boolean a(a a1, long l, boolean flag) {
        boolean flag2;
        boolean flag4;
        flag4 = false;
        flag2 = true;
_L6:
        if (l > 0L) goto _L2; else goto _L1
_L1:
        flag = flag4;
        if (!flag2) {
            c(a1);
            flag = flag4;
        }
_L4:
        return flag;
_L2:
        boolean flag1;
        boolean flag3;
        flag1 = flag2;
        if (!flag2)
            break MISSING_BLOCK_LABEL_67;
        if (!flag)
            break MISSING_BLOCK_LABEL_55;
        flag3 = flag2;
        c();
        flag3 = flag2;
        b(a1);
        flag1 = false;
        flag3 = flag1;
        l = a1.condition.awaitNanos(l);
        flag3 = flag1;
        boolean flag5 = a1.isSatisfied();
        flag2 = flag1;
        if (!flag5)
            break; /* Loop/switch isn't completed */
        if (!flag1)
            c(a1);
        flag = true;
        if (true) goto _L4; else goto _L3
_L3:
        if (true) goto _L6; else goto _L5
_L5:
        Exception exception;
        exception;
        if (!flag3)
            c(a1);
        throw exception;
    }

    private void b(a a1) {
        int i = a1.waiterCount;
        a1.waiterCount = i + 1;
        if (i == 0) {
            a1.next = c;
            c = a1;
        }
    }

    private void c() {
        a a1 = c;
        do {
label0:
            {
                if (a1 != null) {
                    if (!a(a1))
                        break label0;
                    a1.condition.signal();
                }
                return;
            }
            a1 = a1.next;
        } while (true);
    }

    private void c(a a1) {
        int i;
        i = a1.waiterCount - 1;
        a1.waiterCount = i;
        if (i != 0) goto _L2; else goto _L1
_L1:
        a a2;
        a a3;
        a2 = c;
        a3 = null;
_L6:
        if (a2 != a1) goto _L4; else goto _L3
_L3:
        if (a3 == null)
            c = a2.next;
        else
            a3.next = a2.next;
        a2.next = null;
_L2:
        return;
_L4:
        a a4 = a2.next;
        a3 = a2;
        a2 = a4;
        if (true) goto _L6; else goto _L5
_L5:
    }

    private void d() {
        for (a a1 = c; a1 != null; a1 = a1.next)
            a1.condition.signalAll();

    }

    public void a() {
        b.lock();
    }

    public boolean a(a a1, long l, TimeUnit timeunit) {
        long l1;
        boolean flag1;
        boolean flag2;
        l1 = a(l, timeunit);
        if (a1.monitor != this)
            throw new IllegalMonitorStateException();
        timeunit = b;
        l = 0L;
        flag2 = timeunit.isHeldByCurrentThread();
        flag1 = Thread.interrupted();
        if (a) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
        if (timeunit.tryLock()) goto _L3; else goto _L2
_L2:
        l = a(l1);
        long l2;
        l2 = l1;
        flag = flag1;
_L18:
        flag1 = timeunit.tryLock(l2, TimeUnit.NANOSECONDS);
        if (!flag1) goto _L4; else goto _L3
_L3:
        flag1 = flag2;
_L14:
        l2 = l;
        flag2 = a1.isSatisfied();
        if (!flag2) goto _L6; else goto _L5
_L5:
        flag1 = true;
_L11:
        if (flag1)
            break MISSING_BLOCK_LABEL_125;
        timeunit.unlock();
        flag2 = flag1;
        if (flag) {
            Thread.currentThread().interrupt();
            flag2 = flag1;
        }
_L8:
        return flag2;
_L4:
        if (flag)
            Thread.currentThread().interrupt();
        flag2 = false;
        if (true) goto _L8; else goto _L7
_L7:
        InterruptedException interruptedexception;
        interruptedexception;
        flag = true;
        l2 = a(l, l1);
        flag = true;
        continue; /* Loop/switch isn't completed */
_L6:
        if (l != 0L) goto _L10; else goto _L9
_L9:
        l2 = l;
        l = a(l1);
        long l3 = l1;
_L12:
        l2 = l;
        flag1 = a(a1, l3, flag1);
          goto _L11
_L10:
        l2 = l;
        l3 = a(l, l1);
          goto _L12
        interruptedexception;
        flag = true;
        flag1 = false;
        l = l2;
        if (true) goto _L14; else goto _L13
_L13:
        a1;
        timeunit.unlock();
        throw a1;
        a1;
_L16:
        if (flag)
            Thread.currentThread().interrupt();
        throw a1;
        a1;
        flag = flag1;
        continue; /* Loop/switch isn't completed */
        a1;
        continue; /* Loop/switch isn't completed */
        a1;
        if (true) goto _L16; else goto _L15
_L15:
        if (true) goto _L18; else goto _L17
_L17:
    }

    public void b() {
        ReentrantLock reentrantlock = b;
        if (reentrantlock.getHoldCount() == 1)
            c();
        reentrantlock.unlock();
        return;
        Exception exception;
        exception;
        reentrantlock.unlock();
        throw exception;
    }
}
