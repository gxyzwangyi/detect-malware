// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.common.net;

import com.google.common.base.*;
import java.io.Serializable;

public final class HostAndPort
    implements Serializable {

    private final String a;
    private final int b;
    private final boolean c;

    private HostAndPort(String s, int j, boolean flag) {
        a = s;
        b = j;
        c = flag;
    }

    public static HostAndPort a(String s) {
        HostAndPort hostandport = b(s);
        boolean flag;
        if (!hostandport.b())
            flag = true;
        else
            flag = false;
        i.a(flag, "Host has a port: %s", new Object[] {
            s
        });
        return hostandport;
    }

    public static HostAndPort a(String s, int j) {
        i.a(b(j), "Port out of range: %s", new Object[] {
            Integer.valueOf(j)
        });
        HostAndPort hostandport = b(s);
        boolean flag;
        if (!hostandport.b())
            flag = true;
        else
            flag = false;
        i.a(flag, "Host has a port: %s", new Object[] {
            s
        });
        return new HostAndPort(hostandport.a, j, hostandport.c);
    }

    public static HostAndPort b(String s) {
        i.a(s);
        Object obj = null;
        int j;
        boolean flag;
        String s1;
        if (s.startsWith("[")) {
            obj = c(s);
            s1 = obj[0];
            obj = obj[1];
            flag = false;
        } else {
            j = s.indexOf(':');
            if (j >= 0 && s.indexOf(':', j + 1) == -1) {
                s1 = s.substring(0, j);
                obj = s.substring(j + 1);
                flag = false;
            } else {
                if (j >= 0)
                    flag = true;
                else
                    flag = false;
                s1 = s;
            }
        }
        if (!m.a(((String) (obj)))) {
            boolean flag1;
            if (!((String) (obj)).startsWith("+"))
                flag1 = true;
            else
                flag1 = false;
            i.a(flag1, "Unparseable port number: %s", new Object[] {
                s
            });
            try {
                j = Integer.parseInt(((String) (obj)));
            }
            catch (NumberFormatException numberformatexception) {
                throw new IllegalArgumentException((new StringBuilder()).append("Unparseable port number: ").append(s).toString());
            }
            i.a(b(j), "Port number out of range: %s", new Object[] {
                s
            });
        } else {
            j = -1;
        }
        return new HostAndPort(s1, j, flag);
    }

    private static boolean b(int j) {
        boolean flag;
        if (j >= 0 && j <= 65535)
            flag = true;
        else
            flag = false;
        return flag;
    }

    private static String[] c(String s) {
        int j;
        int l;
        boolean flag;
        String s1;
        if (s.charAt(0) == '[')
            flag = true;
        else
            flag = false;
        i.a(flag, "Bracketed host-port string must start with a bracket: %s", new Object[] {
            s
        });
        j = s.indexOf(':');
        l = s.lastIndexOf(']');
        if (j > -1 && l > j)
            flag = true;
        else
            flag = false;
        i.a(flag, "Invalid bracketed host/port: %s", new Object[] {
            s
        });
        s1 = s.substring(1, l);
        if (l + 1 == s.length()) {
            s = new String[2];
            s[0] = s1;
            s[1] = "";
        } else {
            boolean flag1;
            if (s.charAt(l + 1) == ':')
                flag1 = true;
            else
                flag1 = false;
            i.a(flag1, "Only a colon may follow a close bracket: %s", new Object[] {
                s
            });
            for (int k = l + 2; k < s.length(); k++)
                i.a(Character.isDigit(s.charAt(k)), "Port must be numeric: %s", new Object[] {
                    s
                });

            String as[] = new String[2];
            as[0] = s1;
            as[1] = s.substring(l + 2);
            s = as;
        }
        return s;
    }

    public int a(int j) {
        if (b())
            j = b;
        return j;
    }

    public String a() {
        return a;
    }

    public boolean b() {
        boolean flag;
        if (b >= 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public int c() {
        i.b(b());
        return b;
    }

    public boolean equals(Object obj) {
        boolean flag = true;
        if (this != obj) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        if (obj instanceof HostAndPort) {
            obj = (HostAndPort)obj;
            if (!g.a(a, ((HostAndPort) (obj)).a) || b != ((HostAndPort) (obj)).b || c != ((HostAndPort) (obj)).c)
                flag = false;
        } else {
            flag = false;
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    public int hashCode() {
        return g.a(new Object[] {
            a, Integer.valueOf(b), Boolean.valueOf(c)
        });
    }

    public String toString() {
        StringBuilder stringbuilder = new StringBuilder(a.length() + 8);
        if (a.indexOf(':') >= 0)
            stringbuilder.append('[').append(a).append(']');
        else
            stringbuilder.append(a);
        if (b())
            stringbuilder.append(':').append(b);
        return stringbuilder.toString();
    }
}
