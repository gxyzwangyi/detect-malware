// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.zxing.qrcode.detector;

import com.google.zxing.DecodeHintType;
import com.google.zxing.NotFoundException;
import com.google.zxing.common.b;
import com.google.zxing.i;
import com.google.zxing.j;
import java.io.Serializable;
import java.util.*;

// Referenced classes of package com.google.zxing.qrcode.detector:
//            d, e

public class FinderPatternFinder {
    private static final class CenterComparator
        implements Serializable, Comparator {

        private final float a;

        public int a(d d1, d d2) {
            int k;
            if (d2.d() == d1.d()) {
                float f1 = Math.abs(d2.c() - a);
                float f = Math.abs(d1.c() - a);
                if (f1 < f)
                    k = 1;
                else
                if (f1 == f)
                    k = 0;
                else
                    k = -1;
            } else {
                k = d2.d() - d1.d();
            }
            return k;
        }

        public int compare(Object obj, Object obj1) {
            return a((d)obj, (d)obj1);
        }

        private CenterComparator(float f) {
            a = f;
        }

    }

    private static final class FurthestFromAverageComparator
        implements Serializable, Comparator {

        private final float a;

        public int a(d d1, d d2) {
            float f1 = Math.abs(d2.c() - a);
            float f = Math.abs(d1.c() - a);
            byte byte0;
            if (f1 < f)
                byte0 = -1;
            else
            if (f1 == f)
                byte0 = 0;
            else
                byte0 = 1;
            return byte0;
        }

        public int compare(Object obj, Object obj1) {
            return a((d)obj, (d)obj1);
        }

        private FurthestFromAverageComparator(float f) {
            a = f;
        }

    }


    private final b a;
    private final List b = new ArrayList();
    private boolean c;
    private final int d[] = new int[5];
    private final j e;

    public FinderPatternFinder(b b1, j j1) {
        a = b1;
        e = j1;
    }

    private static float a(int ai[], int k) {
        return (float)(k - ai[4] - ai[3]) - (float)ai[2] / 2.0F;
    }

    private boolean a(int k, int l, int i1, int j1) {
        int k1;
        int ai[];
        ai = a();
        for (k1 = 0; k >= k1 && l >= k1 && a.a(l - k1, k - k1); k1++)
            ai[2] = ai[2] + 1;

        if (k < k1) goto _L2; else goto _L1
_L1:
        int i2 = k1;
        if (l >= k1) goto _L3; else goto _L2
_L2:
        boolean flag = false;
_L5:
        return flag;
_L3:
        int j2;
        int k2;
label0:
        {
            for (; k >= i2 && l >= i2 && !a.a(l - i2, k - i2) && ai[1] <= i1; i2++)
                ai[1] = ai[1] + 1;

            if (k < i2 || l < i2 || ai[1] > i1) {
                flag = false;
                continue; /* Loop/switch isn't completed */
            }
            for (; k >= i2 && l >= i2 && a.a(l - i2, k - i2) && ai[0] <= i1; i2++)
                ai[0] = ai[0] + 1;

            if (ai[0] > i1) {
                flag = false;
                continue; /* Loop/switch isn't completed */
            }
            k2 = a.f();
            j2 = a.e();
            int l1;
            for (l1 = 1; k + l1 < k2 && l + l1 < j2 && a.a(l + l1, k + l1); l1++)
                ai[2] = ai[2] + 1;

            if (k + l1 < k2) {
                i2 = l1;
                if (l + l1 < j2)
                    break label0;
            }
            flag = false;
            continue; /* Loop/switch isn't completed */
        }
        for (; k + i2 < k2 && l + i2 < j2 && !a.a(l + i2, k + i2) && ai[3] < i1; i2++)
            ai[3] = ai[3] + 1;

        if (k + i2 >= k2 || l + i2 >= j2 || ai[3] >= i1) {
            flag = false;
        } else {
            for (; k + i2 < k2 && l + i2 < j2 && a.a(l + i2, k + i2) && ai[4] < i1; i2++)
                ai[4] = ai[4] + 1;

            if (ai[4] >= i1)
                flag = false;
            else
            if (Math.abs((ai[0] + ai[1] + ai[2] + ai[3] + ai[4]) - j1) < j1 * 2 && a(ai))
                flag = true;
            else
                flag = false;
        }
        if (true) goto _L5; else goto _L4
_L4:
    }

    protected static boolean a(int ai[]) {
        int k;
        int l;
        boolean flag;
        boolean flag1;
        flag1 = true;
        flag = false;
        l = 0;
        k = 0;
_L3:
        int j1;
        if (l >= 5)
            break MISSING_BLOCK_LABEL_36;
        j1 = ai[l];
        if (j1 != 0) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        k += j1;
        l++;
          goto _L3
        if (k >= 7) {
            int i1 = (k << 8) / 7;
            k = i1 / 2;
            if (Math.abs(i1 - (ai[0] << 8)) < k && Math.abs(i1 - (ai[1] << 8)) < k && Math.abs(i1 * 3 - (ai[2] << 8)) < k * 3 && Math.abs(i1 - (ai[3] << 8)) < k && Math.abs(i1 - (ai[4] << 8)) < k)
                flag = flag1;
            else
                flag = false;
        }
          goto _L1
    }

    private int[] a() {
        d[0] = 0;
        d[1] = 0;
        d[2] = 0;
        d[3] = 0;
        d[4] = 0;
        return d;
    }

    private float b(int k, int l, int i1, int j1) {
        float f1;
        int k1;
        int l1;
        int i2;
        b b1;
        int ai[];
        f1 = (0.0F / 0.0F);
        b1 = a;
        i2 = b1.f();
        ai = a();
        for (k1 = k; k1 >= 0 && b1.a(l, k1); k1--)
            ai[2] = ai[2] + 1;

        l1 = k1;
        if (k1 >= 0) goto _L2; else goto _L1
_L1:
        float f = f1;
_L4:
        return f;
_L2:
        for (; l1 >= 0 && !b1.a(l, l1) && ai[1] <= i1; l1--)
            ai[1] = ai[1] + 1;

        f = f1;
        if (l1 >= 0) {
            f = f1;
            if (ai[1] <= i1) {
                for (; l1 >= 0 && b1.a(l, l1) && ai[0] <= i1; l1--)
                    ai[0] = ai[0] + 1;

                f = f1;
                if (ai[0] <= i1) {
                    for (k++; k < i2 && b1.a(l, k); k++)
                        ai[2] = ai[2] + 1;

                    f = f1;
                    if (k != i2) {
                        for (; k < i2 && !b1.a(l, k) && ai[3] < i1; k++)
                            ai[3] = ai[3] + 1;

                        f = f1;
                        if (k != i2) {
                            f = f1;
                            if (ai[3] < i1) {
                                for (; k < i2 && b1.a(l, k) && ai[4] < i1; k++)
                                    ai[4] = ai[4] + 1;

                                f = f1;
                                if (ai[4] < i1) {
                                    f = f1;
                                    if (Math.abs((ai[0] + ai[1] + ai[2] + ai[3] + ai[4]) - j1) * 5 < j1 * 2) {
                                        f = f1;
                                        if (a(ai))
                                            f = a(ai, k);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private int b() {
        if (b.size() > 1) goto _L2; else goto _L1
_L1:
        int k = 0;
_L4:
        return k;
_L2:
        d d1 = null;
        Iterator iterator = b.iterator();
        do {
            if (!iterator.hasNext())
                break;
            d d2 = (d)iterator.next();
            if (d2.d() >= 2)
                if (d1 == null) {
                    d1 = d2;
                } else {
                    c = true;
                    k = (int)(Math.abs(d1.a() - d2.a()) - Math.abs(d1.b() - d2.b())) / 2;
                    continue; /* Loop/switch isn't completed */
                }
        } while (true);
        k = 0;
        if (true) goto _L4; else goto _L3
_L3:
    }

    private float c(int k, int l, int i1, int j1) {
        float f1;
        int k1;
        int l1;
        int i2;
        int ai[];
        b b1;
        f1 = (0.0F / 0.0F);
        b1 = a;
        i2 = b1.e();
        ai = a();
        for (k1 = k; k1 >= 0 && b1.a(k1, l); k1--)
            ai[2] = ai[2] + 1;

        l1 = k1;
        if (k1 >= 0) goto _L2; else goto _L1
_L1:
        float f = f1;
_L4:
        return f;
_L2:
        for (; l1 >= 0 && !b1.a(l1, l) && ai[1] <= i1; l1--)
            ai[1] = ai[1] + 1;

        f = f1;
        if (l1 >= 0) {
            f = f1;
            if (ai[1] <= i1) {
                for (; l1 >= 0 && b1.a(l1, l) && ai[0] <= i1; l1--)
                    ai[0] = ai[0] + 1;

                f = f1;
                if (ai[0] <= i1) {
                    for (k++; k < i2 && b1.a(k, l); k++)
                        ai[2] = ai[2] + 1;

                    f = f1;
                    if (k != i2) {
                        for (; k < i2 && !b1.a(k, l) && ai[3] < i1; k++)
                            ai[3] = ai[3] + 1;

                        f = f1;
                        if (k != i2) {
                            f = f1;
                            if (ai[3] < i1) {
                                for (; k < i2 && b1.a(k, l) && ai[4] < i1; k++)
                                    ai[4] = ai[4] + 1;

                                f = f1;
                                if (ai[4] < i1) {
                                    f = f1;
                                    if (Math.abs((ai[0] + ai[1] + ai[2] + ai[3] + ai[4]) - j1) * 5 < j1) {
                                        f = f1;
                                        if (a(ai))
                                            f = a(ai, k);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private boolean c() {
        float f;
        float f1;
        int k;
        int l;
        boolean flag;
        f1 = 0.0F;
        flag = false;
        l = b.size();
        Iterator iterator = b.iterator();
        f = 0.0F;
        k = 0;
        do {
            if (!iterator.hasNext())
                break;
            d d1 = (d)iterator.next();
            if (d1.d() >= 2) {
                f = d1.c() + f;
                k++;
            }
        } while (true);
        if (k >= 3) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        float f2 = f / (float)l;
        for (Iterator iterator1 = b.iterator(); iterator1.hasNext();)
            f1 += Math.abs(((d)iterator1.next()).c() - f2);

        if (f1 <= 0.05F * f)
            flag = true;
        if (true) goto _L1; else goto _L3
_L3:
    }

    private d[] d() {
        float f3 = 0.0F;
        int k = b.size();
        if (k < 3)
            throw NotFoundException.a();
        if (k > 3) {
            Iterator iterator = b.iterator();
            float f = 0.0F;
            float f2 = 0.0F;
            while (iterator.hasNext())  {
                float f4 = ((d)iterator.next()).c();
                f2 += f4;
                f = f4 * f4 + f;
            }
            f2 /= k;
            f = (float)Math.sqrt(f / (float)k - f2 * f2);
            Collections.sort(b, new FurthestFromAverageComparator(f2));
            f = Math.max(0.2F * f2, f);
            int i1;
            for (int l = 0; l < b.size() && b.size() > 3; l = i1 + 1) {
                i1 = l;
                if (Math.abs(((d)b.get(l)).c() - f2) > f) {
                    b.remove(l);
                    i1 = l - 1;
                }
            }

        }
        if (b.size() > 3) {
            Iterator iterator1 = b.iterator();
            float f1;
            for (f1 = f3; iterator1.hasNext(); f1 += ((d)iterator1.next()).c());
            f1 /= b.size();
            Collections.sort(b, new CenterComparator(f1));
            b.subList(3, b.size()).clear();
        }
        return (new d[] {
            (d)b.get(0), (d)b.get(1), (d)b.get(2)
        });
    }

    final e a(Map map) {
        int k;
        int l;
        int i1;
        int l1;
        int i2;
        boolean flag1;
        boolean flag3;
        if (map != null && map.containsKey(DecodeHintType.d))
            l = 1;
        else
            l = 0;
        if (map != null && map.containsKey(DecodeHintType.b))
            flag3 = true;
        else
            flag3 = false;
        i2 = a.f();
        l1 = a.e();
        k = (i2 * 3) / 228;
        if (k < 3 || l != 0)
            k = 3;
        flag1 = false;
        map = new int[5];
        i1 = k - 1;
        while (i1 < i2 && !flag1)  {
            map[0] = 0;
            map[1] = 0;
            map[2] = 0;
            map[3] = 0;
            map[4] = 0;
            boolean flag = false;
            l = 0;
            int j1 = k;
            k = ((flag) ? 1 : 0);
            while (l < l1)  {
                if (a.a(l, i1)) {
                    int k1 = k;
                    if ((k & 1) == 1)
                        k1 = k + 1;
                    map[k1] = map[k1] + 1;
                    k = k1;
                } else
                if ((k & 1) == 0) {
                    if (k == 4) {
                        if (a(((int []) (map)))) {
                            if (a(((int []) (map)), i1, l, flag3)) {
                                j1 = 2;
                                if (c) {
                                    flag1 = c();
                                } else {
                                    k = b();
                                    boolean flag2;
                                    if (k > map[2]) {
                                        l = i1 + (k - map[2] - 2);
                                        k = l1 - 1;
                                    } else {
                                        k = l;
                                        l = i1;
                                    }
                                    i1 = l;
                                    l = k;
                                }
                                map[0] = 0;
                                map[1] = 0;
                                map[2] = 0;
                                map[3] = 0;
                                map[4] = 0;
                                k = 0;
                            } else {
                                map[0] = map[2];
                                map[1] = map[3];
                                map[2] = map[4];
                                map[3] = 1;
                                map[4] = 0;
                                k = 3;
                            }
                        } else {
                            map[0] = map[2];
                            map[1] = map[3];
                            map[2] = map[4];
                            map[3] = 1;
                            map[4] = 0;
                            k = 3;
                        }
                    } else {
                        k++;
                        map[k] = map[k] + 1;
                    }
                } else {
                    map[k] = map[k] + 1;
                }
                l++;
            }
            flag2 = flag1;
            k = j1;
            if (a(((int []) (map)))) {
                flag2 = flag1;
                k = j1;
                if (a(((int []) (map)), i1, l1, flag3)) {
                    l = map[0];
                    flag2 = flag1;
                    k = l;
                    if (c) {
                        flag2 = c();
                        k = l;
                    }
                }
            }
            i1 += k;
            flag1 = flag2;
        }
        map = d();
        i.a(map);
        return new e(map);
    }

    protected final boolean a(int ai[], int k, int l, boolean flag) {
        float f;
        float f1;
        boolean flag1;
        int i1;
        boolean flag2;
        boolean flag3;
        flag3 = false;
        flag1 = false;
        i1 = ai[0] + ai[1] + ai[2] + ai[3] + ai[4];
        f1 = a(ai, l);
        f = b(k, (int)f1, ai[2], i1);
        flag2 = flag3;
        if (Float.isNaN(f)) goto _L2; else goto _L1
_L1:
        float f2;
        f2 = c((int)f1, (int)f, ai[2], i1);
        flag2 = flag3;
        if (Float.isNaN(f2)) goto _L2; else goto _L3
_L3:
        if (!flag) goto _L5; else goto _L4
_L4:
        flag2 = flag3;
        if (!a((int)f, (int)f2, ai[2], i1)) goto _L2; else goto _L5
_L5:
        f1 = (float)i1 / 7F;
        l = 0;
_L11:
        k = ((flag1) ? 1 : 0);
        if (l >= b.size()) goto _L7; else goto _L6
_L6:
        ai = (d)b.get(l);
        if (!ai.a(f1, f, f2)) goto _L9; else goto _L8
_L8:
        b.set(l, ai.b(f, f2, f1));
        k = 1;
_L7:
        if (k == 0) {
            ai = new d(f2, f, f1);
            b.add(ai);
            if (e != null)
                e.a(ai);
        }
        flag2 = true;
_L2:
        return flag2;
_L9:
        l++;
        if (true) goto _L11; else goto _L10
_L10:
    }
}
