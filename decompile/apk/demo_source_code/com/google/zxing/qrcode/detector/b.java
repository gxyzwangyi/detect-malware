// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.zxing.qrcode.detector;

import com.google.zxing.NotFoundException;
import com.google.zxing.j;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

// Referenced classes of package com.google.zxing.qrcode.detector:
//            a

final class b {

    private final com.google.zxing.common.b a;
    private final List b = new ArrayList(5);
    private final int c;
    private final int d;
    private final int e;
    private final int f;
    private final float g;
    private final int h[] = new int[3];
    private final j i;

    b(com.google.zxing.common.b b1, int k, int l, int i1, int j1, float f1, j j2) {
        a = b1;
        c = k;
        d = l;
        e = i1;
        f = j1;
        g = f1;
        i = j2;
    }

    private float a(int k, int l, int i1, int j1) {
        float f1;
        float f2;
        int k1;
        int l1;
        int ai[];
        com.google.zxing.common.b b1;
        f2 = (0.0F / 0.0F);
        b1 = a;
        l1 = b1.f();
        ai = h;
        ai[0] = 0;
        ai[1] = 0;
        ai[2] = 0;
        for (k1 = k; k1 >= 0 && b1.a(l, k1) && ai[1] <= i1; k1--)
            ai[1] = ai[1] + 1;

        f1 = f2;
        if (k1 < 0) goto _L2; else goto _L1
_L1:
        if (ai[1] <= i1) goto _L4; else goto _L3
_L3:
        f1 = f2;
_L2:
        return f1;
_L4:
        for (; k1 >= 0 && !b1.a(l, k1) && ai[0] <= i1; k1--)
            ai[0] = ai[0] + 1;

        f1 = f2;
        if (ai[0] <= i1) {
            for (k++; k < l1 && b1.a(l, k) && ai[1] <= i1; k++)
                ai[1] = ai[1] + 1;

            f1 = f2;
            if (k != l1) {
                f1 = f2;
                if (ai[1] <= i1) {
                    for (; k < l1 && !b1.a(l, k) && ai[2] <= i1; k++)
                        ai[2] = ai[2] + 1;

                    f1 = f2;
                    if (ai[2] <= i1) {
                        f1 = f2;
                        if (Math.abs((ai[0] + ai[1] + ai[2]) - j1) * 5 < j1 * 2) {
                            f1 = f2;
                            if (a(ai))
                                f1 = a(ai, k);
                        }
                    }
                }
            }
        }
        if (true) goto _L2; else goto _L5
_L5:
    }

    private static float a(int ai[], int k) {
        return (float)(k - ai[2]) - (float)ai[1] / 2.0F;
    }

    private a a(int ai[], int k, int l) {
        float f1;
        float f3;
        int j1 = ai[0];
        int i1 = ai[1];
        int k1 = ai[2];
        f1 = a(ai, l);
        f3 = a(k, (int)f1, ai[1] * 2, j1 + i1 + k1);
        if (Float.isNaN(f3)) goto _L2; else goto _L1
_L1:
        float f2;
        Iterator iterator;
        f2 = (float)(ai[0] + ai[1] + ai[2]) / 3F;
        iterator = b.iterator();
_L6:
        if (!iterator.hasNext()) goto _L4; else goto _L3
_L3:
        ai = (a)iterator.next();
        if (!ai.a(f2, f3, f1)) goto _L6; else goto _L5
_L5:
        ai = ai.b(f3, f1, f2);
_L8:
        return ai;
_L4:
        ai = new a(f1, f3, f2);
        b.add(ai);
        if (i != null)
            i.a(ai);
_L2:
        ai = null;
        if (true) goto _L8; else goto _L7
_L7:
    }

    private boolean a(int ai[]) {
        float f1;
        float f2;
        int k;
        boolean flag;
        flag = false;
        f1 = g;
        f2 = f1 / 2.0F;
        k = 0;
_L3:
        if (k >= 3)
            break MISSING_BLOCK_LABEL_45;
        if (Math.abs(f1 - (float)ai[k]) < f2) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        k++;
          goto _L3
        flag = true;
          goto _L1
    }

    a a() {
        int i1;
        int k1;
        int l1;
        int i2;
        int j2;
        int ai[];
        k1 = c;
        i2 = f;
        l1 = k1 + e;
        j2 = d;
        ai = new int[3];
        i1 = 0;
_L17:
        if (i1 >= i2) goto _L2; else goto _L1
_L1:
        int k;
        int j1;
        int k2;
        if ((i1 & 1) == 0)
            k = i1 + 1 >> 1;
        else
            k = -(i1 + 1 >> 1);
        k2 = j2 + (i2 >> 1) + k;
        ai[0] = 0;
        ai[1] = 0;
        ai[2] = 0;
        for (k = k1; k < l1 && !a.a(k, k2); k++);
        boolean flag = false;
        j1 = k;
        k = ((flag) ? 1 : 0);
_L9:
        if (j1 >= l1) goto _L4; else goto _L3
_L3:
        if (!a.a(j1, k2)) goto _L6; else goto _L5
_L5:
        if (k != 1) goto _L8; else goto _L7
_L7:
        ai[k] = ai[k] + 1;
_L15:
        j1++;
          goto _L9
_L8:
        if (k != 2) goto _L11; else goto _L10
_L10:
        if (!a(ai)) goto _L13; else goto _L12
_L12:
        a a1 = a(ai, k2, j1);
        if (a1 == null) goto _L13; else goto _L14
_L14:
        return a1;
_L13:
        ai[0] = ai[2];
        ai[1] = 1;
        ai[2] = 0;
        k = 1;
          goto _L15
_L11:
        k++;
        ai[k] = ai[k] + 1;
          goto _L15
_L6:
        int l = k;
        if (k == 1)
            l = k + 1;
        ai[l] = ai[l] + 1;
        k = l;
          goto _L15
_L4:
        a a2;
        if (!a(ai))
            continue; /* Loop/switch isn't completed */
        a2 = a(ai, k2, l1);
        a1 = a2;
        if (a2 != null) goto _L14; else goto _L16
_L16:
        i1++;
          goto _L17
_L2:
        if (!b.isEmpty())
            a1 = (a)b.get(0);
        else
            throw NotFoundException.a();
          goto _L14
    }
}
