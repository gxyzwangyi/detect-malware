// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.zxing.oned.rss;

import com.google.zxing.*;
import com.google.zxing.common.a;
import com.google.zxing.*;
import java.util.*;

// Referenced classes of package com.google.zxing.oned.rss:
//            a, d, c, f, 
//            b

public final class e extends com.google.zxing.oned.rss.a {

    private static final int a[] = {
        1, 10, 34, 70, 126
    };
    private static final int b[] = {
        4, 20, 48, 81
    };
    private static final int c[] = {
        0, 161, 961, 2015, 2715
    };
    private static final int d[] = {
        0, 336, 1036, 1516
    };
    private static final int e[] = {
        8, 6, 4, 3, 1
    };
    private static final int f[] = {
        2, 4, 6, 8
    };
    private static final int g[][];
    private final List h = new ArrayList();
    private final List i = new ArrayList();

    public e() {
    }

    private static h a(d d1, d d2) {
        Object obj = String.valueOf(0x453af5L * (long)d1.a() + (long)d2.a());
        Object obj1 = new StringBuilder(14);
        for (int k = 13 - ((String) (obj)).length(); k > 0; k--)
            ((StringBuilder) (obj1)).append('0');

        ((StringBuilder) (obj1)).append(((String) (obj)));
        int l = 0;
        int i1 = 0;
        for (; l < 13; l++) {
            int k1 = ((StringBuilder) (obj1)).charAt(l) - 48;
            int j1 = k1;
            if ((l & 1) == 0)
                j1 = k1 * 3;
            i1 += j1;
        }

        i1 = 10 - i1 % 10;
        l = i1;
        if (i1 == 10)
            l = 0;
        ((StringBuilder) (obj1)).append(l);
        i ai[] = d1.c().c();
        i ai1[] = d2.c().c();
        d2 = String.valueOf(((StringBuilder) (obj1)).toString());
        d1 = ai[0];
        ai = ai[1];
        obj1 = ai1[0];
        i l1 = ai1[1];
        BarcodeFormat barcodeformat = BarcodeFormat.m;
        return new h(d2, null, new i[] {
            d1, ai, obj1, l1
        }, barcodeformat);
    }

    private b a(a a1, c c1, boolean flag) {
        int ai[] = c();
        ai[0] = 0;
        ai[1] = 0;
        ai[2] = 0;
        ai[3] = 0;
        ai[4] = 0;
        ai[5] = 0;
        ai[6] = 0;
        ai[7] = 0;
        float f2;
        int j1;
        int k1;
        int ai1[];
        float af[];
        if (flag) {
            b(a1, c1.b()[0], ai);
        } else {
            a(a1, c1.b()[1] + 1, ai);
            j1 = 0;
            k = ai.length - 1;
            while (j1 < k)  {
                k1 = ai[j1];
                ai[j1] = ai[k];
                ai[k] = k1;
                j1++;
                k--;
            }
        }
        if (flag)
            j1 = 16;
        else
            j1 = 15;
        f2 = (float)a(ai) / (float)j1;
        a1 = f();
        ai1 = g();
        af = d();
        c1 = e();
        k1 = 0;
        while (k1 < ai.length)  {
            float f1 = (float)ai[k1] / f2;
            int l1 = (int)(0.5F + f1);
            int k;
            if (l1 < 1) {
                k = 1;
            } else {
                k = l1;
                if (l1 > 8)
                    k = 8;
            }
            l1 = k1 >> 1;
            if ((k1 & 1) == 0) {
                a1[l1] = k;
                af[l1] = f1 - (float)k;
            } else {
                ai1[l1] = k;
                c1[l1] = f1 - (float)k;
            }
            k1++;
        }
        a(flag, j1);
        k1 = a1.length - 1;
        j1 = 0;
        int l;
        int i2;
        for (l = 0; k1 >= 0; l = i2 + l) {
            int l2 = a1[k1];
            i2 = a1[k1];
            k1--;
            j1 = j1 * 9 + l2;
        }

        int j2 = 0;
        k1 = 0;
        for (int i3 = ai1.length - 1; i3 >= 0; i3--) {
            j2 = j2 * 9 + ai1[i3];
            k1 += ai1[i3];
        }

        j1 += j2 * 3;
        if (flag) {
            if ((l & 1) != 0 || l > 12 || l < 4)
                throw NotFoundException.a();
            k1 = (12 - l) / 2;
            int k2 = e[k1];
            l = com.google.zxing.oned.rss.f.a(a1, k2, false);
            k2 = com.google.zxing.oned.rss.f.a(ai1, 9 - k2, true);
            a1 = new b(l * a[k1] + k2 + c[k1], j1);
        } else {
            if ((k1 & 1) != 0 || k1 > 10 || k1 < 4)
                throw NotFoundException.a();
            int i1 = (10 - k1) / 2;
            k1 = f[i1];
            a1 = new b(com.google.zxing.oned.rss.f.a(a1, k1, true) + com.google.zxing.oned.rss.f.a(ai1, 9 - k1, false) * b[i1] + d[i1], j1);
        }
        return a1;
    }

    private c a(a a1, int k, boolean flag, int ai[]) {
        boolean flag1 = a1.a(ai[0]);
        int l;
        for (l = ai[0] - 1; l >= 0 && a1.a(l) ^ flag1; l--);
        int j1 = l + 1;
        l = ai[0];
        int ai1[] = b();
        System.arraycopy(ai1, 0, ai1, 1, ai1.length - 1);
        ai1[0] = l - j1;
        int k1 = a(ai1, g);
        l = ai[1];
        int i1;
        if (flag) {
            i1 = a1.a() - 1 - j1;
            l = a1.a() - 1 - l;
        } else {
            i1 = j1;
        }
        return new c(k1, new int[] {
            j1, ai[1]
        }, i1, l, k);
    }

    private d a(a a1, boolean flag, int k, Map map) {
        c c1;
        int ai[];
        ai = a(a1, 0, flag);
        c1 = a(a1, k, flag, ai);
        if (map != null) goto _L2; else goto _L1
_L1:
        map = null;
_L3:
        float f1;
        float f2;
        if (map == null)
            break MISSING_BLOCK_LABEL_90;
        f2 = (float)(ai[0] + ai[1]) / 2.0F;
        f1 = f2;
        if (!flag)
            break MISSING_BLOCK_LABEL_67;
        f1 = (float)(a1.a() - 1) - f2;
        i l = JVM INSTR new #106 <Class i>;
        l.i(f1, k);
        map.a(l);
        map = a(a1, c1, true);
        b b1 = a(a1, c1, false);
        a1 = JVM INSTR new #50  <Class d>;
        a1.d(map.a() * 1597 + b1.a(), map.b() + b1.b() * 4, c1);
_L4:
        return a1;
_L2:
        map = (j)map.get(DecodeHintType.j);
          goto _L3
        a1;
        a1 = null;
          goto _L4
    }

    private static void a(Collection collection, d d1) {
        if (d1 != null) goto _L2; else goto _L1
_L1:
        return;
_L2:
        boolean flag;
        Iterator iterator = collection.iterator();
        d d2;
        do {
            if (!iterator.hasNext())
                break; /* Loop/switch isn't completed */
            d2 = (d)iterator.next();
        } while (d2.a() != d1.a());
        d2.e();
        flag = true;
_L4:
        if (!flag)
            collection.add(d1);
        if (true) goto _L1; else goto _L3
_L3:
        flag = false;
          goto _L4
        if (true) goto _L1; else goto _L5
_L5:
    }

    private void a(boolean flag, int k) {
        int l;
        int i1;
        boolean flag1;
        boolean flag2;
        boolean flag3;
        boolean flag4;
        int l1;
        int i2;
        int j2;
        flag1 = false;
        flag4 = true;
        i2 = a(f());
        l1 = a(g());
        j2 = (i2 + l1) - k;
        if (flag)
            k = 1;
        else
            k = 0;
        if ((i2 & 1) == k)
            flag2 = true;
        else
            flag2 = false;
        if ((l1 & 1) == 1)
            flag3 = true;
        else
            flag3 = false;
        if (!flag) goto _L2; else goto _L1
_L1:
        int j1;
        int k1;
        if (i2 > 12) {
            i1 = 1;
            l = 0;
        } else
        if (i2 < 4) {
            i1 = 0;
            l = 1;
        } else {
            i1 = 0;
            l = 0;
        }
        if (l1 <= 12) goto _L4; else goto _L3
_L3:
        k = 0;
        flag1 = true;
_L7:
        if (j2 == 1) {
            if (flag2) {
                if (flag3)
                    throw NotFoundException.a();
                i1 = k;
                k = 1;
                do {
                    if (l != 0) {
                        if (k != 0)
                            throw NotFoundException.a();
                        a(f(), d());
                    }
                    if (k != 0)
                        b(f(), d());
                    if (i1 != 0) {
                        if (flag1)
                            throw NotFoundException.a();
                        a(g(), d());
                    }
                    if (flag1)
                        b(g(), e());
                    return;
                } while (true);
            } else {
                if (!flag3)
                    throw NotFoundException.a();
                flag1 = true;
                j1 = k;
                k = i1;
                i1 = j1;
                continue;
            }
        } else {
            if (j2 == -1) {
                if (flag2) {
                    if (flag3)
                        throw NotFoundException.a();
                    l = i1;
                    j1 = 1;
                    i1 = k;
                    k = l;
                    l = j1;
                } else {
                    if (!flag3)
                        throw NotFoundException.a();
                    k = i1;
                    i1 = ((flag4) ? 1 : 0);
                }
                continue;
            }
            if (j2 == 0) {
                if (flag2) {
                    if (!flag3)
                        throw NotFoundException.a();
                    if (i2 < l1) {
                        flag1 = true;
                        l = i1;
                        j1 = 1;
                        i1 = k;
                        k = l;
                        l = j1;
                    } else {
                        k = 1;
                        i1 = ((flag4) ? 1 : 0);
                    }
                    continue;
                }
                if (flag3)
                    throw NotFoundException.a();
            } else {
                throw NotFoundException.a();
            }
            j1 = i1;
            i1 = k;
            k = j1;
            continue;
        }
_L4:
        k1 = i1;
        j1 = l;
        if (l1 < 4) {
            k = 1;
            continue; /* Loop/switch isn't completed */
        }
          goto _L5
_L2:
        if (i2 > 11) {
            i1 = 1;
            l = 0;
        } else
        if (i2 < 5) {
            i1 = 0;
            l = 1;
        } else {
            i1 = 0;
            l = 0;
        }
        if (l1 > 10) {
            k = 0;
            flag1 = true;
            continue; /* Loop/switch isn't completed */
        }
        k1 = i1;
        j1 = l;
        if (l1 < 4) {
            k = 1;
            continue; /* Loop/switch isn't completed */
        }
_L5:
        k = 0;
        i1 = k1;
        l = j1;
        if (true) goto _L7; else goto _L6
_L6:
    }

    private int[] a(a a1, int k, boolean flag) {
        int ai[] = b();
        ai[0] = 0;
        ai[1] = 0;
        ai[2] = 0;
        ai[3] = 0;
        int k1 = a1.a();
        boolean flag1 = false;
        do {
label0:
            {
label1:
                {
                    int l;
                    int i1;
                    if (k < k1) {
                        if (!a1.a(k))
                            flag1 = true;
                        else
                            flag1 = false;
                        if (flag != flag1)
                            break label1;
                    }
                    i1 = k;
                    l = 0;
                    flag = flag1;
                    while (i1 < k1)  {
                        int j1;
                        if (a1.a(i1) ^ flag) {
                            ai[l] = ai[l] + 1;
                            j1 = k;
                        } else {
                            if (l == 3) {
                                if (b(ai))
                                    return (new int[] {
                                        k, i1
                                    });
                                j1 = k + (ai[0] + ai[1]);
                                ai[0] = ai[2];
                                ai[1] = ai[3];
                                ai[2] = 0;
                                ai[3] = 0;
                                k = l - 1;
                                l = j1;
                            } else {
                                j1 = l + 1;
                                l = k;
                                k = j1;
                            }
                            ai[k] = 1;
                            if (!flag) {
                                flag = true;
                                j1 = l;
                                l = k;
                            } else {
                                flag = false;
                                j1 = l;
                                l = k;
                            }
                        }
                        i1++;
                        k = j1;
                    }
                    break label0;
                }
                k++;
                continue;
            }
            throw NotFoundException.a();
        } while (true);
    }

    private static boolean b(d d1, d d2) {
        int j1 = d1.b();
        int i1 = d2.b();
        int l = d1.c().a() * 9 + d2.c().a();
        int k = l;
        if (l > 72)
            k = l - 1;
        l = k;
        if (k > 8)
            l = k - 1;
        boolean flag;
        if ((j1 + i1 * 16) % 79 == l)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public h a(int k, a a1, Map map) {
        d d1 = a(a1, false, k, map);
        a(((Collection) (h)), d1);
        a1.d();
        map = a(a1, true, k, map);
        a(((Collection) (i)), ((d) (map)));
        a1.d();
        int i1 = h.size();
label0:
        for (k = 0; k < i1; k++) {
            a1 = (d)h.get(k);
            if (a1.d() <= 1)
                continue;
            int j1 = i.size();
            int l = 0;
            do {
                if (l >= j1)
                    continue label0;
                map = (d)i.get(l);
                if (map.d() > 1 && b(a1, map))
                    return a(((d) (a1)), ((d) (map)));
                l++;
            } while (true);
        }

        throw NotFoundException.a();
    }

    public void a() {
        h.clear();
        i.clear();
    }

    static  {
        int ai[] = {
            3, 8, 2, 1
        };
        int ai1[] = {
            3, 5, 5, 1
        };
        int ai2[] = {
            2, 7, 4, 1
        };
        int ai3[] = {
            2, 3, 8, 1
        };
        int ai4[] = {
            1, 5, 7, 1
        };
        int ai5[] = {
            1, 3, 9, 1
        };
        g = (new int[][] {
            ai, ai1, new int[] {
                3, 3, 7, 1
            }, new int[] {
                3, 1, 9, 1
            }, ai2, new int[] {
                2, 5, 6, 1
            }, ai3, ai4, ai5
        });
    }
}
