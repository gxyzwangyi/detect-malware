// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.zxing.oned;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.DecodeHintType;
import com.google.zxing.NotFoundException;
import com.google.zxing.h;
import com.google.zxing.i;
import java.util.Arrays;
import java.util.Map;

// Referenced classes of package com.google.zxing.oned:
//            k

public final class a extends k {

    static final char a[] = "0123456789-$:/.+ABCD".toCharArray();
    static final int b[] = {
        3, 6, 9, 96, 18, 66, 33, 36, 48, 72, 
        12, 24, 69, 81, 84, 21, 26, 41, 11, 14
    };
    private static final char c[] = {
        'A', 'B', 'C', 'D'
    };
    private final StringBuilder d = new StringBuilder(20);
    private int e[];
    private int f;

    public a() {
        e = new int[80];
        f = 0;
    }

    private void a(com.google.zxing.common.a a1) {
        f = 0;
        int l = a1.d(0);
        int k1 = a1.a();
        if (l >= k1)
            throw NotFoundException.a();
        int j = 1;
        int j1 = 0;
        while (l < k1)  {
            int i1;
            if ((a1.a(l) ^ j) != 0) {
                j1++;
                i1 = j;
                j = j1;
            } else {
                b(j1);
                if (j == 0)
                    j = 1;
                else
                    j = 0;
                i1 = j;
                j = 1;
            }
            l++;
            j1 = j;
            j = i1;
        }
        b(j1);
    }

    static boolean a(char ac[], char c1) {
        boolean flag;
        boolean flag1;
        flag1 = false;
        flag = flag1;
        if (ac == null) goto _L2; else goto _L1
_L1:
        int j;
        int l;
        l = ac.length;
        j = 0;
_L7:
        flag = flag1;
        if (j >= l) goto _L2; else goto _L3
_L3:
        if (ac[j] != c1) goto _L5; else goto _L4
_L4:
        flag = true;
_L2:
        return flag;
_L5:
        j++;
        if (true) goto _L7; else goto _L6
_L6:
    }

    private int b() {
        for (int j = 1; j < f; j += 2) {
            int l = c(j);
            if (l == -1 || !a(c, a[l]))
                continue;
            l = 0;
            for (int i1 = j; i1 < j + 7; i1++)
                l += e[i1];

            if (j == 1 || e[j - 1] >= l / 2)
                return j;
        }

        throw NotFoundException.a();
    }

    private void b(int j) {
        e[f] = j;
        f = f + 1;
        if (f >= e.length) {
            int ai[] = new int[f * 2];
            System.arraycopy(e, 0, ai, 0, f);
            e = ai;
        }
    }

    private int c(int j) {
        int l3;
        int i4;
        l3 = 0x7fffffff;
        i4 = j + 7;
        if (i4 < f) goto _L2; else goto _L1
_L1:
        j = -1;
_L4:
        return j;
_L2:
        int ai[] = e;
        int i1 = j;
        int j2 = 0x7fffffff;
        int l = 0;
        while (i1 < i4)  {
            int l2 = ai[i1];
            int k1 = j2;
            if (l2 < j2)
                k1 = l2;
            if (l2 > l)
                l = l2;
            i1 += 2;
            j2 = k1;
        }
        int k3 = (j2 + l) / 2;
        i1 = j + 1;
        l = 0;
        int l1;
        for (j2 = l3; i1 < i4; j2 = l1) {
            int i3 = ai[i1];
            l1 = j2;
            if (i3 < j2)
                l1 = i3;
            if (i3 > l)
                l = i3;
            i1 += 2;
        }

        int j3 = (j2 + l) / 2;
        i1 = 0;
        l = 0;
        int i2 = 128;
        while (i1 < 7)  {
            int k2;
            if ((i1 & 1) == 0)
                k2 = k3;
            else
                k2 = j3;
            i2 >>= 1;
            if (ai[j + i1] > k2)
                l |= i2;
            i1++;
        }
        for (int j1 = 0; j1 < b.length; j1++) {
            j = j1;
            if (b[j1] == l)
                continue; /* Loop/switch isn't completed */
        }

        j = -1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public h a(int j, com.google.zxing.common.a a1, Map map) {
        int l;
        int i1;
        Arrays.fill(e, 0);
        a(a1);
        i1 = b();
        d.setLength(0);
        l = i1;
_L3:
        int j1;
        int l1;
        j1 = c(l);
        if (j1 == -1)
            throw NotFoundException.a();
        d.append((char)j1);
        l1 = l + 8;
        if (d.length() <= 1 || !a(c, a[j1])) goto _L2; else goto _L1
_L2:
        l = l1;
        if (l1 < f) goto _L3; else goto _L1
_L1:
        int i2 = e[l1 - 1];
        l = -8;
        int k1 = 0;
        for (; l < -1; l++)
            k1 += e[l1 + l];

        if (l1 < f && i2 < k1 / 2)
            throw NotFoundException.a();
        a(i1);
        for (l = 0; l < d.length(); l++)
            d.setCharAt(l, a[d.charAt(l)]);

        char c1 = d.charAt(0);
        if (!a(c, c1))
            throw NotFoundException.a();
        c1 = d.charAt(d.length() - 1);
        if (!a(c, c1))
            throw NotFoundException.a();
        if (d.length() <= 3)
            throw NotFoundException.a();
        if (map == null || !map.containsKey(DecodeHintType.i)) {
            d.deleteCharAt(d.length() - 1);
            d.deleteCharAt(0);
        }
        k1 = 0;
        int j2;
        for (l = 0; k1 < i1; l = j2 + l) {
            j2 = e[k1];
            k1++;
        }

        float f1 = l;
        for (; i1 < l1 - 1; i1++)
            l += e[i1];

        float f2 = l;
        String s = d.toString();
        i k2 = new i(f1, j);
        a1 = new i(f2, j);
        map = BarcodeFormat.b;
        return new h(s, null, new i[] {
            k2, a1
        }, map);
    }

    void a(int j) {
        boolean flag = false;
        int ai[] = new int[4];
        int[] _tmp = ai;
        ai[0] = 0;
        ai[1] = 0;
        ai[2] = 0;
        ai[3] = 0;
        int ai1[] = new int[4];
        int[] _tmp1 = ai1;
        ai1[0] = 0;
        ai1[1] = 0;
        ai1[2] = 0;
        ai1[3] = 0;
        int l2 = d.length() - 1;
        int i1 = 0;
        int l = j;
        int ai2[];
        int ai3[];
        do {
            int i2 = b[d.charAt(i1)];
            for (int j1 = 6; j1 >= 0; j1--) {
                int i3 = (j1 & 1) + (i2 & 1) * 2;
                ai[i3] = ai[i3] + e[l + j1];
                ai1[i3] = ai1[i3] + 1;
                i2 >>= 1;
            }

            if (i1 >= l2) {
                ai3 = new int[4];
                ai2 = new int[4];
                int k1 = 0;
                do {
                    l = ((flag) ? 1 : 0);
                    i1 = j;
                    if (k1 >= 2)
                        break;
                    ai2[k1] = 0;
                    ai2[k1 + 2] = (ai[k1] << 8) / ai1[k1] + (ai[k1 + 2] << 8) / ai1[k1 + 2] >> 1;
                    ai3[k1] = ai2[k1 + 2];
                    ai3[k1 + 2] = (ai[k1 + 2] * 512 + 384) / ai1[k1 + 2];
                    k1++;
                } while (true);
                break;
            }
            l += 8;
            i1++;
        } while (true);
        do {
            int l1 = b[d.charAt(l)];
            for (j = 6; j >= 0; j--) {
                int j2 = (j & 1) + (l1 & 1) * 2;
                int k2 = e[i1 + j] << 8;
                if (k2 < ai2[j2] || k2 > ai3[j2])
                    throw NotFoundException.a();
                l1 >>= 1;
            }

            if (l < l2) {
                i1 += 8;
                l++;
            } else {
                return;
            }
        } while (true);
    }

}
