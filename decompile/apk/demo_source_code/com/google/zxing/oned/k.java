// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.zxing.oned;

import com.google.zxing.*;
import com.google.zxing.common.a;
import com.google.zxing.*;
import java.util.*;

public abstract class k
    implements g {

    public k() {
    }

    protected static int a(int ai[], int ai1[], int j) {
        int l;
        int i1;
        int j2;
        int k2;
        j2 = 0x7fffffff;
        k2 = ai.length;
        int j1 = 0;
        i1 = 0;
        l = 0;
        for (; j1 < k2; j1++) {
            l += ai[j1];
            i1 += ai1[j1];
        }

        if (l >= i1) goto _L2; else goto _L1
_L1:
        int i2 = j2;
_L4:
        return i2;
_L2:
        int l2 = (l << 8) / i1;
        i1 = 0;
        int k1 = 0;
        while (i1 < k2)  {
            int l1 = ai[i1] << 8;
            i2 = ai1[i1] * l2;
            if (l1 > i2)
                l1 -= i2;
            else
                l1 = i2 - l1;
            i2 = j2;
            if (l1 > j * l2 >> 8)
                continue; /* Loop/switch isn't completed */
            k1 += l1;
            i1++;
        }
        i2 = k1 / l;
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected static void a(a a1, int j, int ai[]) {
        int l;
        int i1;
        int k1;
        int l1;
        k1 = ai.length;
        Arrays.fill(ai, 0, k1, 0);
        l1 = a1.a();
        if (j >= l1)
            throw NotFoundException.a();
        boolean flag;
        if (!a1.a(j))
            l = 1;
        else
            l = 0;
        flag = false;
        i1 = j;
        j = ((flag) ? 1 : 0);
        if (i1 >= l1) goto _L2; else goto _L1
_L1:
        if (!(a1.a(i1) ^ l)) goto _L4; else goto _L3
_L3:
        ai[j] = ai[j] + 1;
_L6:
        i1++;
        break MISSING_BLOCK_LABEL_47;
_L4:
        int j1;
        j1 = j + 1;
        if (j1 != k1)
            break MISSING_BLOCK_LABEL_124;
        j = j1;
_L2:
        if (j != k1 && (j != k1 - 1 || i1 != l1))
            throw NotFoundException.a();
        else
            return;
        ai[j1] = 1;
        if (l == 0)
            j = 1;
        else
            j = 0;
        l = j;
        j = j1;
        if (true) goto _L6; else goto _L5
_L5:
    }

    private h b(b b1, Map map) {
        int l;
        int l1;
        int i2;
        Object obj;
        i2 = b1.a();
        int k1 = b1.b();
        obj = new a(i2);
        int j;
        int j2;
        if (map != null && map.containsKey(DecodeHintType.d))
            j = 1;
        else
            j = 0;
        if (j != 0)
            l = 8;
        else
            l = 5;
        j2 = Math.max(1, k1 >> l);
        if (j != 0)
            j = k1;
        else
            j = 15;
        l = 0;
_L4:
label0:
        {
            if (l < j) {
                l1 = l + 1 >> 1;
                int i1;
                if ((l & 1) == 0)
                    i1 = 1;
                else
                    i1 = 0;
                if (i1 != 0)
                    i1 = l1;
                else
                    i1 = -l1;
                l1 = (k1 >> 1) + i1 * j2;
                if (l1 >= 0 && l1 < k1)
                    break label0;
            }
            throw NotFoundException.a();
        }
        Object obj1 = b1.a(l1, ((a) (obj)));
        int j1;
        obj = obj1;
        j1 = 0;
_L2:
        Object obj2;
        obj2 = obj;
        obj1 = map;
        if (j1 >= 2)
            break; /* Loop/switch isn't completed */
        if (j1 == 1) {
            ((a) (obj)).d();
            if (map != null && map.containsKey(DecodeHintType.j)) {
                obj1 = new EnumMap(com/google/zxing/DecodeHintType);
                ((Map) (obj1)).putAll(map);
                ((Map) (obj1)).remove(DecodeHintType.j);
                map = ((Map) (obj1));
            }
        }
        obj1 = a(l1, ((a) (obj)), map);
        if (j1 != 1)
            break MISSING_BLOCK_LABEL_362;
        i ai[];
        ((h) (obj1)).a(ResultMetadataType.b, Integer.valueOf(180));
        ai = ((h) (obj1)).c();
        if (ai == null)
            break MISSING_BLOCK_LABEL_362;
        obj2 = JVM INSTR new #110 <Class i>;
        ((i) (obj2)).i((float)i2 - ai[0].a() - 1.0F, ai[0].b());
        ai[0] = ((i) (obj2));
        ai[1] = new i((float)i2 - ai[1].a() - 1.0F, ai[1].b());
        return ((h) (obj1));
        obj1;
        j1++;
        if (true) goto _L2; else goto _L1
        obj1;
        obj1 = map;
        obj2 = obj;
_L1:
        l++;
        obj = obj2;
        map = ((Map) (obj1));
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected static void b(a a1, int j, int ai[]) {
        int l = ai.length;
        boolean flag = a1.a(j);
        do {
            if (j <= 0 || l < 0)
                break;
            int i1 = j - 1;
            j = i1;
            if (a1.a(i1) != flag) {
                l--;
                if (!flag) {
                    flag = true;
                    j = i1;
                } else {
                    flag = false;
                    j = i1;
                }
            }
        } while (true);
        if (l >= 0) {
            throw NotFoundException.a();
        } else {
            a(a1, j + 1, ai);
            return;
        }
    }

    public abstract h a(int j, a a1, Map map);

    public h a(b b1, Map map) {
        h h1 = b(b1, map);
        b1 = h1;
_L2:
        return b1;
        Object obj;
        obj;
        int j;
        if (map != null && map.containsKey(DecodeHintType.d))
            j = 1;
        else
            j = 0;
        if (j == 0 || !b1.d())
            break; /* Loop/switch isn't completed */
        obj = b1.e();
        b1 = b(((b) (obj)), map);
        map = b1.e();
        if (map != null && map.containsKey(ResultMetadataType.b))
            j = (((Integer)map.get(ResultMetadataType.b)).intValue() + 270) % 360;
        else
            j = 270;
        b1.a(ResultMetadataType.b, Integer.valueOf(j));
        map = b1.c();
        if (map != null) {
            int l = ((b) (obj)).b();
            j = 0;
            while (j < map.length)  {
                map[j] = new i((float)l - map[j].b() - 1.0F, map[j].a());
                j++;
            }
        }
        if (true) goto _L2; else goto _L1
_L1:
        throw obj;
    }

    public void a() {
    }
}
