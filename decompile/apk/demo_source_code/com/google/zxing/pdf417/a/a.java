// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.zxing.pdf417.a;

import com.google.zxing.b;
import com.google.zxing.i;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

// Referenced classes of package com.google.zxing.pdf417.a:
//            b

public final class a {

    private static final int a[] = {
        0, 4, 1, 5
    };
    private static final int b[] = {
        6, 2, 7, 3
    };
    private static final int c[] = {
        8, 1, 1, 1, 1, 1, 1, 3
    };
    private static final int d[] = {
        7, 1, 1, 3, 1, 1, 1, 2, 1
    };

    private static int a(int ai[], int ai1[], int j) {
        int k;
        int j1;
        int i2;
        int j2;
        i2 = 0x7fffffff;
        j2 = ai.length;
        int l = 0;
        j1 = 0;
        k = 0;
        for (; l < j2; l++) {
            k += ai[l];
            j1 += ai1[l];
        }

        if (k >= j1) goto _L2; else goto _L1
_L1:
        int k1 = i2;
_L4:
        return k1;
_L2:
        int k2 = (k << 8) / j1;
        int i1 = 0;
        j1 = 0;
        while (i1 < j2)  {
            k1 = ai[i1] << 8;
            int l1 = ai1[i1] * k2;
            if (k1 > l1)
                l1 = k1 - l1;
            else
                l1 -= k1;
            k1 = i2;
            if (l1 > j * k2 >> 8)
                continue; /* Loop/switch isn't completed */
            j1 += l1;
            i1++;
        }
        k1 = j1 / k;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public static com.google.zxing.pdf417.a.b a(b b1, Map map, boolean flag) {
        com.google.zxing.common.b b2 = b1.c();
        List list = a(flag, b2);
        map = list;
        b1 = b2;
        if (list.isEmpty()) {
            b1 = b2.g();
            b1.a();
            map = a(flag, ((com.google.zxing.common.b) (b1)));
        }
        return new com.google.zxing.pdf417.a.b(b1, map);
    }

    private static List a(boolean flag, com.google.zxing.common.b b1) {
        int j;
        int k;
        int l;
        ArrayList arraylist;
        arraylist = new ArrayList();
        k = 0;
        l = 0;
        j = 0;
_L8:
        if (j >= b1.f()) goto _L2; else goto _L1
_L1:
        i ai[] = a(b1, j, l);
        if (ai[0] != null || ai[3] != null) goto _L4; else goto _L3
_L3:
        if (k != 0) goto _L5; else goto _L2
_L2:
        return arraylist;
_L5:
        Iterator iterator = arraylist.iterator();
        do {
            if (!iterator.hasNext())
                break;
            ai = (i[])iterator.next();
            k = j;
            if (ai[1] != null)
                k = (int)Math.max(j, ai[1].b());
            j = k;
            if (ai[3] != null)
                j = Math.max(k, (int)ai[3].b());
        } while (true);
        l = 0;
        j += 5;
        k = 0;
        continue; /* Loop/switch isn't completed */
_L4:
        arraylist.add(ai);
        if (!flag) goto _L2; else goto _L6
_L6:
        int i1;
        if (ai[2] != null) {
            j = (int)ai[2].a();
            k = (int)ai[2].b();
        } else {
            j = (int)ai[4].a();
            k = (int)ai[4].b();
        }
        i1 = k;
        k = 1;
        l = j;
        j = i1;
        if (true) goto _L8; else goto _L7
_L7:
    }

    private static void a(i ai[], i ai1[], int ai2[]) {
        for (int j = 0; j < ai2.length; j++)
            ai[ai2[j]] = ai1[j];

    }

    private static int[] a(com.google.zxing.common.b b1, int j, int k, int l, boolean flag, int ai[], int ai1[]) {
        int j1;
        int k1;
        int l1;
        Arrays.fill(ai1, 0, ai1.length, 0);
        l1 = ai.length;
        for (int i1 = 0; b1.a(j, k) && j > 0 && i1 < 3; i1++)
            j--;

        boolean flag1 = false;
        j1 = j;
        k1 = j;
        j = j1;
        j1 = ((flag1) ? 1 : 0);
_L2:
        if (k1 >= l)
            break MISSING_BLOCK_LABEL_211;
        if (!(b1.a(k1, k) ^ flag))
            break; /* Loop/switch isn't completed */
        ai1[j1] = ai1[j1] + 1;
_L7:
        k1++;
        if (true) goto _L2; else goto _L1
_L1:
        if (j1 != l1 - 1) goto _L4; else goto _L3
_L3:
        if (a(ai1, ai, 204) >= 107) goto _L6; else goto _L5
_L5:
        b1 = new int[2];
        b1[0] = j;
        b1[1] = k1;
_L9:
        return b1;
_L6:
        j += ai1[0] + ai1[1];
        System.arraycopy(ai1, 2, ai1, 0, l1 - 2);
        ai1[l1 - 2] = 0;
        ai1[l1 - 1] = 0;
        j1--;
_L8:
        ai1[j1] = 1;
        if (!flag)
            flag = true;
        else
            flag = false;
          goto _L7
_L4:
        j1++;
          goto _L8
        if (j1 == l1 - 1 && a(ai1, ai, 204) < 107) {
            b1 = new int[2];
            b1[0] = j;
            b1[1] = k1 - 1;
        } else {
            b1 = null;
        }
          goto _L9
    }

    private static i[] a(com.google.zxing.common.b b1, int j, int k) {
        int l = b1.f();
        int i1 = b1.e();
        i ai[] = new i[8];
        a(ai, a(b1, l, i1, j, k, c), a);
        if (ai[4] != null) {
            k = (int)ai[4].a();
            j = (int)ai[4].b();
        }
        a(ai, a(b1, l, i1, j, k, d), b);
        return ai;
    }

    private static i[] a(com.google.zxing.common.b b1, int j, int k, int l, int i1, int ai[]) {
        int ai4[];
        i ai5[];
        ai5 = new i[4];
        ai4 = new int[ai.length];
_L10:
        int ai1[];
        if (l >= j)
            break MISSING_BLOCK_LABEL_352;
        ai1 = a(b1, i1, l, k, false, ai, ai4);
        if (ai1 == null) goto _L2; else goto _L1
_L1:
        int k1;
label0:
        {
            int j1 = l;
            do {
                l = j1;
                if (j1 <= 0)
                    break label0;
                j1--;
                int ai2[] = a(b1, i1, j1, k, false, ai, ai4);
                if (ai2 == null)
                    break;
                ai1 = ai2;
            } while (true);
            l = j1 + 1;
        }
        ai5[0] = new i(ai1[0], l);
        ai5[1] = new i(ai1[1], l);
        k1 = 1;
        i1 = l;
_L13:
        int l1;
        l = i1 + 1;
        l1 = l;
        if (k1 == 0) goto _L4; else goto _L3
_L3:
        ai1 = new int[2];
        ai1[0] = (int)ai5[0].a();
        ai1[1] = (int)ai5[1].a();
        l1 = 0;
        k1 = l;
_L9:
        if (k1 >= j) goto _L6; else goto _L5
_L5:
        int ai3[] = a(b1, ai1[0], k1, k, false, ai, ai4);
        if (ai3 == null || Math.abs(ai1[0] - ai3[0]) >= 5 || Math.abs(ai1[1] - ai3[1]) >= 5) goto _L8; else goto _L7
_L7:
        l = 0;
        ai1 = ai3;
_L12:
        k1++;
        l1 = l;
          goto _L9
_L2:
        l += 5;
          goto _L10
_L8:
        if (l1 <= 25) goto _L11; else goto _L6
_L6:
        l1 = k1 - (l1 + 1);
        ai5[2] = new i(ai1[0], l1);
        ai5[3] = new i(ai1[1], l1);
          goto _L4
_L11:
        l = l1 + 1;
          goto _L12
_L4:
        if (l1 - i1 < 10)
            for (j = 0; j < ai5.length; j++)
                ai5[j] = null;

        return ai5;
        k1 = 0;
        i1 = l;
          goto _L13
    }

}
