// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.zxing.common;

import com.google.zxing.a;
import com.google.zxing.c;
import java.lang.reflect.Array;

// Referenced classes of package com.google.zxing.common:
//            g, b

public final class i extends g {

    private b a;

    public i(c c1) {
        super(c1);
    }

    private static int a(int j, int k, int l) {
        if (j >= k)
            if (j > l)
                k = l;
            else
                k = j;
        return k;
    }

    private static void a(byte abyte0[], int j, int k, int l, int i1, b b1) {
        int k1 = k * i1 + j;
        for (int j1 = 0; j1 < 8;) {
            for (int l1 = 0; l1 < 8; l1++)
                if ((abyte0[k1 + l1] & 0xff) <= l)
                    b1.b(j + l1, k + j1);

            j1++;
            k1 += i1;
        }

    }

    private static void a(byte abyte0[], int j, int k, int l, int i1, int ai[][], b b1) {
        for (int j1 = 0; j1 < k; j1++) {
            int k1 = j1 << 3;
            int l1 = i1 - 8;
            if (k1 > l1)
                k1 = l1;
            for (int i2 = 0; i2 < j; i2++) {
                int j2 = i2 << 3;
                int k2 = l - 8;
                if (j2 > k2)
                    j2 = k2;
                int j3 = a(i2, 2, j - 3);
                int k3 = a(j1, 2, k - 3);
                int i3 = 0;
                for (int l2 = -2; l2 <= 2; l2++) {
                    int ai1[] = ai[k3 + l2];
                    int j4 = ai1[j3 - 2];
                    int k4 = ai1[j3 - 1];
                    int i4 = ai1[j3];
                    int l3 = ai1[j3 + 1];
                    i3 += ai1[j3 + 2] + (j4 + k4 + i4 + l3);
                }

                a(abyte0, j2, k1, i3 / 25, l, b1);
            }

        }

    }

    private static int[][] a(byte abyte0[], int j, int k, int l, int i1) {
        int j3;
        int ai[][];
        ai = (int[][])Array.newInstance(Integer.TYPE, new int[] {
            k, j
        });
        j3 = 0;
_L5:
        if (j3 >= k) goto _L2; else goto _L1
_L1:
        int k3;
        int l3;
        k3 = j3 << 3;
        int j1 = i1 - 8;
        if (k3 > j1)
            k3 = j1;
        l3 = 0;
_L4:
        if (l3 >= j)
            continue; /* Loop/switch isn't completed */
        int l1 = l3 << 3;
        int k1 = l - 8;
        int i2;
        int j2;
        int k2;
        boolean flag;
        if (l1 <= k1)
            k1 = l1;
        flag = false;
        i2 = 255;
        l1 = 0;
        j2 = 0;
        k2 = k3 * l + k1;
        k1 = ((flag) ? 1 : 0);
        int j4;
        for (; j2 < 8; j2 = j4 + 1) {
            for (int i4 = 0; i4 < 8;) {
                int l2 = abyte0[k2 + i4] & 0xff;
                if (l2 < i2)
                    i2 = l2;
                if (l2 > l1)
                    l1 = l2;
                i4++;
                k1 += l2;
            }

            int i3;
            int k4;
            if (l1 - i2 > 24) {
                i3 = k2 + l;
                k2 = j2 + 1;
                j2 = i3;
                do {
                    k4 = j2;
                    j4 = k2;
                    i3 = k1;
                    if (k2 >= 8)
                        break;
                    for (i3 = 0; i3 < 8; i3++)
                        k1 += abyte0[j2 + i3] & 0xff;

                    k2++;
                    j2 += l;
                } while (true);
            } else {
                i3 = k1;
                j4 = j2;
                k4 = k2;
            }
            k2 = k4 + l;
            k1 = i3;
        }

        k1 >>= 6;
        if (l1 - i2 <= 24) {
            if (j3 <= 0 || l3 <= 0)
                break MISSING_BLOCK_LABEL_394;
            k1 = ai[j3 - 1][l3] + ai[j3][l3 - 1] * 2 + ai[j3 - 1][l3 - 1] >> 2;
            if (i2 >= k1)
                break MISSING_BLOCK_LABEL_394;
        }
_L6:
        ai[j3][l3] = k1;
        l3++;
        if (true) goto _L4; else goto _L3
_L3:
        j3++;
          goto _L5
_L2:
        return ai;
        k1 = i2 >> 1;
          goto _L6
    }

    public a a(c c1) {
        return new i(c1);
    }

    public b b() {
        Object obj;
        if (a != null) {
            obj = a;
        } else {
            obj = a();
            int i1 = ((c) (obj)).b();
            int j1 = ((c) (obj)).c();
            if (i1 >= 40 && j1 >= 40) {
                byte abyte0[] = ((c) (obj)).a();
                int k = i1 >> 3;
                int j = k;
                if ((i1 & 7) != 0)
                    j = k + 1;
                int l = j1 >> 3;
                k = l;
                if ((j1 & 7) != 0)
                    k = l + 1;
                obj = a(abyte0, j, k, i1, j1);
                b b1 = new b(i1, j1);
                a(abyte0, j, k, i1, j1, ((int [][]) (obj)), b1);
                a = b1;
            } else {
                a = super.b();
            }
            obj = a;
        }
        return ((b) (obj));
    }
}
