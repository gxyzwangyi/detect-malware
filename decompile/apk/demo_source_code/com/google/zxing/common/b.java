// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.google.zxing.common;

import java.util.Arrays;

// Referenced classes of package com.google.zxing.common:
//            a

public final class b
    implements Cloneable {

    private final int a;
    private final int b;
    private final int c;
    private final int d[];

    public b(int i) {
        this(i, i);
    }

    public b(int i, int j) {
        if (i < 1 || j < 1) {
            throw new IllegalArgumentException("Both dimensions must be greater than 0");
        } else {
            a = i;
            b = j;
            c = i + 31 >> 5;
            d = new int[c * j];
            return;
        }
    }

    private b(int i, int j, int k, int ai[]) {
        a = i;
        b = j;
        c = k;
        d = ai;
    }

    public a a(int i, a a1) {
        int k;
        if (a1 == null || a1.a() < a)
            a1 = new a(a);
        else
            a1.b();
        k = c;
        for (int j = 0; j < c; j++)
            a1.a(j << 5, d[i * k + j]);

        return a1;
    }

    public void a() {
        int i = e();
        int k = f();
        a a1 = new a(i);
        a a2 = new a(i);
        for (int j = 0; j < (k + 1) / 2; j++) {
            a1 = a(j, a1);
            a2 = a(k - 1 - j, a2);
            a1.d();
            a2.d();
            b(j, a2);
            b(k - 1 - j, a1);
        }

    }

    public void a(int i, int j, int k, int l) {
        int i1;
        if (j < 0 || i < 0)
            throw new IllegalArgumentException("Left and top must be nonnegative");
        if (l < 1 || k < 1)
            throw new IllegalArgumentException("Height and width must be at least 1");
        i1 = i + k;
        l = j + l;
        if (l > b || i1 > a)
            throw new IllegalArgumentException("The region must fit inside the matrix");
_L4:
        if (j < l) {
            int j1 = c;
            k = i;
            while (k < i1)  {
                int ai[] = d;
                int k1 = (k >> 5) + j * j1;
                ai[k1] = ai[k1] | 1 << (k & 0x1f);
                k++;
            }
        } else {
            return;
        }
        if (true) goto _L2; else goto _L1
_L1:
        break; /* Loop/switch isn't completed */
_L2:
        j++;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public boolean a(int i, int j) {
        int k = c;
        boolean flag;
        if ((d[k * j + (i >> 5)] >>> (i & 0x1f) & 1) != 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public void b(int i, int j) {
        j = c * j + (i >> 5);
        int ai[] = d;
        ai[j] = ai[j] | 1 << (i & 0x1f);
    }

    public void b(int i, a a1) {
        System.arraycopy(a1.c(), 0, d, c * i, c);
    }

    public int[] b() {
        int i;
        int k;
        int l;
        int i1;
        int l1;
        i1 = a;
        l = b;
        k = -1;
        l1 = -1;
        i = 0;
_L12:
        if (i >= b) goto _L2; else goto _L1
_L1:
        int i2 = 0;
_L11:
        if (i2 >= c) goto _L4; else goto _L3
_L3:
        int j1;
        int j2;
        j2 = d[c * i + i2];
        if (j2 == 0)
            break MISSING_BLOCK_LABEL_298;
        j1 = l;
        if (i < l)
            j1 = i;
        l = l1;
        if (i > l1)
            l = i;
        if (i2 * 32 >= i1) goto _L6; else goto _L5
_L5:
        for (l1 = 0; j2 << 31 - l1 == 0; l1++);
        if (i2 * 32 + l1 >= i1) goto _L6; else goto _L7
_L7:
        l1 = i2 * 32 + l1;
_L14:
        if (i2 * 32 + 31 <= k) goto _L9; else goto _L8
_L8:
        for (i1 = 31; j2 >>> i1 == 0; i1--);
        if (i2 * 32 + i1 <= k) goto _L9; else goto _L10
_L10:
        int k2 = i2 * 32 + i1;
        k = l;
        i1 = j1;
        l = k2;
_L13:
        i2++;
        j1 = k;
        k = l;
        l = i1;
        i1 = l1;
        l1 = j1;
          goto _L11
_L4:
        i++;
          goto _L12
_L2:
        int j = k - i1;
        k = l1 - l;
        int ai[];
        if (j < 0 || k < 0) {
            ai = null;
        } else {
            ai = new int[4];
            ai[0] = i1;
            ai[1] = l;
            ai[2] = j;
            ai[3] = k;
        }
        return ai;
_L9:
        i1 = j1;
        j1 = k;
        k = l;
        l = j1;
          goto _L13
_L6:
        l1 = i1;
          goto _L14
        int k1 = i1;
        i1 = l;
        l = k;
        k = l1;
        l1 = k1;
          goto _L13
    }

    public void c(int i, int j) {
        j = c * j + (i >> 5);
        int ai[] = d;
        ai[j] = ai[j] ^ 1 << (i & 0x1f);
    }

    public int[] c() {
        int i;
        for (i = 0; i < d.length && d[i] == 0; i++);
        int ai[];
        if (i == d.length) {
            ai = null;
        } else {
            int l = i / c;
            int k = c;
            int i1 = d[i];
            int j;
            for (j = 0; i1 << 31 - j == 0; j++);
            ai = new int[2];
            ai[0] = (i % k << 5) + j;
            ai[1] = l;
        }
        return ai;
    }

    public Object clone() {
        return g();
    }

    public int[] d() {
        int i;
        for (i = d.length - 1; i >= 0 && d[i] == 0; i--);
        int ai[];
        if (i < 0) {
            ai = null;
        } else {
            int l = i / c;
            int k = c;
            int i1 = d[i];
            int j;
            for (j = 31; i1 >>> j == 0; j--);
            ai = new int[2];
            ai[0] = (i % k << 5) + j;
            ai[1] = l;
        }
        return ai;
    }

    public int e() {
        return a;
    }

    public boolean equals(Object obj) {
        boolean flag1 = false;
        if (obj instanceof b) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        obj = (b)obj;
        flag = flag1;
        if (a == ((b) (obj)).a) {
            flag = flag1;
            if (b == ((b) (obj)).b) {
                flag = flag1;
                if (c == ((b) (obj)).c) {
                    flag = flag1;
                    if (Arrays.equals(d, ((b) (obj)).d))
                        flag = true;
                }
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public int f() {
        return b;
    }

    public b g() {
        return new b(a, b, c, (int[])d.clone());
    }

    public int hashCode() {
        return (((a * 31 + a) * 31 + b) * 31 + c) * 31 + Arrays.hashCode(d);
    }

    public String toString() {
        StringBuilder stringbuilder = new StringBuilder(b * (a + 1));
        for (int i = 0; i < b; i++) {
            int j = 0;
            while (j < a)  {
                String s;
                if (a(j, i))
                    s = "X ";
                else
                    s = "  ";
                stringbuilder.append(s);
                j++;
            }
            stringbuilder.append('\n');
        }

        return stringbuilder.toString();
    }
}
