// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.barchart.udt.nio;

import com.barchart.udt.*;
import java.io.IOException;
import java.net.*;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import org.slf4j.b;
import org.slf4j.c;

// Referenced classes of package com.barchart.udt.nio:
//            a, KindUDT, h, e

public class k extends SocketChannel
    implements a {

    protected static final b a = org.slf4j.c.a(com/barchart/udt/nio/k);
    protected final Object b;
    protected volatile boolean c;
    protected volatile boolean d;
    protected volatile boolean e;
    protected e f;
    protected final SocketUDT g;

    protected k(h h1, SocketUDT socketudt) {
        super(h1);
        b = new Object();
        c = isBlocking();
        g = socketudt;
        g.a(true);
    }

    protected k(h h1, SocketUDT socketudt, boolean flag) {
        this(h1, socketudt);
        if (flag) {
            d = true;
            e = false;
        } else {
            d = false;
            e = true;
        }
    }

    public k a(SocketAddress socketaddress) {
        g.a((InetSocketAddress)socketaddress);
        return this;
    }

    public boolean a() {
        return d;
    }

    public KindUDT b() {
        return com.barchart.udt.nio.KindUDT.b;
    }

    public SocketUDT c() {
        return g;
    }

    public boolean connect(SocketAddress socketaddress) {
        boolean flag;
        flag = true;
        if (!isOpen())
            throw new ClosedChannelException();
        if (!isConnected()) goto _L2; else goto _L1
_L1:
        a.d("already connected; ignoring remote={}", socketaddress);
_L4:
        return flag;
_L2:
        Object obj;
        if (socketaddress == null) {
            close();
            a.d("remote == null");
            throw new NullPointerException();
        }
        obj = (InetSocketAddress)socketaddress;
        if (((InetSocketAddress) (obj)).isUnresolved()) {
            a.e("can not use unresolved address: remote={}", socketaddress);
            close();
            throw new UnresolvedAddressException();
        }
        if (!isBlocking())
            break MISSING_BLOCK_LABEL_205;
        socketaddress = ((SocketAddress) (b));
        socketaddress;
        JVM INSTR monitorenter ;
        if (e) {
            close();
            obj = JVM INSTR new #113 <Class ConnectionPendingException>;
            ((ConnectionPendingException) (obj)).ConnectionPendingException();
            throw obj;
        }
        break MISSING_BLOCK_LABEL_158;
        obj;
        end(true);
        e = false;
        b.notifyAll();
        throw obj;
        obj;
        socketaddress;
        JVM INSTR monitorexit ;
        throw obj;
        e = true;
        begin();
        g.b(((InetSocketAddress) (obj)));
        end(true);
        e = false;
        b.notifyAll();
        socketaddress;
        JVM INSTR monitorexit ;
        flag = g.r();
        continue; /* Loop/switch isn't completed */
        if (!isRegistered()) {
            a.d((new StringBuilder()).append("UDT channel is in NON blocking mode; must register with a selector before trying to connect(); socketId=").append(g.n()).toString());
            throw new IllegalBlockingModeException();
        }
        socketaddress = ((SocketAddress) (b));
        socketaddress;
        JVM INSTR monitorenter ;
        if (e) {
            close();
            a.d("connection already in progress");
            obj = JVM INSTR new #113 <Class ConnectionPendingException>;
            ((ConnectionPendingException) (obj)).ConnectionPendingException();
            throw obj;
        }
        break MISSING_BLOCK_LABEL_296;
        obj;
        socketaddress;
        JVM INSTR monitorexit ;
        throw obj;
        d = false;
        e = true;
        g.b(((InetSocketAddress) (obj)));
        socketaddress;
        JVM INSTR monitorexit ;
        flag = false;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public TypeUDT d() {
        return e().a();
    }

    public h e() {
        return (h)super.provider();
    }

    public e f() {
        this;
        JVM INSTR monitorenter ;
        e e1 = f;
        if (e1 != null)
            break MISSING_BLOCK_LABEL_25;
        e1 = JVM INSTR new #175 <Class e>;
        e1.e(this);
        f = e1;
_L1:
        e1 = f;
        this;
        JVM INSTR monitorexit ;
        return e1;
        Object obj;
        obj;
        a.d("failed to make socket", ((Throwable) (obj)));
          goto _L1
        obj;
        throw obj;
    }

    public boolean finishConnect() {
        if (!isOpen())
            throw new ClosedChannelException();
        if (!isBlocking()) goto _L2; else goto _L1
_L1:
        Object obj = b;
        obj;
        JVM INSTR monitorenter ;
_L3:
        boolean flag = e;
        if (!flag)
            break MISSING_BLOCK_LABEL_67;
        b.wait();
          goto _L3
        InterruptedException interruptedexception;
        interruptedexception;
        IOException ioexception = JVM INSTR new #191 <Class IOException>;
        ioexception.IOException(interruptedexception);
        throw ioexception;
        Exception exception;
        exception;
        obj;
        JVM INSTR monitorexit ;
        throw exception;
        obj;
        JVM INSTR monitorexit ;
_L2:
        if (isConnected()) {
            d = true;
            e = false;
            return true;
        } else {
            a.e("connect failure : {}", g);
            throw new IOException();
        }
    }

    protected void implCloseSelectableChannel() {
        g.b();
    }

    protected void implConfigureBlocking(boolean flag) {
        g.a(flag);
        c = flag;
    }

    public boolean isConnected() {
        return g.r();
    }

    public boolean isConnectionPending() {
        return e;
    }

    public int read(ByteBuffer bytebuffer) {
        boolean flag;
        int l;
        flag = false;
        l = bytebuffer.remaining();
        if (l > 0) goto _L2; else goto _L1
_L1:
        int j = ((flag) ? 1 : 0);
_L9:
        return j;
_L2:
        boolean flag1;
        SocketUDT socketudt;
        socketudt = g;
        flag1 = c;
        if (!flag1)
            break MISSING_BLOCK_LABEL_40;
        begin();
        if (!bytebuffer.isDirect()) goto _L4; else goto _L3
_L3:
        int i = socketudt.a(bytebuffer);
_L6:
        if (flag1)
            end(true);
        j = ((flag) ? 1 : 0);
        if (i >= 0) {
            j = ((flag) ? 1 : 0);
            int i1;
            byte abyte0[];
            if (i != 0)
                if (i <= l) {
                    j = i;
                } else {
                    a.e("should not happen: socket={}", socketudt);
                    j = ((flag) ? 1 : 0);
                }
        }
        continue; /* Loop/switch isn't completed */
_L4:
        abyte0 = bytebuffer.array();
        i1 = bytebuffer.position();
        j = socketudt.a(abyte0, i1, bytebuffer.limit());
        i = j;
        if (j <= 0) goto _L6; else goto _L5
_L5:
        i = j;
        if (j > l) goto _L6; else goto _L7
_L7:
        bytebuffer.position(i1 + j);
        i = j;
          goto _L6
        bytebuffer;
        if (flag1)
            end(true);
        throw bytebuffer;
        if (true) goto _L9; else goto _L8
_L8:
    }

    public long read(ByteBuffer abytebuffer[], int i, int j) {
        throw new RuntimeException("feature not available");
    }

    public Socket socket() {
        return f();
    }

    public String toString() {
        return g.toString();
    }

    public int write(ByteBuffer bytebuffer) {
        boolean flag;
        int l1;
        flag = false;
        if (bytebuffer == null)
            throw new NullPointerException("buffer == null");
        l1 = bytebuffer.remaining();
        if (l1 > 0) goto _L2; else goto _L1
_L1:
        int l = ((flag) ? 1 : 0);
_L9:
        return l;
_L2:
        boolean flag1;
        SocketUDT socketudt;
        socketudt = g;
        flag1 = c;
        if (!flag1)
            break MISSING_BLOCK_LABEL_56;
        begin();
        if (!bytebuffer.isDirect()) goto _L4; else goto _L3
_L3:
        int j = 0;
_L8:
        int i1 = socketudt.b(bytebuffer);
        int i;
        i = j;
        if (i1 > 0)
            i = j + i1;
        boolean flag2 = bytebuffer.hasRemaining();
        j = i1;
        l = i;
        if (!flag2) goto _L6; else goto _L5
_L5:
        j = i;
        if (flag1) goto _L8; else goto _L7
_L7:
        j = i1;
_L10:
        if (flag1)
            end(true);
        l = ((flag) ? 1 : 0);
        if (j >= 0) {
            l = ((flag) ? 1 : 0);
            int j1;
            int k1;
            int i2;
            boolean flag3;
            byte abyte0[];
            if (j != 0)
                if (i <= l1) {
                    l = i;
                } else {
                    a.e("should not happen; socket={}", socketudt);
                    l = ((flag) ? 1 : 0);
                }
        }
          goto _L9
_L4:
        abyte0 = bytebuffer.array();
        j = bytebuffer.position();
        i2 = bytebuffer.limit();
        j1 = 0;
_L11:
        k1 = socketudt.b(abyte0, j, i2);
        i = j;
        l = j1;
        if (k1 <= 0)
            break MISSING_BLOCK_LABEL_224;
        i = j;
        l = j1;
        if (k1 > l1)
            break MISSING_BLOCK_LABEL_224;
        l = j1 + k1;
        i = j + k1;
        bytebuffer.position(i);
        j1 = l;
        flag3 = bytebuffer.hasRemaining();
        j = k1;
        l = j1;
        if (flag3) {
            if (flag1)
                break MISSING_BLOCK_LABEL_297;
            l = j1;
            j = k1;
        }
_L6:
        i = l;
          goto _L10
        bytebuffer;
        if (flag1)
            end(true);
        throw bytebuffer;
        j = i;
          goto _L11
    }

    public long write(ByteBuffer abytebuffer[], int i, int j) {
        long l1;
        l1 = 0L;
        int l = i;
        do {
label0:
            {
                if (l >= i + j)
                    break MISSING_BLOCK_LABEL_82;
                ByteBuffer bytebuffer = abytebuffer[l];
                int i1;
                int j1;
                try {
                    i1 = bytebuffer.remaining();
                    j1 = write(bytebuffer);
                }
                // Misplaced declaration of an exception variable
                catch (ByteBuffer abytebuffer[]) {
                    throw new IOException("failed to write buffer array", abytebuffer);
                }
                if (i1 != j1)
                    break label0;
                l1 += j1;
                l++;
            }
        } while (true);
        abytebuffer = JVM INSTR new #263 <Class IllegalStateException>;
        abytebuffer.IllegalStateException("failed to write buffer in array");
        throw abytebuffer;
        return l1;
    }

}
