// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.barchart.udt.nio;

import com.barchart.udt.EpollUDT;
import com.barchart.udt.SocketUDT;
import com.barchart.udt.b.a;
import java.nio.IntBuffer;
import java.nio.channels.*;
import java.nio.channels.spi.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.slf4j.b;
import org.slf4j.c;

// Referenced classes of package com.barchart.udt.nio:
//            g, a

public class i extends AbstractSelector {

    protected static final b a = org.slf4j.c.a(com/barchart/udt/nio/i);
    public final int b;
    private final EpollUDT c = new EpollUDT();
    private final IntBuffer d;
    private final ConcurrentMap e = new ConcurrentHashMap();
    private final Set f;
    private volatile int g;
    private final ConcurrentMap h = new ConcurrentHashMap();
    private final Set i;
    private final Lock j = new ReentrantLock();
    private final IntBuffer k = com.barchart.udt.b.a.a(3);
    private final ConcurrentMap l = new ConcurrentHashMap();
    private volatile int m;
    private volatile int n;
    private final IntBuffer o;

    protected i(SelectorProvider selectorprovider, int i1) {
        super(selectorprovider);
        f = com.barchart.udt.b.a.a(e.values());
        i = com.barchart.udt.b.a.a(h.keySet());
        b = i1;
        d = com.barchart.udt.b.a.a(i1);
        o = com.barchart.udt.b.a.a(i1);
    }

    protected int a(long l1) {
        if (!isOpen()) {
            a.d("slector is closed");
            throw new ClosedSelectorException();
        }
        int i1;
        j.lock();
        i1 = b(l1);
        j.unlock();
        return i1;
        Exception exception;
        exception;
        j.unlock();
        throw exception;
    }

    protected void a() {
        if (!l.isEmpty()) {
            Iterator iterator = l.values().iterator();
            while (iterator.hasNext())  {
                g g1 = (g)iterator.next();
                iterator.remove();
                if (g1.isValid()) {
                    g1.a(false);
                    e.remove(Integer.valueOf(g1.g()));
                }
            }
        }
    }

    protected void a(int i1) {
        int k1 = k.get(0);
        int j1 = 0;
        while (j1 < k1)  {
            int l1 = d.get(j1);
            g g1 = (g)e.get(Integer.valueOf(l1));
            if (g1 == null)
                a("missing from read ", l1);
            else
            if (g1.d(i1))
                h.putIfAbsent(g1, g1);
            j1++;
        }
    }

    protected void a(g g1) {
        l.putIfAbsent(g1, g1);
    }

    protected void a(String s, int i1) {
        if (a.b())
            a.b("{} {}", s, String.format("[id: 0x%08x]", new Object[] {
                Integer.valueOf(i1)
            }));
    }

    protected int b(long l1) {
        a();
        c(l1);
        b();
        return h.size();
        Exception exception;
        exception;
        throw exception;
    }

    protected void b() {
        int i1 = g;
        g = i1 + 1;
        a(i1);
        b(i1);
    }

    protected void b(int i1) {
        int k1 = k.get(1);
        int j1 = 0;
        while (j1 < k1)  {
            int l1 = o.get(j1);
            g g1 = (g)e.get(Integer.valueOf(l1));
            if (g1 == null)
                a("missing from write", l1);
            else
            if (g1.e(i1))
                h.putIfAbsent(g1, g1);
            j1++;
        }
    }

    protected int c(long l1) {
        e();
        if (l1 >= 0L) goto _L2; else goto _L1
_L1:
        int i1;
label0:
        {
            int j1;
            do {
                j1 = d(10L);
                i1 = j1;
                if (j1 > 0)
                    break label0;
            } while (!d());
            i1 = j1;
        }
_L4:
        return i1;
_L2:
        if (l1 > 0L) {
            int k1;
            long l2;
            do {
                k1 = d(10L);
                i1 = k1;
                if (k1 > 0)
                    continue; /* Loop/switch isn't completed */
                i1 = k1;
                if (d())
                    continue; /* Loop/switch isn't completed */
                l2 = l1 - 10L;
                l1 = l2;
            } while (l2 > 0L);
            i1 = k1;
        } else {
            i1 = d(0L);
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected EpollUDT c() {
        return c;
    }

    protected int d(long l1) {
        return SocketUDT.a(c.b(), d, o, k, l1);
    }

    protected boolean d() {
        boolean flag;
        if (m != n)
            flag = true;
        else
            flag = false;
        return flag;
    }

    protected void e() {
        m = n;
    }

    protected void implCloseSelector() {
        wakeup();
        j.lock();
        for (Iterator iterator = e.values().iterator(); iterator.hasNext(); a((g)iterator.next()));
        break MISSING_BLOCK_LABEL_66;
        Exception exception;
        exception;
        j.unlock();
        throw exception;
        j.unlock();
        a();
        return;
    }

    public Set keys() {
        if (!isOpen())
            throw new ClosedSelectorException();
        else
            return f;
    }

    protected SelectionKey register(AbstractSelectableChannel abstractselectablechannel, int i1, Object obj) {
        if (e.size() >= b) {
            a.d("reached maximimSelectorSize");
            throw new IllegalSelectorException();
        }
        if (!(abstractselectablechannel instanceof com.barchart.udt.nio.a)) {
            a.d("!(channel instanceof ChannelUDT)");
            throw new IllegalSelectorException();
        }
        com.barchart.udt.nio.a a1 = (com.barchart.udt.nio.a)abstractselectablechannel;
        Integer integer = Integer.valueOf(a1.c().n());
        g g1 = (g)e.get(integer);
        abstractselectablechannel = g1;
        if (g1 == null) {
            abstractselectablechannel = new g(this, a1, obj);
            e.putIfAbsent(integer, abstractselectablechannel);
            abstractselectablechannel = (g)e.get(integer);
        }
        abstractselectablechannel.interestOps(i1);
        return abstractselectablechannel;
    }

    public int select() {
        return select(0L);
    }

    public int select(long l1) {
        if (l1 < 0L)
            throw new IllegalArgumentException("negative timeout");
        int i1;
        if (l1 > 0L)
            i1 = a(l1);
        else
            i1 = a(-1L);
        return i1;
    }

    public int selectNow() {
        return a(SocketUDT.c);
    }

    public Set selectedKeys() {
        if (!isOpen())
            throw new ClosedSelectorException();
        else
            return i;
    }

    public Selector wakeup() {
        n = n + 1;
        return this;
    }

}
