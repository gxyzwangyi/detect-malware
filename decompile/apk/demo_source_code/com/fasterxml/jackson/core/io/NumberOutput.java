// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.core.io;


public final class NumberOutput {

    private static int BILLION = 0x3b9aca00;
    private static final char FULL_3[];
    private static final byte FULL_TRIPLETS_B[];
    private static final char LEAD_3[];
    private static long MAX_INT_AS_LONG = 0x7fffffffL;
    private static int MILLION = 0xf4240;
    private static long MIN_INT_AS_LONG = 0x80000000L;
    private static final char NC = 0;
    static final String SMALLEST_LONG = String.valueOf(0x0L);
    private static long TEN_BILLION_L = 0x540be400L;
    private static long THOUSAND_L = 1000L;
    private static final String sSmallIntStrs[] = {
        "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", 
        "10"
    };
    private static final String sSmallIntStrs2[] = {
        "-1", "-2", "-3", "-4", "-5", "-6", "-7", "-8", "-9", "-10"
    };

    public NumberOutput() {
    }

    private static int calcLongStrLength(long l) {
        int i = 10;
        long l1 = TEN_BILLION_L;
        do {
            if (l < l1 || i == 19)
                return i;
            i++;
            l1 = (l1 << 1) + (l1 << 3);
        } while (true);
    }

    private static int full3(int i, byte abyte0[], int j) {
        int l = i << 2;
        int k = j + 1;
        byte abyte1[] = FULL_TRIPLETS_B;
        i = l + 1;
        abyte0[j] = abyte1[l];
        j = k + 1;
        abyte0[k] = FULL_TRIPLETS_B[i];
        abyte0[j] = FULL_TRIPLETS_B[i + 1];
        return j + 1;
    }

    private static int full3(int i, char ac[], int j) {
        int l = i << 2;
        i = j + 1;
        char ac1[] = FULL_3;
        int k = l + 1;
        ac[j] = ac1[l];
        j = i + 1;
        ac[i] = FULL_3[k];
        ac[j] = FULL_3[k + 1];
        return j + 1;
    }

    private static int leading3(int i, byte abyte0[], int j) {
        i <<= 2;
        char ac[] = LEAD_3;
        int k = i + 1;
        char c = ac[i];
        i = j;
        if (c != 0) {
            abyte0[j] = (byte)c;
            i = j + 1;
        }
        c = LEAD_3[k];
        j = i;
        if (c != 0) {
            abyte0[i] = (byte)c;
            j = i + 1;
        }
        abyte0[j] = (byte)LEAD_3[k + 1];
        return j + 1;
    }

    private static int leading3(int i, char ac[], int j) {
        i <<= 2;
        char ac1[] = LEAD_3;
        int k = i + 1;
        char c = ac1[i];
        i = j;
        if (c != 0) {
            ac[j] = c;
            i = j + 1;
        }
        c = LEAD_3[k];
        j = i;
        if (c != 0) {
            ac[i] = c;
            j = i + 1;
        }
        ac[j] = LEAD_3[k + 1];
        return j + 1;
    }

    public static int outputInt(int i, byte abyte0[], int j) {
        int k;
        int l;
        l = i;
        k = j;
        if (i >= 0) goto _L2; else goto _L1
_L1:
        if (i != 0x80000000) goto _L4; else goto _L3
_L3:
        i = outputLong(i, abyte0, j);
_L6:
        return i;
_L4:
        abyte0[j] = 45;
        l = -i;
        k = j + 1;
_L2:
        if (l < MILLION) {
            if (l < 1000) {
                if (l < 10) {
                    i = k + 1;
                    abyte0[k] = (byte)(l + 48);
                } else {
                    i = leading3(l, abyte0, k);
                }
            } else {
                i = l / 1000;
                i = full3(l - i * 1000, abyte0, leading3(i, abyte0, k));
            }
        } else {
            boolean flag;
            if (l >= BILLION)
                flag = true;
            else
                flag = false;
            i = l;
            j = k;
            if (flag) {
                i = l - BILLION;
                if (i >= BILLION) {
                    i -= BILLION;
                    abyte0[k] = 50;
                    j = k + 1;
                } else {
                    abyte0[k] = 49;
                    j = k + 1;
                }
            }
            k = i / 1000;
            l = k / 1000;
            if (flag)
                j = full3(l, abyte0, j);
            else
                j = leading3(l, abyte0, j);
            i = full3(i - k * 1000, abyte0, full3(k - l * 1000, abyte0, j));
        }
        if (true) goto _L6; else goto _L5
_L5:
    }

    public static int outputInt(int i, char ac[], int j) {
        int k;
        int l;
        l = i;
        k = j;
        if (i >= 0) goto _L2; else goto _L1
_L1:
        if (i != 0x80000000) goto _L4; else goto _L3
_L3:
        i = outputLong(i, ac, j);
_L6:
        return i;
_L4:
        ac[j] = '-';
        l = -i;
        k = j + 1;
_L2:
        if (l < MILLION) {
            if (l < 1000) {
                if (l < 10) {
                    i = k + 1;
                    ac[k] = (char)(l + 48);
                } else {
                    i = leading3(l, ac, k);
                }
            } else {
                i = l / 1000;
                i = full3(l - i * 1000, ac, leading3(i, ac, k));
            }
        } else {
            boolean flag;
            if (l >= BILLION)
                flag = true;
            else
                flag = false;
            i = l;
            j = k;
            if (flag) {
                i = l - BILLION;
                if (i >= BILLION) {
                    i -= BILLION;
                    ac[k] = '2';
                    j = k + 1;
                } else {
                    ac[k] = '1';
                    j = k + 1;
                }
            }
            l = i / 1000;
            k = l / 1000;
            if (flag)
                j = full3(k, ac, j);
            else
                j = leading3(k, ac, j);
            i = full3(i - l * 1000, ac, full3(l - k * 1000, ac, j));
        }
        if (true) goto _L6; else goto _L5
_L5:
    }

    public static int outputLong(long l, byte abyte0[], int i) {
        if (l >= 0L) goto _L2; else goto _L1
_L1:
        if (l <= MIN_INT_AS_LONG) goto _L4; else goto _L3
_L3:
        i = outputInt((int)l, abyte0, i);
_L8:
        return i;
_L4:
        int k;
        long l2;
        if (l == 0x0L) {
            int k1 = SMALLEST_LONG.length();
            int i1 = 0;
            int j = i;
            do {
                i = j;
                if (i1 >= k1)
                    continue; /* Loop/switch isn't completed */
                abyte0[j] = (byte)SMALLEST_LONG.charAt(i1);
                i1++;
                j++;
            } while (true);
        }
        abyte0[i] = 45;
        l2 = -l;
        k = i + 1;
_L6:
        int j1;
        j1 = k + calcLongStrLength(l2);
        i = j1;
        for (; l2 > MAX_INT_AS_LONG; l2 = l) {
            i -= 3;
            l = l2 / THOUSAND_L;
            full3((int)(l2 - THOUSAND_L * l), abyte0, i);
        }

        break; /* Loop/switch isn't completed */
_L2:
        l2 = l;
        k = i;
        if (l <= MAX_INT_AS_LONG) {
            i = outputInt((int)l, abyte0, i);
            continue; /* Loop/switch isn't completed */
        }
        if (true) goto _L6; else goto _L5
_L5:
        int i2 = (int)l2;
        int l1 = i;
        for (i = i2; i >= 1000; i = i2) {
            l1 -= 3;
            i2 = i / 1000;
            full3(i - i2 * 1000, abyte0, l1);
        }

        leading3(i, abyte0, k);
        i = j1;
        if (true) goto _L8; else goto _L7
_L7:
    }

    public static int outputLong(long l, char ac[], int i) {
        if (l >= 0L) goto _L2; else goto _L1
_L1:
        if (l <= MIN_INT_AS_LONG) goto _L4; else goto _L3
_L3:
        i = outputInt((int)l, ac, i);
_L8:
        return i;
_L4:
        int k;
        long l1;
        if (l == 0x0L) {
            int j = SMALLEST_LONG.length();
            SMALLEST_LONG.getChars(0, j, ac, i);
            i += j;
            continue; /* Loop/switch isn't completed */
        }
        ac[i] = '-';
        l1 = -l;
        k = i + 1;
_L6:
        int i1;
        i1 = k + calcLongStrLength(l1);
        i = i1;
        for (; l1 > MAX_INT_AS_LONG; l1 = l) {
            i -= 3;
            l = l1 / THOUSAND_L;
            full3((int)(l1 - THOUSAND_L * l), ac, i);
        }

        break; /* Loop/switch isn't completed */
_L2:
        l1 = l;
        k = i;
        if (l <= MAX_INT_AS_LONG) {
            i = outputInt((int)l, ac, i);
            continue; /* Loop/switch isn't completed */
        }
        if (true) goto _L6; else goto _L5
_L5:
        int k1 = (int)l1;
        int j1 = i;
        for (i = k1; i >= 1000; i = k1) {
            j1 -= 3;
            k1 = i / 1000;
            full3(i - k1 * 1000, ac, j1);
        }

        leading3(i, ac, k);
        i = i1;
        if (true) goto _L8; else goto _L7
_L7:
    }

    public static String toString(double d) {
        return Double.toString(d);
    }

    public static String toString(float f) {
        return Float.toString(f);
    }

    public static String toString(int i) {
        if (i >= sSmallIntStrs.length) goto _L2; else goto _L1
_L1:
        if (i < 0) goto _L4; else goto _L3
_L3:
        String s = sSmallIntStrs[i];
_L6:
        return s;
_L4:
        int j = -i - 1;
        if (j < sSmallIntStrs2.length) {
            s = sSmallIntStrs2[j];
            continue; /* Loop/switch isn't completed */
        }
_L2:
        s = Integer.toString(i);
        if (true) goto _L6; else goto _L5
_L5:
    }

    public static String toString(long l) {
        String s;
        if (l <= 0x7fffffffL && l >= 0x80000000L)
            s = toString((int)l);
        else
            s = Long.toString(l);
        return s;
    }

    static  {
        LEAD_3 = new char[4000];
        FULL_3 = new char[4000];
        int k = 0;
        int i = 0;
        for (; k < 10; k++) {
            char c2 = (char)(k + 48);
            char c;
            char c1;
            char c3;
            int l;
            if (k == 0)
                c = '\0';
            else
                c = c2;
            for (l = 0; l < 10; l++) {
                c3 = (char)(l + 48);
                int i1;
                if (k == 0 && l == 0)
                    c1 = '\0';
                else
                    c1 = c3;
                for (i1 = 0; i1 < 10; i1++) {
                    char c4 = (char)(i1 + 48);
                    LEAD_3[i] = c;
                    LEAD_3[i + 1] = c1;
                    LEAD_3[i + 2] = c4;
                    FULL_3[i] = c2;
                    FULL_3[i + 1] = c3;
                    FULL_3[i + 2] = c4;
                    i += 4;
                }

            }

        }

        FULL_TRIPLETS_B = new byte[4000];
        for (int j = 0; j < 4000; j++)
            FULL_TRIPLETS_B[j] = (byte)FULL_3[j];

    }
}
