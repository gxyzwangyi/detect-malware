// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.core.json;

import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.core.base.ParserBase;
import com.fasterxml.jackson.core.io.CharTypes;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;
import com.fasterxml.jackson.core.util.ByteArrayBuilder;
import com.fasterxml.jackson.core.util.TextBuffer;
import java.io.*;

// Referenced classes of package com.fasterxml.jackson.core.json:
//            JsonReadContext

public class ReaderBasedJsonParser extends ParserBase {

    protected static final int _icLatin1[] = CharTypes.getInputCodeLatin1();
    protected boolean _bufferRecyclable;
    protected final int _hashSeed;
    protected char _inputBuffer[];
    protected int _nameStartCol;
    protected long _nameStartOffset;
    protected int _nameStartRow;
    protected ObjectCodec _objectCodec;
    protected Reader _reader;
    protected final CharsToNameCanonicalizer _symbols;
    protected boolean _tokenIncomplete;

    public ReaderBasedJsonParser(IOContext iocontext, int i, Reader reader, ObjectCodec objectcodec, CharsToNameCanonicalizer charstonamecanonicalizer) {
        super(iocontext, i);
        _reader = reader;
        _inputBuffer = iocontext.allocTokenBuffer();
        _inputPtr = 0;
        _inputEnd = 0;
        _objectCodec = objectcodec;
        _symbols = charstonamecanonicalizer;
        _hashSeed = charstonamecanonicalizer.hashSeed();
        _bufferRecyclable = true;
    }

    public ReaderBasedJsonParser(IOContext iocontext, int i, Reader reader, ObjectCodec objectcodec, CharsToNameCanonicalizer charstonamecanonicalizer, char ac[], int j, 
            int k, boolean flag) {
        super(iocontext, i);
        _reader = reader;
        _inputBuffer = ac;
        _inputPtr = j;
        _inputEnd = k;
        _objectCodec = objectcodec;
        _symbols = charstonamecanonicalizer;
        _hashSeed = charstonamecanonicalizer.hashSeed();
        _bufferRecyclable = flag;
    }

    private String _handleOddName2(int i, int j, int ai[]) {
        int i1;
        char ac[];
        _textBuffer.resetWithShared(_inputBuffer, i, _inputPtr - i);
        ac = _textBuffer.getCurrentSegment();
        i = _textBuffer.getCurrentSegmentSize();
        i1 = ai.length;
_L5:
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        char c;
        _textBuffer.setCurrentLength(i);
        ai = _textBuffer;
        ac = ai.getTextBuffer();
        int k = ai.getTextOffset();
        i = ai.size();
        return _symbols.findSymbol(ac, k, i, j);
_L2:
        int l;
        if ((c = _inputBuffer[_inputPtr]) > i1 ? Character.isJavaIdentifierPart(c) : ai[c] == 0) goto _L3; else goto _L1
_L3:
        _inputPtr = _inputPtr + 1;
        j = j * 33 + c;
        l = i + 1;
        ac[i] = c;
        if (l >= ac.length) {
            ac = _textBuffer.finishCurrentSegment();
            i = 0;
        } else {
            i = l;
        }
        if (true) goto _L5; else goto _L4
_L4:
    }

    private final void _isNextTokenNameYes(int i) {
        _currToken = JsonToken.FIELD_NAME;
        _updateLocation();
        i;
        JVM INSTR lookupswitch 17: default 160
    //                   34: 170
    //                   45: 256
    //                   48: 267
    //                   49: 267
    //                   50: 267
    //                   51: 267
    //                   52: 267
    //                   53: 267
    //                   54: 267
    //                   55: 267
    //                   56: 267
    //                   57: 267
    //                   91: 185
    //                   102: 222
    //                   110: 239
    //                   116: 205
    //                   123: 195;
           goto _L1 _L2 _L3 _L4 _L4 _L4 _L4 _L4 _L4 _L4 _L4 _L4 _L4 _L5 _L6 _L7 _L8 _L9
_L1:
        _nextToken = _handleOddValue(i);
_L11:
        return;
_L2:
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        continue; /* Loop/switch isn't completed */
_L5:
        _nextToken = JsonToken.START_ARRAY;
        continue; /* Loop/switch isn't completed */
_L9:
        _nextToken = JsonToken.START_OBJECT;
        continue; /* Loop/switch isn't completed */
_L8:
        _matchToken("true", 1);
        _nextToken = JsonToken.VALUE_TRUE;
        continue; /* Loop/switch isn't completed */
_L6:
        _matchToken("false", 1);
        _nextToken = JsonToken.VALUE_FALSE;
        continue; /* Loop/switch isn't completed */
_L7:
        _matchToken("null", 1);
        _nextToken = JsonToken.VALUE_NULL;
        continue; /* Loop/switch isn't completed */
_L3:
        _nextToken = _parseNegNumber();
        continue; /* Loop/switch isn't completed */
_L4:
        _nextToken = _parsePosNumber(i);
        if (true) goto _L11; else goto _L10
_L10:
    }

    private final void _matchFalse() {
        int i = _inputPtr;
        if (i + 4 >= _inputEnd) goto _L2; else goto _L1
_L1:
        char ac[] = _inputBuffer;
        if (ac[i] != 'a') goto _L2; else goto _L3
_L3:
        i++;
        if (ac[i] != 'l') goto _L2; else goto _L4
_L4:
        i++;
        if (ac[i] != 's') goto _L2; else goto _L5
_L5:
        i++;
        if (ac[i] != 'e') goto _L2; else goto _L6
_L6:
        int j;
        j = i + 1;
        i = ac[j];
        if (i >= '0' && i != ']' && i != '}') goto _L2; else goto _L7
_L7:
        _inputPtr = j;
_L9:
        return;
_L2:
        _matchToken("false", 1);
        if (true) goto _L9; else goto _L8
_L8:
    }

    private final void _matchNull() {
        int i = _inputPtr;
        if (i + 3 >= _inputEnd) goto _L2; else goto _L1
_L1:
        char ac[] = _inputBuffer;
        if (ac[i] != 'u') goto _L2; else goto _L3
_L3:
        i++;
        if (ac[i] != 'l') goto _L2; else goto _L4
_L4:
        i++;
        if (ac[i] != 'l') goto _L2; else goto _L5
_L5:
        char c;
        i++;
        c = ac[i];
        if (c >= '0' && c != ']' && c != '}') goto _L2; else goto _L6
_L6:
        _inputPtr = i;
_L8:
        return;
_L2:
        _matchToken("null", 1);
        if (true) goto _L8; else goto _L7
_L7:
    }

    private final void _matchTrue() {
        int i = _inputPtr;
        if (i + 3 >= _inputEnd) goto _L2; else goto _L1
_L1:
        char ac[] = _inputBuffer;
        if (ac[i] != 'r') goto _L2; else goto _L3
_L3:
        i++;
        if (ac[i] != 'u') goto _L2; else goto _L4
_L4:
        i++;
        if (ac[i] != 'e') goto _L2; else goto _L5
_L5:
        int j;
        j = i + 1;
        i = ac[j];
        if (i >= '0' && i != ']' && i != '}') goto _L2; else goto _L6
_L6:
        _inputPtr = j;
_L8:
        return;
_L2:
        _matchToken("true", 1);
        if (true) goto _L8; else goto _L7
_L7:
    }

    private final JsonToken _nextAfterName() {
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        if (jsontoken != JsonToken.START_ARRAY) goto _L2; else goto _L1
_L1:
        _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
_L4:
        _currToken = jsontoken;
        return jsontoken;
_L2:
        if (jsontoken == JsonToken.START_OBJECT)
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final JsonToken _nextTokenNotInObject(int i) {
        if (i != 34) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _tokenIncomplete = true;
        jsontoken = JsonToken.VALUE_STRING;
        _currToken = jsontoken;
_L4:
        return jsontoken;
_L2:
        switch (i) {
        default:
            jsontoken = _handleOddValue(i);
            _currToken = jsontoken;
            break;

        case 91: // '['
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            jsontoken = JsonToken.START_ARRAY;
            _currToken = jsontoken;
            break;

        case 123: // '{'
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            jsontoken = JsonToken.START_OBJECT;
            _currToken = jsontoken;
            break;

        case 116: // 't'
            _matchToken("true", 1);
            jsontoken = JsonToken.VALUE_TRUE;
            _currToken = jsontoken;
            break;

        case 102: // 'f'
            _matchToken("false", 1);
            jsontoken = JsonToken.VALUE_FALSE;
            _currToken = jsontoken;
            break;

        case 110: // 'n'
            _matchToken("null", 1);
            jsontoken = JsonToken.VALUE_NULL;
            _currToken = jsontoken;
            break;

        case 45: // '-'
            jsontoken = _parseNegNumber();
            _currToken = jsontoken;
            break;

        case 48: // '0'
        case 49: // '1'
        case 50: // '2'
        case 51: // '3'
        case 52: // '4'
        case 53: // '5'
        case 54: // '6'
        case 55: // '7'
        case 56: // '8'
        case 57: // '9'
            jsontoken = _parsePosNumber(i);
            _currToken = jsontoken;
            break;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final JsonToken _parseFloat(int i, int j, int k, boolean flag, int l) {
        int i1;
        int l1;
        boolean flag1;
        int k2;
        l1 = 0;
        flag1 = false;
        k2 = _inputEnd;
        if (i != 46)
            break MISSING_BLOCK_LABEL_368;
        i = 0;
        i1 = k;
_L11:
        if (i1 < k2) goto _L2; else goto _L1
_L1:
        Object obj = _parseNumber2(flag, j);
_L10:
        return ((JsonToken) (obj));
_L2:
        obj = _inputBuffer;
        k = i1 + 1;
        i1 = obj[i1];
        if (i1 >= '0' && i1 <= '9') goto _L4; else goto _L3
_L3:
        int k1;
        if (i == 0)
            reportUnexpectedNumberChar(i1, "Decimal point not followed by a digit");
        k1 = i;
        i = k;
        k = i1;
_L15:
        if (k == 101) goto _L6; else goto _L5
_L5:
        int i2;
        int j2;
        j2 = i;
        i2 = k;
        if (k != 69) goto _L7; else goto _L6
_L6:
        if (i < k2) goto _L9; else goto _L8
_L8:
        _inputPtr = j;
        obj = _parseNumber2(flag, j);
          goto _L10
_L4:
        i++;
        i1 = k;
          goto _L11
_L9:
        obj = _inputBuffer;
        i1 = i + 1;
        k = obj[i];
        if (k != 45 && k != 43) goto _L13; else goto _L12
_L12:
label0:
        {
            if (i1 < k2)
                break label0;
            _inputPtr = j;
            obj = _parseNumber2(flag, j);
        }
          goto _L10
        obj = _inputBuffer;
        i = i1 + 1;
        k = obj[i1];
        i1 = ((flag1) ? 1 : 0);
_L14:
label1:
        {
            if (k > 57 || k < 48)
                break MISSING_BLOCK_LABEL_268;
            i1++;
            if (i < k2)
                break label1;
            _inputPtr = j;
            obj = _parseNumber2(flag, j);
        }
          goto _L10
        k = _inputBuffer[i];
        i++;
          goto _L14
        l1 = i1;
        j2 = i;
        i2 = k;
        if (i1 == 0) {
            reportUnexpectedNumberChar(k, "Exponent indicator not followed by a digit");
            i2 = k;
            j2 = i;
            l1 = i1;
        }
_L7:
        i = j2 - 1;
        _inputPtr = i;
        if (_parsingContext.inRoot())
            _verifyRootSpace(i2);
        _textBuffer.resetWithShared(_inputBuffer, j, i - j);
        obj = resetFloat(flag, l, k1, l1);
          goto _L10
_L13:
        i = i1;
        i1 = ((flag1) ? 1 : 0);
          goto _L14
        k1 = 0;
        int j1 = i;
        i = k;
        k = j1;
          goto _L15
    }

    private String _parseName2(int i, int j, int k) {
        char ac[];
        _textBuffer.resetWithShared(_inputBuffer, i, _inputPtr - i);
        ac = _textBuffer.getCurrentSegment();
        i = _textBuffer.getCurrentSegmentSize();
_L5:
        char c;
        char c1;
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF((new StringBuilder()).append(": was expecting closing '").append((char)k).append("' for name").toString());
        char ac1[] = _inputBuffer;
        int l = _inputPtr;
        _inputPtr = l + 1;
        c1 = ac1[l];
        c = c1;
        if (c1 > '\\') goto _L2; else goto _L1
_L1:
        if (c1 != '\\') goto _L4; else goto _L3
_L3:
        c = _decodeEscaped();
_L2:
        j = j * 33 + c;
        int i1 = i + 1;
        ac[i] = c;
        TextBuffer textbuffer;
        if (i1 >= ac.length) {
            ac = _textBuffer.finishCurrentSegment();
            i = 0;
        } else {
            i = i1;
        }
        if (true) goto _L5; else goto _L4
_L4:
        c = c1;
        if (c1 <= k) {
            if (c1 == k) {
                _textBuffer.setCurrentLength(i);
                textbuffer = _textBuffer;
                ac = textbuffer.getTextBuffer();
                i = textbuffer.getTextOffset();
                k = textbuffer.size();
                return _symbols.findSymbol(ac, i, k, j);
            }
            c = c1;
            if (c1 < ' ') {
                _throwUnquotedSpace(c1, "name");
                c = c1;
            }
        }
          goto _L2
    }

    private final JsonToken _parseNumber2(boolean flag, int i) {
        int j = i;
        if (flag)
            j = i + 1;
        _inputPtr = j;
        char ac1[] = _textBuffer.emptyAndGetCurrentSegment();
        char c;
        char c1;
        int l;
        int i1;
        int j1;
        int k1;
        int l1;
        int i2;
        char c2;
        Object obj;
        if (flag) {
            i = 1;
            ac1[0] = '-';
        } else {
            i = 0;
        }
        j = 0;
        if (_inputPtr < _inputEnd) {
            char ac[] = _inputBuffer;
            int k = _inputPtr;
            _inputPtr = k + 1;
            c1 = ac[k];
        } else {
            c1 = getNextChar("No digit following minus sign");
        }
        c = c1;
        if (c1 == '0')
            c = _verifyNoLeadingZeroes();
        j1 = 0;
        if (c < '0' || c > '9')
            break MISSING_BLOCK_LABEL_873;
        l = j + 1;
        i1 = i;
        obj = ac1;
        if (i >= ac1.length) {
            obj = _textBuffer.finishCurrentSegment();
            i1 = 0;
        }
        j = i1 + 1;
        obj[i1] = c;
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        i = 1;
        c = '\0';
        i1 = l;
_L21:
        if (i1 != 0) goto _L4; else goto _L3
_L3:
        obj = _handleInvalidNumberStart(c, flag);
_L13:
        return ((JsonToken) (obj));
_L2:
        ac1 = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        c = ac1[i];
        i = j;
        ac1 = ((char []) (obj));
        j = l;
        break MISSING_BLOCK_LABEL_98;
_L4:
        l = 0;
        if (c != '.')
            break MISSING_BLOCK_LABEL_853;
        j1 = j + 1;
        obj[j] = c;
        j = j1;
_L16:
        if (_inputPtr < _inputEnd || loadMore()) goto _L6; else goto _L5
_L5:
        i = 1;
_L14:
        if (l == 0)
            reportUnexpectedNumberChar(c, "Decimal point not followed by a digit");
        j1 = l;
        l = j;
        j = i;
        ac1 = ((char []) (obj));
        i = l;
_L19:
        k1 = 0;
        if (c != 'e' && c != 'E') goto _L8; else goto _L7
_L7:
        l = i;
        obj = ac1;
        if (i >= ac1.length) {
            obj = _textBuffer.finishCurrentSegment();
            l = 0;
        }
        i = l + 1;
        obj[l] = c;
        if (_inputPtr < _inputEnd) {
            ac1 = _inputBuffer;
            l = _inputPtr;
            _inputPtr = l + 1;
            c = ac1[l];
        } else {
            c = getNextChar("expected a digit for number exponent");
        }
        if (c == '-' || c == '+') {
            if (i >= obj.length) {
                obj = _textBuffer.finishCurrentSegment();
                i = 0;
            }
            obj[i] = c;
            if (_inputPtr < _inputEnd) {
                ac1 = _inputBuffer;
                l = _inputPtr;
                _inputPtr = l + 1;
                c = ac1[l];
            } else {
                c = getNextChar("expected a digit for number exponent");
            }
            i++;
            l = k1;
        } else {
            l = k1;
        }
        if (c > '9' || c < '0') goto _L10; else goto _L9
_L9:
        l++;
        k1 = i;
        ac1 = ((char []) (obj));
        if (i >= obj.length) {
            ac1 = _textBuffer.finishCurrentSegment();
            k1 = 0;
        }
        i = k1 + 1;
        ac1[k1] = c;
        if (_inputPtr < _inputEnd || loadMore()) goto _L12; else goto _L11
_L11:
        k1 = l;
        l = 1;
        j = i;
        i = k1;
_L17:
        k1 = i;
        l1 = l;
        c2 = c;
        i2 = j;
        if (i == 0) {
            reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit");
            i2 = j;
            c2 = c;
            l1 = l;
            k1 = i;
        }
_L18:
        if (l1 == 0) {
            _inputPtr = _inputPtr - 1;
            if (_parsingContext.inRoot())
                _verifyRootSpace(c2);
        }
        _textBuffer.setCurrentLength(i2);
        obj = reset(flag, i1, j1, k1);
          goto _L13
_L6:
        ac1 = _inputBuffer;
        j1 = _inputPtr;
        _inputPtr = j1 + 1;
        c = ac1[j1];
        if (c >= '0' && c <= '9') goto _L15; else goto _L14
_L15:
        l++;
        if (j >= obj.length) {
            obj = _textBuffer.finishCurrentSegment();
            j = 0;
        }
        j1 = j + 1;
        obj[j] = c;
        j = j1;
          goto _L16
_L12:
        obj = _inputBuffer;
        k1 = _inputPtr;
        _inputPtr = k1 + 1;
        c = obj[k1];
        obj = ac1;
        break MISSING_BLOCK_LABEL_488;
_L10:
        k1 = j;
        j = i;
        i = l;
        l = k1;
          goto _L17
_L8:
        c2 = c;
        k1 = 0;
        l1 = j;
        i2 = i;
          goto _L18
        j1 = 0;
        l = i;
        i = j;
        ac1 = ((char []) (obj));
        j = l;
          goto _L19
        i1 = j;
        obj = ac1;
        j = i;
        i = j1;
        if (true) goto _L21; else goto _L20
_L20:
    }

    private final int _skipAfterComma2() {
        do {
            if (_inputPtr >= _inputEnd && !loadMore())
                break;
            char ac[] = _inputBuffer;
            int i = _inputPtr;
            _inputPtr = i + 1;
            i = ac[i];
            if (i > ' ') {
                if (i == '/')
                    _skipComment();
                else
                if (i != '#' || !_skipYAMLComment())
                    return i;
            } else
            if (i < ' ')
                if (i == '\n') {
                    _currInputRow = _currInputRow + 1;
                    _currInputRowStart = _inputPtr;
                } else
                if (i == '\r')
                    _skipCR();
                else
                if (i != '\t')
                    _throwInvalidSpace(i);
        } while (true);
        throw _constructError((new StringBuilder()).append("Unexpected end-of-input within/between ").append(_parsingContext.getTypeDesc()).append(" entries").toString());
    }

    private void _skipCComment() {
_L8:
        if (_inputPtr >= _inputEnd && !loadMore()) goto _L2; else goto _L1
_L1:
        int i;
        char ac[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        i = ac[i];
        if (i > '*')
            continue; /* Loop/switch isn't completed */
        if (i != '*') goto _L4; else goto _L3
_L3:
        if (_inputPtr < _inputEnd || loadMore()) goto _L5; else goto _L2
_L2:
        _reportInvalidEOF(" in a comment");
_L6:
        return;
_L5:
        if (_inputBuffer[_inputPtr] != '/')
            continue; /* Loop/switch isn't completed */
        _inputPtr = _inputPtr + 1;
        if (true) goto _L6; else goto _L4
_L4:
        if (i < ' ')
            if (i == '\n') {
                _currInputRow = _currInputRow + 1;
                _currInputRowStart = _inputPtr;
            } else
            if (i == '\r')
                _skipCR();
            else
            if (i != '\t')
                _throwInvalidSpace(i);
        if (true) goto _L8; else goto _L7
_L7:
    }

    private final int _skipColon() {
        if (_inputPtr + 4 < _inputEnd) goto _L2; else goto _L1
_L1:
        int i = _skipColon2(false);
_L4:
        return i;
_L2:
label0:
        {
            char c = _inputBuffer[_inputPtr];
            if (c == ':') {
                char ac[] = _inputBuffer;
                i = _inputPtr + 1;
                _inputPtr = i;
                i = ac[i];
                if (i > 32) {
                    if (i == 47 || i == 35)
                        i = _skipColon2(true);
                    else
                        _inputPtr = _inputPtr + 1;
                    continue; /* Loop/switch isn't completed */
                }
                if (i == 32 || i == 9) {
                    char ac1[] = _inputBuffer;
                    i = _inputPtr + 1;
                    _inputPtr = i;
                    i = ac1[i];
                    if (i > 32) {
                        if (i == 47 || i == 35)
                            i = _skipColon2(true);
                        else
                            _inputPtr = _inputPtr + 1;
                        continue; /* Loop/switch isn't completed */
                    }
                }
                i = _skipColon2(true);
                continue; /* Loop/switch isn't completed */
            }
            if (c != ' ') {
                i = c;
                if (c != '\t')
                    break label0;
            }
            char ac2[] = _inputBuffer;
            i = _inputPtr + 1;
            _inputPtr = i;
            i = ac2[i];
        }
        if (i == 58) {
            char ac3[] = _inputBuffer;
            i = _inputPtr + 1;
            _inputPtr = i;
            i = ac3[i];
            if (i > 32) {
                if (i == 47 || i == 35)
                    i = _skipColon2(true);
                else
                    _inputPtr = _inputPtr + 1;
                continue; /* Loop/switch isn't completed */
            }
            if (i == 32 || i == 9) {
                char ac4[] = _inputBuffer;
                i = _inputPtr + 1;
                _inputPtr = i;
                i = ac4[i];
                if (i > 32) {
                    if (i == 47 || i == 35)
                        i = _skipColon2(true);
                    else
                        _inputPtr = _inputPtr + 1;
                    continue; /* Loop/switch isn't completed */
                }
            }
            i = _skipColon2(true);
        } else {
            i = _skipColon2(false);
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final int _skipColon2(boolean flag) {
        do {
            if (_inputPtr >= _inputEnd)
                loadMoreGuaranteed();
            char ac[] = _inputBuffer;
            int i = _inputPtr;
            _inputPtr = i + 1;
            i = ac[i];
            if (i > ' ') {
                if (i == '/')
                    _skipComment();
                else
                if (i != '#' || !_skipYAMLComment()) {
                    if (flag)
                        return i;
                    if (i != ':')
                        _reportUnexpectedChar(i, "was expecting a colon to separate field name and value");
                    flag = true;
                }
            } else
            if (i < ' ')
                if (i == '\n') {
                    _currInputRow = _currInputRow + 1;
                    _currInputRowStart = _inputPtr;
                } else
                if (i == '\r')
                    _skipCR();
                else
                if (i != '\t')
                    _throwInvalidSpace(i);
        } while (true);
    }

    private final int _skipColonFast(int i) {
        int l;
        char c1;
        boolean flag;
        flag = true;
        char ac[] = _inputBuffer;
        l = i + 1;
        c1 = ac[i];
        if (c1 != ':') goto _L2; else goto _L1
_L1:
        int j;
        char ac1[] = _inputBuffer;
        j = l + 1;
        l = ac1[l];
        if (l <= 32) goto _L4; else goto _L3
_L3:
        i = j;
        if (l == 47) goto _L6; else goto _L5
_L5:
        i = j;
        if (l == 35) goto _L6; else goto _L7
_L7:
        _inputPtr = j;
        i = l;
_L11:
        return i;
_L4:
        if (l == 32) goto _L9; else goto _L8
_L8:
        i = j;
        if (l != 9) goto _L6; else goto _L9
_L9:
        char ac2[] = _inputBuffer;
        i = j + 1;
        j = ac2[j];
        if (j > ' ' && j != '/' && j != '#') {
            _inputPtr = i;
            i = j;
            continue; /* Loop/switch isn't completed */
        }
_L6:
        _inputPtr = i - 1;
        i = _skipColon2(true);
        continue; /* Loop/switch isn't completed */
_L2:
        int k;
label0:
        {
            if (c1 != ' ') {
                k = c1;
                i = l;
                if (c1 != '\t')
                    break label0;
            }
            k = _inputBuffer[l];
            i = l + 1;
        }
label1:
        {
            if (k != ':')
                flag = false;
            k = i;
            if (flag) {
                char ac3[] = _inputBuffer;
                k = i + 1;
                char c = ac3[i];
                if (c > ' ') {
                    i = k;
                    if (c != '/') {
                        i = k;
                        if (c != '#') {
                            _inputPtr = k;
                            i = c;
                            continue; /* Loop/switch isn't completed */
                        }
                    }
                    break label1;
                }
                if (c != ' ') {
                    i = k;
                    if (c != '\t')
                        break label1;
                }
                ac3 = _inputBuffer;
                i = k + 1;
                c = ac3[k];
                k = i;
                if (c > ' ') {
                    k = i;
                    if (c != '/') {
                        k = i;
                        if (c != '#') {
                            _inputPtr = i;
                            i = c;
                            continue; /* Loop/switch isn't completed */
                        }
                    }
                }
            }
            i = k;
        }
        _inputPtr = i - 1;
        i = _skipColon2(flag);
        if (true) goto _L11; else goto _L10
_L10:
    }

    private final int _skipComma(int i) {
        if (i != 44)
            _reportUnexpectedChar(i, (new StringBuilder()).append("was expecting comma to separate ").append(_parsingContext.getTypeDesc()).append(" entries").toString());
_L3:
        char c;
        if (_inputPtr >= _inputEnd)
            break MISSING_BLOCK_LABEL_172;
        char ac[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        c = ac[i];
        if (c <= ' ') goto _L2; else goto _L1
_L1:
label0:
        {
            if (c != '/') {
                i = c;
                if (c != '#')
                    break label0;
            }
            _inputPtr = _inputPtr - 1;
            i = _skipAfterComma2();
        }
_L4:
        return i;
_L2:
        if (c < ' ')
            if (c == '\n') {
                _currInputRow = _currInputRow + 1;
                _currInputRowStart = _inputPtr;
            } else
            if (c == '\r')
                _skipCR();
            else
            if (c != '\t')
                _throwInvalidSpace(c);
          goto _L3
        i = _skipAfterComma2();
          goto _L4
    }

    private void _skipComment() {
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_COMMENTS))
            _reportUnexpectedChar(47, "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)");
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(" in a comment");
        char ac[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        i = ac[i];
        if (i == '/')
            _skipLine();
        else
        if (i == '*')
            _skipCComment();
        else
            _reportUnexpectedChar(i, "was expecting either '*' or '/' for a comment");
    }

    private void _skipLine() {
_L7:
        if (_inputPtr >= _inputEnd && !loadMore()) goto _L2; else goto _L1
_L1:
        int i;
        char ac[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        i = ac[i];
        if (i >= ' ')
            continue; /* Loop/switch isn't completed */
        if (i != '\n') goto _L4; else goto _L3
_L3:
        _currInputRow = _currInputRow + 1;
        _currInputRowStart = _inputPtr;
_L2:
        return;
_L4:
        if (i != '\r')
            break; /* Loop/switch isn't completed */
        _skipCR();
        if (true) goto _L2; else goto _L5
_L5:
        if (i != '\t')
            _throwInvalidSpace(i);
        if (true) goto _L7; else goto _L6
_L6:
    }

    private final int _skipWSOrEnd() {
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        int i = _eofAsNextChar();
_L9:
        return i;
_L2:
        char c;
        char ac[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        c = ac[i];
        if (c > ' ') {
            if (c != '/') {
                i = c;
                if (c != '#')
                    continue; /* Loop/switch isn't completed */
            }
            _inputPtr = _inputPtr - 1;
            i = _skipWSOrEnd2();
            continue; /* Loop/switch isn't completed */
        }
        if (c == ' ') goto _L4; else goto _L3
_L3:
        if (c != '\n') goto _L6; else goto _L5
_L5:
        _currInputRow = _currInputRow + 1;
        _currInputRowStart = _inputPtr;
_L4:
        if (_inputPtr >= _inputEnd)
            break; /* Loop/switch isn't completed */
        char ac1[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        c = ac1[i];
        if (c > ' ') {
            if (c != '/') {
                i = c;
                if (c != '#')
                    continue; /* Loop/switch isn't completed */
            }
            _inputPtr = _inputPtr - 1;
            i = _skipWSOrEnd2();
            continue; /* Loop/switch isn't completed */
        }
        if (c != ' ')
            if (c == '\n') {
                _currInputRow = _currInputRow + 1;
                _currInputRowStart = _inputPtr;
            } else
            if (c == '\r')
                _skipCR();
            else
            if (c != '\t')
                _throwInvalidSpace(c);
        continue; /* Loop/switch isn't completed */
_L6:
        if (c == '\r')
            _skipCR();
        else
        if (c != '\t')
            _throwInvalidSpace(c);
        continue; /* Loop/switch isn't completed */
        if (true) goto _L4; else goto _L7
_L7:
        i = _skipWSOrEnd2();
        if (true) goto _L9; else goto _L8
_L8:
    }

    private int _skipWSOrEnd2() {
_L7:
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        int i = _eofAsNextChar();
_L4:
        return i;
_L2:
        char c;
        char ac[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        c = ac[i];
        if (c <= ' ')
            break MISSING_BLOCK_LABEL_85;
        if (c == '/') {
            _skipComment();
            break; /* Loop/switch isn't completed */
        }
        i = c;
        if (c != '#') goto _L4; else goto _L3
_L3:
        i = c;
        if (!_skipYAMLComment()) goto _L4; else goto _L5
_L5:
        continue; /* Loop/switch isn't completed */
        if (c != ' ')
            if (c == '\n') {
                _currInputRow = _currInputRow + 1;
                _currInputRowStart = _inputPtr;
            } else
            if (c == '\r')
                _skipCR();
            else
            if (c != '\t')
                _throwInvalidSpace(c);
        if (true) goto _L7; else goto _L6
_L6:
    }

    private boolean _skipYAMLComment() {
        boolean flag;
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_YAML_COMMENTS)) {
            flag = false;
        } else {
            _skipLine();
            flag = true;
        }
        return flag;
    }

    private final void _updateLocation() {
        int i = _inputPtr;
        _tokenInputTotal = _currInputProcessed + (long)i;
        _tokenInputRow = _currInputRow;
        _tokenInputCol = i - _currInputRowStart;
    }

    private final void _updateNameLocation() {
        int i = _inputPtr;
        _nameStartOffset = i;
        _nameStartRow = _currInputRow;
        _nameStartCol = i - _currInputRowStart;
    }

    private char _verifyNLZ2() {
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        char c = '0';
_L4:
        return c;
_L2:
        char c1 = _inputBuffer[_inputPtr];
        if (c1 < '0' || c1 > '9') {
            c = '0';
            continue; /* Loop/switch isn't completed */
        }
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS))
            reportInvalidNumber("Leading zeroes not allowed");
        _inputPtr = _inputPtr + 1;
        c = c1;
        if (c1 != '0')
            continue; /* Loop/switch isn't completed */
        c = c1;
        do {
            if (_inputPtr >= _inputEnd && !loadMore())
                continue; /* Loop/switch isn't completed */
            c1 = _inputBuffer[_inputPtr];
            if (c1 < '0' || c1 > '9') {
                c = '0';
                continue; /* Loop/switch isn't completed */
            }
            _inputPtr = _inputPtr + 1;
            c = c1;
        } while (c1 == '0');
        c = c1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final char _verifyNoLeadingZeroes() {
        byte byte0 = 48;
        if (_inputPtr >= _inputEnd) goto _L2; else goto _L1
_L1:
        char c;
        char c1;
        c1 = _inputBuffer[_inputPtr];
        c = byte0;
        if (c1 < '0') goto _L4; else goto _L3
_L3:
        if (c1 <= '9') goto _L2; else goto _L5
_L5:
        c = byte0;
_L4:
        return c;
_L2:
        c = _verifyNLZ2();
        if (true) goto _L4; else goto _L6
_L6:
    }

    private final void _verifyRootSpace(int i) {
        _inputPtr = _inputPtr + 1;
        i;
        JVM INSTR lookupswitch 4: default 52
    //                   9: 57
    //                   10: 65
    //                   13: 58
    //                   32: 57;
           goto _L1 _L2 _L3 _L4 _L2
_L2:
        break; /* Loop/switch isn't completed */
_L1:
        _reportMissingRootWS(i);
_L6:
        return;
_L4:
        _skipCR();
        continue; /* Loop/switch isn't completed */
_L3:
        _currInputRow = _currInputRow + 1;
        _currInputRowStart = _inputPtr;
        if (true) goto _L6; else goto _L5
_L5:
    }

    protected void _closeInput() {
        if (_reader != null) {
            if (_ioContext.isResourceManaged() || isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.AUTO_CLOSE_SOURCE))
                _reader.close();
            _reader = null;
        }
    }

    protected byte[] _decodeBase64(Base64Variant base64variant) {
        ByteArrayBuilder bytearraybuilder = _getByteArrayBuilder();
_L8:
        char c;
        int j;
        int k;
        do {
            if (_inputPtr >= _inputEnd)
                loadMoreGuaranteed();
            char ac[] = _inputBuffer;
            int i = _inputPtr;
            _inputPtr = i + 1;
            c = ac[i];
        } while (c <= ' ');
        k = base64variant.decodeBase64Char(c);
        j = k;
        if (k >= 0) goto _L2; else goto _L1
_L1:
        if (c != '"') goto _L4; else goto _L3
_L3:
        base64variant = bytearraybuilder.toByteArray();
_L6:
        return base64variant;
_L4:
        j = _decodeBase64Escape(base64variant, c, 0);
        if (j < 0)
            continue; /* Loop/switch isn't completed */
_L2:
        int i1;
        int j1;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        char ac1[] = _inputBuffer;
        int l = _inputPtr;
        _inputPtr = l + 1;
        c = ac1[l];
        i1 = base64variant.decodeBase64Char(c);
        l = i1;
        if (i1 < 0)
            l = _decodeBase64Escape(base64variant, c, 1);
        j1 = l | j << 6;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        ac1 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        c = ac1[j];
        i1 = base64variant.decodeBase64Char(c);
        l = i1;
        if (i1 < 0) {
            j = i1;
            if (i1 != -2) {
                if (c == '"' && !base64variant.usesPadding()) {
                    bytearraybuilder.append(j1 >> 4);
                    base64variant = bytearraybuilder.toByteArray();
                    continue; /* Loop/switch isn't completed */
                }
                j = _decodeBase64Escape(base64variant, c, 2);
            }
            l = j;
            if (j == -2) {
                if (_inputPtr >= _inputEnd)
                    loadMoreGuaranteed();
                ac1 = _inputBuffer;
                j = _inputPtr;
                _inputPtr = j + 1;
                c = ac1[j];
                if (!base64variant.usesPaddingChar(c))
                    throw reportInvalidBase64Char(base64variant, c, 3, (new StringBuilder()).append("expected padding character '").append(base64variant.getPaddingChar()).append("'").toString());
                bytearraybuilder.append(j1 >> 4);
                continue; /* Loop/switch isn't completed */
            }
        }
        j1 = j1 << 6 | l;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        ac1 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        c = ac1[j];
        l = base64variant.decodeBase64Char(c);
        i1 = l;
        if (l >= 0)
            break MISSING_BLOCK_LABEL_507;
        j = l;
        if (l == -2)
            break MISSING_BLOCK_LABEL_486;
        if (c != '"' || base64variant.usesPadding())
            break; /* Loop/switch isn't completed */
        bytearraybuilder.appendTwoBytes(j1 >> 2);
        base64variant = bytearraybuilder.toByteArray();
        if (true) goto _L6; else goto _L5
_L5:
        j = _decodeBase64Escape(base64variant, c, 3);
        i1 = j;
        if (j == -2) {
            bytearraybuilder.appendTwoBytes(j1 >> 2);
            continue; /* Loop/switch isn't completed */
        }
        bytearraybuilder.appendThreeBytes(i1 | j1 << 6);
        if (true) goto _L8; else goto _L7
_L7:
    }

    protected char _decodeEscaped() {
        char c;
        char c1;
        int i;
        i = 0;
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(" in character escape sequence");
        char ac[] = _inputBuffer;
        int j = _inputPtr;
        _inputPtr = j + 1;
        c1 = ac[j];
        c = c1;
        c1;
        JVM INSTR lookupswitch 9: default 140
    //                   34: 146
    //                   47: 146
    //                   92: 146
    //                   98: 148
    //                   102: 166
    //                   110: 160
    //                   114: 172
    //                   116: 154
    //                   117: 178;
           goto _L1 _L2 _L2 _L2 _L3 _L4 _L5 _L6 _L7 _L8
_L2:
        break; /* Loop/switch isn't completed */
_L1:
        c = _handleUnrecognizedCharacterEscape(c1);
_L10:
        return c;
_L3:
        c = '\b';
        continue; /* Loop/switch isn't completed */
_L7:
        c = '\t';
        continue; /* Loop/switch isn't completed */
_L5:
        c = '\n';
        continue; /* Loop/switch isn't completed */
_L4:
        c = '\f';
        continue; /* Loop/switch isn't completed */
_L6:
        c = '\r';
        continue; /* Loop/switch isn't completed */
_L8:
        for (int k = 0; k < 4; k++) {
            if (_inputPtr >= _inputEnd && !loadMore())
                _reportInvalidEOF(" in character escape sequence");
            char ac1[] = _inputBuffer;
            int l = _inputPtr;
            _inputPtr = l + 1;
            l = ac1[l];
            int i1 = CharTypes.charToHex(l);
            if (i1 < 0)
                _reportUnexpectedChar(l, "expected a hex-digit for character escape sequence");
            i = i << 4 | i1;
        }

        c = (char)i;
        if (true) goto _L10; else goto _L9
_L9:
    }

    protected final void _finishString() {
        int i;
        int j;
        int k;
        i = _inputPtr;
        k = _inputEnd;
        j = i;
        if (i >= k) goto _L2; else goto _L1
_L1:
        int l;
        int ai[];
        ai = _icLatin1;
        l = ai.length;
_L5:
        char c = _inputBuffer[i];
        if (c >= l || ai[c] == 0) goto _L4; else goto _L3
_L3:
        j = i;
        if (c != '"')
            break; /* Loop/switch isn't completed */
        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, i - _inputPtr);
        _inputPtr = i + 1;
_L6:
        return;
_L4:
        j = i + 1;
        i = j;
        if (j < k) goto _L5; else goto _L2
_L2:
        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, j - _inputPtr);
        _inputPtr = j;
        _finishString2();
          goto _L6
    }

    protected void _finishString2() {
        int i;
        int l;
        char ac[];
        int ai[];
        ac = _textBuffer.getCurrentSegment();
        i = _textBuffer.getCurrentSegmentSize();
        ai = _icLatin1;
        l = ai.length;
_L2:
        char c;
        char c1;
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(": was expecting closing quote for a string value");
        char ac1[] = _inputBuffer;
        int j = _inputPtr;
        _inputPtr = j + 1;
        c1 = ac1[j];
        c = c1;
        if (c1 < l) {
            c = c1;
            if (ai[c1] != 0) {
                if (c1 == '"') {
                    _textBuffer.setCurrentLength(i);
                    return;
                }
                if (c1 != '\\')
                    break; /* Loop/switch isn't completed */
                c = _decodeEscaped();
            }
        }
_L3:
        if (i >= ac.length) {
            ac = _textBuffer.finishCurrentSegment();
            i = 0;
        }
        int k = i + 1;
        ac[i] = c;
        i = k;
        if (true) goto _L2; else goto _L1
_L1:
        c = c1;
        if (c1 < ' ') {
            _throwUnquotedSpace(c1, "string value");
            c = c1;
        }
          goto _L3
        if (true) goto _L2; else goto _L4
_L4:
    }

    protected final String _getText2(JsonToken jsontoken) {
        if (jsontoken != null) goto _L2; else goto _L1
_L1:
        jsontoken = null;
_L4:
        return jsontoken;
_L2:
        switch (jsontoken.id()) {
        default:
            jsontoken = jsontoken.asString();
            break;

        case 5: // '\005'
            jsontoken = _parsingContext.getCurrentName();
            break;

        case 6: // '\006'
        case 7: // '\007'
        case 8: // '\b'
            jsontoken = _textBuffer.contentsAsString();
            break;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected JsonToken _handleApos() {
        int i;
        char ac[];
        ac = _textBuffer.emptyAndGetCurrentSegment();
        i = _textBuffer.getCurrentSegmentSize();
_L2:
        char c;
        char c1;
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(": was expecting closing quote for a string value");
        char ac1[] = _inputBuffer;
        int j = _inputPtr;
        _inputPtr = j + 1;
        c1 = ac1[j];
        c = c1;
        if (c1 <= '\\') {
            if (c1 != '\\')
                break; /* Loop/switch isn't completed */
            c = _decodeEscaped();
        }
_L3:
        if (i >= ac.length) {
            ac = _textBuffer.finishCurrentSegment();
            i = 0;
        }
        int k = i + 1;
        ac[i] = c;
        i = k;
        if (true) goto _L2; else goto _L1
_L1:
        c = c1;
        if (c1 <= '\'') {
            if (c1 == '\'') {
                _textBuffer.setCurrentLength(i);
                return JsonToken.VALUE_STRING;
            }
            c = c1;
            if (c1 < ' ') {
                _throwUnquotedSpace(c1, "string value");
                c = c1;
            }
        }
          goto _L3
        if (true) goto _L2; else goto _L4
_L4:
    }

    protected JsonToken _handleInvalidNumberStart(int i, boolean flag) {
        double d;
        int j;
        d = (-1.0D / 0.0D);
        j = i;
        if (i != 73) goto _L2; else goto _L1
_L1:
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOFInValue();
        char ac[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        i = ac[i];
        if (i != 78) goto _L4; else goto _L3
_L3:
        Object obj;
        if (flag)
            obj = "-INF";
        else
            obj = "+INF";
        _matchToken(((String) (obj)), 3);
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS)) goto _L6; else goto _L5
_L5:
        if (!flag)
            d = (1.0D / 0.0D);
        obj = resetAsNaN(((String) (obj)), d);
_L7:
        return ((JsonToken) (obj));
_L6:
        _reportError((new StringBuilder()).append("Non-standard token '").append(((String) (obj))).append("': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow").toString());
        j = i;
_L2:
        reportUnexpectedNumberChar(j, "expected digit (0-9) to follow minus sign, for valid numeric value");
        obj = null;
          goto _L7
_L4:
        j = i;
        if (i != 110) goto _L2; else goto _L8
_L8:
label0:
        {
            if (flag)
                obj = "-Infinity";
            else
                obj = "+Infinity";
            _matchToken(((String) (obj)), 3);
            if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS))
                break label0;
            if (!flag)
                d = (1.0D / 0.0D);
            obj = resetAsNaN(((String) (obj)), d);
        }
          goto _L7
        _reportError((new StringBuilder()).append("Non-standard token '").append(((String) (obj))).append("': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow").toString());
        j = i;
          goto _L2
    }

    protected String _handleOddName(int i) {
        if (i != 39 || !isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_SINGLE_QUOTES)) goto _L2; else goto _L1
_L1:
        Object obj = _parseAposName();
_L4:
        return ((String) (obj));
_L2:
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES))
            _reportUnexpectedChar(i, "was expecting double-quote to start field name");
        obj = CharTypes.getInputCodeLatin1JsNames();
        int i1 = obj.length;
        int j;
        int k;
        int l;
        int j1;
        boolean flag;
        if (i < i1) {
            if (obj[i] == 0)
                flag = true;
            else
                flag = false;
        } else {
            flag = Character.isJavaIdentifierPart((char)i);
        }
        if (!flag)
            _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name");
        l = _inputPtr;
        j = _hashSeed;
        j1 = _inputEnd;
        k = j;
        i = l;
        if (l < j1) {
            i = l;
            do {
                k = _inputBuffer[i];
                if (k < i1) {
                    if (obj[k] != 0) {
                        k = _inputPtr - 1;
                        _inputPtr = i;
                        obj = _symbols.findSymbol(_inputBuffer, k, i - k, j);
                        continue; /* Loop/switch isn't completed */
                    }
                } else
                if (!Character.isJavaIdentifierPart((char)k)) {
                    k = _inputPtr - 1;
                    _inputPtr = i;
                    obj = _symbols.findSymbol(_inputBuffer, k, i - k, j);
                    continue; /* Loop/switch isn't completed */
                }
                k = j * 33 + k;
                l = i + 1;
                j = k;
                i = l;
            } while (l < j1);
            i = l;
        }
        j = _inputPtr;
        _inputPtr = i;
        obj = _handleOddName2(j - 1, k, ((int []) (obj)));
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected JsonToken _handleOddValue(int i) {
        i;
        JVM INSTR lookupswitch 4: default 44
    //                   39: 91
    //                   43: 193
    //                   73: 151
    //                   78: 109;
           goto _L1 _L2 _L3 _L4 _L5
_L1:
        Object obj;
        if (Character.isJavaIdentifierStart(i))
            _reportInvalidToken((new StringBuilder()).append("").append((char)i).toString(), "('true', 'false' or 'null')");
        _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')");
        obj = null;
_L7:
        return ((JsonToken) (obj));
_L2:
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_SINGLE_QUOTES)) goto _L1; else goto _L6
_L6:
        obj = _handleApos();
          goto _L7
_L5:
        _matchToken("NaN", 1);
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS)) goto _L9; else goto _L8
_L8:
        obj = resetAsNaN("NaN", (0.0D / 0.0D));
          goto _L7
_L9:
        _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow");
          goto _L1
_L4:
        _matchToken("Infinity", 1);
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS)) goto _L11; else goto _L10
_L10:
        obj = resetAsNaN("Infinity", (1.0D / 0.0D));
          goto _L7
_L11:
        _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow");
          goto _L1
_L3:
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOFInValue();
        obj = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        obj = _handleInvalidNumberStart(obj[i], false);
          goto _L7
    }

    protected boolean _isNextTokenNameMaybe(int i, String s) {
        boolean flag;
        String s1;
        if (i == 34)
            s1 = _parseName();
        else
            s1 = _handleOddName(i);
        _parsingContext.setCurrentName(s1);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
        _updateLocation();
        if (i != 34) goto _L2; else goto _L1
_L1:
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        flag = s.equals(s1);
_L12:
        return flag;
_L2:
        i;
        JVM INSTR lookupswitch 16: default 212
    //                   45: 235
    //                   48: 244
    //                   49: 244
    //                   50: 244
    //                   51: 244
    //                   52: 244
    //                   53: 244
    //                   54: 244
    //                   55: 244
    //                   56: 244
    //                   57: 244
    //                   91: 290
    //                   102: 254
    //                   110: 266
    //                   116: 278
    //                   123: 298;
           goto _L3 _L4 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L6 _L7 _L8 _L9 _L10
_L10:
        break MISSING_BLOCK_LABEL_298;
_L4:
        break; /* Loop/switch isn't completed */
_L3:
        JsonToken jsontoken = _handleOddValue(i);
_L13:
        _nextToken = jsontoken;
        flag = s.equals(s1);
        if (true) goto _L12; else goto _L11
_L11:
        jsontoken = _parseNegNumber();
          goto _L13
_L5:
        jsontoken = _parsePosNumber(i);
          goto _L13
_L7:
        _matchFalse();
        jsontoken = JsonToken.VALUE_FALSE;
          goto _L13
_L8:
        _matchNull();
        jsontoken = JsonToken.VALUE_NULL;
          goto _L13
_L9:
        _matchTrue();
        jsontoken = JsonToken.VALUE_TRUE;
          goto _L13
_L6:
        jsontoken = JsonToken.START_ARRAY;
          goto _L13
        jsontoken = JsonToken.START_OBJECT;
          goto _L13
    }

    protected final void _matchToken(String s, int i) {
        int j;
        int k = s.length();
        do {
            if (_inputPtr >= _inputEnd && !loadMore())
                _reportInvalidToken(s.substring(0, i));
            if (_inputBuffer[_inputPtr] != s.charAt(i))
                _reportInvalidToken(s.substring(0, i));
            _inputPtr = _inputPtr + 1;
            j = i + 1;
            i = j;
        } while (j < k);
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        return;
_L2:
        char c = _inputBuffer[_inputPtr];
        if (c >= '0' && c != ']' && c != '}' && Character.isJavaIdentifierPart(c))
            _reportInvalidToken(s.substring(0, j));
        if (true) goto _L1; else goto _L3
_L3:
    }

    protected String _parseAposName() {
        int i;
        int j;
        int k;
        int l;
        int i1;
        l = _inputPtr;
        k = _hashSeed;
        i1 = _inputEnd;
        i = k;
        j = l;
        if (l >= i1) goto _L2; else goto _L1
_L1:
        int j1;
        Object obj;
        obj = _icLatin1;
        j1 = obj.length;
        j = l;
        i = k;
_L8:
        k = _inputBuffer[j];
        if (k != 39) goto _L4; else goto _L3
_L3:
        k = _inputPtr;
        _inputPtr = j + 1;
        obj = _symbols.findSymbol(_inputBuffer, k, j - k, i);
_L6:
        return ((String) (obj));
_L4:
        if (k >= j1 || obj[k] == 0)
            break; /* Loop/switch isn't completed */
_L2:
        k = _inputPtr;
        _inputPtr = j;
        obj = _parseName2(k, i, 39);
        if (true) goto _L6; else goto _L5
_L5:
        l = i * 33 + k;
        k = j + 1;
        i = l;
        j = k;
        if (k < i1) goto _L8; else goto _L7
_L7:
        i = l;
        j = k;
          goto _L2
    }

    protected final String _parseName() {
        int i;
        int j;
        int ai[];
        i = _inputPtr;
        j = _hashSeed;
        ai = _icLatin1;
_L3:
        int k;
        if (i >= _inputEnd)
            break MISSING_BLOCK_LABEL_96;
        k = _inputBuffer[i];
        if (k >= ai.length || ai[k] == 0) goto _L2; else goto _L1
_L1:
        String s;
        if (k != 34)
            break MISSING_BLOCK_LABEL_96;
        k = _inputPtr;
        _inputPtr = i + 1;
        s = _symbols.findSymbol(_inputBuffer, k, i - k, j);
_L4:
        return s;
_L2:
        j = j * 33 + k;
        i++;
          goto _L3
        int l = _inputPtr;
        _inputPtr = i;
        s = _parseName2(l, j, 34);
          goto _L4
    }

    protected final JsonToken _parseNegNumber() {
        int i;
        int l;
        int i1;
        i = _inputPtr;
        l = i - 1;
        i1 = _inputEnd;
        if (i < i1) goto _L2; else goto _L1
_L1:
        Object obj = _parseNumber2(true, l);
_L9:
        return ((JsonToken) (obj));
_L2:
        int j;
        obj = _inputBuffer;
        j = i + 1;
        i = obj[i];
        if (i <= '9' && i >= '0') goto _L4; else goto _L3
_L3:
        _inputPtr = j;
        obj = _handleInvalidNumberStart(i, true);
          goto _L5
_L4:
        if (i != '0') goto _L7; else goto _L6
_L6:
        obj = _parseNumber2(true, l);
          goto _L5
_L7:
        i = 1;
_L10:
        if (j >= i1) {
            obj = _parseNumber2(true, l);
        } else {
label0:
            {
                obj = _inputBuffer;
                int k = j + 1;
                j = obj[j];
                if (j >= '0' && j <= '9')
                    break label0;
                if (j == '.' || j == 'e' || j == 'E') {
                    _inputPtr = k;
                    obj = _parseFloat(j, l, k, true, i);
                } else {
                    k--;
                    _inputPtr = k;
                    if (_parsingContext.inRoot())
                        _verifyRootSpace(j);
                    _textBuffer.resetWithShared(_inputBuffer, l, k - l);
                    obj = resetInt(true, i);
                }
            }
        }
_L5:
        if (true) goto _L9; else goto _L8
_L8:
        i++;
        j = k;
          goto _L10
    }

    protected final JsonToken _parsePosNumber(int i) {
        int j;
        int l;
        int i1;
        j = _inputPtr;
        l = j - 1;
        i1 = _inputEnd;
        if (i != 48) goto _L2; else goto _L1
_L1:
        Object obj = _parseNumber2(false, l);
_L4:
        return ((JsonToken) (obj));
_L2:
        i = 1;
_L5:
        if (j >= i1) {
            _inputPtr = l;
            obj = _parseNumber2(false, l);
        } else {
label0:
            {
                obj = _inputBuffer;
                int k = j + 1;
                j = obj[j];
                if (j >= '0' && j <= '9')
                    break label0;
                if (j == '.' || j == 'e' || j == 'E') {
                    _inputPtr = k;
                    obj = _parseFloat(j, l, k, false, i);
                } else {
                    k--;
                    _inputPtr = k;
                    if (_parsingContext.inRoot())
                        _verifyRootSpace(j);
                    _textBuffer.resetWithShared(_inputBuffer, l, k - l);
                    obj = resetInt(false, i);
                }
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
        i++;
        j = k;
          goto _L5
    }

    protected int _readBinary(Base64Variant base64variant, OutputStream outputstream, byte abyte0[]) {
        int i;
        int j;
        int k1;
        k1 = abyte0.length;
        j = 0;
        i = 0;
_L8:
        char c;
        int l;
        int i1;
        do {
            if (_inputPtr >= _inputEnd)
                loadMoreGuaranteed();
            char ac[] = _inputBuffer;
            int k = _inputPtr;
            _inputPtr = k + 1;
            c = ac[k];
        } while (c <= ' ');
        l = base64variant.decodeBase64Char(c);
        i1 = l;
        if (l >= 0) goto _L2; else goto _L1
_L1:
        if (c != '"') goto _L4; else goto _L3
_L3:
        l = i;
        i = j;
_L6:
        _tokenIncomplete = false;
        j = i;
        if (l > 0) {
            j = i + l;
            outputstream.write(abyte0, 0, l);
        }
        return j;
_L4:
        i1 = _decodeBase64Escape(base64variant, c, 0);
        if (i1 < 0)
            continue; /* Loop/switch isn't completed */
_L2:
        char c1;
        int j1;
        int l1;
        char ac1[];
        if (i > k1 - 3) {
            j += i;
            outputstream.write(abyte0, 0, i);
            l = 0;
            i = j;
        } else {
            l = i;
            i = j;
        }
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        ac1 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        c1 = ac1[j];
        j1 = base64variant.decodeBase64Char(c1);
        j = j1;
        if (j1 < 0)
            j = _decodeBase64Escape(base64variant, c1, 1);
        l1 = i1 << 6 | j;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        ac1 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        c1 = ac1[j];
        i1 = base64variant.decodeBase64Char(c1);
        j1 = i1;
        if (i1 < 0) {
            j = i1;
            if (i1 != -2) {
                if (c1 == '"' && !base64variant.usesPadding()) {
                    j = l + 1;
                    abyte0[l] = (byte)(l1 >> 4);
                    l = j;
                    continue; /* Loop/switch isn't completed */
                }
                j = _decodeBase64Escape(base64variant, c1, 2);
            }
            j1 = j;
            if (j == -2) {
                if (_inputPtr >= _inputEnd)
                    loadMoreGuaranteed();
                ac1 = _inputBuffer;
                j = _inputPtr;
                _inputPtr = j + 1;
                c1 = ac1[j];
                if (!base64variant.usesPaddingChar(c1))
                    throw reportInvalidBase64Char(base64variant, c1, 3, (new StringBuilder()).append("expected padding character '").append(base64variant.getPaddingChar()).append("'").toString());
                i1 = l + 1;
                abyte0[l] = (byte)(l1 >> 4);
                j = i;
                i = i1;
                continue; /* Loop/switch isn't completed */
            }
        }
        l1 = l1 << 6 | j1;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        ac1 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        c1 = ac1[j];
        j1 = base64variant.decodeBase64Char(c1);
        i1 = j1;
        if (j1 >= 0)
            break MISSING_BLOCK_LABEL_689;
        j = j1;
        if (j1 == -2)
            break MISSING_BLOCK_LABEL_632;
        if (c1 != '"' || base64variant.usesPadding())
            break; /* Loop/switch isn't completed */
        j = l1 >> 2;
        i1 = l + 1;
        abyte0[l] = (byte)(j >> 8);
        l = i1 + 1;
        abyte0[i1] = (byte)j;
        if (true) goto _L6; else goto _L5
_L5:
        j = _decodeBase64Escape(base64variant, c1, 3);
        i1 = j;
        if (j == -2) {
            j = l1 >> 2;
            i1 = l + 1;
            abyte0[l] = (byte)(j >> 8);
            l = i1 + 1;
            abyte0[i1] = (byte)j;
            j = i;
            i = l;
            continue; /* Loop/switch isn't completed */
        }
        j = l1 << 6 | i1;
        i1 = l + 1;
        abyte0[l] = (byte)(j >> 16);
        j1 = i1 + 1;
        abyte0[i1] = (byte)(j >> 8);
        l = j1 + 1;
        abyte0[j1] = (byte)j;
        j = i;
        i = l;
        if (true) goto _L8; else goto _L7
_L7:
    }

    protected void _releaseBuffers() {
        super._releaseBuffers();
        _symbols.release();
        if (_bufferRecyclable) {
            char ac[] = _inputBuffer;
            if (ac != null) {
                _inputBuffer = null;
                _ioContext.releaseTokenBuffer(ac);
            }
        }
    }

    protected void _reportInvalidToken(String s) {
        _reportInvalidToken(s, "'null', 'true', 'false' or NaN");
    }

    protected void _reportInvalidToken(String s, String s1) {
        s = new StringBuilder(s);
_L5:
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        char c;
        _reportError((new StringBuilder()).append("Unrecognized token '").append(s.toString()).append("': was expecting ").append(s1).toString());
        return;
_L2:
        if (!Character.isJavaIdentifierPart(c = _inputBuffer[_inputPtr])) goto _L1; else goto _L3
_L3:
        _inputPtr = _inputPtr + 1;
        s.append(c);
        if (true) goto _L5; else goto _L4
_L4:
    }

    protected final void _skipCR() {
        if ((_inputPtr < _inputEnd || loadMore()) && _inputBuffer[_inputPtr] == '\n')
            _inputPtr = _inputPtr + 1;
        _currInputRow = _currInputRow + 1;
        _currInputRowStart = _inputPtr;
    }

    protected final void _skipString() {
        _tokenIncomplete = false;
        int i = _inputPtr;
        int j = _inputEnd;
        char ac[] = _inputBuffer;
        do {
            int k = j;
            int l = i;
            if (i >= j) {
                _inputPtr = i;
                if (!loadMore())
                    _reportInvalidEOF(": was expecting closing quote for a string value");
                l = _inputPtr;
                k = _inputEnd;
            }
            i = l + 1;
            j = ac[l];
            if (j <= '\\') {
                if (j == '\\') {
                    _inputPtr = i;
                    _decodeEscaped();
                    i = _inputPtr;
                    j = _inputEnd;
                    continue;
                }
                if (j <= 34) {
                    if (j == 34) {
                        _inputPtr = i;
                        return;
                    }
                    if (j < 32) {
                        _inputPtr = i;
                        _throwUnquotedSpace(j, "string value");
                    }
                }
            }
            j = k;
        } while (true);
    }

    public byte[] getBinaryValue(Base64Variant base64variant) {
        if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null))
            _reportError((new StringBuilder()).append("Current token (").append(_currToken).append(") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary").toString());
        if (!_tokenIncomplete) goto _L2; else goto _L1
_L1:
        try {
            _binaryValue = _decodeBase64(base64variant);
        }
        catch (IllegalArgumentException illegalargumentexception) {
            throw _constructError((new StringBuilder()).append("Failed to decode VALUE_STRING as base64 (").append(base64variant).append("): ").append(illegalargumentexception.getMessage()).toString());
        }
        _tokenIncomplete = false;
_L4:
        return _binaryValue;
_L2:
        if (_binaryValue == null) {
            ByteArrayBuilder bytearraybuilder = _getByteArrayBuilder();
            _decodeBase64(getText(), bytearraybuilder, base64variant);
            _binaryValue = bytearraybuilder.toByteArray();
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public ObjectCodec getCodec() {
        return _objectCodec;
    }

    public JsonLocation getCurrentLocation() {
        int j = _inputPtr;
        int i = _currInputRowStart;
        return new JsonLocation(_ioContext.getSourceReference(), -1L, _currInputProcessed + (long)_inputPtr, _currInputRow, (j - i) + 1);
    }

    public Object getInputSource() {
        return _reader;
    }

    protected char getNextChar(String s) {
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(s);
        s = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        return s[i];
    }

    public final String getText() {
        Object obj = _currToken;
        if (obj == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            obj = _textBuffer.contentsAsString();
        } else {
            obj = _getText2(((JsonToken) (obj)));
        }
        return ((String) (obj));
    }

    public final char[] getTextCharacters() {
        if (_currToken == null) goto _L2; else goto _L1
_L1:
        _currToken.id();
        JVM INSTR tableswitch 5 8: default 44
    //                   5 54
    //                   6 136
    //                   7 152
    //                   8 152;
           goto _L3 _L4 _L5 _L6 _L6
_L3:
        Object obj = _currToken.asCharArray();
_L13:
        return ((char []) (obj));
_L4:
        if (_nameCopied) goto _L8; else goto _L7
_L7:
        int i;
        obj = _parsingContext.getCurrentName();
        i = ((String) (obj)).length();
        if (_nameCopyBuffer != null) goto _L10; else goto _L9
_L9:
        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(i);
_L11:
        ((String) (obj)).getChars(0, i, _nameCopyBuffer, 0);
        _nameCopied = true;
_L8:
        obj = _nameCopyBuffer;
        continue; /* Loop/switch isn't completed */
_L10:
        if (_nameCopyBuffer.length < i)
            _nameCopyBuffer = new char[i];
        if (true) goto _L11; else goto _L5
_L5:
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            _finishString();
        }
_L6:
        obj = _textBuffer.getTextBuffer();
        continue; /* Loop/switch isn't completed */
_L2:
        obj = null;
        if (true) goto _L13; else goto _L12
_L12:
    }

    public final int getTextLength() {
        int i = 0;
        if (_currToken == null) goto _L2; else goto _L1
_L1:
        _currToken.id();
        JVM INSTR tableswitch 5 8: default 48
    //                   5 59
    //                   6 73
    //                   7 89
    //                   8 89;
           goto _L3 _L4 _L5 _L6 _L6
_L3:
        i = _currToken.asCharArray().length;
_L2:
        return i;
_L4:
        i = _parsingContext.getCurrentName().length();
        continue; /* Loop/switch isn't completed */
_L5:
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            _finishString();
        }
_L6:
        i = _textBuffer.size();
        if (true) goto _L2; else goto _L7
_L7:
    }

    public final int getTextOffset() {
        int i;
        boolean flag;
        flag = false;
        i = ((flag) ? 1 : 0);
        if (_currToken == null) goto _L2; else goto _L1
_L1:
        i = ((flag) ? 1 : 0);
        _currToken.id();
        JVM INSTR tableswitch 5 8: default 52
    //                   5 54
    //                   6 56
    //                   7 72
    //                   8 72;
           goto _L3 _L4 _L5 _L6 _L6
_L4:
        break; /* Loop/switch isn't completed */
_L3:
        i = ((flag) ? 1 : 0);
_L2:
        return i;
_L5:
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            _finishString();
        }
_L6:
        i = _textBuffer.getTextOffset();
        if (true) goto _L2; else goto _L7
_L7:
    }

    public JsonLocation getTokenLocation() {
        Object obj = _ioContext.getSourceReference();
        if (_currToken == JsonToken.FIELD_NAME)
            obj = new JsonLocation(obj, -1L, _currInputProcessed + (_nameStartOffset - 1L), _nameStartRow, _nameStartCol);
        else
            obj = new JsonLocation(obj, -1L, _tokenInputTotal - 1L, _tokenInputRow, _tokenInputCol);
        return ((JsonLocation) (obj));
    }

    public final String getValueAsString() {
        String s;
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            s = _textBuffer.contentsAsString();
        } else
        if (_currToken == JsonToken.FIELD_NAME)
            s = getCurrentName();
        else
            s = super.getValueAsString(null);
        return s;
    }

    public final String getValueAsString(String s) {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString();
            }
            s = _textBuffer.contentsAsString();
        } else
        if (_currToken == JsonToken.FIELD_NAME)
            s = getCurrentName();
        else
            s = super.getValueAsString(s);
        return s;
    }

    protected boolean loadMore() {
        boolean flag1 = false;
        int i = _inputEnd;
        _currInputProcessed = _currInputProcessed + (long)i;
        _currInputRowStart = _currInputRowStart - i;
        _nameStartOffset = _nameStartOffset - (long)i;
        boolean flag = flag1;
        if (_reader != null) {
            int j = _reader.read(_inputBuffer, 0, _inputBuffer.length);
            if (j > 0) {
                _inputPtr = 0;
                _inputEnd = j;
                flag = true;
            } else {
                _closeInput();
                flag = flag1;
                if (j == 0)
                    throw new IOException((new StringBuilder()).append("Reader returned 0 characters when trying to read ").append(_inputEnd).toString());
            }
        }
        return flag;
    }

    public final Boolean nextBooleanValue() {
        Object obj = null;
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        _currToken = jsontoken;
        if (jsontoken != JsonToken.VALUE_TRUE) goto _L4; else goto _L3
_L3:
        Boolean boolean1 = Boolean.TRUE;
_L6:
        return boolean1;
_L4:
        if (jsontoken == JsonToken.VALUE_FALSE)
            boolean1 = Boolean.FALSE;
        else
        if (jsontoken == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            boolean1 = obj;
        } else {
            boolean1 = obj;
            if (jsontoken == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
                boolean1 = obj;
            }
        }
        continue; /* Loop/switch isn't completed */
_L2:
        JsonToken jsontoken1 = nextToken();
        boolean1 = obj;
        if (jsontoken1 != null) {
            int i = jsontoken1.id();
            if (i == 9) {
                boolean1 = Boolean.TRUE;
            } else {
                boolean1 = obj;
                if (i == 10)
                    boolean1 = Boolean.FALSE;
            }
        }
        if (true) goto _L6; else goto _L5
_L5:
    }

    public String nextFieldName() {
        _numTypesValid = 0;
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        Object obj;
        _nextAfterName();
        obj = null;
_L12:
        return ((String) (obj));
_L2:
        int i;
        String s;
        if (_tokenIncomplete)
            _skipString();
        int j = _skipWSOrEnd();
        if (j < 0) {
            close();
            _currToken = null;
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        _binaryValue = null;
        if (j == 93) {
            _updateLocation();
            if (!_parsingContext.inArray())
                _reportMismatchedEndMarker(j, '}');
            _parsingContext = _parsingContext.clearAndGetParent();
            _currToken = JsonToken.END_ARRAY;
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        if (j == 125) {
            _updateLocation();
            if (!_parsingContext.inObject())
                _reportMismatchedEndMarker(j, ']');
            _parsingContext = _parsingContext.clearAndGetParent();
            _currToken = JsonToken.END_OBJECT;
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        i = j;
        if (_parsingContext.expectComma())
            i = _skipComma(j);
        if (!_parsingContext.inObject()) {
            _updateLocation();
            _nextTokenNotInObject(i);
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        _updateNameLocation();
        if (i == 34)
            s = _parseName();
        else
            s = _handleOddName(i);
        _parsingContext.setCurrentName(s);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
        _updateLocation();
        if (i == 34) {
            _tokenIncomplete = true;
            _nextToken = JsonToken.VALUE_STRING;
            obj = s;
            continue; /* Loop/switch isn't completed */
        }
        i;
        JVM INSTR lookupswitch 16: default 420
    //                   45: 437
    //                   48: 445
    //                   49: 445
    //                   50: 445
    //                   51: 445
    //                   52: 445
    //                   53: 445
    //                   54: 445
    //                   55: 445
    //                   56: 445
    //                   57: 445
    //                   91: 487
    //                   102: 454
    //                   110: 465
    //                   116: 476
    //                   123: 494;
           goto _L3 _L4 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L6 _L7 _L8 _L9 _L10
_L10:
        break MISSING_BLOCK_LABEL_494;
_L4:
        break; /* Loop/switch isn't completed */
_L3:
        obj = _handleOddValue(i);
_L13:
        _nextToken = ((JsonToken) (obj));
        obj = s;
        if (true) goto _L12; else goto _L11
_L11:
        obj = _parseNegNumber();
          goto _L13
_L5:
        obj = _parsePosNumber(i);
          goto _L13
_L7:
        _matchFalse();
        obj = JsonToken.VALUE_FALSE;
          goto _L13
_L8:
        _matchNull();
        obj = JsonToken.VALUE_NULL;
          goto _L13
_L9:
        _matchTrue();
        obj = JsonToken.VALUE_TRUE;
          goto _L13
_L6:
        obj = JsonToken.START_ARRAY;
          goto _L13
        obj = JsonToken.START_OBJECT;
          goto _L13
    }

    public boolean nextFieldName(SerializableString serializablestring) {
        int i;
        boolean flag;
        _numTypesValid = 0;
        if (_currToken == JsonToken.FIELD_NAME) {
            _nextAfterName();
            flag = false;
        } else {
            if (_tokenIncomplete)
                _skipString();
            int j = _skipWSOrEnd();
            if (j < 0) {
                close();
                _currToken = null;
                flag = false;
            } else {
                _binaryValue = null;
                if (j == 93) {
                    _updateLocation();
                    if (!_parsingContext.inArray())
                        _reportMismatchedEndMarker(j, '}');
                    _parsingContext = _parsingContext.clearAndGetParent();
                    _currToken = JsonToken.END_ARRAY;
                    flag = false;
                } else
                if (j == 125) {
                    _updateLocation();
                    if (!_parsingContext.inObject())
                        _reportMismatchedEndMarker(j, ']');
                    _parsingContext = _parsingContext.clearAndGetParent();
                    _currToken = JsonToken.END_OBJECT;
                    flag = false;
                } else {
label0:
                    {
                        i = j;
                        if (_parsingContext.expectComma())
                            i = _skipComma(j);
                        if (_parsingContext.inObject())
                            break label0;
                        _updateLocation();
                        _nextTokenNotInObject(i);
                        flag = false;
                    }
                }
            }
        }
_L5:
        return flag;
        _updateNameLocation();
        if (i != 34) goto _L2; else goto _L1
_L1:
        int k;
        char ac[];
        ac = serializablestring.asQuotedChars();
        k = ac.length;
        if (_inputPtr + k + 4 >= _inputEnd) goto _L2; else goto _L3
_L3:
        int i1 = _inputPtr + k;
        if (_inputBuffer[i1] != '"') goto _L2; else goto _L4
_L4:
        int l;
        k = _inputPtr;
        l = 0;
_L6:
label1:
        {
            if (k != i1)
                break label1;
            _parsingContext.setCurrentName(serializablestring.getValue());
            _isNextTokenNameYes(_skipColonFast(k + 1));
            flag = true;
        }
          goto _L5
        if (ac[l] == _inputBuffer[k])
            break MISSING_BLOCK_LABEL_343;
_L2:
        flag = _isNextTokenNameMaybe(i, serializablestring.getValue());
          goto _L5
        l++;
        k++;
          goto _L6
    }

    public final int nextIntValue(int i) {
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        _currToken = jsontoken;
        if (jsontoken != JsonToken.VALUE_NUMBER_INT) goto _L4; else goto _L3
_L3:
        int j = getIntValue();
_L6:
        return j;
_L4:
        if (jsontoken == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            j = i;
        } else {
            j = i;
            if (jsontoken == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
                j = i;
            }
        }
        continue; /* Loop/switch isn't completed */
_L2:
        j = i;
        if (nextToken() == JsonToken.VALUE_NUMBER_INT)
            j = getIntValue();
        if (true) goto _L6; else goto _L5
_L5:
    }

    public final long nextLongValue(long l) {
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        _currToken = jsontoken;
        if (jsontoken != JsonToken.VALUE_NUMBER_INT) goto _L4; else goto _L3
_L3:
        long l1 = getLongValue();
_L6:
        return l1;
_L4:
        if (jsontoken == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            l1 = l;
        } else {
            l1 = l;
            if (jsontoken == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
                l1 = l;
            }
        }
        continue; /* Loop/switch isn't completed */
_L2:
        l1 = l;
        if (nextToken() == JsonToken.VALUE_NUMBER_INT)
            l1 = getLongValue();
        if (true) goto _L6; else goto _L5
_L5:
    }

    public final String nextTextValue() {
        Object obj = null;
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        _currToken = jsontoken;
        if (jsontoken != JsonToken.VALUE_STRING) goto _L4; else goto _L3
_L3:
        String s;
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            _finishString();
        }
        s = _textBuffer.contentsAsString();
_L6:
        return s;
_L4:
        if (jsontoken == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            s = obj;
        } else {
            s = obj;
            if (jsontoken == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
                s = obj;
            }
        }
        continue; /* Loop/switch isn't completed */
_L2:
        s = obj;
        if (nextToken() == JsonToken.VALUE_STRING)
            s = getText();
        if (true) goto _L6; else goto _L5
_L5:
    }

    public final JsonToken nextToken() {
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        Object obj = _nextAfterName();
_L20:
        return ((JsonToken) (obj));
_L2:
        int j;
        _numTypesValid = 0;
        if (_tokenIncomplete)
            _skipString();
        j = _skipWSOrEnd();
        if (j >= 0) goto _L4; else goto _L3
_L3:
        close();
        _currToken = null;
        obj = null;
          goto _L5
_L4:
        _binaryValue = null;
        if (j != 93) goto _L7; else goto _L6
_L6:
        _updateLocation();
        if (!_parsingContext.inArray())
            _reportMismatchedEndMarker(j, '}');
        _parsingContext = _parsingContext.clearAndGetParent();
        obj = JsonToken.END_ARRAY;
        _currToken = ((JsonToken) (obj));
          goto _L5
_L7:
        if (j != 125) goto _L9; else goto _L8
_L8:
        _updateLocation();
        if (!_parsingContext.inObject())
            _reportMismatchedEndMarker(j, ']');
        _parsingContext = _parsingContext.clearAndGetParent();
        obj = JsonToken.END_OBJECT;
        _currToken = ((JsonToken) (obj));
          goto _L5
_L9:
        boolean flag;
        int i = j;
        if (_parsingContext.expectComma())
            i = _skipComma(j);
        flag = _parsingContext.inObject();
        j = i;
        if (flag) {
            _updateNameLocation();
            if (i == 34)
                obj = _parseName();
            else
                obj = _handleOddName(i);
            _parsingContext.setCurrentName(((String) (obj)));
            _currToken = JsonToken.FIELD_NAME;
            j = _skipColon();
        }
        _updateLocation();
        j;
        JVM INSTR lookupswitch 19: default 404
    //                   34: 440
    //                   45: 559
    //                   48: 568
    //                   49: 568
    //                   50: 568
    //                   51: 568
    //                   52: 568
    //                   53: 568
    //                   54: 568
    //                   55: 568
    //                   56: 568
    //                   57: 568
    //                   91: 453
    //                   93: 515
    //                   102: 535
    //                   110: 547
    //                   116: 523
    //                   123: 484
    //                   125: 515;
           goto _L10 _L11 _L12 _L13 _L13 _L13 _L13 _L13 _L13 _L13 _L13 _L13 _L13 _L14 _L15 _L16 _L17 _L18 _L19 _L15
_L10:
        obj = _handleOddValue(j);
_L21:
        if (flag) {
            _nextToken = ((JsonToken) (obj));
            obj = _currToken;
        } else {
            _currToken = ((JsonToken) (obj));
        }
_L5:
        if (true) goto _L20; else goto _L11
_L11:
        _tokenIncomplete = true;
        obj = JsonToken.VALUE_STRING;
          goto _L21
_L14:
        if (!flag)
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
        obj = JsonToken.START_ARRAY;
          goto _L21
_L19:
        if (!flag)
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        obj = JsonToken.START_OBJECT;
          goto _L21
_L15:
        _reportUnexpectedChar(j, "expected a value");
_L18:
        _matchTrue();
        obj = JsonToken.VALUE_TRUE;
          goto _L21
_L16:
        _matchFalse();
        obj = JsonToken.VALUE_FALSE;
          goto _L21
_L17:
        _matchNull();
        obj = JsonToken.VALUE_NULL;
          goto _L21
_L12:
        obj = _parseNegNumber();
          goto _L21
_L13:
        obj = _parsePosNumber(j);
          goto _L21
    }

    public int readBinaryValue(Base64Variant base64variant, OutputStream outputstream) {
        if (_tokenIncomplete && _currToken == JsonToken.VALUE_STRING) goto _L2; else goto _L1
_L1:
        int i;
        base64variant = getBinaryValue(base64variant);
        outputstream.write(base64variant);
        i = base64variant.length;
_L4:
        return i;
_L2:
        byte abyte0[] = _ioContext.allocBase64Buffer();
        i = _readBinary(base64variant, outputstream, abyte0);
        _ioContext.releaseBase64Buffer(abyte0);
        if (true) goto _L4; else goto _L3
_L3:
        base64variant;
        _ioContext.releaseBase64Buffer(abyte0);
        throw base64variant;
    }

    public int releaseBuffered(Writer writer) {
        int i = _inputEnd - _inputPtr;
        if (i < 1) {
            i = 0;
        } else {
            int j = _inputPtr;
            writer.write(_inputBuffer, j, i);
        }
        return i;
    }

    public void setCodec(ObjectCodec objectcodec) {
        _objectCodec = objectcodec;
    }

}
