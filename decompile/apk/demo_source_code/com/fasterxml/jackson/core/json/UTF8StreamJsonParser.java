// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.core.json;

import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.core.base.ParserBase;
import com.fasterxml.jackson.core.io.CharTypes;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;
import com.fasterxml.jackson.core.util.ByteArrayBuilder;
import com.fasterxml.jackson.core.util.TextBuffer;
import java.io.*;
import java.util.Arrays;

// Referenced classes of package com.fasterxml.jackson.core.json:
//            JsonReadContext

public class UTF8StreamJsonParser extends ParserBase {

    static final byte BYTE_LF = 10;
    protected static final int _icLatin1[] = CharTypes.getInputCodeLatin1();
    private static final int _icUTF8[] = CharTypes.getInputCodeUtf8();
    protected boolean _bufferRecyclable;
    protected byte _inputBuffer[];
    protected InputStream _inputStream;
    protected int _nameStartCol;
    protected int _nameStartOffset;
    protected int _nameStartRow;
    protected ObjectCodec _objectCodec;
    private int _quad1;
    protected int _quadBuffer[];
    protected final ByteQuadsCanonicalizer _symbols;
    protected boolean _tokenIncomplete;

    public UTF8StreamJsonParser(IOContext iocontext, int i, InputStream inputstream, ObjectCodec objectcodec, ByteQuadsCanonicalizer bytequadscanonicalizer, byte abyte0[], int j, 
            int k, boolean flag) {
        super(iocontext, i);
        _quadBuffer = new int[16];
        _inputStream = inputstream;
        _objectCodec = objectcodec;
        _symbols = bytequadscanonicalizer;
        _inputBuffer = abyte0;
        _inputPtr = j;
        _inputEnd = k;
        _currInputRowStart = j;
        _currInputProcessed = -j;
        _bufferRecyclable = flag;
    }

    private final void _checkMatchEnd(String s, int i, int j) {
        if (Character.isJavaIdentifierPart((char)_decodeCharForError(j)))
            _reportInvalidToken(s.substring(0, i));
    }

    private final int _decodeUtf8_2(int i) {
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        byte abyte0[] = _inputBuffer;
        int j = _inputPtr;
        _inputPtr = j + 1;
        j = abyte0[j];
        if ((j & 0xc0) != 128)
            _reportInvalidOther(j & 0xff, _inputPtr);
        return j & 0x3f | (i & 0x1f) << 6;
    }

    private final int _decodeUtf8_3(int i) {
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        byte abyte0[] = _inputBuffer;
        int j = _inputPtr;
        _inputPtr = j + 1;
        j = abyte0[j];
        if ((j & 0xc0) != 128)
            _reportInvalidOther(j & 0xff, _inputPtr);
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte0 = _inputBuffer;
        int k = _inputPtr;
        _inputPtr = k + 1;
        k = abyte0[k];
        if ((k & 0xc0) != 128)
            _reportInvalidOther(k & 0xff, _inputPtr);
        return ((i & 0xf) << 6 | j & 0x3f) << 6 | k & 0x3f;
    }

    private final int _decodeUtf8_3fast(int i) {
        byte abyte0[] = _inputBuffer;
        int j = _inputPtr;
        _inputPtr = j + 1;
        j = abyte0[j];
        if ((j & 0xc0) != 128)
            _reportInvalidOther(j & 0xff, _inputPtr);
        abyte0 = _inputBuffer;
        int k = _inputPtr;
        _inputPtr = k + 1;
        k = abyte0[k];
        if ((k & 0xc0) != 128)
            _reportInvalidOther(k & 0xff, _inputPtr);
        return ((i & 0xf) << 6 | j & 0x3f) << 6 | k & 0x3f;
    }

    private final int _decodeUtf8_4(int i) {
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        byte abyte0[] = _inputBuffer;
        int j = _inputPtr;
        _inputPtr = j + 1;
        j = abyte0[j];
        if ((j & 0xc0) != 128)
            _reportInvalidOther(j & 0xff, _inputPtr);
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte0 = _inputBuffer;
        int k = _inputPtr;
        _inputPtr = k + 1;
        k = abyte0[k];
        if ((k & 0xc0) != 128)
            _reportInvalidOther(k & 0xff, _inputPtr);
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte0 = _inputBuffer;
        int l = _inputPtr;
        _inputPtr = l + 1;
        l = abyte0[l];
        if ((l & 0xc0) != 128)
            _reportInvalidOther(l & 0xff, _inputPtr);
        return (((j & 0x3f | (i & 7) << 6) << 6 | k & 0x3f) << 6 | l & 0x3f) - 0x10000;
    }

    private final void _finishString2(char ac[], int i) {
label0:
        {
label1:
            {
label2:
                {
                    int ai[] = _icUTF8;
                    byte abyte0[] = _inputBuffer;
                    char ac1[] = ac;
label3:
                    do {
                        {
                            int j;
                            int k;
label4:
                            {
                                j = _inputPtr;
                                k = j;
                                if (j >= _inputEnd) {
                                    loadMoreGuaranteed();
                                    k = _inputPtr;
                                }
                                ac = ac1;
                                j = i;
                                if (i >= ac1.length) {
                                    ac = _textBuffer.finishCurrentSegment();
                                    j = 0;
                                }
                                int l = Math.min(_inputEnd, (ac.length - j) + k);
                                do {
                                    if (k >= l)
                                        break;
                                    i = k + 1;
                                    k = abyte0[k] & 0xff;
                                    if (ai[k] != 0) {
                                        _inputPtr = i;
                                        if (k == 34) {
                                            _textBuffer.setCurrentLength(j);
                                            return;
                                        }
                                        break label4;
                                    }
                                    ac[j] = (char)k;
                                    k = i;
                                    j++;
                                } while (true);
                                _inputPtr = k;
                                ac1 = ac;
                                i = j;
                                continue;
                            }
                            int i1;
                            switch (ai[k]) {
                            default:
                                if (k < 32) {
                                    _throwUnquotedSpace(k, "string value");
                                    i = k;
                                } else {
                                    _reportInvalidChar(k);
                                    i = k;
                                }
                                break;

                            case 1: // '\001'
                                break label3;

                            case 2: // '\002'
                                break label2;

                            case 3: // '\003'
                                break label1;

                            case 4: // '\004'
                                break label0;
                            }
                        }
                        if (j >= ac.length) {
                            ac = _textBuffer.finishCurrentSegment();
                            j = 0;
                        }
                        k = j + 1;
                        ac[j] = (char)i;
                        ac1 = ac;
                        i = k;
                    } while (true);
                    i = _decodeEscaped();
                    break MISSING_BLOCK_LABEL_214;
                }
                i = _decodeUtf8_2(k);
                break MISSING_BLOCK_LABEL_214;
            }
            if (_inputEnd - _inputPtr >= 2)
                i = _decodeUtf8_3fast(k);
            else
                i = _decodeUtf8_3(k);
            break MISSING_BLOCK_LABEL_214;
        }
        i1 = _decodeUtf8_4(k);
        k = j + 1;
        ac[j] = (char)(0xd800 | i1 >> 10);
        i = k;
        ac1 = ac;
        if (k >= ac.length) {
            ac1 = _textBuffer.finishCurrentSegment();
            i = 0;
        }
        j = i;
        i = i1 & 0x3ff | 0xdc00;
        ac = ac1;
        break MISSING_BLOCK_LABEL_214;
    }

    private final boolean _isNextTokenNameMaybe(int i, SerializableString serializablestring) {
        boolean flag;
        String s = _parseName(i);
        _parsingContext.setCurrentName(s);
        flag = s.equals(serializablestring.getValue());
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
        _updateLocation();
        if (i != 34) goto _L2; else goto _L1
_L1:
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
_L12:
        return flag;
_L2:
        i;
        JVM INSTR lookupswitch 16: default 204
    //                   45: 274
    //                   48: 282
    //                   49: 282
    //                   50: 282
    //                   51: 282
    //                   52: 282
    //                   53: 282
    //                   54: 282
    //                   55: 282
    //                   56: 282
    //                   57: 282
    //                   91: 218
    //                   102: 246
    //                   110: 260
    //                   116: 232
    //                   123: 225;
           goto _L3 _L4 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L6 _L7 _L8 _L9 _L10
_L5:
        break MISSING_BLOCK_LABEL_282;
_L6:
        break; /* Loop/switch isn't completed */
_L3:
        serializablestring = _handleUnexpectedValue(i);
_L13:
        _nextToken = serializablestring;
        if (true) goto _L12; else goto _L11
_L11:
        serializablestring = JsonToken.START_ARRAY;
          goto _L13
_L10:
        serializablestring = JsonToken.START_OBJECT;
          goto _L13
_L9:
        _matchToken("true", 1);
        serializablestring = JsonToken.VALUE_TRUE;
          goto _L13
_L7:
        _matchToken("false", 1);
        serializablestring = JsonToken.VALUE_FALSE;
          goto _L13
_L8:
        _matchToken("null", 1);
        serializablestring = JsonToken.VALUE_NULL;
          goto _L13
_L4:
        serializablestring = _parseNegNumber();
          goto _L13
        serializablestring = _parsePosNumber(i);
          goto _L13
    }

    private final void _isNextTokenNameYes(int i) {
        _currToken = JsonToken.FIELD_NAME;
        _updateLocation();
        i;
        JVM INSTR lookupswitch 17: default 160
    //                   34: 170
    //                   45: 256
    //                   48: 267
    //                   49: 267
    //                   50: 267
    //                   51: 267
    //                   52: 267
    //                   53: 267
    //                   54: 267
    //                   55: 267
    //                   56: 267
    //                   57: 267
    //                   91: 185
    //                   102: 222
    //                   110: 239
    //                   116: 205
    //                   123: 195;
           goto _L1 _L2 _L3 _L4 _L4 _L4 _L4 _L4 _L4 _L4 _L4 _L4 _L4 _L5 _L6 _L7 _L8 _L9
_L1:
        _nextToken = _handleUnexpectedValue(i);
_L11:
        return;
_L2:
        _tokenIncomplete = true;
        _nextToken = JsonToken.VALUE_STRING;
        continue; /* Loop/switch isn't completed */
_L5:
        _nextToken = JsonToken.START_ARRAY;
        continue; /* Loop/switch isn't completed */
_L9:
        _nextToken = JsonToken.START_OBJECT;
        continue; /* Loop/switch isn't completed */
_L8:
        _matchToken("true", 1);
        _nextToken = JsonToken.VALUE_TRUE;
        continue; /* Loop/switch isn't completed */
_L6:
        _matchToken("false", 1);
        _nextToken = JsonToken.VALUE_FALSE;
        continue; /* Loop/switch isn't completed */
_L7:
        _matchToken("null", 1);
        _nextToken = JsonToken.VALUE_NULL;
        continue; /* Loop/switch isn't completed */
_L3:
        _nextToken = _parseNegNumber();
        continue; /* Loop/switch isn't completed */
_L4:
        _nextToken = _parsePosNumber(i);
        if (true) goto _L11; else goto _L10
_L10:
    }

    private final void _matchToken2(String s, int i) {
        int j;
        int k = s.length();
        do {
            if (_inputPtr >= _inputEnd && !loadMore() || _inputBuffer[_inputPtr] != s.charAt(i))
                _reportInvalidToken(s.substring(0, i));
            _inputPtr = _inputPtr + 1;
            j = i + 1;
            i = j;
        } while (j < k);
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        return;
_L2:
        i = _inputBuffer[_inputPtr] & 0xff;
        if (i >= 48 && i != 93 && i != 125)
            _checkMatchEnd(s, j, i);
        if (true) goto _L1; else goto _L3
_L3:
    }

    private final JsonToken _nextAfterName() {
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        if (jsontoken != JsonToken.START_ARRAY) goto _L2; else goto _L1
_L1:
        _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
_L4:
        _currToken = jsontoken;
        return jsontoken;
_L2:
        if (jsontoken == JsonToken.START_OBJECT)
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final JsonToken _nextTokenNotInObject(int i) {
        if (i != 34) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _tokenIncomplete = true;
        jsontoken = JsonToken.VALUE_STRING;
        _currToken = jsontoken;
_L4:
        return jsontoken;
_L2:
        switch (i) {
        default:
            jsontoken = _handleUnexpectedValue(i);
            _currToken = jsontoken;
            break;

        case 91: // '['
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            jsontoken = JsonToken.START_ARRAY;
            _currToken = jsontoken;
            break;

        case 123: // '{'
            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            jsontoken = JsonToken.START_OBJECT;
            _currToken = jsontoken;
            break;

        case 116: // 't'
            _matchToken("true", 1);
            jsontoken = JsonToken.VALUE_TRUE;
            _currToken = jsontoken;
            break;

        case 102: // 'f'
            _matchToken("false", 1);
            jsontoken = JsonToken.VALUE_FALSE;
            _currToken = jsontoken;
            break;

        case 110: // 'n'
            _matchToken("null", 1);
            jsontoken = JsonToken.VALUE_NULL;
            _currToken = jsontoken;
            break;

        case 45: // '-'
            jsontoken = _parseNegNumber();
            _currToken = jsontoken;
            break;

        case 48: // '0'
        case 49: // '1'
        case 50: // '2'
        case 51: // '3'
        case 52: // '4'
        case 53: // '5'
        case 54: // '6'
        case 55: // '7'
        case 56: // '8'
        case 57: // '9'
            jsontoken = _parsePosNumber(i);
            _currToken = jsontoken;
            break;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final JsonToken _parseFloat(char ac[], int i, int j, boolean flag, int k) {
        int l;
        boolean flag1;
        int l1;
        l = 0;
        l1 = 0;
        flag1 = false;
        if (j != 46)
            break MISSING_BLOCK_LABEL_593;
        int j1 = i + 1;
        ac[i] = (char)j;
        i = j1;
_L11:
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        flag1 = true;
_L9:
        int k1;
        char ac1[];
        if (l == 0)
            reportUnexpectedNumberChar(j, "Decimal point not followed by a digit");
        k1 = l;
        l = j;
        j = ((flag1) ? 1 : 0);
        ac1 = ac;
_L14:
        l1 = 0;
        if (l != 101 && l != 69) goto _L4; else goto _L3
_L3:
        int i2;
        int j2;
        int k2;
        int i1 = i;
        ac = ac1;
        if (i >= ac1.length) {
            ac = _textBuffer.finishCurrentSegment();
            i1 = 0;
        }
        i = i1 + 1;
        ac[i1] = (char)l;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        ac1 = _inputBuffer;
        l = _inputPtr;
        _inputPtr = l + 1;
        l = ac1[l] & 0xff;
        if (l == 45 || l == 43) {
            if (i >= ac.length) {
                ac = _textBuffer.finishCurrentSegment();
                i = 0;
            }
            ac[i] = (char)l;
            if (_inputPtr >= _inputEnd)
                loadMoreGuaranteed();
            ac1 = _inputBuffer;
            l = _inputPtr;
            _inputPtr = l + 1;
            l = ac1[l] & 0xff;
            i++;
            i1 = l1;
        } else {
            i1 = l1;
        }
        if (l > 57 || l < 48) goto _L6; else goto _L5
_L5:
        i1++;
        l1 = i;
        ac1 = ac;
        if (i >= ac.length) {
            ac1 = _textBuffer.finishCurrentSegment();
            l1 = 0;
        }
        i = l1 + 1;
        ac1[l1] = (char)l;
        if (_inputPtr < _inputEnd || loadMore()) goto _L8; else goto _L7
_L7:
        l1 = 1;
        j = i;
        i = l1;
_L12:
        l1 = i1;
        i2 = i;
        j2 = l;
        k2 = j;
        if (i1 == 0) {
            reportUnexpectedNumberChar(l, "Exponent indicator not followed by a digit");
            k2 = j;
            j2 = l;
            i2 = i;
            l1 = i1;
        }
_L13:
        if (i2 == 0) {
            _inputPtr = _inputPtr - 1;
            if (_parsingContext.inRoot())
                _verifyRootSpace(j2);
        }
        _textBuffer.setCurrentLength(k2);
        return resetFloat(flag, k, k1, l1);
_L2:
        ac1 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        j = ac1[j] & 0xff;
        if (j >= 48 && j <= 57) goto _L10; else goto _L9
_L10:
        l++;
        if (i >= ac.length) {
            ac = _textBuffer.finishCurrentSegment();
            i = 0;
        }
        k1 = i + 1;
        ac[i] = (char)j;
        i = k1;
          goto _L11
_L8:
        ac = _inputBuffer;
        l = _inputPtr;
        _inputPtr = l + 1;
        l = ac[l] & 0xff;
        ac = ac1;
        break MISSING_BLOCK_LABEL_263;
_L6:
        l1 = j;
        j = i;
        i = l1;
          goto _L12
_L4:
        l1 = 0;
        i2 = j;
        j2 = l;
        k2 = i;
          goto _L13
        k1 = 0;
        l = j;
        ac1 = ac;
        j = l1;
          goto _L14
    }

    private final JsonToken _parseNumber2(char ac[], int i, boolean flag, int j) {
_L7:
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        _textBuffer.setCurrentLength(i);
        ac = resetInt(flag, j);
_L5:
        return ac;
_L2:
        int i1;
        byte abyte0[] = _inputBuffer;
        int k = _inputPtr;
        _inputPtr = k + 1;
        i1 = abyte0[k] & 0xff;
        if (i1 <= 57 && i1 >= 48) goto _L4; else goto _L3
_L3:
        if (i1 == 46 || i1 == 101 || i1 == 69) {
            ac = _parseFloat(ac, i, i1, flag, j);
        } else {
            _inputPtr = _inputPtr - 1;
            _textBuffer.setCurrentLength(i);
            if (_parsingContext.inRoot()) {
                ac = _inputBuffer;
                i = _inputPtr;
                _inputPtr = i + 1;
                _verifyRootSpace(ac[i] & 0xff);
            }
            ac = resetInt(flag, j);
        }
        if (true) goto _L5; else goto _L4
_L4:
        if (i >= ac.length) {
            ac = _textBuffer.finishCurrentSegment();
            i = 0;
        }
        int l = i + 1;
        ac[i] = (char)i1;
        j++;
        i = l;
        if (true) goto _L7; else goto _L6
_L6:
    }

    private final void _skipCComment() {
        int ai[] = CharTypes.getInputCodeComment();
_L13:
        if (_inputPtr >= _inputEnd && !loadMore()) goto _L2; else goto _L1
_L1:
        int i;
        int j;
        byte abyte0[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        i = abyte0[i] & 0xff;
        j = ai[i];
        if (j == 0)
            continue; /* Loop/switch isn't completed */
        j;
        JVM INSTR lookupswitch 6: default 116
    //                   2: 205
    //                   3: 212
    //                   4: 219
    //                   10: 177
    //                   13: 198
    //                   42: 124;
           goto _L3 _L4 _L5 _L6 _L7 _L8 _L9
_L3:
        _reportInvalidChar(i);
        continue; /* Loop/switch isn't completed */
_L9:
        if (_inputPtr < _inputEnd || loadMore()) goto _L10; else goto _L2
_L2:
        _reportInvalidEOF(" in a comment");
_L11:
        return;
_L10:
        if (_inputBuffer[_inputPtr] != 47)
            continue; /* Loop/switch isn't completed */
        _inputPtr = _inputPtr + 1;
          goto _L11
_L7:
        _currInputRow = _currInputRow + 1;
        _currInputRowStart = _inputPtr;
        continue; /* Loop/switch isn't completed */
_L8:
        _skipCR();
        continue; /* Loop/switch isn't completed */
_L4:
        _skipUtf8_2();
        continue; /* Loop/switch isn't completed */
_L5:
        _skipUtf8_3();
        continue; /* Loop/switch isn't completed */
_L6:
        _skipUtf8_4(i);
        if (true) goto _L13; else goto _L12
_L12:
    }

    private final int _skipColon() {
        if (_inputPtr + 4 < _inputEnd) goto _L2; else goto _L1
_L1:
        int i = _skipColon2(false);
_L4:
        return i;
_L2:
label0:
        {
            byte byte0 = _inputBuffer[_inputPtr];
            if (byte0 == 58) {
                byte abyte0[] = _inputBuffer;
                i = _inputPtr + 1;
                _inputPtr = i;
                i = abyte0[i];
                if (i > 32) {
                    if (i == 47 || i == 35)
                        i = _skipColon2(true);
                    else
                        _inputPtr = _inputPtr + 1;
                    continue; /* Loop/switch isn't completed */
                }
                if (i == 32 || i == 9) {
                    byte abyte1[] = _inputBuffer;
                    i = _inputPtr + 1;
                    _inputPtr = i;
                    i = abyte1[i];
                    if (i > 32) {
                        if (i == 47 || i == 35)
                            i = _skipColon2(true);
                        else
                            _inputPtr = _inputPtr + 1;
                        continue; /* Loop/switch isn't completed */
                    }
                }
                i = _skipColon2(true);
                continue; /* Loop/switch isn't completed */
            }
            if (byte0 != 32) {
                i = byte0;
                if (byte0 != 9)
                    break label0;
            }
            byte abyte2[] = _inputBuffer;
            i = _inputPtr + 1;
            _inputPtr = i;
            i = abyte2[i];
        }
        if (i == 58) {
            byte abyte3[] = _inputBuffer;
            i = _inputPtr + 1;
            _inputPtr = i;
            i = abyte3[i];
            if (i > 32) {
                if (i == 47 || i == 35)
                    i = _skipColon2(true);
                else
                    _inputPtr = _inputPtr + 1;
                continue; /* Loop/switch isn't completed */
            }
            if (i == 32 || i == 9) {
                byte abyte4[] = _inputBuffer;
                i = _inputPtr + 1;
                _inputPtr = i;
                i = abyte4[i];
                if (i > 32) {
                    if (i == 47 || i == 35)
                        i = _skipColon2(true);
                    else
                        _inputPtr = _inputPtr + 1;
                    continue; /* Loop/switch isn't completed */
                }
            }
            i = _skipColon2(true);
        } else {
            i = _skipColon2(false);
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final int _skipColon2(boolean flag) {
        do {
            if (_inputPtr >= _inputEnd && !loadMore())
                break;
            byte abyte0[] = _inputBuffer;
            int i = _inputPtr;
            _inputPtr = i + 1;
            i = abyte0[i] & 0xff;
            if (i > 32) {
                if (i == 47)
                    _skipComment();
                else
                if (i != 35 || !_skipYAMLComment()) {
                    if (flag)
                        return i;
                    if (i != 58)
                        _reportUnexpectedChar(i, "was expecting a colon to separate field name and value");
                    flag = true;
                }
            } else
            if (i != 32)
                if (i == 10) {
                    _currInputRow = _currInputRow + 1;
                    _currInputRowStart = _inputPtr;
                } else
                if (i == 13)
                    _skipCR();
                else
                if (i != 9)
                    _throwInvalidSpace(i);
        } while (true);
        throw _constructError((new StringBuilder()).append("Unexpected end-of-input within/between ").append(_parsingContext.getTypeDesc()).append(" entries").toString());
    }

    private final int _skipColonFast(int i) {
        int l;
        byte byte1;
        byte abyte0[] = _inputBuffer;
        l = i + 1;
        byte1 = abyte0[i];
        if (byte1 != 58) goto _L2; else goto _L1
_L1:
        int j;
        byte abyte1[] = _inputBuffer;
        j = l + 1;
        l = abyte1[l];
        if (l <= 32) goto _L4; else goto _L3
_L3:
        i = j;
        if (l == 47) goto _L6; else goto _L5
_L5:
        i = j;
        if (l == 35) goto _L6; else goto _L7
_L7:
        _inputPtr = j;
        i = l;
_L11:
        return i;
_L4:
        if (l == 32) goto _L9; else goto _L8
_L8:
        i = j;
        if (l != 9) goto _L6; else goto _L9
_L9:
        byte abyte2[] = _inputBuffer;
        i = j + 1;
        j = abyte2[j];
        if (j > 32 && j != 47 && j != 35) {
            _inputPtr = i;
            i = j;
            continue; /* Loop/switch isn't completed */
        }
_L6:
        _inputPtr = i - 1;
        i = _skipColon2(true);
        continue; /* Loop/switch isn't completed */
_L2:
        int k;
label0:
        {
            if (byte1 != 32) {
                k = byte1;
                i = l;
                if (byte1 != 9)
                    break label0;
            }
            k = _inputBuffer[l];
            i = l + 1;
        }
label1:
        {
label2:
            {
                if (k != 58)
                    break label1;
                byte abyte3[] = _inputBuffer;
                k = i + 1;
                byte byte0 = abyte3[i];
                if (byte0 > 32) {
                    i = k;
                    if (byte0 != 47) {
                        i = k;
                        if (byte0 != 35) {
                            _inputPtr = k;
                            i = byte0;
                            continue; /* Loop/switch isn't completed */
                        }
                    }
                    break label2;
                }
                if (byte0 != 32) {
                    i = k;
                    if (byte0 != 9)
                        break label2;
                }
                abyte3 = _inputBuffer;
                i = k + 1;
                k = abyte3[k];
                if (k > 32 && k != 47 && k != 35) {
                    _inputPtr = i;
                    i = k;
                    continue; /* Loop/switch isn't completed */
                }
            }
            _inputPtr = i - 1;
            i = _skipColon2(true);
            continue; /* Loop/switch isn't completed */
        }
        _inputPtr = i - 1;
        i = _skipColon2(false);
        if (true) goto _L11; else goto _L10
_L10:
    }

    private final void _skipComment() {
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_COMMENTS))
            _reportUnexpectedChar(47, "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)");
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(" in a comment");
        byte abyte0[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        i = abyte0[i] & 0xff;
        if (i == 47)
            _skipLine();
        else
        if (i == 42)
            _skipCComment();
        else
            _reportUnexpectedChar(i, "was expecting either '*' or '/' for a comment");
    }

    private final void _skipLine() {
        int ai[] = CharTypes.getInputCodeComment();
_L11:
        if (_inputPtr >= _inputEnd && !loadMore()) goto _L2; else goto _L1
_L1:
        int i;
        int j;
        byte abyte0[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        j = abyte0[i] & 0xff;
        i = ai[j];
        if (i == 0)
            continue; /* Loop/switch isn't completed */
        i;
        JVM INSTR lookupswitch 6: default 116
    //                   2: 154
    //                   3: 161
    //                   4: 168
    //                   10: 128
    //                   13: 147
    //                   42: 4;
           goto _L3 _L4 _L5 _L6 _L7 _L8 _L9
_L5:
        break MISSING_BLOCK_LABEL_161;
_L6:
        break MISSING_BLOCK_LABEL_168;
_L9:
        continue; /* Loop/switch isn't completed */
_L3:
        if (i < 0)
            _reportInvalidChar(j);
        continue; /* Loop/switch isn't completed */
_L7:
        _currInputRow = _currInputRow + 1;
        _currInputRowStart = _inputPtr;
_L2:
        return;
_L8:
        _skipCR();
        if (true) goto _L2; else goto _L4
_L4:
        _skipUtf8_2();
        continue; /* Loop/switch isn't completed */
        _skipUtf8_3();
        continue; /* Loop/switch isn't completed */
        _skipUtf8_4(j);
        if (true) goto _L11; else goto _L10
_L10:
    }

    private final void _skipUtf8_2() {
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        byte abyte0[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        i = abyte0[i];
        if ((i & 0xc0) != 128)
            _reportInvalidOther(i & 0xff, _inputPtr);
    }

    private final void _skipUtf8_3() {
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        byte abyte0[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        i = abyte0[i];
        if ((i & 0xc0) != 128)
            _reportInvalidOther(i & 0xff, _inputPtr);
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte0 = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        i = abyte0[i];
        if ((i & 0xc0) != 128)
            _reportInvalidOther(i & 0xff, _inputPtr);
    }

    private final void _skipUtf8_4(int i) {
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        byte abyte0[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        i = abyte0[i];
        if ((i & 0xc0) != 128)
            _reportInvalidOther(i & 0xff, _inputPtr);
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte0 = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        i = abyte0[i];
        if ((i & 0xc0) != 128)
            _reportInvalidOther(i & 0xff, _inputPtr);
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte0 = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        i = abyte0[i];
        if ((i & 0xc0) != 128)
            _reportInvalidOther(i & 0xff, _inputPtr);
    }

    private final int _skipWS() {
_L3:
        int k;
        if (_inputPtr >= _inputEnd)
            break MISSING_BLOCK_LABEL_133;
        byte abyte0[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        k = abyte0[i] & 0xff;
        if (k <= 32) goto _L2; else goto _L1
_L1:
        int j;
label0:
        {
            if (k != 47) {
                j = k;
                if (k != 35)
                    break label0;
            }
            _inputPtr = _inputPtr - 1;
            j = _skipWS2();
        }
_L4:
        return j;
_L2:
        if (k != 32)
            if (k == 10) {
                _currInputRow = _currInputRow + 1;
                _currInputRowStart = _inputPtr;
            } else
            if (k == 13)
                _skipCR();
            else
            if (k != 9)
                _throwInvalidSpace(k);
          goto _L3
        j = _skipWS2();
          goto _L4
    }

    private final int _skipWS2() {
        do {
            if (_inputPtr >= _inputEnd && !loadMore())
                break;
            byte abyte0[] = _inputBuffer;
            int i = _inputPtr;
            _inputPtr = i + 1;
            i = abyte0[i] & 0xff;
            if (i > 32) {
                if (i == 47)
                    _skipComment();
                else
                if (i != 35 || !_skipYAMLComment())
                    return i;
            } else
            if (i != 32)
                if (i == 10) {
                    _currInputRow = _currInputRow + 1;
                    _currInputRowStart = _inputPtr;
                } else
                if (i == 13)
                    _skipCR();
                else
                if (i != 9)
                    _throwInvalidSpace(i);
        } while (true);
        throw _constructError((new StringBuilder()).append("Unexpected end-of-input within/between ").append(_parsingContext.getTypeDesc()).append(" entries").toString());
    }

    private final int _skipWSOrEnd() {
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        int i = _eofAsNextChar();
_L9:
        return i;
_L2:
        int j;
        byte abyte0[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        j = abyte0[i] & 0xff;
        if (j > 32) {
            if (j != 47) {
                i = j;
                if (j != 35)
                    continue; /* Loop/switch isn't completed */
            }
            _inputPtr = _inputPtr - 1;
            i = _skipWSOrEnd2();
            continue; /* Loop/switch isn't completed */
        }
        if (j == 32) goto _L4; else goto _L3
_L3:
        if (j != 10) goto _L6; else goto _L5
_L5:
        _currInputRow = _currInputRow + 1;
        _currInputRowStart = _inputPtr;
_L4:
        if (_inputPtr >= _inputEnd)
            break; /* Loop/switch isn't completed */
        byte abyte1[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        j = abyte1[i] & 0xff;
        if (j > 32) {
            if (j != 47) {
                i = j;
                if (j != 35)
                    continue; /* Loop/switch isn't completed */
            }
            _inputPtr = _inputPtr - 1;
            i = _skipWSOrEnd2();
            continue; /* Loop/switch isn't completed */
        }
        if (j != 32)
            if (j == 10) {
                _currInputRow = _currInputRow + 1;
                _currInputRowStart = _inputPtr;
            } else
            if (j == 13)
                _skipCR();
            else
            if (j != 9)
                _throwInvalidSpace(j);
        continue; /* Loop/switch isn't completed */
_L6:
        if (j == 13)
            _skipCR();
        else
        if (j != 9)
            _throwInvalidSpace(j);
        continue; /* Loop/switch isn't completed */
        if (true) goto _L4; else goto _L7
_L7:
        i = _skipWSOrEnd2();
        if (true) goto _L9; else goto _L8
_L8:
    }

    private final int _skipWSOrEnd2() {
_L2:
        int i;
        do {
label0:
            {
                if (_inputPtr >= _inputEnd && !loadMore())
                    break label0;
                byte abyte0[] = _inputBuffer;
                i = _inputPtr;
                _inputPtr = i + 1;
                int j = abyte0[i] & 0xff;
                if (j > 32) {
label1:
                    {
                        if (j != 47)
                            break label1;
                        _skipComment();
                    }
                } else
                if (j != 32)
                    if (j == 10) {
                        _currInputRow = _currInputRow + 1;
                        _currInputRowStart = _inputPtr;
                    } else
                    if (j == 13)
                        _skipCR();
                    else
                    if (j != 9)
                        _throwInvalidSpace(j);
            }
        } while (true);
        i = j;
        if (j != 35)
            break MISSING_BLOCK_LABEL_79;
        if (_skipYAMLComment()) goto _L2; else goto _L1
_L1:
        i = j;
_L4:
        return i;
        i = _eofAsNextChar();
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final boolean _skipYAMLComment() {
        boolean flag;
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_YAML_COMMENTS)) {
            flag = false;
        } else {
            _skipLine();
            flag = true;
        }
        return flag;
    }

    private final void _updateLocation() {
        _tokenInputRow = _currInputRow;
        int i = _inputPtr;
        _tokenInputTotal = _currInputProcessed + (long)i;
        _tokenInputCol = i - _currInputRowStart;
    }

    private final void _updateNameLocation() {
        _nameStartRow = _currInputRow;
        int i = _inputPtr;
        _nameStartOffset = i;
        _nameStartCol = i - _currInputRowStart;
    }

    private final int _verifyNoLeadingZeroes() {
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        int i = 48;
_L4:
        return i;
_L2:
        int j = _inputBuffer[_inputPtr] & 0xff;
        if (j < 48 || j > 57) {
            i = 48;
            continue; /* Loop/switch isn't completed */
        }
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_NUMERIC_LEADING_ZEROS))
            reportInvalidNumber("Leading zeroes not allowed");
        _inputPtr = _inputPtr + 1;
        i = j;
        if (j != 48)
            continue; /* Loop/switch isn't completed */
        i = j;
        do {
            if (_inputPtr >= _inputEnd && !loadMore())
                continue; /* Loop/switch isn't completed */
            j = _inputBuffer[_inputPtr] & 0xff;
            if (j < 48 || j > 57) {
                i = 48;
                continue; /* Loop/switch isn't completed */
            }
            _inputPtr = _inputPtr + 1;
            i = j;
        } while (j == 48);
        i = j;
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final void _verifyRootSpace(int i) {
        _inputPtr = _inputPtr + 1;
        i;
        JVM INSTR lookupswitch 4: default 52
    //                   9: 57
    //                   10: 65
    //                   13: 58
    //                   32: 57;
           goto _L1 _L2 _L3 _L4 _L2
_L2:
        break; /* Loop/switch isn't completed */
_L1:
        _reportMissingRootWS(i);
_L6:
        return;
_L4:
        _skipCR();
        continue; /* Loop/switch isn't completed */
_L3:
        _currInputRow = _currInputRow + 1;
        _currInputRowStart = _inputPtr;
        if (true) goto _L6; else goto _L5
_L5:
    }

    private final String addName(int ai[], int i, int j) {
        int k;
        int l;
        int i1;
        int j1;
        int k1;
        int l1;
        int i2;
        char ac[];
        int j2 = ((i << 2) - 4) + j;
        char ac1[];
        if (j < 4) {
            i2 = ai[i - 1];
            ai[i - 1] = i2 << (4 - j << 3);
        } else {
            i2 = 0;
        }
        ac = _textBuffer.emptyAndGetCurrentSegment();
        j1 = 0;
        k = 0;
        if (k >= j2)
            break; /* Loop/switch isn't completed */
        l = ai[k >> 2] >> (3 - (k & 3) << 3) & 0xff;
        i1 = k + 1;
        l1 = l;
        k1 = i1;
        if (l <= 127)
            break MISSING_BLOCK_LABEL_556;
        if ((l & 0xe0) == 192) {
            k = l & 0x1f;
            l = 1;
        } else
        if ((l & 0xf0) == 224) {
            k = l & 0xf;
            l = 2;
        } else
        if ((l & 0xf8) == 240) {
            k = l & 7;
            l = 3;
        } else {
            _reportInvalidInitial(l);
            k = 1;
            l = 1;
        }
        if (i1 + l > j2)
            _reportInvalidEOF(" in field name");
        l1 = ai[i1 >> 2] >> (3 - (i1 & 3) << 3);
        k1 = i1 + 1;
        if ((l1 & 0xc0) != 128)
            _reportInvalidOther(l1);
        l1 = k << 6 | l1 & 0x3f;
        i1 = l1;
        k = k1;
        if (l > 1) {
            k = ai[k1 >> 2] >> (3 - (k1 & 3) << 3);
            k1++;
            if ((k & 0xc0) != 128)
                _reportInvalidOther(k);
            l1 = l1 << 6 | k & 0x3f;
            i1 = l1;
            k = k1;
            if (l > 2) {
                i1 = ai[k1 >> 2] >> (3 - (k1 & 3) << 3);
                k = k1 + 1;
                if ((i1 & 0xc0) != 128)
                    _reportInvalidOther(i1 & 0xff);
                i1 = l1 << 6 | i1 & 0x3f;
            }
        }
        l1 = i1;
        k1 = k;
        if (l <= 2)
            break MISSING_BLOCK_LABEL_556;
        l = i1 - 0x10000;
        ac1 = ac;
        if (j1 >= ac.length)
            ac1 = _textBuffer.expandCurrentSegment();
        ac1[j1] = (char)(55296 + (l >> 10));
        i1 = j1 + 1;
        ac = ac1;
        l = l & 0x3ff | 0xdc00;
_L4:
        ac1 = ac;
        if (i1 >= ac.length)
            ac1 = _textBuffer.expandCurrentSegment();
        j1 = i1 + 1;
        ac1[i1] = (char)l;
        ac = ac1;
        if (true) goto _L2; else goto _L1
_L2:
        break MISSING_BLOCK_LABEL_49;
_L1:
        String s = new String(ac, 0, j1);
        if (j < 4)
            ai[i - 1] = i2;
        return _symbols.addName(s, ai, i);
        l = l1;
        k = k1;
        i1 = j1;
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final String findName(int i, int j) {
        i = pad(i, j);
        String s = _symbols.findName(i);
        if (s == null) {
            _quadBuffer[0] = i;
            s = addName(_quadBuffer, 1, j);
        }
        return s;
    }

    private final String findName(int i, int j, int k) {
        j = pad(j, k);
        String s = _symbols.findName(i, j);
        if (s == null) {
            _quadBuffer[0] = i;
            _quadBuffer[1] = j;
            s = addName(_quadBuffer, 2, k);
        }
        return s;
    }

    private final String findName(int i, int j, int k, int l) {
        k = pad(k, l);
        Object obj = _symbols.findName(i, j, k);
        if (obj == null) {
            obj = _quadBuffer;
            obj[0] = i;
            obj[1] = j;
            obj[2] = pad(k, l);
            obj = addName(((int []) (obj)), 3, l);
        }
        return ((String) (obj));
    }

    private final String findName(int ai[], int i, int j, int k) {
        int ai1[] = ai;
        if (i >= ai.length) {
            ai1 = growArrayBy(ai, ai.length);
            _quadBuffer = ai1;
        }
        int l = i + 1;
        ai1[i] = pad(j, k);
        String s = _symbols.findName(ai1, l);
        ai = s;
        if (s == null)
            ai = addName(ai1, l, k);
        return ai;
    }

    public static int[] growArrayBy(int ai[], int i) {
        if (ai == null)
            ai = new int[i];
        else
            ai = Arrays.copyOf(ai, ai.length + i);
        return ai;
    }

    private int nextByte() {
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        byte abyte0[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        return abyte0[i] & 0xff;
    }

    private static final int pad(int i, int j) {
        if (j != 4)
            i |= -1 << (j << 3);
        return i;
    }

    private final String parseName(int i, int j, int k) {
        return parseEscapedName(_quadBuffer, 0, i, j, k);
    }

    private final String parseName(int i, int j, int k, int l) {
        _quadBuffer[0] = i;
        return parseEscapedName(_quadBuffer, 1, j, k, l);
    }

    private final String parseName(int i, int j, int k, int l, int i1) {
        _quadBuffer[0] = i;
        _quadBuffer[1] = j;
        return parseEscapedName(_quadBuffer, 2, k, l, i1);
    }

    protected void _closeInput() {
        if (_inputStream != null) {
            if (_ioContext.isResourceManaged() || isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.AUTO_CLOSE_SOURCE))
                _inputStream.close();
            _inputStream = null;
        }
    }

    protected final byte[] _decodeBase64(Base64Variant base64variant) {
        ByteArrayBuilder bytearraybuilder = _getByteArrayBuilder();
_L8:
        int j;
        int k;
        int i1;
        do {
            if (_inputPtr >= _inputEnd)
                loadMoreGuaranteed();
            byte abyte0[] = _inputBuffer;
            int i = _inputPtr;
            _inputPtr = i + 1;
            i1 = abyte0[i] & 0xff;
        } while (i1 <= 32);
        k = base64variant.decodeBase64Char(i1);
        j = k;
        if (k >= 0) goto _L2; else goto _L1
_L1:
        if (i1 != 34) goto _L4; else goto _L3
_L3:
        base64variant = bytearraybuilder.toByteArray();
_L6:
        return base64variant;
_L4:
        j = _decodeBase64Escape(base64variant, i1, 0);
        if (j < 0)
            continue; /* Loop/switch isn't completed */
_L2:
        int j1;
        int k1;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        byte abyte1[] = _inputBuffer;
        int l = _inputPtr;
        _inputPtr = l + 1;
        j1 = abyte1[l] & 0xff;
        i1 = base64variant.decodeBase64Char(j1);
        l = i1;
        if (i1 < 0)
            l = _decodeBase64Escape(base64variant, j1, 1);
        j1 = l | j << 6;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte1 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        k1 = abyte1[j] & 0xff;
        i1 = base64variant.decodeBase64Char(k1);
        l = i1;
        if (i1 < 0) {
            j = i1;
            if (i1 != -2) {
                if (k1 == 34 && !base64variant.usesPadding()) {
                    bytearraybuilder.append(j1 >> 4);
                    base64variant = bytearraybuilder.toByteArray();
                    continue; /* Loop/switch isn't completed */
                }
                j = _decodeBase64Escape(base64variant, k1, 2);
            }
            l = j;
            if (j == -2) {
                if (_inputPtr >= _inputEnd)
                    loadMoreGuaranteed();
                abyte1 = _inputBuffer;
                j = _inputPtr;
                _inputPtr = j + 1;
                j = abyte1[j] & 0xff;
                if (!base64variant.usesPaddingChar(j))
                    throw reportInvalidBase64Char(base64variant, j, 3, (new StringBuilder()).append("expected padding character '").append(base64variant.getPaddingChar()).append("'").toString());
                bytearraybuilder.append(j1 >> 4);
                continue; /* Loop/switch isn't completed */
            }
        }
        j1 = j1 << 6 | l;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte1 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        k1 = abyte1[j] & 0xff;
        l = base64variant.decodeBase64Char(k1);
        i1 = l;
        if (l >= 0)
            break MISSING_BLOCK_LABEL_526;
        j = l;
        if (l == -2)
            break MISSING_BLOCK_LABEL_505;
        if (k1 != 34 || base64variant.usesPadding())
            break; /* Loop/switch isn't completed */
        bytearraybuilder.appendTwoBytes(j1 >> 2);
        base64variant = bytearraybuilder.toByteArray();
        if (true) goto _L6; else goto _L5
_L5:
        j = _decodeBase64Escape(base64variant, k1, 3);
        i1 = j;
        if (j == -2) {
            bytearraybuilder.appendTwoBytes(j1 >> 2);
            continue; /* Loop/switch isn't completed */
        }
        bytearraybuilder.appendThreeBytes(i1 | j1 << 6);
        if (true) goto _L8; else goto _L7
_L7:
    }

    protected int _decodeCharForError(int i) {
        int j = i & 0xff;
        i = j;
        if (j > 127) {
            int k;
            if ((j & 0xe0) == 192) {
                j &= 0x1f;
                i = 1;
            } else
            if ((j & 0xf0) == 224) {
                j &= 0xf;
                i = 2;
            } else
            if ((j & 0xf8) == 240) {
                j &= 7;
                i = 3;
            } else {
                _reportInvalidInitial(j & 0xff);
                i = 1;
            }
            k = nextByte();
            if ((k & 0xc0) != 128)
                _reportInvalidOther(k & 0xff);
            j = j << 6 | k & 0x3f;
            if (i > 1) {
                int l = nextByte();
                if ((l & 0xc0) != 128)
                    _reportInvalidOther(l & 0xff);
                j = l & 0x3f | j << 6;
                if (i > 2) {
                    i = nextByte();
                    if ((i & 0xc0) != 128)
                        _reportInvalidOther(i & 0xff);
                    i = i & 0x3f | j << 6;
                } else {
                    i = j;
                }
            } else {
                i = j;
            }
        }
        return i;
    }

    protected char _decodeEscaped() {
        int i;
        int j;
        i = 0;
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(" in character escape sequence");
        byte abyte0[] = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        j = abyte0[j];
        j;
        JVM INSTR lookupswitch 9: default 132
    //                   34: 175
    //                   47: 175
    //                   92: 175
    //                   98: 145
    //                   102: 163
    //                   110: 157
    //                   114: 169
    //                   116: 151
    //                   117: 181;
           goto _L1 _L2 _L2 _L2 _L3 _L4 _L5 _L6 _L7 _L8
_L1:
        char c = _handleUnrecognizedCharacterEscape((char)_decodeCharForError(j));
_L10:
        return c;
_L3:
        c = '\b';
        continue; /* Loop/switch isn't completed */
_L7:
        c = '\t';
        continue; /* Loop/switch isn't completed */
_L5:
        c = '\n';
        continue; /* Loop/switch isn't completed */
_L4:
        c = '\f';
        continue; /* Loop/switch isn't completed */
_L6:
        c = '\r';
        continue; /* Loop/switch isn't completed */
_L2:
        c = (char)j;
        continue; /* Loop/switch isn't completed */
_L8:
        int k = 0;
        for (; i < 4; i++) {
            if (_inputPtr >= _inputEnd && !loadMore())
                _reportInvalidEOF(" in character escape sequence");
            byte abyte1[] = _inputBuffer;
            int l = _inputPtr;
            _inputPtr = l + 1;
            l = abyte1[l];
            int i1 = CharTypes.charToHex(l);
            if (i1 < 0)
                _reportUnexpectedChar(l, "expected a hex-digit for character escape sequence");
            k = k << 4 | i1;
        }

        c = (char)k;
        if (true) goto _L10; else goto _L9
_L9:
    }

    protected String _finishAndReturnString() {
        int i;
        int j;
        int k;
        byte abyte0[];
        int ai[];
        char ac[];
        j = _inputPtr;
        i = j;
        if (j >= _inputEnd) {
            loadMoreGuaranteed();
            i = _inputPtr;
        }
        ac = _textBuffer.emptyAndGetCurrentSegment();
        ai = _icUTF8;
        k = Math.min(_inputEnd, ac.length + i);
        abyte0 = _inputBuffer;
        j = 0;
_L3:
        int l;
        if (i >= k)
            break MISSING_BLOCK_LABEL_125;
        l = abyte0[i] & 0xff;
        if (ai[l] == 0) goto _L2; else goto _L1
_L1:
        String s;
        if (l != 34)
            break MISSING_BLOCK_LABEL_125;
        _inputPtr = i + 1;
        s = _textBuffer.setCurrentAndReturn(j);
_L4:
        return s;
_L2:
        ac[j] = (char)l;
        j++;
        i++;
          goto _L3
        _inputPtr = i;
        _finishString2(ac, j);
        s = _textBuffer.contentsAsString();
          goto _L4
    }

    protected void _finishString() {
        int i;
        int j;
        int k;
        char ac[];
        int ai[];
        byte abyte0[];
        j = _inputPtr;
        i = j;
        if (j >= _inputEnd) {
            loadMoreGuaranteed();
            i = _inputPtr;
        }
        ac = _textBuffer.emptyAndGetCurrentSegment();
        ai = _icUTF8;
        k = Math.min(_inputEnd, ac.length + i);
        abyte0 = _inputBuffer;
        j = 0;
_L3:
        int l;
        if (i >= k)
            break MISSING_BLOCK_LABEL_121;
        l = abyte0[i] & 0xff;
        if (ai[l] == 0) goto _L2; else goto _L1
_L1:
        if (l != 34)
            break MISSING_BLOCK_LABEL_121;
        _inputPtr = i + 1;
        _textBuffer.setCurrentLength(j);
_L4:
        return;
_L2:
        ac[j] = (char)l;
        j++;
        i++;
          goto _L3
        _inputPtr = i;
        _finishString2(ac, j);
          goto _L4
    }

    protected final String _getText2(JsonToken jsontoken) {
        if (jsontoken != null) goto _L2; else goto _L1
_L1:
        jsontoken = null;
_L4:
        return jsontoken;
_L2:
        switch (jsontoken.id()) {
        default:
            jsontoken = jsontoken.asString();
            break;

        case 5: // '\005'
            jsontoken = _parsingContext.getCurrentName();
            break;

        case 6: // '\006'
        case 7: // '\007'
        case 8: // '\b'
            jsontoken = _textBuffer.contentsAsString();
            break;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected JsonToken _handleApos() {
        int i;
        char ac1[];
        int ai[];
        byte abyte0[];
        ac1 = _textBuffer.emptyAndGetCurrentSegment();
        ai = _icUTF8;
        abyte0 = _inputBuffer;
        i = 0;
_L9:
        int j;
        int k;
        char ac[];
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        ac = ac1;
        j = i;
        if (i >= ac1.length) {
            ac = _textBuffer.finishCurrentSegment();
            j = 0;
        }
        k = _inputEnd;
        i = _inputPtr + (ac.length - j);
        if (i < k)
            k = i;
_L3:
        ac1 = ac;
        i = j;
        if (_inputPtr >= k) goto _L2; else goto _L1
_L1:
label0:
        {
            i = _inputPtr;
            _inputPtr = i + 1;
            i = abyte0[i] & 0xff;
            if (i == 39 || ai[i] != 0) {
                if (i == 39) {
                    _textBuffer.setCurrentLength(j);
                    return JsonToken.VALUE_STRING;
                }
                break label0;
            }
            ac[j] = (char)i;
            j++;
        }
          goto _L3
        ai[i];
        JVM INSTR tableswitch 1 4: default 196
    //                   1 247
    //                   2 255
    //                   3 264
    //                   4 295;
           goto _L4 _L5 _L6 _L7 _L8
_L4:
        if (i < 32)
            _throwUnquotedSpace(i, "string value");
        _reportInvalidChar(i);
_L10:
        int l;
        if (j >= ac.length) {
            ac1 = _textBuffer.finishCurrentSegment();
            j = 0;
        } else {
            ac1 = ac;
        }
        l = j + 1;
        ac1[j] = (char)i;
        i = l;
_L2:
        if (true) goto _L9; else goto _L5
_L5:
        i = _decodeEscaped();
          goto _L10
_L6:
        i = _decodeUtf8_2(i);
          goto _L10
_L7:
        if (_inputEnd - _inputPtr >= 2)
            i = _decodeUtf8_3fast(i);
        else
            i = _decodeUtf8_3(i);
          goto _L10
_L8:
        l = _decodeUtf8_4(i);
        i = j + 1;
        ac[j] = (char)(0xd800 | l >> 10);
        if (i >= ac.length) {
            ac = _textBuffer.finishCurrentSegment();
            j = 0;
        } else {
            j = i;
        }
        i = 0xdc00 | l & 0x3ff;
          goto _L10
    }

    protected JsonToken _handleInvalidNumberStart(int i, boolean flag) {
_L3:
        int j;
        Object obj;
        j = i;
        if (i != 73)
            break MISSING_BLOCK_LABEL_187;
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOFInValue();
        byte abyte0[] = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        j = abyte0[i];
        if (j == 78) {
            if (flag)
                obj = "-INF";
            else
                obj = "+INF";
        } else {
            if (j != 110)
                break MISSING_BLOCK_LABEL_187;
            if (flag)
                obj = "-Infinity";
            else
                obj = "+Infinity";
        }
        _matchToken(((String) (obj)), 3);
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS)) goto _L2; else goto _L1
_L1:
        double d;
        if (flag)
            d = (-1.0D / 0.0D);
        else
            d = (1.0D / 0.0D);
        obj = resetAsNaN(((String) (obj)), d);
_L4:
        return ((JsonToken) (obj));
_L2:
        _reportError((new StringBuilder()).append("Non-standard token '").append(((String) (obj))).append("': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow").toString());
        i = j;
          goto _L3
        reportUnexpectedNumberChar(j, "expected digit (0-9) to follow minus sign, for valid numeric value");
        obj = null;
          goto _L4
    }

    protected String _handleOddName(int i) {
        if (i != 39 || !isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_SINGLE_QUOTES)) goto _L2; else goto _L1
_L1:
        String s = _parseAposName();
_L4:
        return s;
_L2:
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES))
            _reportUnexpectedChar((char)_decodeCharForError(i), "was expecting double-quote to start field name");
        int ai2[] = CharTypes.getInputCodeUtf8JsNames();
        if (ai2[i] != 0)
            _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name");
        s = _quadBuffer;
        int l = 0;
        int k = 0;
        int j = i;
        i = 0;
        do {
            int i1;
label0:
            {
                int ai[];
                if (l < 4) {
                    k = j | k << 8;
                    j = l + 1;
                } else {
                    int ai1[] = s;
                    if (i >= s.length) {
                        ai1 = growArrayBy(s, s.length);
                        _quadBuffer = ai1;
                    }
                    ai1[i] = k;
                    s = ai1;
                    l = 1;
                    k = j;
                    i++;
                    j = l;
                }
                if (_inputPtr >= _inputEnd && !loadMore())
                    _reportInvalidEOF(" in field name");
                i1 = _inputBuffer[_inputPtr] & 0xff;
                if (ai2[i1] == 0)
                    break label0;
                l = i;
                ai = s;
                if (j > 0) {
                    ai = s;
                    if (i >= s.length) {
                        ai = growArrayBy(s, s.length);
                        _quadBuffer = ai;
                    }
                    ai[i] = k;
                    l = i + 1;
                }
                s = _symbols.findName(ai, l);
                if (s == null)
                    s = addName(ai, l, j);
            }
            if (true)
                continue;
            _inputPtr = _inputPtr + 1;
            l = j;
            j = i1;
        } while (true);
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected JsonToken _handleUnexpectedValue(int i) {
        i;
        JVM INSTR lookupswitch 6: default 60
    //                   39: 115
    //                   43: 217
    //                   73: 175
    //                   78: 133
    //                   93: 107
    //                   125: 107;
           goto _L1 _L2 _L3 _L4 _L5 _L6 _L6
_L1:
        Object obj;
        if (Character.isJavaIdentifierStart(i))
            _reportInvalidToken((new StringBuilder()).append("").append((char)i).toString(), "('true', 'false' or 'null')");
        _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')");
        obj = null;
_L8:
        return ((JsonToken) (obj));
_L6:
        _reportUnexpectedChar(i, "expected a value");
_L2:
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_SINGLE_QUOTES)) goto _L1; else goto _L7
_L7:
        obj = _handleApos();
          goto _L8
_L5:
        _matchToken("NaN", 1);
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS)) goto _L10; else goto _L9
_L9:
        obj = resetAsNaN("NaN", (0.0D / 0.0D));
          goto _L8
_L10:
        _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow");
          goto _L1
_L4:
        _matchToken("Infinity", 1);
        if (!isEnabled(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS)) goto _L12; else goto _L11
_L11:
        obj = resetAsNaN("Infinity", (1.0D / 0.0D));
          goto _L8
_L12:
        _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow");
          goto _L1
_L3:
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOFInValue();
        obj = _inputBuffer;
        i = _inputPtr;
        _inputPtr = i + 1;
        obj = _handleInvalidNumberStart(obj[i] & 0xff, false);
          goto _L8
    }

    protected final boolean _loadToHaveAtLeast(int i) {
        boolean flag = false;
        if (_inputStream != null) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        int j = _inputEnd - _inputPtr;
        if (j > 0 && _inputPtr > 0) {
            int k = _inputPtr;
            _currInputProcessed = _currInputProcessed + (long)k;
            _currInputRowStart = _currInputRowStart - k;
            _nameStartOffset = _nameStartOffset - k;
            System.arraycopy(_inputBuffer, k, _inputBuffer, 0, j);
            _inputEnd = j;
        } else {
            _inputEnd = 0;
        }
        _inputPtr = 0;
        do {
            if (_inputEnd >= i)
                break;
            int l = _inputStream.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);
            if (l < 1) {
                _closeInput();
                if (l == 0)
                    throw new IOException((new StringBuilder()).append("InputStream.read() returned 0 characters when trying to read ").append(j).append(" bytes").toString());
                continue; /* Loop/switch isn't completed */
            }
            _inputEnd = l + _inputEnd;
        } while (true);
        flag = true;
        if (true) goto _L1; else goto _L3
_L3:
    }

    protected final void _matchToken(String s, int i) {
        int j;
        int k;
        k = s.length();
        j = i;
        if (_inputPtr + k < _inputEnd) goto _L2; else goto _L1
_L1:
        _matchToken2(s, i);
_L4:
        return;
_L2:
        do {
            if (_inputBuffer[_inputPtr] != s.charAt(j))
                _reportInvalidToken(s.substring(0, j));
            _inputPtr = _inputPtr + 1;
            i = j + 1;
            j = i;
        } while (i < k);
        j = _inputBuffer[_inputPtr] & 0xff;
        if (j >= 48 && j != 93 && j != 125)
            _checkMatchEnd(s, i, j);
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected String _parseAposName() {
        int i1;
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(": was expecting closing ''' for name");
        byte abyte0[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        i1 = abyte0[i] & 0xff;
        if (i1 != 39) goto _L2; else goto _L1
_L1:
        String s = "";
_L4:
        return s;
_L2:
        int j;
        int k;
        int l;
        int ai2[];
        s = _quadBuffer;
        ai2 = _icLatin1;
        k = 0;
        l = 0;
        j = 0;
_L5:
        int j1;
label0:
        {
            if (i1 != 39)
                break label0;
            if (k > 0) {
                int ai[] = s;
                if (j >= s.length) {
                    ai = growArrayBy(s, s.length);
                    _quadBuffer = ai;
                }
                ai[j] = pad(l, k);
                s = ai;
                j++;
            }
            int ai1[] = _symbols.findName(s, j);
            if (ai1 == null)
                s = addName(s, j, k);
            else
                s = ai1;
        }
        if (true) goto _L4; else goto _L3
_L3:
        j1 = i1;
        if (i1 == 34)
            break MISSING_BLOCK_LABEL_573;
        j1 = i1;
        if (ai2[i1] == 0)
            break MISSING_BLOCK_LABEL_573;
        if (i1 != 92)
            _throwUnquotedSpace(i1, "name");
        else
            i1 = _decodeEscaped();
        j1 = i1;
        if (i1 <= 127)
            break MISSING_BLOCK_LABEL_573;
        if (k >= 4) {
            ai1 = s;
            if (j >= s.length) {
                ai1 = growArrayBy(s, s.length);
                _quadBuffer = ai1;
            }
            ai1[j] = l;
            k = 0;
            j++;
            l = 0;
            s = ai1;
        }
        if (i1 < 2048) {
            l = l << 8 | (i1 >> 6 | 0xc0);
            k++;
        } else {
            l = l << 8 | (i1 >> 12 | 0xe0);
            if (++k >= 4) {
                ai1 = s;
                if (j >= s.length) {
                    ai1 = growArrayBy(s, s.length);
                    _quadBuffer = ai1;
                }
                ai1[j] = l;
                j++;
                s = ai1;
                k = 0;
                l = 0;
            }
            l = l << 8 | (i1 >> 6 & 0x3f | 0x80);
            k++;
        }
        j1 = l;
        l = k;
        k = i1 & 0x3f | 0x80;
        i1 = l;
_L6:
        if (i1 < 4) {
            l = k | j1 << 8;
            i1++;
            k = j;
            j = i1;
        } else {
            ai1 = s;
            if (j >= s.length) {
                ai1 = growArrayBy(s, s.length);
                _quadBuffer = ai1;
            }
            ai1[j] = j1;
            s = ai1;
            l = 1;
            i1 = j + 1;
            j = l;
            l = k;
            k = i1;
        }
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(" in field name");
        ai1 = _inputBuffer;
        i1 = _inputPtr;
        _inputPtr = i1 + 1;
        j1 = ai1[i1] & 0xff;
        i1 = j;
        j = k;
        k = i1;
        i1 = j1;
          goto _L5
        i1 = k;
        k = j1;
        j1 = l;
          goto _L6
    }

    protected final String _parseName(int i) {
        Object obj;
        if (i != 34)
            obj = _handleOddName(i);
        else
        if (_inputPtr + 13 > _inputEnd) {
            obj = slowParseName();
        } else {
            byte abyte0[] = _inputBuffer;
            obj = _icLatin1;
            i = _inputPtr;
            _inputPtr = i + 1;
            i = abyte0[i] & 0xff;
            if (obj[i] == 0) {
                int j = _inputPtr;
                _inputPtr = j + 1;
                j = abyte0[j] & 0xff;
                if (obj[j] == 0) {
                    i = i << 8 | j;
                    j = _inputPtr;
                    _inputPtr = j + 1;
                    j = abyte0[j] & 0xff;
                    if (obj[j] == 0) {
                        i = i << 8 | j;
                        j = _inputPtr;
                        _inputPtr = j + 1;
                        j = abyte0[j] & 0xff;
                        if (obj[j] == 0) {
                            i = i << 8 | j;
                            j = _inputPtr;
                            _inputPtr = j + 1;
                            j = abyte0[j] & 0xff;
                            if (obj[j] == 0) {
                                _quad1 = i;
                                obj = parseMediumName(j);
                            } else
                            if (j == 34)
                                obj = findName(i, 4);
                            else
                                obj = parseName(i, j, 4);
                        } else
                        if (j == 34)
                            obj = findName(i, 3);
                        else
                            obj = parseName(i, j, 3);
                    } else
                    if (j == 34)
                        obj = findName(i, 2);
                    else
                        obj = parseName(i, j, 2);
                } else
                if (j == 34)
                    obj = findName(i, 1);
                else
                    obj = parseName(i, j, 1);
            } else
            if (i == 34)
                obj = "";
            else
                obj = parseName(0, i, 0);
        }
        return ((String) (obj));
    }

    protected JsonToken _parseNegNumber() {
        int k;
        char ac[];
        ac = _textBuffer.emptyAndGetCurrentSegment();
        ac[0] = '-';
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        byte abyte0[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        k = abyte0[i] & 0xff;
        if (k >= 48 && k <= 57) goto _L2; else goto _L1
_L1:
        ac = _handleInvalidNumberStart(k, true);
_L4:
        return ac;
_L2:
        int j = k;
        if (k == 48)
            j = _verifyNoLeadingZeroes();
        int l = 2;
        ac[1] = (char)j;
        k = (_inputPtr + ac.length) - 2;
        int i1;
        byte abyte1[];
        if (k > _inputEnd) {
            k = _inputEnd;
            j = 1;
        } else {
            j = 1;
        }
        if (_inputPtr >= k) {
            ac = _parseNumber2(ac, l, true, j);
        } else {
label0:
            {
                abyte1 = _inputBuffer;
                i1 = _inputPtr;
                _inputPtr = i1 + 1;
                i1 = abyte1[i1] & 0xff;
                if (i1 >= 48 && i1 <= 57)
                    break label0;
                if (i1 == 46 || i1 == 101 || i1 == 69) {
                    ac = _parseFloat(ac, l, i1, true, j);
                } else {
                    _inputPtr = _inputPtr - 1;
                    _textBuffer.setCurrentLength(l);
                    if (_parsingContext.inRoot())
                        _verifyRootSpace(i1);
                    ac = resetInt(true, j);
                }
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
        j++;
        ac[l] = (char)i1;
        l++;
        break MISSING_BLOCK_LABEL_127;
    }

    protected JsonToken _parsePosNumber(int i) {
        int k = 1;
        char ac[] = _textBuffer.emptyAndGetCurrentSegment();
        int j = i;
        if (i == 48)
            j = _verifyNoLeadingZeroes();
        ac[0] = (char)j;
        j = (_inputPtr + ac.length) - 1;
        int l;
        Object obj;
        if (j > _inputEnd) {
            j = _inputEnd;
            i = 1;
        } else {
            i = 1;
        }
        if (_inputPtr < j) goto _L2; else goto _L1
_L1:
        obj = _parseNumber2(ac, k, false, i);
_L5:
        return ((JsonToken) (obj));
_L2:
        obj = _inputBuffer;
        l = _inputPtr;
        _inputPtr = l + 1;
        l = obj[l] & 0xff;
        if (l >= 48 && l <= 57) goto _L4; else goto _L3
_L3:
        if (l == 46 || l == 101 || l == 69) {
            obj = _parseFloat(ac, k, l, false, i);
        } else {
            _inputPtr = _inputPtr - 1;
            _textBuffer.setCurrentLength(k);
            if (_parsingContext.inRoot())
                _verifyRootSpace(l);
            obj = resetInt(false, i);
        }
        if (true) goto _L5; else goto _L4
_L4:
        ac[k] = (char)l;
        k++;
        i++;
        if (false)
            ;
        else
            break MISSING_BLOCK_LABEL_56;
    }

    protected int _readBinary(Base64Variant base64variant, OutputStream outputstream, byte abyte0[]) {
        int i;
        int j;
        int l1;
        l1 = abyte0.length;
        j = 0;
        i = 0;
_L8:
        int l;
        int i1;
        int j1;
        do {
            if (_inputPtr >= _inputEnd)
                loadMoreGuaranteed();
            byte abyte1[] = _inputBuffer;
            int k = _inputPtr;
            _inputPtr = k + 1;
            j1 = abyte1[k] & 0xff;
        } while (j1 <= 32);
        l = base64variant.decodeBase64Char(j1);
        i1 = l;
        if (l >= 0) goto _L2; else goto _L1
_L1:
        if (j1 != 34) goto _L4; else goto _L3
_L3:
        l = i;
        i = j;
_L6:
        _tokenIncomplete = false;
        j = i;
        if (l > 0) {
            j = i + l;
            outputstream.write(abyte0, 0, l);
        }
        return j;
_L4:
        i1 = _decodeBase64Escape(base64variant, j1, 0);
        if (i1 < 0)
            continue; /* Loop/switch isn't completed */
_L2:
        int k1;
        int i2;
        int j2;
        byte abyte2[];
        if (i > l1 - 3) {
            j += i;
            outputstream.write(abyte0, 0, i);
            l = 0;
            i = j;
        } else {
            l = i;
            i = j;
        }
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte2 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        i2 = abyte2[j] & 0xff;
        k1 = base64variant.decodeBase64Char(i2);
        j = k1;
        if (k1 < 0)
            j = _decodeBase64Escape(base64variant, i2, 1);
        i2 = i1 << 6 | j;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte2 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        j2 = abyte2[j] & 0xff;
        i1 = base64variant.decodeBase64Char(j2);
        k1 = i1;
        if (i1 < 0) {
            j = i1;
            if (i1 != -2) {
                if (j2 == 34 && !base64variant.usesPadding()) {
                    j = l + 1;
                    abyte0[l] = (byte)(i2 >> 4);
                    l = j;
                    continue; /* Loop/switch isn't completed */
                }
                j = _decodeBase64Escape(base64variant, j2, 2);
            }
            k1 = j;
            if (j == -2) {
                if (_inputPtr >= _inputEnd)
                    loadMoreGuaranteed();
                abyte2 = _inputBuffer;
                j = _inputPtr;
                _inputPtr = j + 1;
                j = abyte2[j] & 0xff;
                if (!base64variant.usesPaddingChar(j))
                    throw reportInvalidBase64Char(base64variant, j, 3, (new StringBuilder()).append("expected padding character '").append(base64variant.getPaddingChar()).append("'").toString());
                i1 = l + 1;
                abyte0[l] = (byte)(i2 >> 4);
                j = i;
                i = i1;
                continue; /* Loop/switch isn't completed */
            }
        }
        i2 = i2 << 6 | k1;
        if (_inputPtr >= _inputEnd)
            loadMoreGuaranteed();
        abyte2 = _inputBuffer;
        j = _inputPtr;
        _inputPtr = j + 1;
        j2 = abyte2[j] & 0xff;
        k1 = base64variant.decodeBase64Char(j2);
        i1 = k1;
        if (k1 >= 0)
            break MISSING_BLOCK_LABEL_709;
        j = k1;
        if (k1 == -2)
            break MISSING_BLOCK_LABEL_652;
        if (j2 != 34 || base64variant.usesPadding())
            break; /* Loop/switch isn't completed */
        i1 = i2 >> 2;
        j = l + 1;
        abyte0[l] = (byte)(i1 >> 8);
        l = j + 1;
        abyte0[j] = (byte)i1;
        if (true) goto _L6; else goto _L5
_L5:
        j = _decodeBase64Escape(base64variant, j2, 3);
        i1 = j;
        if (j == -2) {
            j = i2 >> 2;
            i1 = l + 1;
            abyte0[l] = (byte)(j >> 8);
            l = i1 + 1;
            abyte0[i1] = (byte)j;
            j = i;
            i = l;
            continue; /* Loop/switch isn't completed */
        }
        j = i2 << 6 | i1;
        k1 = l + 1;
        abyte0[l] = (byte)(j >> 16);
        i1 = k1 + 1;
        abyte0[k1] = (byte)(j >> 8);
        l = i1 + 1;
        abyte0[i1] = (byte)j;
        j = i;
        i = l;
        if (true) goto _L8; else goto _L7
_L7:
    }

    protected void _releaseBuffers() {
        super._releaseBuffers();
        _symbols.release();
        if (_bufferRecyclable) {
            byte abyte0[] = _inputBuffer;
            if (abyte0 != null) {
                _inputBuffer = ByteArrayBuilder.NO_BYTES;
                _ioContext.releaseReadIOBuffer(abyte0);
            }
        }
    }

    protected void _reportInvalidChar(int i) {
        if (i < 32)
            _throwInvalidSpace(i);
        _reportInvalidInitial(i);
    }

    protected void _reportInvalidInitial(int i) {
        _reportError((new StringBuilder()).append("Invalid UTF-8 start byte 0x").append(Integer.toHexString(i)).toString());
    }

    protected void _reportInvalidOther(int i) {
        _reportError((new StringBuilder()).append("Invalid UTF-8 middle byte 0x").append(Integer.toHexString(i)).toString());
    }

    protected void _reportInvalidOther(int i, int j) {
        _inputPtr = j;
        _reportInvalidOther(i);
    }

    protected void _reportInvalidToken(String s) {
        _reportInvalidToken(s, "'null', 'true', 'false' or NaN");
    }

    protected void _reportInvalidToken(String s, String s1) {
        s = new StringBuilder(s);
_L5:
        if (_inputPtr < _inputEnd || loadMore()) goto _L2; else goto _L1
_L1:
        _reportError((new StringBuilder()).append("Unrecognized token '").append(s.toString()).append("': was expecting ").append(s1).toString());
        return;
_L2:
        char c;
        byte abyte0[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        c = (char)_decodeCharForError(abyte0[i]);
        if (!Character.isJavaIdentifierPart(c)) goto _L1; else goto _L3
_L3:
        s.append(c);
        if (true) goto _L5; else goto _L4
_L4:
    }

    protected final void _skipCR() {
        if ((_inputPtr < _inputEnd || loadMore()) && _inputBuffer[_inputPtr] == 10)
            _inputPtr = _inputPtr + 1;
        _currInputRow = _currInputRow + 1;
        _currInputRowStart = _inputPtr;
    }

    protected void _skipString() {
        _tokenIncomplete = false;
        int ai[] = _icUTF8;
        byte abyte0[] = _inputBuffer;
label0:
        do
            do {
                int k = _inputPtr;
                int i1 = _inputEnd;
                int j = i1;
                int i = k;
                if (k >= i1) {
                    loadMoreGuaranteed();
                    i = _inputPtr;
                    j = _inputEnd;
                }
                int l;
                for (; i < j; i = l) {
                    l = i + 1;
                    i = abyte0[i] & 0xff;
                    if (ai[i] != 0) {
                        _inputPtr = l;
                        if (i == 34)
                            return;
                        switch (ai[i]) {
                        default:
                            if (i < 32)
                                _throwUnquotedSpace(i, "string value");
                            else
                                _reportInvalidChar(i);
                            break;

                        case 1: // '\001'
                            _decodeEscaped();
                            break;

                        case 2: // '\002'
                            _skipUtf8_2();
                            break;

                        case 3: // '\003'
                            _skipUtf8_3();
                            break;

                        case 4: // '\004'
                            _skipUtf8_4(i);
                            break;
                        }
                        continue label0;
                    }
                }

                _inputPtr = i;
            } while (true);
        while (true);
    }

    public byte[] getBinaryValue(Base64Variant base64variant) {
        if (_currToken != JsonToken.VALUE_STRING && (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null))
            _reportError((new StringBuilder()).append("Current token (").append(_currToken).append(") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary").toString());
        if (!_tokenIncomplete) goto _L2; else goto _L1
_L1:
        try {
            _binaryValue = _decodeBase64(base64variant);
        }
        catch (IllegalArgumentException illegalargumentexception) {
            throw _constructError((new StringBuilder()).append("Failed to decode VALUE_STRING as base64 (").append(base64variant).append("): ").append(illegalargumentexception.getMessage()).toString());
        }
        _tokenIncomplete = false;
_L4:
        return _binaryValue;
_L2:
        if (_binaryValue == null) {
            ByteArrayBuilder bytearraybuilder = _getByteArrayBuilder();
            _decodeBase64(getText(), bytearraybuilder, base64variant);
            _binaryValue = bytearraybuilder.toByteArray();
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public ObjectCodec getCodec() {
        return _objectCodec;
    }

    public JsonLocation getCurrentLocation() {
        int j = _inputPtr;
        int i = _currInputRowStart;
        return new JsonLocation(_ioContext.getSourceReference(), _currInputProcessed + (long)_inputPtr, -1L, _currInputRow, (j - i) + 1);
    }

    public Object getInputSource() {
        return _inputStream;
    }

    public String getText() {
        String s;
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                s = _finishAndReturnString();
            } else {
                s = _textBuffer.contentsAsString();
            }
        } else {
            s = _getText2(_currToken);
        }
        return s;
    }

    public char[] getTextCharacters() {
        if (_currToken == null) goto _L2; else goto _L1
_L1:
        _currToken.id();
        JVM INSTR tableswitch 5 8: default 44
    //                   5 54
    //                   6 136
    //                   7 152
    //                   8 152;
           goto _L3 _L4 _L5 _L6 _L6
_L3:
        Object obj = _currToken.asCharArray();
_L13:
        return ((char []) (obj));
_L4:
        if (_nameCopied) goto _L8; else goto _L7
_L7:
        int i;
        obj = _parsingContext.getCurrentName();
        i = ((String) (obj)).length();
        if (_nameCopyBuffer != null) goto _L10; else goto _L9
_L9:
        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(i);
_L11:
        ((String) (obj)).getChars(0, i, _nameCopyBuffer, 0);
        _nameCopied = true;
_L8:
        obj = _nameCopyBuffer;
        continue; /* Loop/switch isn't completed */
_L10:
        if (_nameCopyBuffer.length < i)
            _nameCopyBuffer = new char[i];
        if (true) goto _L11; else goto _L5
_L5:
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            _finishString();
        }
_L6:
        obj = _textBuffer.getTextBuffer();
        continue; /* Loop/switch isn't completed */
_L2:
        obj = null;
        if (true) goto _L13; else goto _L12
_L12:
    }

    public int getTextLength() {
        int i = 0;
        if (_currToken == null) goto _L2; else goto _L1
_L1:
        _currToken.id();
        JVM INSTR tableswitch 5 8: default 48
    //                   5 59
    //                   6 73
    //                   7 89
    //                   8 89;
           goto _L3 _L4 _L5 _L6 _L6
_L3:
        i = _currToken.asCharArray().length;
_L2:
        return i;
_L4:
        i = _parsingContext.getCurrentName().length();
        continue; /* Loop/switch isn't completed */
_L5:
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            _finishString();
        }
_L6:
        i = _textBuffer.size();
        if (true) goto _L2; else goto _L7
_L7:
    }

    public int getTextOffset() {
        int i;
        boolean flag;
        flag = false;
        i = ((flag) ? 1 : 0);
        if (_currToken == null) goto _L2; else goto _L1
_L1:
        i = ((flag) ? 1 : 0);
        _currToken.id();
        JVM INSTR tableswitch 5 8: default 52
    //                   5 54
    //                   6 56
    //                   7 72
    //                   8 72;
           goto _L3 _L4 _L5 _L6 _L6
_L4:
        break; /* Loop/switch isn't completed */
_L3:
        i = ((flag) ? 1 : 0);
_L2:
        return i;
_L5:
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            _finishString();
        }
_L6:
        i = _textBuffer.getTextOffset();
        if (true) goto _L2; else goto _L7
_L7:
    }

    public JsonLocation getTokenLocation() {
        Object obj = _ioContext.getSourceReference();
        if (_currToken == JsonToken.FIELD_NAME)
            obj = new JsonLocation(obj, _currInputProcessed + (long)(_nameStartOffset - 1), -1L, _nameStartRow, _nameStartCol);
        else
            obj = new JsonLocation(obj, _tokenInputTotal - 1L, -1L, _tokenInputRow, _tokenInputCol);
        return ((JsonLocation) (obj));
    }

    public int getValueAsInt() {
        JsonToken jsontoken = _currToken;
        if (jsontoken != JsonToken.VALUE_NUMBER_INT && jsontoken != JsonToken.VALUE_NUMBER_FLOAT) goto _L2; else goto _L1
_L1:
        if ((_numTypesValid & 1) != 0) goto _L4; else goto _L3
_L3:
        if (_numTypesValid != 0) goto _L6; else goto _L5
_L5:
        int i = _parseIntValue();
_L8:
        return i;
_L6:
        if ((_numTypesValid & 1) == 0)
            convertNumberToInt();
_L4:
        i = _numberInt;
        continue; /* Loop/switch isn't completed */
_L2:
        i = super.getValueAsInt(0);
        if (true) goto _L8; else goto _L7
_L7:
    }

    public int getValueAsInt(int i) {
        JsonToken jsontoken = _currToken;
        if (jsontoken != JsonToken.VALUE_NUMBER_INT && jsontoken != JsonToken.VALUE_NUMBER_FLOAT) goto _L2; else goto _L1
_L1:
        if ((_numTypesValid & 1) != 0) goto _L4; else goto _L3
_L3:
        if (_numTypesValid != 0) goto _L6; else goto _L5
_L5:
        i = _parseIntValue();
_L8:
        return i;
_L6:
        if ((_numTypesValid & 1) == 0)
            convertNumberToInt();
_L4:
        i = _numberInt;
        continue; /* Loop/switch isn't completed */
_L2:
        i = super.getValueAsInt(i);
        if (true) goto _L8; else goto _L7
_L7:
    }

    public String getValueAsString() {
        String s;
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                s = _finishAndReturnString();
            } else {
                s = _textBuffer.contentsAsString();
            }
        } else
        if (_currToken == JsonToken.FIELD_NAME)
            s = getCurrentName();
        else
            s = super.getValueAsString(null);
        return s;
    }

    public String getValueAsString(String s) {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                s = _finishAndReturnString();
            } else {
                s = _textBuffer.contentsAsString();
            }
        } else
        if (_currToken == JsonToken.FIELD_NAME)
            s = getCurrentName();
        else
            s = super.getValueAsString(s);
        return s;
    }

    protected final boolean loadMore() {
        boolean flag;
        boolean flag1;
        flag1 = false;
        int i = _inputEnd;
        _currInputProcessed = _currInputProcessed + (long)_inputEnd;
        _currInputRowStart = _currInputRowStart - _inputEnd;
        _nameStartOffset = _nameStartOffset - i;
        flag = flag1;
        if (_inputStream == null) goto _L2; else goto _L1
_L1:
        int j = _inputBuffer.length;
        if (j != 0) goto _L4; else goto _L3
_L3:
        flag = flag1;
_L2:
        return flag;
_L4:
        j = _inputStream.read(_inputBuffer, 0, j);
        if (j <= 0)
            break; /* Loop/switch isn't completed */
        _inputPtr = 0;
        _inputEnd = j;
        flag = true;
        if (true) goto _L2; else goto _L5
_L5:
        _closeInput();
        flag = flag1;
        if (j == 0)
            throw new IOException((new StringBuilder()).append("InputStream.read() returned 0 characters when trying to read ").append(_inputBuffer.length).append(" bytes").toString());
        if (true) goto _L2; else goto _L6
_L6:
    }

    public Boolean nextBooleanValue() {
        Object obj = null;
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        _currToken = jsontoken;
        if (jsontoken != JsonToken.VALUE_TRUE) goto _L4; else goto _L3
_L3:
        Boolean boolean1 = Boolean.TRUE;
_L6:
        return boolean1;
_L4:
        if (jsontoken == JsonToken.VALUE_FALSE)
            boolean1 = Boolean.FALSE;
        else
        if (jsontoken == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            boolean1 = obj;
        } else {
            boolean1 = obj;
            if (jsontoken == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
                boolean1 = obj;
            }
        }
        continue; /* Loop/switch isn't completed */
_L2:
        JsonToken jsontoken1 = nextToken();
        if (jsontoken1 == JsonToken.VALUE_TRUE) {
            boolean1 = Boolean.TRUE;
        } else {
            boolean1 = obj;
            if (jsontoken1 == JsonToken.VALUE_FALSE)
                boolean1 = Boolean.FALSE;
        }
        if (true) goto _L6; else goto _L5
_L5:
    }

    public String nextFieldName() {
        _numTypesValid = 0;
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        Object obj;
        _nextAfterName();
        obj = null;
_L12:
        return ((String) (obj));
_L2:
        int i;
        String s;
        if (_tokenIncomplete)
            _skipString();
        int j = _skipWSOrEnd();
        if (j < 0) {
            close();
            _currToken = null;
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        _binaryValue = null;
        if (j == 93) {
            _updateLocation();
            if (!_parsingContext.inArray())
                _reportMismatchedEndMarker(j, '}');
            _parsingContext = _parsingContext.clearAndGetParent();
            _currToken = JsonToken.END_ARRAY;
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        if (j == 125) {
            _updateLocation();
            if (!_parsingContext.inObject())
                _reportMismatchedEndMarker(j, ']');
            _parsingContext = _parsingContext.clearAndGetParent();
            _currToken = JsonToken.END_OBJECT;
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        i = j;
        if (_parsingContext.expectComma()) {
            if (j != 44)
                _reportUnexpectedChar(j, (new StringBuilder()).append("was expecting comma to separate ").append(_parsingContext.getTypeDesc()).append(" entries").toString());
            i = _skipWS();
        }
        if (!_parsingContext.inObject()) {
            _updateLocation();
            _nextTokenNotInObject(i);
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        _updateNameLocation();
        s = _parseName(i);
        _parsingContext.setCurrentName(s);
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
        _updateLocation();
        if (i == 34) {
            _tokenIncomplete = true;
            _nextToken = JsonToken.VALUE_STRING;
            obj = s;
            continue; /* Loop/switch isn't completed */
        }
        i;
        JVM INSTR lookupswitch 16: default 448
    //                   45: 465
    //                   48: 473
    //                   49: 473
    //                   50: 473
    //                   51: 473
    //                   52: 473
    //                   53: 473
    //                   54: 473
    //                   55: 473
    //                   56: 473
    //                   57: 473
    //                   91: 524
    //                   102: 482
    //                   110: 496
    //                   116: 510
    //                   123: 531;
           goto _L3 _L4 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L6 _L7 _L8 _L9 _L10
_L10:
        break MISSING_BLOCK_LABEL_531;
_L4:
        break; /* Loop/switch isn't completed */
_L3:
        obj = _handleUnexpectedValue(i);
_L13:
        _nextToken = ((JsonToken) (obj));
        obj = s;
        if (true) goto _L12; else goto _L11
_L11:
        obj = _parseNegNumber();
          goto _L13
_L5:
        obj = _parsePosNumber(i);
          goto _L13
_L7:
        _matchToken("false", 1);
        obj = JsonToken.VALUE_FALSE;
          goto _L13
_L8:
        _matchToken("null", 1);
        obj = JsonToken.VALUE_NULL;
          goto _L13
_L9:
        _matchToken("true", 1);
        obj = JsonToken.VALUE_TRUE;
          goto _L13
_L6:
        obj = JsonToken.START_ARRAY;
          goto _L13
        obj = JsonToken.START_OBJECT;
          goto _L13
    }

    public boolean nextFieldName(SerializableString serializablestring) {
        int i;
        boolean flag;
        _numTypesValid = 0;
        if (_currToken == JsonToken.FIELD_NAME) {
            _nextAfterName();
            flag = false;
        } else {
            if (_tokenIncomplete)
                _skipString();
            int j = _skipWSOrEnd();
            if (j < 0) {
                close();
                _currToken = null;
                flag = false;
            } else {
                _binaryValue = null;
                if (j == 93) {
                    _updateLocation();
                    if (!_parsingContext.inArray())
                        _reportMismatchedEndMarker(j, '}');
                    _parsingContext = _parsingContext.clearAndGetParent();
                    _currToken = JsonToken.END_ARRAY;
                    flag = false;
                } else
                if (j == 125) {
                    _updateLocation();
                    if (!_parsingContext.inObject())
                        _reportMismatchedEndMarker(j, ']');
                    _parsingContext = _parsingContext.clearAndGetParent();
                    _currToken = JsonToken.END_OBJECT;
                    flag = false;
                } else {
label0:
                    {
                        i = j;
                        if (_parsingContext.expectComma()) {
                            if (j != 44)
                                _reportUnexpectedChar(j, (new StringBuilder()).append("was expecting comma to separate ").append(_parsingContext.getTypeDesc()).append(" entries").toString());
                            i = _skipWS();
                        }
                        if (_parsingContext.inObject())
                            break label0;
                        _updateLocation();
                        _nextTokenNotInObject(i);
                        flag = false;
                    }
                }
            }
        }
_L5:
        return flag;
        _updateNameLocation();
        if (i != 34) goto _L2; else goto _L1
_L1:
        int k;
        byte abyte0[];
        abyte0 = serializablestring.asQuotedUTF8();
        k = abyte0.length;
        if (_inputPtr + k + 4 >= _inputEnd) goto _L2; else goto _L3
_L3:
        int i1 = _inputPtr + k;
        if (_inputBuffer[i1] != 34) goto _L2; else goto _L4
_L4:
        int l;
        k = _inputPtr;
        l = 0;
_L6:
label1:
        {
            if (k != i1)
                break label1;
            _parsingContext.setCurrentName(serializablestring.getValue());
            _isNextTokenNameYes(_skipColonFast(k + 1));
            flag = true;
        }
          goto _L5
        if (abyte0[l] == _inputBuffer[k])
            break MISSING_BLOCK_LABEL_380;
_L2:
        flag = _isNextTokenNameMaybe(i, serializablestring);
          goto _L5
        l++;
        k++;
          goto _L6
    }

    public int nextIntValue(int i) {
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        _currToken = jsontoken;
        if (jsontoken != JsonToken.VALUE_NUMBER_INT) goto _L4; else goto _L3
_L3:
        int j = getIntValue();
_L6:
        return j;
_L4:
        if (jsontoken == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            j = i;
        } else {
            j = i;
            if (jsontoken == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
                j = i;
            }
        }
        continue; /* Loop/switch isn't completed */
_L2:
        j = i;
        if (nextToken() == JsonToken.VALUE_NUMBER_INT)
            j = getIntValue();
        if (true) goto _L6; else goto _L5
_L5:
    }

    public long nextLongValue(long l) {
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        _currToken = jsontoken;
        if (jsontoken != JsonToken.VALUE_NUMBER_INT) goto _L4; else goto _L3
_L3:
        long l1 = getLongValue();
_L6:
        return l1;
_L4:
        if (jsontoken == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            l1 = l;
        } else {
            l1 = l;
            if (jsontoken == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
                l1 = l;
            }
        }
        continue; /* Loop/switch isn't completed */
_L2:
        l1 = l;
        if (nextToken() == JsonToken.VALUE_NUMBER_INT)
            l1 = getLongValue();
        if (true) goto _L6; else goto _L5
_L5:
    }

    public String nextTextValue() {
        Object obj = null;
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        JsonToken jsontoken;
        _nameCopied = false;
        jsontoken = _nextToken;
        _nextToken = null;
        _currToken = jsontoken;
        if (jsontoken != JsonToken.VALUE_STRING) goto _L4; else goto _L3
_L3:
        String s;
        if (_tokenIncomplete) {
            _tokenIncomplete = false;
            s = _finishAndReturnString();
        } else {
            s = _textBuffer.contentsAsString();
        }
_L6:
        return s;
_L4:
        if (jsontoken == JsonToken.START_ARRAY) {
            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            s = obj;
        } else {
            s = obj;
            if (jsontoken == JsonToken.START_OBJECT) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
                s = obj;
            }
        }
        continue; /* Loop/switch isn't completed */
_L2:
        s = obj;
        if (nextToken() == JsonToken.VALUE_STRING)
            s = getText();
        if (true) goto _L6; else goto _L5
_L5:
    }

    public JsonToken nextToken() {
        if (_currToken != JsonToken.FIELD_NAME) goto _L2; else goto _L1
_L1:
        Object obj = _nextAfterName();
_L12:
        return ((JsonToken) (obj));
_L2:
        int i;
        _numTypesValid = 0;
        if (_tokenIncomplete)
            _skipString();
        int j = _skipWSOrEnd();
        if (j < 0) {
            close();
            _currToken = null;
            obj = null;
            continue; /* Loop/switch isn't completed */
        }
        _binaryValue = null;
        if (j == 93) {
            _updateLocation();
            if (!_parsingContext.inArray())
                _reportMismatchedEndMarker(j, '}');
            _parsingContext = _parsingContext.clearAndGetParent();
            obj = JsonToken.END_ARRAY;
            _currToken = ((JsonToken) (obj));
            continue; /* Loop/switch isn't completed */
        }
        if (j == 125) {
            _updateLocation();
            if (!_parsingContext.inObject())
                _reportMismatchedEndMarker(j, ']');
            _parsingContext = _parsingContext.clearAndGetParent();
            obj = JsonToken.END_OBJECT;
            _currToken = ((JsonToken) (obj));
            continue; /* Loop/switch isn't completed */
        }
        i = j;
        if (_parsingContext.expectComma()) {
            if (j != 44)
                _reportUnexpectedChar(j, (new StringBuilder()).append("was expecting comma to separate ").append(_parsingContext.getTypeDesc()).append(" entries").toString());
            i = _skipWS();
        }
        if (!_parsingContext.inObject()) {
            _updateLocation();
            obj = _nextTokenNotInObject(i);
            continue; /* Loop/switch isn't completed */
        }
        _updateNameLocation();
        obj = _parseName(i);
        _parsingContext.setCurrentName(((String) (obj)));
        _currToken = JsonToken.FIELD_NAME;
        i = _skipColon();
        _updateLocation();
        if (i == 34) {
            _tokenIncomplete = true;
            _nextToken = JsonToken.VALUE_STRING;
            obj = _currToken;
            continue; /* Loop/switch isn't completed */
        }
        i;
        JVM INSTR lookupswitch 16: default 444
    //                   45: 463
    //                   48: 471
    //                   49: 471
    //                   50: 471
    //                   51: 471
    //                   52: 471
    //                   53: 471
    //                   54: 471
    //                   55: 471
    //                   56: 471
    //                   57: 471
    //                   91: 522
    //                   102: 480
    //                   110: 494
    //                   116: 508
    //                   123: 529;
           goto _L3 _L4 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L5 _L6 _L7 _L8 _L9 _L10
_L10:
        break MISSING_BLOCK_LABEL_529;
_L4:
        break; /* Loop/switch isn't completed */
_L3:
        obj = _handleUnexpectedValue(i);
_L13:
        _nextToken = ((JsonToken) (obj));
        obj = _currToken;
        if (true) goto _L12; else goto _L11
_L11:
        obj = _parseNegNumber();
          goto _L13
_L5:
        obj = _parsePosNumber(i);
          goto _L13
_L7:
        _matchToken("false", 1);
        obj = JsonToken.VALUE_FALSE;
          goto _L13
_L8:
        _matchToken("null", 1);
        obj = JsonToken.VALUE_NULL;
          goto _L13
_L9:
        _matchToken("true", 1);
        obj = JsonToken.VALUE_TRUE;
          goto _L13
_L6:
        obj = JsonToken.START_ARRAY;
          goto _L13
        obj = JsonToken.START_OBJECT;
          goto _L13
    }

    protected final String parseEscapedName(int ai[], int i, int j, int k, int l) {
        int ai5[] = _icLatin1;
_L2:
        int i1;
        i1 = k;
        if (ai5[k] == 0)
            break; /* Loop/switch isn't completed */
        if (k == 34) {
            int ai1[] = ai;
            k = i;
            if (l > 0) {
                ai1 = ai;
                if (i >= ai.length) {
                    ai1 = growArrayBy(ai, ai.length);
                    _quadBuffer = ai1;
                }
                ai1[i] = pad(j, l);
                k = i + 1;
            }
            String s = _symbols.findName(ai1, k);
            ai = s;
            if (s == null)
                ai = addName(ai1, k, l);
            return ai;
        }
        int j1;
        byte abyte0[];
        if (k != 92)
            _throwUnquotedSpace(k, "name");
        else
            k = _decodeEscaped();
        i1 = k;
        if (k <= 127)
            break; /* Loop/switch isn't completed */
        if (l >= 4) {
            int ai2[] = ai;
            if (i >= ai.length) {
                ai2 = growArrayBy(ai, ai.length);
                _quadBuffer = ai2;
            }
            i1 = i + 1;
            ai2[i] = j;
            l = 0;
            j = 0;
            ai = ai2;
            i = i1;
        }
        if (k < 2048) {
            i1 = k >> 6 | 0xc0 | j << 8;
            l++;
            j = i;
            i = i1;
        } else {
            j = k >> 12 | 0xe0 | j << 8;
            if (++l >= 4) {
                int ai3[] = ai;
                if (i >= ai.length) {
                    ai3 = growArrayBy(ai, ai.length);
                    _quadBuffer = ai3;
                }
                ai3[i] = j;
                i++;
                ai = ai3;
                l = 0;
                j = 0;
            }
            i1 = j << 8 | (k >> 6 & 0x3f | 0x80);
            l++;
            j = i;
            i = i1;
        }
        j1 = k & 0x3f | 0x80;
        i1 = j;
        k = i;
        j = j1;
        i = i1;
_L3:
        if (l < 4) {
            l++;
            j |= k << 8;
        } else {
            int ai4[] = ai;
            if (i >= ai.length) {
                ai4 = growArrayBy(ai, ai.length);
                _quadBuffer = ai4;
            }
            ai4[i] = k;
            l = 1;
            i++;
            ai = ai4;
        }
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(" in field name");
        abyte0 = _inputBuffer;
        k = _inputPtr;
        _inputPtr = k + 1;
        k = abyte0[k] & 0xff;
        if (true) goto _L2; else goto _L1
_L1:
        k = j;
        j = i1;
          goto _L3
        if (true) goto _L2; else goto _L4
_L4:
    }

    protected final String parseLongName(int i, int j, int k) {
        Object obj;
        byte abyte0[];
        _quadBuffer[0] = _quad1;
        _quadBuffer[1] = j;
        _quadBuffer[2] = k;
        abyte0 = _inputBuffer;
        obj = _icLatin1;
        k = 3;
        j = i;
        i = k;
_L1:
        if (_inputPtr + 4 <= _inputEnd) {
            k = _inputPtr;
            _inputPtr = k + 1;
            k = abyte0[k] & 0xff;
            if (obj[k] != 0) {
                if (k == 34)
                    obj = findName(_quadBuffer, i, j, 1);
                else
                    obj = parseEscapedName(_quadBuffer, i, j, k, 1);
            } else {
                j = j << 8 | k;
                k = _inputPtr;
                _inputPtr = k + 1;
                k = abyte0[k] & 0xff;
                if (obj[k] != 0) {
                    if (k == 34)
                        obj = findName(_quadBuffer, i, j, 2);
                    else
                        obj = parseEscapedName(_quadBuffer, i, j, k, 2);
                } else {
                    j = j << 8 | k;
                    k = _inputPtr;
                    _inputPtr = k + 1;
                    k = abyte0[k] & 0xff;
                    if (obj[k] != 0) {
                        if (k == 34)
                            obj = findName(_quadBuffer, i, j, 3);
                        else
                            obj = parseEscapedName(_quadBuffer, i, j, k, 3);
                    } else {
label0:
                        {
                            k = j << 8 | k;
                            j = _inputPtr;
                            _inputPtr = j + 1;
                            j = abyte0[j] & 0xff;
                            if (obj[j] == 0)
                                break label0;
                            if (j == 34)
                                obj = findName(_quadBuffer, i, k, 4);
                            else
                                obj = parseEscapedName(_quadBuffer, i, k, j, 4);
                        }
                    }
                }
            }
        } else {
            obj = parseEscapedName(_quadBuffer, i, 0, j, 0);
        }
        return ((String) (obj));
        if (i >= _quadBuffer.length)
            _quadBuffer = growArrayBy(_quadBuffer, i);
        _quadBuffer[i] = k;
        i++;
          goto _L1
    }

    protected final String parseMediumName(int i) {
        byte abyte0[] = _inputBuffer;
        Object obj = _icLatin1;
        int j = _inputPtr;
        _inputPtr = j + 1;
        j = abyte0[j] & 0xff;
        if (obj[j] != 0) {
            if (j == 34)
                obj = findName(_quad1, i, 1);
            else
                obj = parseName(_quad1, i, j, 1);
        } else {
            i = j | i << 8;
            j = _inputPtr;
            _inputPtr = j + 1;
            j = abyte0[j] & 0xff;
            if (obj[j] != 0) {
                if (j == 34)
                    obj = findName(_quad1, i, 2);
                else
                    obj = parseName(_quad1, i, j, 2);
            } else {
                i = i << 8 | j;
                j = _inputPtr;
                _inputPtr = j + 1;
                j = abyte0[j] & 0xff;
                if (obj[j] != 0) {
                    if (j == 34)
                        obj = findName(_quad1, i, 3);
                    else
                        obj = parseName(_quad1, i, j, 3);
                } else {
                    i = i << 8 | j;
                    j = _inputPtr;
                    _inputPtr = j + 1;
                    j = abyte0[j] & 0xff;
                    if (obj[j] != 0) {
                        if (j == 34)
                            obj = findName(_quad1, i, 4);
                        else
                            obj = parseName(_quad1, i, j, 4);
                    } else {
                        obj = parseMediumName2(j, i);
                    }
                }
            }
        }
        return ((String) (obj));
    }

    protected final String parseMediumName2(int i, int j) {
        Object obj = _inputBuffer;
        int ai[] = _icLatin1;
        int k = _inputPtr;
        _inputPtr = k + 1;
        k = obj[k] & 0xff;
        if (ai[k] != 0) {
            if (k == 34)
                obj = findName(_quad1, j, i, 1);
            else
                obj = parseName(_quad1, j, i, k, 1);
        } else {
            i = i << 8 | k;
            k = _inputPtr;
            _inputPtr = k + 1;
            k = obj[k] & 0xff;
            if (ai[k] != 0) {
                if (k == 34)
                    obj = findName(_quad1, j, i, 2);
                else
                    obj = parseName(_quad1, j, i, k, 2);
            } else {
                i = i << 8 | k;
                k = _inputPtr;
                _inputPtr = k + 1;
                k = obj[k] & 0xff;
                if (ai[k] != 0) {
                    if (k == 34)
                        obj = findName(_quad1, j, i, 3);
                    else
                        obj = parseName(_quad1, j, i, k, 3);
                } else {
                    i = i << 8 | k;
                    k = _inputPtr;
                    _inputPtr = k + 1;
                    k = obj[k] & 0xff;
                    if (ai[k] != 0) {
                        if (k == 34)
                            obj = findName(_quad1, j, i, 4);
                        else
                            obj = parseName(_quad1, j, i, k, 4);
                    } else {
                        obj = parseLongName(k, j, i);
                    }
                }
            }
        }
        return ((String) (obj));
    }

    public int readBinaryValue(Base64Variant base64variant, OutputStream outputstream) {
        if (_tokenIncomplete && _currToken == JsonToken.VALUE_STRING) goto _L2; else goto _L1
_L1:
        int i;
        base64variant = getBinaryValue(base64variant);
        outputstream.write(base64variant);
        i = base64variant.length;
_L4:
        return i;
_L2:
        byte abyte0[] = _ioContext.allocBase64Buffer();
        i = _readBinary(base64variant, outputstream, abyte0);
        _ioContext.releaseBase64Buffer(abyte0);
        if (true) goto _L4; else goto _L3
_L3:
        base64variant;
        _ioContext.releaseBase64Buffer(abyte0);
        throw base64variant;
    }

    public int releaseBuffered(OutputStream outputstream) {
        int i = _inputEnd - _inputPtr;
        if (i < 1) {
            i = 0;
        } else {
            int j = _inputPtr;
            outputstream.write(_inputBuffer, j, i);
        }
        return i;
    }

    public void setCodec(ObjectCodec objectcodec) {
        _objectCodec = objectcodec;
    }

    protected String slowParseName() {
        if (_inputPtr >= _inputEnd && !loadMore())
            _reportInvalidEOF(": was expecting closing '\"' for name");
        byte abyte0[] = _inputBuffer;
        int i = _inputPtr;
        _inputPtr = i + 1;
        i = abyte0[i] & 0xff;
        String s;
        if (i == 34)
            s = "";
        else
            s = parseEscapedName(_quadBuffer, 0, 0, i, 0);
        return s;
    }

}
