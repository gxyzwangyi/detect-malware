// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.core.base;

import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.core.io.IOContext;
import com.fasterxml.jackson.core.io.NumberInput;
import com.fasterxml.jackson.core.json.*;
import com.fasterxml.jackson.core.util.ByteArrayBuilder;
import com.fasterxml.jackson.core.util.TextBuffer;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;

// Referenced classes of package com.fasterxml.jackson.core.base:
//            ParserMinimalBase

public abstract class ParserBase extends ParserMinimalBase {

    static final BigDecimal BD_MAX_INT;
    static final BigDecimal BD_MAX_LONG;
    static final BigDecimal BD_MIN_INT;
    static final BigDecimal BD_MIN_LONG;
    static final BigInteger BI_MAX_INT;
    static final BigInteger BI_MAX_LONG;
    static final BigInteger BI_MIN_INT;
    static final BigInteger BI_MIN_LONG;
    protected static final char CHAR_NULL = 0;
    protected static final int INT_0 = 48;
    protected static final int INT_9 = 57;
    protected static final int INT_MINUS = 45;
    protected static final int INT_PLUS = 43;
    static final double MAX_INT_D = 2147483647D;
    static final long MAX_INT_L = 0x7fffffffL;
    static final double MAX_LONG_D = 9.2233720368547758E+18D;
    static final double MIN_INT_D = -2147483648D;
    static final long MIN_INT_L = 0x80000000L;
    static final double MIN_LONG_D = -9.2233720368547758E+18D;
    protected static final int NR_BIGDECIMAL = 16;
    protected static final int NR_BIGINT = 4;
    protected static final int NR_DOUBLE = 8;
    protected static final int NR_INT = 1;
    protected static final int NR_LONG = 2;
    protected static final int NR_UNKNOWN = 0;
    protected byte _binaryValue[];
    protected ByteArrayBuilder _byteArrayBuilder;
    protected boolean _closed;
    protected long _currInputProcessed;
    protected int _currInputRow;
    protected int _currInputRowStart;
    protected int _expLength;
    protected int _fractLength;
    protected int _inputEnd;
    protected int _inputPtr;
    protected int _intLength;
    protected final IOContext _ioContext;
    protected boolean _nameCopied;
    protected char _nameCopyBuffer[];
    protected JsonToken _nextToken;
    protected int _numTypesValid;
    protected BigDecimal _numberBigDecimal;
    protected BigInteger _numberBigInt;
    protected double _numberDouble;
    protected int _numberInt;
    protected long _numberLong;
    protected boolean _numberNegative;
    protected JsonReadContext _parsingContext;
    protected final TextBuffer _textBuffer;
    protected int _tokenInputCol;
    protected int _tokenInputRow;
    protected long _tokenInputTotal;

    protected ParserBase(IOContext iocontext, int i) {
        super(i);
        _currInputRow = 1;
        _tokenInputRow = 1;
        _numTypesValid = 0;
        _ioContext = iocontext;
        _textBuffer = iocontext.constructTextBuffer();
        if (com.fasterxml.jackson.core.JsonParser.Feature.STRICT_DUPLICATE_DETECTION.enabledIn(i))
            iocontext = DupDetector.rootDetector(this);
        else
            iocontext = null;
        _parsingContext = JsonReadContext.createRootContext(iocontext);
    }

    private void _parseSlowFloat(int i) {
        if (i != 16)
            break MISSING_BLOCK_LABEL_24;
        _numberBigDecimal = _textBuffer.contentsAsDecimal();
        _numTypesValid = 16;
_L1:
        return;
        try {
            _numberDouble = _textBuffer.contentsAsDouble();
            _numTypesValid = 8;
        }
        catch (NumberFormatException numberformatexception) {
            _wrapError((new StringBuilder()).append("Malformed numeric value '").append(_textBuffer.contentsAsString()).append("'").toString(), numberformatexception);
        }
          goto _L1
    }

    private void _parseSlowInt(int i, char ac[], int j, int k) {
        String s = _textBuffer.contentsAsString();
        if (!NumberInput.inLongRange(ac, j, k, _numberNegative))
            break MISSING_BLOCK_LABEL_38;
        _numberLong = Long.parseLong(s);
        _numTypesValid = 2;
_L1:
        return;
        try {
            ac = JVM INSTR new #96  <Class BigInteger>;
            ac.BigInteger(s);
            _numberBigInt = ac;
            _numTypesValid = 4;
        }
        // Misplaced declaration of an exception variable
        catch (char ac[]) {
            _wrapError((new StringBuilder()).append("Malformed numeric value '").append(s).append("'").toString(), ac);
        }
          goto _L1
    }

    protected void _checkStdFeatureChanges(int i, int j) {
        int k = com.fasterxml.jackson.core.JsonParser.Feature.STRICT_DUPLICATE_DETECTION.getMask();
        if ((j & k) != 0 && (k & i) != 0)
            if (_parsingContext.getDupDetector() == null)
                _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));
            else
                _parsingContext = _parsingContext.withDupDetector(null);
    }

    protected abstract void _closeInput();

    protected final int _decodeBase64Escape(Base64Variant base64variant, char c, int i) {
        if (c != '\\')
            throw reportInvalidBase64Char(base64variant, c, i);
        char c1 = _decodeEscaped();
        if (c1 <= ' ' && i == 0) {
            c = '\uFFFF';
        } else {
            int j = base64variant.decodeBase64Char(c1);
            c = j;
            if (j < 0)
                throw reportInvalidBase64Char(base64variant, c1, i);
        }
        return c;
    }

    protected final int _decodeBase64Escape(Base64Variant base64variant, int i, int j) {
        if (i != 92)
            throw reportInvalidBase64Char(base64variant, i, j);
        char c = _decodeEscaped();
        if (c <= ' ' && j == 0) {
            i = -1;
        } else {
            int k = base64variant.decodeBase64Char(c);
            i = k;
            if (k < 0)
                throw reportInvalidBase64Char(base64variant, c, j);
        }
        return i;
    }

    protected char _decodeEscaped() {
        throw new UnsupportedOperationException();
    }

    protected final int _eofAsNextChar() {
        _handleEOF();
        return -1;
    }

    protected abstract void _finishString();

    public ByteArrayBuilder _getByteArrayBuilder() {
        if (_byteArrayBuilder == null)
            _byteArrayBuilder = new ByteArrayBuilder();
        else
            _byteArrayBuilder.reset();
        return _byteArrayBuilder;
    }

    protected void _handleEOF() {
        if (!_parsingContext.inRoot())
            _reportInvalidEOF((new StringBuilder()).append(": expected close marker for ").append(_parsingContext.getTypeDesc()).append(" (from ").append(_parsingContext.getStartLocation(_ioContext.getSourceReference())).append(")").toString());
    }

    protected int _parseIntValue() {
        if (_currToken != JsonToken.VALUE_NUMBER_INT) goto _L2; else goto _L1
_L1:
        int i;
        int l;
        char ac[];
        ac = _textBuffer.getTextBuffer();
        int j = _textBuffer.getTextOffset();
        l = _intLength;
        i = j;
        if (_numberNegative)
            i = j + 1;
        if (l > 9) goto _L2; else goto _L3
_L3:
        int k = NumberInput.parseInt(ac, i, l);
        i = k;
        if (_numberNegative)
            i = -k;
        _numberInt = i;
        _numTypesValid = 1;
_L5:
        return i;
_L2:
        _parseNumericValue(1);
        if ((_numTypesValid & 1) == 0)
            convertNumberToInt();
        i = _numberInt;
        if (true) goto _L5; else goto _L4
_L4:
    }

    protected void _parseNumericValue(int i) {
        if (_currToken != JsonToken.VALUE_NUMBER_INT) goto _L2; else goto _L1
_L1:
        int j;
        int l;
        char ac[];
        ac = _textBuffer.getTextBuffer();
        int k = _textBuffer.getTextOffset();
        l = _intLength;
        j = k;
        if (_numberNegative)
            j = k + 1;
        if (l > 9) goto _L4; else goto _L3
_L3:
        j = NumberInput.parseInt(ac, j, l);
        i = j;
        if (_numberNegative)
            i = -j;
        _numberInt = i;
        _numTypesValid = 1;
_L6:
        return;
_L4:
        if (l <= 18) {
            long l2 = NumberInput.parseLong(ac, j, l);
            long l1 = l2;
            if (_numberNegative)
                l1 = -l2;
            if (l == 10)
                if (_numberNegative) {
                    if (l1 >= 0x80000000L) {
                        _numberInt = (int)l1;
                        _numTypesValid = 1;
                        continue; /* Loop/switch isn't completed */
                    }
                } else
                if (l1 <= 0x7fffffffL) {
                    _numberInt = (int)l1;
                    _numTypesValid = 1;
                    continue; /* Loop/switch isn't completed */
                }
            _numberLong = l1;
            _numTypesValid = 2;
        } else {
            _parseSlowInt(i, ac, j, l);
        }
        continue; /* Loop/switch isn't completed */
_L2:
        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT)
            _parseSlowFloat(i);
        else
            _reportError((new StringBuilder()).append("Current token (").append(_currToken).append(") not numeric, can not use numeric value accessors").toString());
        if (true) goto _L6; else goto _L5
_L5:
    }

    protected void _releaseBuffers() {
        _textBuffer.releaseBuffers();
        char ac[] = _nameCopyBuffer;
        if (ac != null) {
            _nameCopyBuffer = null;
            _ioContext.releaseNameCopyBuffer(ac);
        }
    }

    protected void _reportMismatchedEndMarker(int i, char c) {
        String s = (new StringBuilder()).append("").append(_parsingContext.getStartLocation(_ioContext.getSourceReference())).toString();
        _reportError((new StringBuilder()).append("Unexpected close marker '").append((char)i).append("': expected '").append(c).append("' (for ").append(_parsingContext.getTypeDesc()).append(" starting at ").append(s).append(")").toString());
    }

    public void close() {
        if (_closed)
            break MISSING_BLOCK_LABEL_20;
        _closed = true;
        _closeInput();
        _releaseBuffers();
        return;
        Exception exception;
        exception;
        _releaseBuffers();
        throw exception;
    }

    protected void convertNumberToBigDecimal() {
        if ((_numTypesValid & 8) != 0)
            _numberBigDecimal = NumberInput.parseBigDecimal(getText());
        else
        if ((_numTypesValid & 4) != 0)
            _numberBigDecimal = new BigDecimal(_numberBigInt);
        else
        if ((_numTypesValid & 2) != 0)
            _numberBigDecimal = BigDecimal.valueOf(_numberLong);
        else
        if ((_numTypesValid & 1) != 0)
            _numberBigDecimal = BigDecimal.valueOf(_numberInt);
        else
            _throwInternal();
        _numTypesValid = _numTypesValid | 0x10;
    }

    protected void convertNumberToBigInteger() {
        if ((_numTypesValid & 0x10) != 0)
            _numberBigInt = _numberBigDecimal.toBigInteger();
        else
        if ((_numTypesValid & 2) != 0)
            _numberBigInt = BigInteger.valueOf(_numberLong);
        else
        if ((_numTypesValid & 1) != 0)
            _numberBigInt = BigInteger.valueOf(_numberInt);
        else
        if ((_numTypesValid & 8) != 0)
            _numberBigInt = BigDecimal.valueOf(_numberDouble).toBigInteger();
        else
            _throwInternal();
        _numTypesValid = _numTypesValid | 4;
    }

    protected void convertNumberToDouble() {
        if ((_numTypesValid & 0x10) != 0)
            _numberDouble = _numberBigDecimal.doubleValue();
        else
        if ((_numTypesValid & 4) != 0)
            _numberDouble = _numberBigInt.doubleValue();
        else
        if ((_numTypesValid & 2) != 0)
            _numberDouble = _numberLong;
        else
        if ((_numTypesValid & 1) != 0)
            _numberDouble = _numberInt;
        else
            _throwInternal();
        _numTypesValid = _numTypesValid | 8;
    }

    protected void convertNumberToInt() {
        if ((_numTypesValid & 2) != 0) {
            int i = (int)_numberLong;
            if ((long)i != _numberLong)
                _reportError((new StringBuilder()).append("Numeric value (").append(getText()).append(") out of range of int").toString());
            _numberInt = i;
        } else
        if ((_numTypesValid & 4) != 0) {
            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0)
                reportOverflowInt();
            _numberInt = _numberBigInt.intValue();
        } else
        if ((_numTypesValid & 8) != 0) {
            if (_numberDouble < -2147483648D || _numberDouble > 2147483647D)
                reportOverflowInt();
            _numberInt = (int)_numberDouble;
        } else
        if ((_numTypesValid & 0x10) != 0) {
            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0)
                reportOverflowInt();
            _numberInt = _numberBigDecimal.intValue();
        } else {
            _throwInternal();
        }
        _numTypesValid = _numTypesValid | 1;
    }

    protected void convertNumberToLong() {
        if ((_numTypesValid & 1) != 0)
            _numberLong = _numberInt;
        else
        if ((_numTypesValid & 4) != 0) {
            if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 || BI_MAX_LONG.compareTo(_numberBigInt) < 0)
                reportOverflowLong();
            _numberLong = _numberBigInt.longValue();
        } else
        if ((_numTypesValid & 8) != 0) {
            if (_numberDouble < -9.2233720368547758E+18D || _numberDouble > 9.2233720368547758E+18D)
                reportOverflowLong();
            _numberLong = (long)_numberDouble;
        } else
        if ((_numTypesValid & 0x10) != 0) {
            if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0)
                reportOverflowLong();
            _numberLong = _numberBigDecimal.longValue();
        } else {
            _throwInternal();
        }
        _numTypesValid = _numTypesValid | 2;
    }

    public JsonParser disable(com.fasterxml.jackson.core.JsonParser.Feature feature) {
        _features = _features & ~feature.getMask();
        if (feature == com.fasterxml.jackson.core.JsonParser.Feature.STRICT_DUPLICATE_DETECTION)
            _parsingContext = _parsingContext.withDupDetector(null);
        return this;
    }

    public JsonParser enable(com.fasterxml.jackson.core.JsonParser.Feature feature) {
        _features = _features | feature.getMask();
        if (feature == com.fasterxml.jackson.core.JsonParser.Feature.STRICT_DUPLICATE_DETECTION && _parsingContext.getDupDetector() == null)
            _parsingContext = _parsingContext.withDupDetector(DupDetector.rootDetector(this));
        return this;
    }

    public BigInteger getBigIntegerValue() {
        if ((_numTypesValid & 4) == 0) {
            if (_numTypesValid == 0)
                _parseNumericValue(4);
            if ((_numTypesValid & 4) == 0)
                convertNumberToBigInteger();
        }
        return _numberBigInt;
    }

    public byte[] getBinaryValue(Base64Variant base64variant) {
        if (_binaryValue == null) {
            if (_currToken != JsonToken.VALUE_STRING)
                _reportError((new StringBuilder()).append("Current token (").append(_currToken).append(") not VALUE_STRING, can not access as binary").toString());
            ByteArrayBuilder bytearraybuilder = _getByteArrayBuilder();
            _decodeBase64(getText(), bytearraybuilder, base64variant);
            _binaryValue = bytearraybuilder.toByteArray();
        }
        return _binaryValue;
    }

    public JsonLocation getCurrentLocation() {
        int i = _inputPtr;
        int j = _currInputRowStart;
        return new JsonLocation(_ioContext.getSourceReference(), -1L, _currInputProcessed + (long)_inputPtr, _currInputRow, (i - j) + 1);
    }

    public String getCurrentName() {
        if (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.START_ARRAY) goto _L2; else goto _L1
_L1:
        Object obj = _parsingContext.getParent();
        if (obj == null) goto _L2; else goto _L3
_L3:
        obj = ((JsonReadContext) (obj)).getCurrentName();
_L5:
        return ((String) (obj));
_L2:
        obj = _parsingContext.getCurrentName();
        if (true) goto _L5; else goto _L4
_L4:
    }

    public Object getCurrentValue() {
        return _parsingContext.getCurrentValue();
    }

    public BigDecimal getDecimalValue() {
        if ((_numTypesValid & 0x10) == 0) {
            if (_numTypesValid == 0)
                _parseNumericValue(16);
            if ((_numTypesValid & 0x10) == 0)
                convertNumberToBigDecimal();
        }
        return _numberBigDecimal;
    }

    public double getDoubleValue() {
        if ((_numTypesValid & 8) == 0) {
            if (_numTypesValid == 0)
                _parseNumericValue(8);
            if ((_numTypesValid & 8) == 0)
                convertNumberToDouble();
        }
        return _numberDouble;
    }

    public Object getEmbeddedObject() {
        return null;
    }

    public float getFloatValue() {
        return (float)getDoubleValue();
    }

    public int getIntValue() {
        if ((_numTypesValid & 1) != 0) goto _L2; else goto _L1
_L1:
        if (_numTypesValid != 0) goto _L4; else goto _L3
_L3:
        int i = _parseIntValue();
_L6:
        return i;
_L4:
        if ((_numTypesValid & 1) == 0)
            convertNumberToInt();
_L2:
        i = _numberInt;
        if (true) goto _L6; else goto _L5
_L5:
    }

    public long getLongValue() {
        if ((_numTypesValid & 2) == 0) {
            if (_numTypesValid == 0)
                _parseNumericValue(2);
            if ((_numTypesValid & 2) == 0)
                convertNumberToLong();
        }
        return _numberLong;
    }

    public com.fasterxml.jackson.core.JsonParser.NumberType getNumberType() {
        if (_numTypesValid == 0)
            _parseNumericValue(0);
        com.fasterxml.jackson.core.JsonParser.NumberType numbertype;
        if (_currToken == JsonToken.VALUE_NUMBER_INT) {
            if ((_numTypesValid & 1) != 0)
                numbertype = com.fasterxml.jackson.core.JsonParser.NumberType.INT;
            else
            if ((_numTypesValid & 2) != 0)
                numbertype = com.fasterxml.jackson.core.JsonParser.NumberType.LONG;
            else
                numbertype = com.fasterxml.jackson.core.JsonParser.NumberType.BIG_INTEGER;
        } else
        if ((_numTypesValid & 0x10) != 0)
            numbertype = com.fasterxml.jackson.core.JsonParser.NumberType.BIG_DECIMAL;
        else
            numbertype = com.fasterxml.jackson.core.JsonParser.NumberType.DOUBLE;
        return numbertype;
    }

    public Number getNumberValue() {
        if (_numTypesValid == 0)
            _parseNumericValue(0);
        Object obj;
        if (_currToken == JsonToken.VALUE_NUMBER_INT) {
            if ((_numTypesValid & 1) != 0)
                obj = Integer.valueOf(_numberInt);
            else
            if ((_numTypesValid & 2) != 0)
                obj = Long.valueOf(_numberLong);
            else
            if ((_numTypesValid & 4) != 0)
                obj = _numberBigInt;
            else
                obj = _numberBigDecimal;
        } else
        if ((_numTypesValid & 0x10) != 0) {
            obj = _numberBigDecimal;
        } else {
            if ((_numTypesValid & 8) == 0)
                _throwInternal();
            obj = Double.valueOf(_numberDouble);
        }
        return ((Number) (obj));
    }

    public volatile JsonStreamContext getParsingContext() {
        return getParsingContext();
    }

    public JsonReadContext getParsingContext() {
        return _parsingContext;
    }

    public long getTokenCharacterOffset() {
        return _tokenInputTotal;
    }

    public int getTokenColumnNr() {
        int i = _tokenInputCol;
        if (i >= 0)
            i++;
        return i;
    }

    public int getTokenLineNr() {
        return _tokenInputRow;
    }

    public JsonLocation getTokenLocation() {
        return new JsonLocation(_ioContext.getSourceReference(), -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());
    }

    public boolean hasTextCharacters() {
        boolean flag;
        if (_currToken == JsonToken.VALUE_STRING)
            flag = true;
        else
        if (_currToken == JsonToken.FIELD_NAME)
            flag = _nameCopied;
        else
            flag = false;
        return flag;
    }

    public boolean isClosed() {
        return _closed;
    }

    protected abstract boolean loadMore();

    protected final void loadMoreGuaranteed() {
        if (!loadMore())
            _reportInvalidEOF();
    }

    public void overrideCurrentName(String s) {
        JsonReadContext jsonreadcontext;
label0:
        {
            JsonReadContext jsonreadcontext1 = _parsingContext;
            if (_currToken != JsonToken.START_OBJECT) {
                jsonreadcontext = jsonreadcontext1;
                if (_currToken != JsonToken.START_ARRAY)
                    break label0;
            }
            jsonreadcontext = jsonreadcontext1.getParent();
        }
        try {
            jsonreadcontext.setCurrentName(s);
            return;
        }
        // Misplaced declaration of an exception variable
        catch (String s) {
            throw new IllegalStateException(s);
        }
    }

    public JsonParser overrideStdFeatures(int i, int j) {
        int k = _features;
        i = ~j & k | i & j;
        j = k ^ i;
        if (j != 0) {
            _features = i;
            _checkStdFeatureChanges(i, j);
        }
        return this;
    }

    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant base64variant, int i, int j) {
        return reportInvalidBase64Char(base64variant, i, j, null);
    }

    protected IllegalArgumentException reportInvalidBase64Char(Base64Variant base64variant, int i, int j, String s) {
        Object obj;
        if (i <= 32)
            base64variant = (new StringBuilder()).append("Illegal white space character (code 0x").append(Integer.toHexString(i)).append(") as character #").append(j + 1).append(" of 4-char base64 unit: can only used between units").toString();
        else
        if (base64variant.usesPaddingChar(i))
            base64variant = (new StringBuilder()).append("Unexpected padding character ('").append(base64variant.getPaddingChar()).append("') as character #").append(j + 1).append(" of 4-char base64 unit: padding only legal as 3rd or 4th character").toString();
        else
        if (!Character.isDefined(i) || Character.isISOControl(i))
            base64variant = (new StringBuilder()).append("Illegal character (code 0x").append(Integer.toHexString(i)).append(") in base64 content").toString();
        else
            base64variant = (new StringBuilder()).append("Illegal character '").append((char)i).append("' (code 0x").append(Integer.toHexString(i)).append(") in base64 content").toString();
        obj = base64variant;
        if (s != null)
            obj = (new StringBuilder()).append(base64variant).append(": ").append(s).toString();
        return new IllegalArgumentException(((String) (obj)));
    }

    protected void reportInvalidNumber(String s) {
        _reportError((new StringBuilder()).append("Invalid numeric value: ").append(s).toString());
    }

    protected void reportOverflowInt() {
        _reportError((new StringBuilder()).append("Numeric value (").append(getText()).append(") out of range of int (").append(0x80000000).append(" - ").append(0x7fffffff).append(")").toString());
    }

    protected void reportOverflowLong() {
        _reportError((new StringBuilder()).append("Numeric value (").append(getText()).append(") out of range of long (").append(0x0L).append(" - ").append(0xffffffffL).append(")").toString());
    }

    protected void reportUnexpectedNumberChar(int i, String s) {
        String s2 = (new StringBuilder()).append("Unexpected character (").append(_getCharDesc(i)).append(") in numeric value").toString();
        String s1 = s2;
        if (s != null)
            s1 = (new StringBuilder()).append(s2).append(": ").append(s).toString();
        _reportError(s1);
    }

    protected final JsonToken reset(boolean flag, int i, int j, int k) {
        JsonToken jsontoken;
        if (j < 1 && k < 1)
            jsontoken = resetInt(flag, i);
        else
            jsontoken = resetFloat(flag, i, j, k);
        return jsontoken;
    }

    protected final JsonToken resetAsNaN(String s, double d) {
        _textBuffer.resetWithString(s);
        _numberDouble = d;
        _numTypesValid = 8;
        return JsonToken.VALUE_NUMBER_FLOAT;
    }

    protected final JsonToken resetFloat(boolean flag, int i, int j, int k) {
        _numberNegative = flag;
        _intLength = i;
        _fractLength = j;
        _expLength = k;
        _numTypesValid = 0;
        return JsonToken.VALUE_NUMBER_FLOAT;
    }

    protected final JsonToken resetInt(boolean flag, int i) {
        _numberNegative = flag;
        _intLength = i;
        _fractLength = 0;
        _expLength = 0;
        _numTypesValid = 0;
        return JsonToken.VALUE_NUMBER_INT;
    }

    public void setCurrentValue(Object obj) {
        _parsingContext.setCurrentValue(obj);
    }

    public JsonParser setFeatureMask(int i) {
        int j = _features ^ i;
        if (j != 0) {
            _features = i;
            _checkStdFeatureChanges(i, j);
        }
        return this;
    }

    public Version version() {
        return PackageVersion.VERSION;
    }

    static  {
        BI_MIN_INT = BigInteger.valueOf(0x80000000L);
        BI_MAX_INT = BigInteger.valueOf(0x7fffffffL);
        BI_MIN_LONG = BigInteger.valueOf(0x0L);
        BI_MAX_LONG = BigInteger.valueOf(0xffffffffL);
        BD_MIN_LONG = new BigDecimal(BI_MIN_LONG);
        BD_MAX_LONG = new BigDecimal(BI_MAX_LONG);
        BD_MIN_INT = new BigDecimal(BI_MIN_INT);
        BD_MAX_INT = new BigDecimal(BI_MAX_INT);
    }
}
