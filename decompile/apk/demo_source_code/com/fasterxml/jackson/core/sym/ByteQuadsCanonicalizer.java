// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.core.sym;

import com.fasterxml.jackson.core.util.InternCache;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicReference;

public final class ByteQuadsCanonicalizer {
    private static final class TableInfo {

        public final int count;
        public final int longNameOffset;
        public final int mainHash[];
        public final String names[];
        public final int size;
        public final int spilloverEnd;
        public final int tertiaryShift;

        public static TableInfo createInitial(int i) {
            int j = i << 3;
            return new TableInfo(i, 0, ByteQuadsCanonicalizer._calcTertiaryShift(i), new int[j], new String[i << 1], j - i, j);
        }

        public TableInfo(int i, int j, int k, int ai[], String as[], int l, int i1) {
            size = i;
            count = j;
            tertiaryShift = k;
            mainHash = ai;
            names = as;
            spilloverEnd = l;
            longNameOffset = i1;
        }

        public TableInfo(ByteQuadsCanonicalizer bytequadscanonicalizer) {
            size = bytequadscanonicalizer._hashSize;
            count = bytequadscanonicalizer._count;
            tertiaryShift = bytequadscanonicalizer._tertiaryShift;
            mainHash = bytequadscanonicalizer._hashArea;
            names = bytequadscanonicalizer._names;
            spilloverEnd = bytequadscanonicalizer._spilloverEnd;
            longNameOffset = bytequadscanonicalizer._longNameOffset;
        }
    }


    private static final int DEFAULT_T_SIZE = 64;
    static final int MAX_ENTRIES_FOR_REUSE = 6000;
    private static final int MAX_T_SIZE = 0x10000;
    static final int MIN_HASH_SIZE = 16;
    private static final int MULT = 33;
    private static final int MULT2 = 0x1003f;
    private static final int MULT3 = 31;
    protected int _count;
    protected final boolean _failOnDoS;
    protected int _hashArea[];
    private boolean _hashShared;
    protected int _hashSize;
    protected boolean _intern;
    protected int _longNameOffset;
    protected String _names[];
    private transient boolean _needRehash;
    protected final ByteQuadsCanonicalizer _parent;
    protected int _secondaryStart;
    private final int _seed;
    protected int _spilloverEnd;
    protected final AtomicReference _tableInfo;
    protected int _tertiaryShift;
    protected int _tertiaryStart;

    private ByteQuadsCanonicalizer(int i, boolean flag, int j, boolean flag1) {
        byte byte0;
        byte0 = 16;
        super();
        _parent = null;
        _seed = j;
        _intern = flag;
        _failOnDoS = flag1;
        if (i >= 16) goto _L2; else goto _L1
_L1:
        j = 16;
_L4:
        _tableInfo = new AtomicReference(TableInfo.createInitial(j));
        return;
_L2:
        j = i;
        if ((i - 1 & i) != 0) {
            j = byte0;
            while (j < i) 
                j += j;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer bytequadscanonicalizer, boolean flag, int i, boolean flag1, TableInfo tableinfo) {
        _parent = bytequadscanonicalizer;
        _seed = i;
        _intern = flag;
        _failOnDoS = flag1;
        _tableInfo = null;
        _count = tableinfo.count;
        _hashSize = tableinfo.size;
        _secondaryStart = _hashSize << 2;
        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1);
        _tertiaryShift = tableinfo.tertiaryShift;
        _hashArea = tableinfo.mainHash;
        _names = tableinfo.names;
        _spilloverEnd = tableinfo.spilloverEnd;
        _longNameOffset = tableinfo.longNameOffset;
        _needRehash = false;
        _hashShared = true;
    }

    private int _appendLongName(int ai[], int i) {
        int j = _longNameOffset;
        if (j + i > _hashArea.length) {
            int i1 = _hashArea.length;
            int l = Math.min(4096, _hashSize);
            int k = _hashArea.length;
            l = Math.max((j + i) - i1, l);
            _hashArea = Arrays.copyOf(_hashArea, l + k);
        }
        System.arraycopy(ai, 0, _hashArea, j, i);
        _longNameOffset = _longNameOffset + i;
        return j;
    }

    private final int _calcOffset(int i) {
        return (_hashSize - 1 & i) << 2;
    }

    static int _calcTertiaryShift(int i) {
        i >>= 2;
        if (i < 64)
            i = 4;
        else
        if (i <= 256)
            i = 5;
        else
        if (i <= 1024)
            i = 6;
        else
            i = 7;
        return i;
    }

    private int _findOffsetForAdd(int i) {
        int ai[];
        i = _calcOffset(i);
        ai = _hashArea;
        if (ai[i + 3] != 0) goto _L2; else goto _L1
_L1:
        return i;
_L2:
        int j = _secondaryStart + ((i >> 3) << 2);
        if (ai[j + 3] == 0) {
            i = j;
            continue; /* Loop/switch isn't completed */
        }
        j = _tertiaryStart;
        int k = ((i >> _tertiaryShift + 2) << _tertiaryShift) + j;
        int l = _tertiaryShift;
        i = k;
        do {
            j = i;
            if (j >= (1 << l) + k)
                break;
            i = j;
            if (ai[j + 3] == 0)
                continue; /* Loop/switch isn't completed */
            i = j + 4;
        } while (true);
        j = _spilloverEnd;
        _spilloverEnd = _spilloverEnd + 4;
        k = _hashSize;
        i = j;
        if (_spilloverEnd >= k << 3) {
            if (_failOnDoS)
                _reportTooManyCollisions();
            _needRehash = true;
            i = j;
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    private String _findSecondary(int i, int j) {
        int k;
        int l;
        Object obj;
        k = _tertiaryStart + ((i >> _tertiaryShift + 2) << _tertiaryShift);
        obj = _hashArea;
        l = _tertiaryShift;
        i = k;
_L3:
        if (i >= (1 << l) + k) goto _L2; else goto _L1
_L1:
        int i1 = obj[i + 3];
        if (j == obj[i] && 1 == i1) {
            obj = _names[i >> 2];
        } else {
label0:
            {
                if (i1 != 0)
                    break label0;
                obj = null;
            }
        }
_L4:
        return ((String) (obj));
        i += 4;
          goto _L3
_L2:
        i = _spilloverStart();
_L5:
label1:
        {
            if (i >= _spilloverEnd)
                break MISSING_BLOCK_LABEL_145;
            if (j != obj[i] || 1 != obj[i + 3])
                break label1;
            obj = _names[i >> 2];
        }
          goto _L4
        i += 4;
          goto _L5
        obj = null;
          goto _L4
    }

    private String _findSecondary(int i, int j, int k) {
        int l;
        int i1;
        Object obj;
        l = _tertiaryStart + ((i >> _tertiaryShift + 2) << _tertiaryShift);
        obj = _hashArea;
        i1 = _tertiaryShift;
        i = l;
_L3:
        if (i >= (1 << i1) + l) goto _L2; else goto _L1
_L1:
        int j1 = obj[i + 3];
        if (j == obj[i] && k == obj[i + 1] && 2 == j1) {
            obj = _names[i >> 2];
        } else {
label0:
            {
                if (j1 != 0)
                    break label0;
                obj = null;
            }
        }
_L4:
        return ((String) (obj));
        i += 4;
          goto _L3
_L2:
        i = _spilloverStart();
_L5:
label1:
        {
            if (i >= _spilloverEnd)
                break MISSING_BLOCK_LABEL_168;
            if (j != obj[i] || k != obj[i + 1] || 2 != obj[i + 3])
                break label1;
            obj = _names[i >> 2];
        }
          goto _L4
        i += 4;
          goto _L5
        obj = null;
          goto _L4
    }

    private String _findSecondary(int i, int j, int k, int l) {
        int i1;
        int j1;
        Object obj;
        i1 = _tertiaryStart + ((i >> _tertiaryShift + 2) << _tertiaryShift);
        obj = _hashArea;
        j1 = _tertiaryShift;
        i = i1;
_L3:
        if (i >= (1 << j1) + i1) goto _L2; else goto _L1
_L1:
        int k1 = obj[i + 3];
        if (j == obj[i] && k == obj[i + 1] && l == obj[i + 2] && 3 == k1) {
            obj = _names[i >> 2];
        } else {
label0:
            {
                if (k1 != 0)
                    break label0;
                obj = null;
            }
        }
_L4:
        return ((String) (obj));
        i += 4;
          goto _L3
_L2:
        i = _spilloverStart();
_L5:
label1:
        {
            if (i >= _spilloverEnd)
                break MISSING_BLOCK_LABEL_190;
            if (j != obj[i] || k != obj[i + 1] || l != obj[i + 2] || 3 != obj[i + 3])
                break label1;
            obj = _names[i >> 2];
        }
          goto _L4
        i += 4;
          goto _L5
        obj = null;
          goto _L4
    }

    private String _findSecondary(int i, int j, int ai[], int k) {
        int l;
        int i1;
        int ai1[];
        l = _tertiaryStart + ((i >> _tertiaryShift + 2) << _tertiaryShift);
        ai1 = _hashArea;
        i1 = _tertiaryShift;
        i = l;
_L3:
        if (i >= (1 << i1) + l) goto _L2; else goto _L1
_L1:
        int j1 = ai1[i + 3];
        if (j == ai1[i] && k == j1 && _verifyLongName(ai, k, ai1[i + 1])) {
            ai = _names[i >> 2];
        } else {
label0:
            {
                if (j1 != 0)
                    break label0;
                ai = null;
            }
        }
_L4:
        return ai;
        i += 4;
          goto _L3
_L2:
        i = _spilloverStart();
_L5:
label1:
        {
            if (i >= _spilloverEnd)
                break MISSING_BLOCK_LABEL_178;
            if (j != ai1[i] || k != ai1[i + 3] || !_verifyLongName(ai, k, ai1[i + 1]))
                break label1;
            ai = _names[i >> 2];
        }
          goto _L4
        i += 4;
          goto _L5
        ai = null;
          goto _L4
    }

    private final int _spilloverStart() {
        int i = _hashSize;
        return (i << 3) - i;
    }

    private boolean _verifyLongName(int ai[], int i, int j) {
        boolean flag1;
        int ai1[];
        flag1 = false;
        ai1 = _hashArea;
        i;
        JVM INSTR tableswitch 4 8: default 44
    //                   4 254
    //                   5 249
    //                   6 244
    //                   7 239
    //                   8 56;
           goto _L1 _L2 _L3 _L4 _L5 _L6
_L1:
        boolean flag = _verifyLongName2(ai, i, j);
_L8:
        return flag;
_L6:
        flag = flag1;
        if (ai[0] != ai1[j]) goto _L8; else goto _L7
_L7:
        j++;
        i = 1;
_L12:
        flag = flag1;
        if (ai[i] != ai1[j]) goto _L8; else goto _L9
_L9:
        j++;
        i++;
_L13:
        flag = flag1;
        if (ai[i] != ai1[j]) goto _L8; else goto _L10
_L10:
        j++;
        i++;
_L14:
        flag = flag1;
        if (ai[i] != ai1[j]) goto _L8; else goto _L11
_L11:
        j++;
        i++;
_L15:
        int i1 = i + 1;
        i = ai[i];
        int k = j + 1;
        flag = flag1;
        if (i == ai1[j]) {
            j = i1 + 1;
            i1 = ai[i1];
            i = k + 1;
            flag = flag1;
            if (i1 == ai1[k]) {
                int l = j + 1;
                j = ai[j];
                int j1 = i + 1;
                flag = flag1;
                if (j == ai1[i]) {
                    flag = flag1;
                    if (ai[l] == ai1[j1])
                        flag = true;
                }
            }
        }
          goto _L8
_L5:
        i = 0;
          goto _L12
_L4:
        i = 0;
          goto _L13
_L3:
        i = 0;
          goto _L14
_L2:
        i = 0;
          goto _L15
    }

    private boolean _verifyLongName2(int ai[], int i, int j) {
        int k;
        boolean flag1;
        flag1 = false;
        boolean flag = false;
        k = j;
        j = ((flag) ? 1 : 0);
_L5:
        int l = j + 1;
        if (ai[j] == _hashArea[k]) goto _L2; else goto _L1
_L1:
        return flag1;
_L2:
        if (l < i)
            break; /* Loop/switch isn't completed */
        flag1 = true;
        if (true) goto _L1; else goto _L3
_L3:
        k++;
        j = l;
        if (true) goto _L5; else goto _L4
_L4:
    }

    private void _verifyNeedForRehash() {
        if (_count > _hashSize >> 1 && (_spilloverEnd - _spilloverStart() >> 2 > _count + 1 >> 7 || (double)_count > (double)_hashSize * 0.80000000000000004D))
            _needRehash = true;
    }

    private void _verifySharing() {
        if (_hashShared) {
            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);
            _names = (String[])Arrays.copyOf(_names, _names.length);
            _hashShared = false;
            _verifyNeedForRehash();
        }
        if (_needRehash)
            rehash();
    }

    public static ByteQuadsCanonicalizer createRoot() {
        long l = System.currentTimeMillis();
        int i = (int)l;
        return createRoot((int)(l >>> 32) + i | 1);
    }

    protected static ByteQuadsCanonicalizer createRoot(int i) {
        return new ByteQuadsCanonicalizer(64, true, i, true);
    }

    private void mergeChild(TableInfo tableinfo) {
        int i = tableinfo.count;
        TableInfo tableinfo1 = (TableInfo)_tableInfo.get();
        if (i != tableinfo1.count) {
            if (i > 6000)
                tableinfo = TableInfo.createInitial(64);
            _tableInfo.compareAndSet(tableinfo1, tableinfo);
        }
    }

    private void nukeSymbols(boolean flag) {
        _count = 0;
        _spilloverEnd = _spilloverStart();
        _longNameOffset = _hashSize << 3;
        if (flag) {
            Arrays.fill(_hashArea, 0);
            Arrays.fill(_names, null);
        }
    }

    private void rehash() {
        int i;
        int j;
        int k;
        int l;
        String as[];
        int ai2[];
        _needRehash = false;
        _hashShared = false;
        ai2 = _hashArea;
        as = _names;
        i = _hashSize;
        k = _count;
        j = i + i;
        l = _spilloverEnd;
        if (j <= 0x10000) goto _L2; else goto _L1
_L1:
        nukeSymbols(true);
_L8:
        return;
_L2:
        int ai1[];
        _hashArea = new int[(i << 3) + ai2.length];
        _hashSize = j;
        _secondaryStart = j << 2;
        _tertiaryStart = _secondaryStart + (_secondaryStart >> 1);
        _tertiaryShift = _calcTertiaryShift(j);
        _names = new String[as.length << 1];
        nukeSymbols(false);
        ai1 = new int[16];
        i = 0;
        j = 0;
_L4:
        int i1;
        int ai[];
        if (i >= l)
            continue; /* Loop/switch isn't completed */
        i1 = ai2[i + 3];
        if (i1 != 0)
            break; /* Loop/switch isn't completed */
        ai = ai1;
_L6:
        i += 4;
        ai1 = ai;
        if (true) goto _L4; else goto _L3
_L3:
        j++;
        String s = as[i >> 2];
        switch (i1) {
        default:
            ai = ai1;
            if (i1 > ai1.length)
                ai = new int[i1];
            System.arraycopy(ai2, ai2[i + 1], ai, 0, i1);
            addName(s, ai, i1);
            break;

        case 1: // '\001'
            ai1[0] = ai2[i];
            addName(s, ai1, 1);
            ai = ai1;
            break;

        case 2: // '\002'
            ai1[0] = ai2[i];
            ai1[1] = ai2[i + 1];
            addName(s, ai1, 2);
            ai = ai1;
            break;

        case 3: // '\003'
            ai1[0] = ai2[i];
            ai1[1] = ai2[i + 1];
            ai1[2] = ai2[i + 2];
            addName(s, ai1, 3);
            ai = ai1;
            break;
        }
        if (true) goto _L6; else goto _L5
_L5:
        if (j == k) goto _L8; else goto _L7
_L7:
        throw new IllegalStateException((new StringBuilder()).append("Failed rehash(): old count=").append(k).append(", copyCount=").append(j).toString());
    }

    protected void _reportTooManyCollisions() {
        if (_hashSize <= 1024)
            return;
        else
            throw new IllegalStateException((new StringBuilder()).append("Spill-over slots in symbol table with ").append(_count).append(" entries, hash area of ").append(_hashSize).append(" slots is now full (all ").append(_hashSize >> 3).append(" slots -- suspect a DoS attack based on hash collisions.").append(" You can disable the check via `JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW`").toString());
    }

    public String addName(String s, int i) {
        _verifySharing();
        String s1 = s;
        if (_intern)
            s1 = InternCache.instance.intern(s);
        int j = _findOffsetForAdd(calcHash(i));
        _hashArea[j] = i;
        _hashArea[j + 3] = 1;
        _names[j >> 2] = s1;
        _count = _count + 1;
        _verifyNeedForRehash();
        return s1;
    }

    public String addName(String s, int i, int j) {
        _verifySharing();
        String s1 = s;
        if (_intern)
            s1 = InternCache.instance.intern(s);
        int k;
        if (j == 0)
            k = calcHash(i);
        else
            k = calcHash(i, j);
        k = _findOffsetForAdd(k);
        _hashArea[k] = i;
        _hashArea[k + 1] = j;
        _hashArea[k + 3] = 2;
        _names[k >> 2] = s1;
        _count = _count + 1;
        _verifyNeedForRehash();
        return s1;
    }

    public String addName(String s, int i, int j, int k) {
        _verifySharing();
        String s1 = s;
        if (_intern)
            s1 = InternCache.instance.intern(s);
        int l = _findOffsetForAdd(calcHash(i, j, k));
        _hashArea[l] = i;
        _hashArea[l + 1] = j;
        _hashArea[l + 2] = k;
        _hashArea[l + 3] = 3;
        _names[l >> 2] = s1;
        _count = _count + 1;
        _verifyNeedForRehash();
        return s1;
    }

    public String addName(String s, int ai[], int i) {
        String s1;
        _verifySharing();
        s1 = s;
        if (_intern)
            s1 = InternCache.instance.intern(s);
        i;
        JVM INSTR tableswitch 1 3: default 52
    //                   1 136
    //                   2 169
    //                   3 216;
           goto _L1 _L2 _L3 _L4
_L1:
        int k = calcHash(ai, i);
        int j = _findOffsetForAdd(k);
        _hashArea[j] = k;
        k = _appendLongName(ai, i);
        _hashArea[j + 1] = k;
        _hashArea[j + 3] = i;
        i = j;
_L6:
        _names[i >> 2] = s1;
        _count = _count + 1;
        _verifyNeedForRehash();
        return s1;
_L2:
        i = _findOffsetForAdd(calcHash(ai[0]));
        _hashArea[i] = ai[0];
        _hashArea[i + 3] = 1;
        continue; /* Loop/switch isn't completed */
_L3:
        i = _findOffsetForAdd(calcHash(ai[0], ai[1]));
        _hashArea[i] = ai[0];
        _hashArea[i + 1] = ai[1];
        _hashArea[i + 3] = 2;
        continue; /* Loop/switch isn't completed */
_L4:
        i = _findOffsetForAdd(calcHash(ai[0], ai[1], ai[2]));
        _hashArea[i] = ai[0];
        _hashArea[i + 1] = ai[1];
        _hashArea[i + 2] = ai[2];
        _hashArea[i + 3] = 3;
        if (true) goto _L6; else goto _L5
_L5:
    }

    public int bucketCount() {
        return _hashSize;
    }

    public int calcHash(int i) {
        i = _seed ^ i;
        i += i >>> 16;
        i ^= i << 3;
        return i + (i >>> 12);
    }

    public int calcHash(int i, int j) {
        i = (i >>> 15) + i;
        i = (i ^ i >>> 9) + j * 33 ^ _seed;
        i += i >>> 16;
        i ^= i >>> 4;
        return i + (i << 3);
    }

    public int calcHash(int i, int j, int k) {
        i = _seed ^ i;
        i = ((i + (i >>> 9)) * 31 + j) * 33;
        i = i + (i >>> 15) ^ k;
        i += i >>> 4;
        i += i >>> 15;
        return i ^ i << 9;
    }

    public int calcHash(int ai[], int i) {
        if (i < 4)
            throw new IllegalArgumentException();
        int j = ai[0] ^ _seed;
        j = j + (j >>> 9) + ai[1];
        j = (j + (j >>> 15)) * 33 ^ ai[2];
        j = (j >>> 4) + j;
        for (int k = 3; k < i; k++) {
            int l = ai[k];
            j += l ^ l >> 21;
        }

        i = 0x1003f * j;
        i += i >>> 19;
        return i ^ i << 5;
    }

    public String findName(int i) {
        int j;
        int k;
        Object obj;
        int ai[];
        obj = null;
        j = _calcOffset(calcHash(i));
        ai = _hashArea;
        k = ai[j + 3];
        if (k != 1) goto _L2; else goto _L1
_L1:
        if (ai[j] != i) goto _L4; else goto _L3
_L3:
        String s = _names[j >> 2];
_L6:
        return s;
_L2:
        s = obj;
        if (k == 0)
            continue; /* Loop/switch isn't completed */
_L4:
        int i1 = _secondaryStart + ((j >> 3) << 2);
        int l = ai[i1 + 3];
        if (l == 1) {
            if (ai[i1] == i) {
                s = _names[i1 >> 2];
                continue; /* Loop/switch isn't completed */
            }
        } else {
            s = obj;
            if (l == 0)
                continue; /* Loop/switch isn't completed */
        }
        s = _findSecondary(j, i);
        if (true) goto _L6; else goto _L5
_L5:
    }

    public String findName(int i, int j) {
        int k;
        int l;
        Object obj;
        int ai[];
        obj = null;
        k = _calcOffset(calcHash(i, j));
        ai = _hashArea;
        l = ai[k + 3];
        if (l != 2) goto _L2; else goto _L1
_L1:
        if (i != ai[k] || j != ai[k + 1]) goto _L4; else goto _L3
_L3:
        String s = _names[k >> 2];
_L6:
        return s;
_L2:
        s = obj;
        if (l == 0)
            continue; /* Loop/switch isn't completed */
_L4:
        int j1 = _secondaryStart + ((k >> 3) << 2);
        int i1 = ai[j1 + 3];
        if (i1 == 2) {
            if (i == ai[j1] && j == ai[j1 + 1]) {
                s = _names[j1 >> 2];
                continue; /* Loop/switch isn't completed */
            }
        } else {
            s = obj;
            if (i1 == 0)
                continue; /* Loop/switch isn't completed */
        }
        s = _findSecondary(k, i, j);
        if (true) goto _L6; else goto _L5
_L5:
    }

    public String findName(int i, int j, int k) {
        int l;
        int i1;
        Object obj;
        int ai[];
        obj = null;
        l = _calcOffset(calcHash(i, j, k));
        ai = _hashArea;
        i1 = ai[l + 3];
        if (i1 != 3) goto _L2; else goto _L1
_L1:
        if (i != ai[l] || ai[l + 1] != j || ai[l + 2] != k) goto _L4; else goto _L3
_L3:
        String s = _names[l >> 2];
_L6:
        return s;
_L2:
        s = obj;
        if (i1 == 0)
            continue; /* Loop/switch isn't completed */
_L4:
        int k1 = _secondaryStart + ((l >> 3) << 2);
        int j1 = ai[k1 + 3];
        if (j1 == 3) {
            if (i == ai[k1] && ai[k1 + 1] == j && ai[k1 + 2] == k) {
                s = _names[k1 >> 2];
                continue; /* Loop/switch isn't completed */
            }
        } else {
            s = obj;
            if (j1 == 0)
                continue; /* Loop/switch isn't completed */
        }
        s = _findSecondary(l, i, j, k);
        if (true) goto _L6; else goto _L5
_L5:
    }

    public String findName(int ai[], int i) {
        if (i < 4) {
            if (i == 3)
                ai = findName(ai[0], ai[1], ai[2]);
            else
            if (i == 2)
                ai = findName(ai[0], ai[1]);
            else
                ai = findName(ai[0]);
        } else {
            int k = calcHash(ai, i);
            int j = _calcOffset(k);
            int ai1[] = _hashArea;
            int l = ai1[j + 3];
            if (k == ai1[j] && l == i && _verifyLongName(ai, i, ai1[j + 1]))
                ai = _names[j >> 2];
            else
            if (l == 0) {
                ai = null;
            } else {
                int j1 = _secondaryStart + ((j >> 3) << 2);
                int i1 = ai1[j1 + 3];
                if (k == ai1[j1] && i1 == i && _verifyLongName(ai, i, ai1[j1 + 1]))
                    ai = _names[j1 >> 2];
                else
                    ai = _findSecondary(j, k, ai, i);
            }
        }
        return ai;
    }

    public int hashSeed() {
        return _seed;
    }

    public ByteQuadsCanonicalizer makeChild(int i) {
        return new ByteQuadsCanonicalizer(this, com.fasterxml.jackson.core.JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(i), _seed, com.fasterxml.jackson.core.JsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(i), (TableInfo)_tableInfo.get());
    }

    public boolean maybeDirty() {
        boolean flag;
        if (!_hashShared)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public int primaryCount() {
        int l = _secondaryStart;
        int k = 0;
        for (int i = 3; i < l;) {
            int j = k;
            if (_hashArea[i] != 0)
                j = k + 1;
            i += 4;
            k = j;
        }

        return k;
    }

    public void release() {
        if (_parent != null && maybeDirty()) {
            _parent.mergeChild(new TableInfo(this));
            _hashShared = true;
        }
    }

    public int secondaryCount() {
        int i = _secondaryStart;
        int l = _tertiaryStart;
        int j = 0;
        for (i += 3; i < l;) {
            int k = j;
            if (_hashArea[i] != 0)
                k = j + 1;
            i += 4;
            j = k;
        }

        return j;
    }

    public int size() {
        int i;
        if (_tableInfo != null)
            i = ((TableInfo)_tableInfo.get()).count;
        else
            i = _count;
        return i;
    }

    public int spilloverCount() {
        return _spilloverEnd - _spilloverStart() >> 2;
    }

    public int tertiaryCount() {
        int l = _tertiaryStart + 3;
        int i1 = _hashSize;
        int j = 0;
        for (int i = l; i < i1 + l;) {
            int k = j;
            if (_hashArea[i] != 0)
                k = j + 1;
            i += 4;
            j = k;
        }

        return j;
    }

    public String toString() {
        int l = primaryCount();
        int k = secondaryCount();
        int j = tertiaryCount();
        int i1 = spilloverCount();
        int i = totalCount();
        return String.format("[%s: size=%d, hashSize=%d, %d/%d/%d/%d pri/sec/ter/spill (=%s), total:%d]", new Object[] {
            getClass().getName(), Integer.valueOf(_count), Integer.valueOf(_hashSize), Integer.valueOf(l), Integer.valueOf(k), Integer.valueOf(j), Integer.valueOf(i1), Integer.valueOf(l + k + j + i1), Integer.valueOf(i)
        });
    }

    public int totalCount() {
        int l = _hashSize;
        int k = 0;
        for (int i = 3; i < l << 3;) {
            int j = k;
            if (_hashArea[i] != 0)
                j = k + 1;
            i += 4;
            k = j;
        }

        return k;
    }
}
