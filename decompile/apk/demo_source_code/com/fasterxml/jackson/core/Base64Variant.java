// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.core;

import com.fasterxml.jackson.core.util.ByteArrayBuilder;
import java.io.Serializable;
import java.util.Arrays;

// Referenced classes of package com.fasterxml.jackson.core:
//            Base64Variants

public final class Base64Variant
    implements Serializable {

    public static final int BASE64_VALUE_INVALID = -1;
    public static final int BASE64_VALUE_PADDING = -2;
    private static final int INT_SPACE = 32;
    static final char PADDING_CHAR_NONE = 0;
    private static final long serialVersionUID = 1L;
    private final transient int _asciiToBase64[];
    private final transient byte _base64ToAsciiB[];
    private final transient char _base64ToAsciiC[];
    private final transient int _maxLineLength;
    final String _name;
    private final transient char _paddingChar;
    private final transient boolean _usesPadding;

    public Base64Variant(Base64Variant base64variant, String s, int i) {
        this(base64variant, s, base64variant._usesPadding, base64variant._paddingChar, i);
    }

    public Base64Variant(Base64Variant base64variant, String s, boolean flag, char c, int i) {
        _asciiToBase64 = new int[128];
        _base64ToAsciiC = new char[64];
        _base64ToAsciiB = new byte[64];
        _name = s;
        s = base64variant._base64ToAsciiB;
        System.arraycopy(s, 0, _base64ToAsciiB, 0, s.length);
        s = base64variant._base64ToAsciiC;
        System.arraycopy(s, 0, _base64ToAsciiC, 0, s.length);
        base64variant = base64variant._asciiToBase64;
        System.arraycopy(base64variant, 0, _asciiToBase64, 0, base64variant.length);
        _usesPadding = flag;
        _paddingChar = c;
        _maxLineLength = i;
    }

    public Base64Variant(String s, String s1, boolean flag, char c, int i) {
        boolean flag1 = false;
        super();
        _asciiToBase64 = new int[128];
        _base64ToAsciiC = new char[64];
        _base64ToAsciiB = new byte[64];
        _name = s;
        _usesPadding = flag;
        _paddingChar = c;
        _maxLineLength = i;
        int j = s1.length();
        if (j != 64)
            throw new IllegalArgumentException((new StringBuilder()).append("Base64Alphabet length must be exactly 64 (was ").append(j).append(")").toString());
        s1.getChars(0, j, _base64ToAsciiC, 0);
        Arrays.fill(_asciiToBase64, -1);
        for (i = ((flag1) ? 1 : 0); i < j; i++) {
            char c1 = _base64ToAsciiC[i];
            _base64ToAsciiB[i] = (byte)c1;
            _asciiToBase64[c1] = i;
        }

        if (flag)
            _asciiToBase64[c] = -2;
    }

    protected void _reportBase64EOF() {
        throw new IllegalArgumentException("Unexpected end-of-String in base64 content");
    }

    protected void _reportInvalidBase64(char c, int i, String s) {
        String s1;
        String s2;
        if (c <= ' ')
            s1 = (new StringBuilder()).append("Illegal white space character (code 0x").append(Integer.toHexString(c)).append(") as character #").append(i + 1).append(" of 4-char base64 unit: can only used between units").toString();
        else
        if (usesPaddingChar(c))
            s1 = (new StringBuilder()).append("Unexpected padding character ('").append(getPaddingChar()).append("') as character #").append(i + 1).append(" of 4-char base64 unit: padding only legal as 3rd or 4th character").toString();
        else
        if (!Character.isDefined(c) || Character.isISOControl(c))
            s1 = (new StringBuilder()).append("Illegal character (code 0x").append(Integer.toHexString(c)).append(") in base64 content").toString();
        else
            s1 = (new StringBuilder()).append("Illegal character '").append(c).append("' (code 0x").append(Integer.toHexString(c)).append(") in base64 content").toString();
        s2 = s1;
        if (s != null)
            s2 = (new StringBuilder()).append(s1).append(": ").append(s).toString();
        throw new IllegalArgumentException(s2);
    }

    public void decode(String s, ByteArrayBuilder bytearraybuilder) {
        int i;
        int k;
        k = s.length();
        i = 0;
_L3:
        if (i >= k) goto _L2; else goto _L1
_L1:
        int j;
        int l;
        j = i + 1;
        char c = s.charAt(i);
        if (j < k) {
label0:
            {
                if (c <= ' ')
                    break MISSING_BLOCK_LABEL_363;
                l = decodeBase64Char(c);
                if (l < 0)
                    _reportInvalidBase64(c, 0, null);
                if (j >= k)
                    _reportBase64EOF();
                i = j + 1;
                c = s.charAt(j);
                j = decodeBase64Char(c);
                if (j < 0)
                    _reportInvalidBase64(c, 1, null);
                l = l << 6 | j;
                if (i < k)
                    break MISSING_BLOCK_LABEL_144;
                if (usesPadding())
                    break label0;
                bytearraybuilder.append(l >> 4);
            }
        }
_L2:
        return;
        _reportBase64EOF();
label1:
        {
            j = i + 1;
            char c1 = s.charAt(i);
            i = decodeBase64Char(c1);
            if (i >= 0)
                break label1;
            if (i != -2)
                _reportInvalidBase64(c1, 2, null);
            if (j >= k)
                _reportBase64EOF();
            i = j + 1;
            c1 = s.charAt(j);
            if (!usesPaddingChar(c1))
                _reportInvalidBase64(c1, 3, (new StringBuilder()).append("expected padding character '").append(getPaddingChar()).append("'").toString());
            bytearraybuilder.append(l >> 4);
        }
          goto _L3
label2:
        {
            l = l << 6 | i;
            if (j < k)
                break MISSING_BLOCK_LABEL_298;
            if (usesPadding())
                break label2;
            bytearraybuilder.appendTwoBytes(l >> 2);
        }
          goto _L2
        _reportBase64EOF();
        i = j + 1;
        char c2 = s.charAt(j);
        j = decodeBase64Char(c2);
        if (j < 0) {
            if (j != -2)
                _reportInvalidBase64(c2, 3, null);
            bytearraybuilder.appendTwoBytes(l >> 2);
        } else {
            bytearraybuilder.appendThreeBytes(l << 6 | j);
        }
          goto _L3
        i = j;
          goto _L1
    }

    public byte[] decode(String s) {
        ByteArrayBuilder bytearraybuilder = new ByteArrayBuilder();
        decode(s, bytearraybuilder);
        return bytearraybuilder.toByteArray();
    }

    public int decodeBase64Byte(byte byte0) {
        if (byte0 < 0)
            byte0 = -1;
        else
            byte0 = _asciiToBase64[byte0];
        return byte0;
    }

    public int decodeBase64Char(char c) {
        if (c <= '\177')
            c = _asciiToBase64[c];
        else
            c = '\uFFFF';
        return c;
    }

    public int decodeBase64Char(int i) {
        if (i <= 127)
            i = _asciiToBase64[i];
        else
            i = -1;
        return i;
    }

    public String encode(byte abyte0[]) {
        return encode(abyte0, false);
    }

    public String encode(byte abyte0[], boolean flag) {
        int l = abyte0.length;
        StringBuilder stringbuilder = new StringBuilder((l >> 2) + l + (l >> 3));
        if (flag)
            stringbuilder.append('"');
        int j = getMaxLineLength();
        int i = 0;
        j >>= 2;
        int i1;
        for (; i <= l - 3; i = i1 + 1) {
            int k1 = i + 1;
            i = abyte0[i];
            i1 = k1 + 1;
            encodeBase64Chunk(stringbuilder, (i << 8 | abyte0[k1] & 0xff) << 8 | abyte0[i1] & 0xff);
            i = --j;
            if (j <= 0) {
                stringbuilder.append('\\');
                stringbuilder.append('n');
                i = getMaxLineLength() >> 2;
            }
            j = i;
        }

        l -= i;
        if (l > 0) {
            int j1 = i + 1;
            int k = abyte0[i] << 16;
            i = k;
            if (l == 2)
                i = k | (abyte0[j1] & 0xff) << 8;
            encodeBase64Partial(stringbuilder, i, l);
        }
        if (flag)
            stringbuilder.append('"');
        return stringbuilder.toString();
    }

    public byte encodeBase64BitsAsByte(int i) {
        return _base64ToAsciiB[i];
    }

    public char encodeBase64BitsAsChar(int i) {
        return _base64ToAsciiC[i];
    }

    public int encodeBase64Chunk(int i, byte abyte0[], int j) {
        int k = j + 1;
        abyte0[j] = _base64ToAsciiB[i >> 18 & 0x3f];
        j = k + 1;
        abyte0[k] = _base64ToAsciiB[i >> 12 & 0x3f];
        k = j + 1;
        abyte0[j] = _base64ToAsciiB[i >> 6 & 0x3f];
        abyte0[k] = _base64ToAsciiB[i & 0x3f];
        return k + 1;
    }

    public int encodeBase64Chunk(int i, char ac[], int j) {
        int k = j + 1;
        ac[j] = _base64ToAsciiC[i >> 18 & 0x3f];
        j = k + 1;
        ac[k] = _base64ToAsciiC[i >> 12 & 0x3f];
        k = j + 1;
        ac[j] = _base64ToAsciiC[i >> 6 & 0x3f];
        ac[k] = _base64ToAsciiC[i & 0x3f];
        return k + 1;
    }

    public void encodeBase64Chunk(StringBuilder stringbuilder, int i) {
        stringbuilder.append(_base64ToAsciiC[i >> 18 & 0x3f]);
        stringbuilder.append(_base64ToAsciiC[i >> 12 & 0x3f]);
        stringbuilder.append(_base64ToAsciiC[i >> 6 & 0x3f]);
        stringbuilder.append(_base64ToAsciiC[i & 0x3f]);
    }

    public int encodeBase64Partial(int i, int j, byte abyte0[], int k) {
        int l = k + 1;
        abyte0[k] = _base64ToAsciiB[i >> 18 & 0x3f];
        k = l + 1;
        abyte0[l] = _base64ToAsciiB[i >> 12 & 0x3f];
        if (_usesPadding) {
            byte byte1 = (byte)_paddingChar;
            int i1 = k + 1;
            byte byte0;
            if (j == 2)
                byte0 = _base64ToAsciiB[i >> 6 & 0x3f];
            else
                byte0 = byte1;
            abyte0[k] = byte0;
            i = i1 + 1;
            abyte0[i1] = byte1;
        } else
        if (j == 2) {
            j = k + 1;
            abyte0[k] = _base64ToAsciiB[i >> 6 & 0x3f];
            i = j;
        } else {
            i = k;
        }
        return i;
    }

    public int encodeBase64Partial(int i, int j, char ac[], int k) {
        int l = k + 1;
        ac[k] = _base64ToAsciiC[i >> 18 & 0x3f];
        k = l + 1;
        ac[l] = _base64ToAsciiC[i >> 12 & 0x3f];
        if (_usesPadding) {
            int i1 = k + 1;
            char c;
            if (j == 2)
                c = _base64ToAsciiC[i >> 6 & 0x3f];
            else
                c = _paddingChar;
            ac[k] = c;
            i = i1 + 1;
            ac[i1] = _paddingChar;
        } else
        if (j == 2) {
            j = k + 1;
            ac[k] = _base64ToAsciiC[i >> 6 & 0x3f];
            i = j;
        } else {
            i = k;
        }
        return i;
    }

    public void encodeBase64Partial(StringBuilder stringbuilder, int i, int j) {
        stringbuilder.append(_base64ToAsciiC[i >> 18 & 0x3f]);
        stringbuilder.append(_base64ToAsciiC[i >> 12 & 0x3f]);
        if (!_usesPadding) goto _L2; else goto _L1
_L1:
        char c;
        if (j == 2)
            c = _base64ToAsciiC[i >> 6 & 0x3f];
        else
            c = _paddingChar;
        stringbuilder.append(c);
        stringbuilder.append(_paddingChar);
_L4:
        return;
_L2:
        if (j == 2)
            stringbuilder.append(_base64ToAsciiC[i >> 6 & 0x3f]);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public boolean equals(Object obj) {
        boolean flag;
        if (obj == this)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public int getMaxLineLength() {
        return _maxLineLength;
    }

    public String getName() {
        return _name;
    }

    public byte getPaddingByte() {
        return (byte)_paddingChar;
    }

    public char getPaddingChar() {
        return _paddingChar;
    }

    public int hashCode() {
        return _name.hashCode();
    }

    protected Object readResolve() {
        return Base64Variants.valueOf(_name);
    }

    public String toString() {
        return _name;
    }

    public boolean usesPadding() {
        return _usesPadding;
    }

    public boolean usesPaddingChar(char c) {
        boolean flag;
        if (c == _paddingChar)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean usesPaddingChar(int i) {
        boolean flag;
        if (i == _paddingChar)
            flag = true;
        else
            flag = false;
        return flag;
    }
}
