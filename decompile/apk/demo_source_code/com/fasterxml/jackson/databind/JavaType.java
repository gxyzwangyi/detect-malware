// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind;

import com.fasterxml.jackson.core.type.ResolvedType;
import com.fasterxml.jackson.databind.type.TypeBindings;
import com.fasterxml.jackson.databind.type.TypeFactory;
import java.io.Serializable;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.List;

public abstract class JavaType extends ResolvedType
    implements Serializable, Type {

    private static final long serialVersionUID = 1L;
    protected final boolean _asStatic;
    protected final Class _class;
    protected final int _hash;
    protected final Object _typeHandler;
    protected final Object _valueHandler;

    protected JavaType(JavaType javatype) {
        _class = javatype._class;
        _hash = javatype._hash;
        _valueHandler = javatype._valueHandler;
        _typeHandler = javatype._typeHandler;
        _asStatic = javatype._asStatic;
    }

    protected JavaType(Class class1, int i, Object obj, Object obj1, boolean flag) {
        _class = class1;
        _hash = class1.getName().hashCode() + i;
        _valueHandler = obj;
        _typeHandler = obj1;
        _asStatic = flag;
    }

    protected abstract JavaType _narrow(Class class1);

    public volatile ResolvedType containedType(int i) {
        return containedType(i);
    }

    public abstract JavaType containedType(int i);

    public abstract int containedTypeCount();

    public abstract String containedTypeName(int i);

    public JavaType containedTypeOrUnknown(int i) {
        JavaType javatype1 = containedType(i);
        JavaType javatype = javatype1;
        if (javatype1 == null)
            javatype = TypeFactory.unknownType();
        return javatype;
    }

    public abstract boolean equals(Object obj);

    public abstract JavaType findSuperType(Class class1);

    public abstract JavaType[] findTypeParameters(Class class1);

    public JavaType forcedNarrowBy(Class class1) {
        if (class1 == _class) {
            class1 = this;
        } else {
            Object obj = _narrow(class1);
            class1 = ((Class) (obj));
            if (_valueHandler != ((JavaType) (obj)).getValueHandler())
                class1 = ((JavaType) (obj)).withValueHandler(_valueHandler);
            obj = class1;
            if (_typeHandler != class1.getTypeHandler())
                obj = class1.withTypeHandler(_typeHandler);
            class1 = ((Class) (obj));
        }
        return class1;
    }

    public abstract TypeBindings getBindings();

    public volatile ResolvedType getContentType() {
        return getContentType();
    }

    public JavaType getContentType() {
        return null;
    }

    public Object getContentTypeHandler() {
        return null;
    }

    public Object getContentValueHandler() {
        return null;
    }

    public String getErasedSignature() {
        StringBuilder stringbuilder = new StringBuilder(40);
        getErasedSignature(stringbuilder);
        return stringbuilder.toString();
    }

    public abstract StringBuilder getErasedSignature(StringBuilder stringbuilder);

    public String getGenericSignature() {
        StringBuilder stringbuilder = new StringBuilder(40);
        getGenericSignature(stringbuilder);
        return stringbuilder.toString();
    }

    public abstract StringBuilder getGenericSignature(StringBuilder stringbuilder);

    public abstract List getInterfaces();

    public volatile ResolvedType getKeyType() {
        return getKeyType();
    }

    public JavaType getKeyType() {
        return null;
    }

    public Class getParameterSource() {
        return null;
    }

    public final Class getRawClass() {
        return _class;
    }

    public volatile ResolvedType getReferencedType() {
        return getReferencedType();
    }

    public JavaType getReferencedType() {
        return null;
    }

    public abstract JavaType getSuperClass();

    public Object getTypeHandler() {
        return _typeHandler;
    }

    public Object getValueHandler() {
        return _valueHandler;
    }

    public boolean hasGenericTypes() {
        boolean flag;
        if (containedTypeCount() > 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public final boolean hasRawClass(Class class1) {
        boolean flag;
        if (_class == class1)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean hasValueHandler() {
        boolean flag;
        if (_valueHandler != null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public final int hashCode() {
        return _hash;
    }

    public boolean isAbstract() {
        return Modifier.isAbstract(_class.getModifiers());
    }

    public boolean isArrayType() {
        return false;
    }

    public boolean isCollectionLikeType() {
        return false;
    }

    public boolean isConcrete() {
        boolean flag;
        if ((_class.getModifiers() & 0x600) == 0)
            flag = true;
        else
            flag = _class.isPrimitive();
        return flag;
    }

    public abstract boolean isContainerType();

    public final boolean isEnumType() {
        return _class.isEnum();
    }

    public final boolean isFinal() {
        return Modifier.isFinal(_class.getModifiers());
    }

    public final boolean isInterface() {
        return _class.isInterface();
    }

    public final boolean isJavaLangObject() {
        boolean flag;
        if (_class == java/lang/Object)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean isMapLikeType() {
        return false;
    }

    public final boolean isPrimitive() {
        return _class.isPrimitive();
    }

    public boolean isThrowable() {
        return java/lang/Throwable.isAssignableFrom(_class);
    }

    public final boolean isTypeOrSubTypeOf(Class class1) {
        boolean flag;
        if (_class == class1 || class1.isAssignableFrom(_class))
            flag = true;
        else
            flag = false;
        return flag;
    }

    public abstract JavaType refine(Class class1, TypeBindings typebindings, JavaType javatype, JavaType ajavatype[]);

    public abstract String toString();

    public final boolean useStaticType() {
        return _asStatic;
    }

    public abstract JavaType withContentType(JavaType javatype);

    public abstract JavaType withContentTypeHandler(Object obj);

    public abstract JavaType withContentValueHandler(Object obj);

    public abstract JavaType withStaticTyping();

    public abstract JavaType withTypeHandler(Object obj);

    public abstract JavaType withValueHandler(Object obj);
}
