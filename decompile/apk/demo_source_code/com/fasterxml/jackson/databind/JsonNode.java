// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind;

import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.node.JsonNodeType;
import com.fasterxml.jackson.databind.node.MissingNode;
import com.fasterxml.jackson.databind.util.ClassUtil;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;

public abstract class JsonNode extends JsonSerializable.Base
    implements TreeNode, Iterable {

    protected JsonNode() {
    }

    protected abstract JsonNode _at(JsonPointer jsonpointer);

    public boolean asBoolean() {
        return asBoolean(false);
    }

    public boolean asBoolean(boolean flag) {
        return flag;
    }

    public double asDouble() {
        return asDouble(0.0D);
    }

    public double asDouble(double d) {
        return d;
    }

    public int asInt() {
        return asInt(0);
    }

    public int asInt(int i) {
        return i;
    }

    public long asLong() {
        return asLong(0L);
    }

    public long asLong(long l) {
        return l;
    }

    public abstract String asText();

    public String asText(String s) {
        String s1 = asText();
        if (s1 != null)
            s = s1;
        return s;
    }

    public volatile TreeNode at(JsonPointer jsonpointer) {
        return at(jsonpointer);
    }

    public volatile TreeNode at(String s) {
        return at(s);
    }

    public final JsonNode at(JsonPointer jsonpointer) {
        if (jsonpointer.matches()) {
            jsonpointer = this;
        } else {
            JsonNode jsonnode = _at(jsonpointer);
            if (jsonnode == null)
                jsonpointer = MissingNode.getInstance();
            else
                jsonpointer = jsonnode.at(jsonpointer.tail());
        }
        return jsonpointer;
    }

    public final JsonNode at(String s) {
        return at(JsonPointer.compile(s));
    }

    public BigInteger bigIntegerValue() {
        return BigInteger.ZERO;
    }

    public byte[] binaryValue() {
        return null;
    }

    public boolean booleanValue() {
        return false;
    }

    public boolean canConvertToInt() {
        return false;
    }

    public boolean canConvertToLong() {
        return false;
    }

    public BigDecimal decimalValue() {
        return BigDecimal.ZERO;
    }

    public abstract JsonNode deepCopy();

    public double doubleValue() {
        return 0.0D;
    }

    public Iterator elements() {
        return ClassUtil.emptyIterator();
    }

    public abstract boolean equals(Object obj);

    public boolean equals(Comparator comparator, JsonNode jsonnode) {
        boolean flag;
        if (comparator.compare(this, jsonnode) == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public Iterator fieldNames() {
        return ClassUtil.emptyIterator();
    }

    public Iterator fields() {
        return ClassUtil.emptyIterator();
    }

    public abstract JsonNode findParent(String s);

    public final List findParents(String s) {
        List list = findParents(s, null);
        s = list;
        if (list == null)
            s = Collections.emptyList();
        return s;
    }

    public abstract List findParents(String s, List list);

    public abstract JsonNode findPath(String s);

    public abstract JsonNode findValue(String s);

    public final List findValues(String s) {
        List list = findValues(s, null);
        s = list;
        if (list == null)
            s = Collections.emptyList();
        return s;
    }

    public abstract List findValues(String s, List list);

    public final List findValuesAsText(String s) {
        List list = findValuesAsText(s, null);
        s = list;
        if (list == null)
            s = Collections.emptyList();
        return s;
    }

    public abstract List findValuesAsText(String s, List list);

    public float floatValue() {
        return 0.0F;
    }

    public volatile TreeNode get(int i) {
        return get(i);
    }

    public volatile TreeNode get(String s) {
        return get(s);
    }

    public abstract JsonNode get(int i);

    public JsonNode get(String s) {
        return null;
    }

    public abstract JsonNodeType getNodeType();

    public boolean has(int i) {
        boolean flag;
        if (get(i) != null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean has(String s) {
        boolean flag;
        if (get(s) != null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean hasNonNull(int i) {
        JsonNode jsonnode = get(i);
        boolean flag;
        if (jsonnode != null && !jsonnode.isNull())
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean hasNonNull(String s) {
        s = get(s);
        boolean flag;
        if (s != null && !s.isNull())
            flag = true;
        else
            flag = false;
        return flag;
    }

    public int intValue() {
        return 0;
    }

    public final boolean isArray() {
        boolean flag;
        if (getNodeType() == JsonNodeType.ARRAY)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean isBigDecimal() {
        return false;
    }

    public boolean isBigInteger() {
        return false;
    }

    public final boolean isBinary() {
        boolean flag;
        if (getNodeType() == JsonNodeType.BINARY)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public final boolean isBoolean() {
        boolean flag;
        if (getNodeType() == JsonNodeType.BOOLEAN)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public final boolean isContainerNode() {
        JsonNodeType jsonnodetype = getNodeType();
        boolean flag;
        if (jsonnodetype == JsonNodeType.OBJECT || jsonnodetype == JsonNodeType.ARRAY)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean isDouble() {
        return false;
    }

    public boolean isFloat() {
        return false;
    }

    public boolean isFloatingPointNumber() {
        return false;
    }

    public boolean isInt() {
        return false;
    }

    public boolean isIntegralNumber() {
        return false;
    }

    public boolean isLong() {
        return false;
    }

    public final boolean isMissingNode() {
        boolean flag;
        if (getNodeType() == JsonNodeType.MISSING)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public final boolean isNull() {
        boolean flag;
        if (getNodeType() == JsonNodeType.NULL)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public final boolean isNumber() {
        boolean flag;
        if (getNodeType() == JsonNodeType.NUMBER)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public final boolean isObject() {
        boolean flag;
        if (getNodeType() == JsonNodeType.OBJECT)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public final boolean isPojo() {
        boolean flag;
        if (getNodeType() == JsonNodeType.POJO)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean isShort() {
        return false;
    }

    public final boolean isTextual() {
        boolean flag;
        if (getNodeType() == JsonNodeType.STRING)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public final boolean isValueNode() {
        static class _cls1 {

            static final int $SwitchMap$com$fasterxml$jackson$databind$node$JsonNodeType[];

            static  {
                $SwitchMap$com$fasterxml$jackson$databind$node$JsonNodeType = new int[JsonNodeType.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    $SwitchMap$com$fasterxml$jackson$databind$node$JsonNodeType[JsonNodeType.ARRAY.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror2) { }
                try {
                    $SwitchMap$com$fasterxml$jackson$databind$node$JsonNodeType[JsonNodeType.OBJECT.ordinal()] = 2;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                $SwitchMap$com$fasterxml$jackson$databind$node$JsonNodeType[JsonNodeType.MISSING.ordinal()] = 3;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        _cls1..SwitchMap.com.fasterxml.jackson.databind.node.JsonNodeType[getNodeType().ordinal()];
        JVM INSTR tableswitch 1 3: default 36
    //                   1 40
    //                   2 40
    //                   3 40;
           goto _L1 _L2 _L2 _L2
_L1:
        boolean flag = true;
_L4:
        return flag;
_L2:
        flag = false;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public final Iterator iterator() {
        return elements();
    }

    public long longValue() {
        return 0L;
    }

    public Number numberValue() {
        return null;
    }

    public volatile TreeNode path(int i) {
        return path(i);
    }

    public volatile TreeNode path(String s) {
        return path(s);
    }

    public abstract JsonNode path(int i);

    public abstract JsonNode path(String s);

    public short shortValue() {
        return 0;
    }

    public int size() {
        return 0;
    }

    public String textValue() {
        return null;
    }

    public abstract String toString();

    public JsonNode with(String s) {
        throw new UnsupportedOperationException((new StringBuilder()).append("JsonNode not of type ObjectNode (but ").append(getClass().getName()).append("), can not call with() on it").toString());
    }

    public JsonNode withArray(String s) {
        throw new UnsupportedOperationException((new StringBuilder()).append("JsonNode not of type ObjectNode (but ").append(getClass().getName()).append("), can not call withArray() on it").toString());
    }
}
