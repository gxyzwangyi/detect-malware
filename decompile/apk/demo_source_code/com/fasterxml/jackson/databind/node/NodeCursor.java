// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.node;

import com.fasterxml.jackson.core.JsonStreamContext;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.JsonNode;
import java.util.Iterator;

// Referenced classes of package com.fasterxml.jackson.databind.node:
//            ContainerNode, ObjectNode

abstract class NodeCursor extends JsonStreamContext {
    protected static final class ArrayCursor extends NodeCursor {

        protected Iterator _contents;
        protected JsonNode _currentNode;

        public boolean currentHasChildren() {
            boolean flag;
            if (((ContainerNode)currentNode()).size() > 0)
                flag = true;
            else
                flag = false;
            return flag;
        }

        public JsonNode currentNode() {
            return _currentNode;
        }

        public JsonToken endToken() {
            return JsonToken.END_ARRAY;
        }

        public volatile JsonStreamContext getParent() {
            return getParent();
        }

        public JsonToken nextToken() {
            JsonToken jsontoken = null;
            if (!_contents.hasNext()) {
                _currentNode = null;
            } else {
                _currentNode = (JsonNode)_contents.next();
                jsontoken = _currentNode.asToken();
            }
            return jsontoken;
        }

        public JsonToken nextValue() {
            return nextToken();
        }

        public ArrayCursor(JsonNode jsonnode, NodeCursor nodecursor) {
            super(1, nodecursor);
            _contents = jsonnode.elements();
        }
    }

    protected static final class ObjectCursor extends NodeCursor {

        protected Iterator _contents;
        protected java.util.Map.Entry _current;
        protected boolean _needEntry;

        public boolean currentHasChildren() {
            boolean flag;
            if (((ContainerNode)currentNode()).size() > 0)
                flag = true;
            else
                flag = false;
            return flag;
        }

        public JsonNode currentNode() {
            JsonNode jsonnode;
            if (_current == null)
                jsonnode = null;
            else
                jsonnode = (JsonNode)_current.getValue();
            return jsonnode;
        }

        public JsonToken endToken() {
            return JsonToken.END_OBJECT;
        }

        public volatile JsonStreamContext getParent() {
            return getParent();
        }

        public JsonToken nextToken() {
            Object obj = null;
            if (_needEntry) {
                if (!_contents.hasNext()) {
                    _currentName = null;
                    _current = null;
                } else {
                    _needEntry = false;
                    _current = (java.util.Map.Entry)_contents.next();
                    if (_current == null)
                        obj = null;
                    else
                        obj = (String)_current.getKey();
                    _currentName = ((String) (obj));
                    obj = JsonToken.FIELD_NAME;
                }
            } else {
                _needEntry = true;
                obj = ((JsonNode)_current.getValue()).asToken();
            }
            return ((JsonToken) (obj));
        }

        public JsonToken nextValue() {
            JsonToken jsontoken1 = nextToken();
            JsonToken jsontoken = jsontoken1;
            if (jsontoken1 == JsonToken.FIELD_NAME)
                jsontoken = nextToken();
            return jsontoken;
        }

        public ObjectCursor(JsonNode jsonnode, NodeCursor nodecursor) {
            super(2, nodecursor);
            _contents = ((ObjectNode)jsonnode).fields();
            _needEntry = true;
        }
    }

    protected static final class RootCursor extends NodeCursor {

        protected boolean _done;
        protected JsonNode _node;

        public boolean currentHasChildren() {
            return false;
        }

        public JsonNode currentNode() {
            return _node;
        }

        public JsonToken endToken() {
            return null;
        }

        public volatile JsonStreamContext getParent() {
            return getParent();
        }

        public JsonToken nextToken() {
            JsonToken jsontoken = null;
            if (!_done) {
                _done = true;
                jsontoken = _node.asToken();
            } else {
                _node = null;
            }
            return jsontoken;
        }

        public JsonToken nextValue() {
            return nextToken();
        }

        public void overrideCurrentName(String s) {
        }

        public RootCursor(JsonNode jsonnode, NodeCursor nodecursor) {
            super(0, nodecursor);
            _done = false;
            _node = jsonnode;
        }
    }


    protected String _currentName;
    protected Object _currentValue;
    protected final NodeCursor _parent;

    public NodeCursor(int i, NodeCursor nodecursor) {
        _type = i;
        _index = -1;
        _parent = nodecursor;
    }

    public abstract boolean currentHasChildren();

    public abstract JsonNode currentNode();

    public abstract JsonToken endToken();

    public final String getCurrentName() {
        return _currentName;
    }

    public Object getCurrentValue() {
        return _currentValue;
    }

    public volatile JsonStreamContext getParent() {
        return getParent();
    }

    public final NodeCursor getParent() {
        return _parent;
    }

    public final NodeCursor iterateChildren() {
        Object obj = currentNode();
        if (obj == null)
            throw new IllegalStateException("No current node");
        if (((JsonNode) (obj)).isArray())
            obj = new ArrayCursor(((JsonNode) (obj)), this);
        else
        if (((JsonNode) (obj)).isObject())
            obj = new ObjectCursor(((JsonNode) (obj)), this);
        else
            throw new IllegalStateException((new StringBuilder()).append("Current node of type ").append(obj.getClass().getName()).toString());
        return ((NodeCursor) (obj));
    }

    public abstract JsonToken nextToken();

    public abstract JsonToken nextValue();

    public void overrideCurrentName(String s) {
        _currentName = s;
    }

    public void setCurrentValue(Object obj) {
        _currentValue = obj;
    }
}
