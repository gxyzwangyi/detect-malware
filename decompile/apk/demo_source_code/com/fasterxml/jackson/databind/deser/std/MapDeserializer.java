// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.deser.std;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.deser.*;
import com.fasterxml.jackson.databind.deser.impl.*;
import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
import com.fasterxml.jackson.databind.util.ArrayBuilders;
import java.util.*;

// Referenced classes of package com.fasterxml.jackson.databind.deser.std:
//            ContainerDeserializerBase

public class MapDeserializer extends ContainerDeserializerBase
    implements ContextualDeserializer, ResolvableDeserializer {
    static final class MapReferring extends com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring {

        private final MapReferringAccumulator _parent;
        public final Object key;
        public final Map next = new LinkedHashMap();

        public void handleResolvedForwardReference(Object obj, Object obj1) {
            _parent.resolveForwardReference(obj, obj1);
        }

        MapReferring(MapReferringAccumulator mapreferringaccumulator, UnresolvedForwardReference unresolvedforwardreference, Class class1, Object obj) {
            super(unresolvedforwardreference, class1);
            _parent = mapreferringaccumulator;
            key = obj;
        }
    }

    private static final class MapReferringAccumulator {

        private List _accumulator;
        private Map _result;
        private final Class _valueType;

        public com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring handleUnresolvedReference(UnresolvedForwardReference unresolvedforwardreference, Object obj) {
            unresolvedforwardreference = new MapReferring(this, unresolvedforwardreference, _valueType, obj);
            _accumulator.add(unresolvedforwardreference);
            return unresolvedforwardreference;
        }

        public void put(Object obj, Object obj1) {
            if (_accumulator.isEmpty())
                _result.put(obj, obj1);
            else
                ((MapReferring)_accumulator.get(_accumulator.size() - 1)).next.put(obj, obj1);
        }

        public void resolveForwardReference(Object obj, Object obj1) {
            Iterator iterator = _accumulator.iterator();
            MapReferring mapreferring;
            for (Map map = _result; iterator.hasNext(); map = mapreferring.next) {
                mapreferring = (MapReferring)iterator.next();
                if (mapreferring.hasId(obj)) {
                    iterator.remove();
                    map.put(mapreferring.key, obj1);
                    map.putAll(mapreferring.next);
                    return;
                }
            }

            throw new IllegalArgumentException((new StringBuilder()).append("Trying to resolve a forward reference with id [").append(obj).append("] that wasn't previously seen as unresolved.").toString());
        }

        public MapReferringAccumulator(Class class1, Map map) {
            _accumulator = new ArrayList();
            _valueType = class1;
            _result = map;
        }
    }


    private static final long serialVersionUID = 1L;
    protected JsonDeserializer _delegateDeserializer;
    protected final boolean _hasDefaultCreator;
    protected HashSet _ignorableProperties;
    protected final KeyDeserializer _keyDeserializer;
    protected final JavaType _mapType;
    protected PropertyBasedCreator _propertyBasedCreator;
    protected boolean _standardStringKey;
    protected final JsonDeserializer _valueDeserializer;
    protected final ValueInstantiator _valueInstantiator;
    protected final TypeDeserializer _valueTypeDeserializer;

    public MapDeserializer(JavaType javatype, ValueInstantiator valueinstantiator, KeyDeserializer keydeserializer, JsonDeserializer jsondeserializer, TypeDeserializer typedeserializer) {
        super(javatype);
        _mapType = javatype;
        _keyDeserializer = keydeserializer;
        _valueDeserializer = jsondeserializer;
        _valueTypeDeserializer = typedeserializer;
        _valueInstantiator = valueinstantiator;
        _hasDefaultCreator = valueinstantiator.canCreateUsingDefault();
        _delegateDeserializer = null;
        _propertyBasedCreator = null;
        _standardStringKey = _isStdKeyDeser(javatype, keydeserializer);
    }

    protected MapDeserializer(MapDeserializer mapdeserializer) {
        super(mapdeserializer._mapType);
        _mapType = mapdeserializer._mapType;
        _keyDeserializer = mapdeserializer._keyDeserializer;
        _valueDeserializer = mapdeserializer._valueDeserializer;
        _valueTypeDeserializer = mapdeserializer._valueTypeDeserializer;
        _valueInstantiator = mapdeserializer._valueInstantiator;
        _propertyBasedCreator = mapdeserializer._propertyBasedCreator;
        _delegateDeserializer = mapdeserializer._delegateDeserializer;
        _hasDefaultCreator = mapdeserializer._hasDefaultCreator;
        _ignorableProperties = mapdeserializer._ignorableProperties;
        _standardStringKey = mapdeserializer._standardStringKey;
    }

    protected MapDeserializer(MapDeserializer mapdeserializer, KeyDeserializer keydeserializer, JsonDeserializer jsondeserializer, TypeDeserializer typedeserializer, HashSet hashset) {
        super(mapdeserializer._mapType);
        _mapType = mapdeserializer._mapType;
        _keyDeserializer = keydeserializer;
        _valueDeserializer = jsondeserializer;
        _valueTypeDeserializer = typedeserializer;
        _valueInstantiator = mapdeserializer._valueInstantiator;
        _propertyBasedCreator = mapdeserializer._propertyBasedCreator;
        _delegateDeserializer = mapdeserializer._delegateDeserializer;
        _hasDefaultCreator = mapdeserializer._hasDefaultCreator;
        _ignorableProperties = hashset;
        _standardStringKey = _isStdKeyDeser(_mapType, keydeserializer);
    }

    private void handleUnresolvedReference(JsonParser jsonparser, MapReferringAccumulator mapreferringaccumulator, Object obj, UnresolvedForwardReference unresolvedforwardreference) {
        if (mapreferringaccumulator == null) {
            throw JsonMappingException.from(jsonparser, "Unresolved forward reference but no identity info.", unresolvedforwardreference);
        } else {
            jsonparser = mapreferringaccumulator.handleUnresolvedReference(unresolvedforwardreference, obj);
            unresolvedforwardreference.getRoid().appendReferring(jsonparser);
            return;
        }
    }

    public Map _deserializeUsingCreator(JsonParser jsonparser, DeserializationContext deserializationcontext) {
        Object obj;
        Object obj1;
        TypeDeserializer typedeserializer;
        PropertyValueBuffer propertyvaluebuffer;
        JsonDeserializer jsondeserializer;
        PropertyBasedCreator propertybasedcreator;
        propertybasedcreator = _propertyBasedCreator;
        propertyvaluebuffer = propertybasedcreator.startBuilding(jsonparser, deserializationcontext, null);
        jsondeserializer = _valueDeserializer;
        typedeserializer = _valueTypeDeserializer;
        if (jsonparser.isExpectedStartObjectToken())
            obj = jsonparser.nextFieldName();
        else
        if (jsonparser.hasToken(JsonToken.FIELD_NAME))
            obj = jsonparser.getCurrentName();
        else
            obj = null;
        if (obj == null)
            break MISSING_BLOCK_LABEL_281;
        obj1 = jsonparser.nextToken();
        if (_ignorableProperties == null || !_ignorableProperties.contains(obj))
            break; /* Loop/switch isn't completed */
        jsonparser.skipChildren();
_L6:
        obj = jsonparser.nextFieldName();
        if (true) goto _L2; else goto _L1
_L2:
        break MISSING_BLOCK_LABEL_40;
_L1:
        Object obj2 = propertybasedcreator.findCreatorProperty(((String) (obj)));
        if (obj2 == null) goto _L4; else goto _L3
_L3:
        if (!propertyvaluebuffer.assignParameter(((SettableBeanProperty) (obj2)), ((SettableBeanProperty) (obj2)).deserialize(jsonparser, deserializationcontext))) goto _L6; else goto _L5
_L5:
        jsonparser.nextToken();
        obj1 = (Map)propertybasedcreator.build(deserializationcontext, propertyvaluebuffer);
        _readAndBind(jsonparser, deserializationcontext, ((Map) (obj1)));
        jsonparser = ((JsonParser) (obj1));
_L7:
        return jsonparser;
        jsonparser;
        wrapAndThrow(jsonparser, _mapType.getRawClass(), ((String) (obj)));
        jsonparser = null;
          goto _L7
_L4:
        obj2 = _keyDeserializer.deserializeKey(((String) (obj)), deserializationcontext);
        if (obj1 != JsonToken.VALUE_NULL) goto _L9; else goto _L8
_L8:
        obj1 = jsondeserializer.getNullValue(deserializationcontext);
        obj = obj1;
_L10:
        propertyvaluebuffer.bufferMapProperty(obj2, obj);
          goto _L6
_L9:
        if (typedeserializer != null)
            break MISSING_BLOCK_LABEL_245;
        obj1 = jsondeserializer.deserialize(jsonparser, deserializationcontext);
        obj = obj1;
          goto _L10
        obj1 = jsondeserializer.deserializeWithType(jsonparser, deserializationcontext, typedeserializer);
        obj = obj1;
          goto _L10
        jsonparser;
        wrapAndThrow(jsonparser, _mapType.getRawClass(), ((String) (obj)));
        jsonparser = null;
          goto _L7
        try {
            jsonparser = (Map)propertybasedcreator.build(deserializationcontext, propertyvaluebuffer);
        }
        // Misplaced declaration of an exception variable
        catch (JsonParser jsonparser) {
            wrapAndThrow(jsonparser, _mapType.getRawClass(), ((String) (obj)));
            jsonparser = null;
        }
          goto _L7
    }

    protected final boolean _isStdKeyDeser(JavaType javatype, KeyDeserializer keydeserializer) {
        boolean flag1 = true;
        if (keydeserializer != null) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        javatype = javatype.getKeyType();
        flag = flag1;
        if (javatype == null)
            continue; /* Loop/switch isn't completed */
        javatype = javatype.getRawClass();
        if (javatype == java/lang/String || javatype == java/lang/Object) {
            flag = flag1;
            if (isDefaultKeyDeserializer(keydeserializer))
                continue; /* Loop/switch isn't completed */
        }
        flag = false;
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected final void _readAndBind(JsonParser jsonparser, DeserializationContext deserializationcontext, Map map) {
        boolean flag;
        Object obj;
        Object obj1;
        MapReferringAccumulator mapreferringaccumulator;
        TypeDeserializer typedeserializer;
        JsonDeserializer jsondeserializer;
        Object obj2;
        KeyDeserializer keydeserializer = _keyDeserializer;
        jsondeserializer = _valueDeserializer;
        typedeserializer = _valueTypeDeserializer;
        mapreferringaccumulator = null;
        if (jsondeserializer.getObjectIdReader() != null)
            flag = true;
        else
            flag = false;
        if (flag)
            mapreferringaccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), map);
        if (!jsonparser.isExpectedStartObjectToken()) goto _L2; else goto _L1
_L1:
        obj = jsonparser.nextFieldName();
_L7:
        if (obj == null) goto _L4; else goto _L3
_L3:
        obj2 = keydeserializer.deserializeKey(((String) (obj)), deserializationcontext);
        obj1 = jsonparser.nextToken();
        if (_ignorableProperties == null || !_ignorableProperties.contains(obj)) goto _L6; else goto _L5
_L5:
        jsonparser.skipChildren();
_L11:
        obj = jsonparser.nextFieldName();
          goto _L7
_L2:
        obj = jsonparser.getCurrentToken();
        if (obj != JsonToken.END_OBJECT) goto _L8; else goto _L4
_L4:
        return;
_L8:
        if (obj != JsonToken.FIELD_NAME)
            throw deserializationcontext.mappingException(_mapType.getRawClass(), jsonparser.getCurrentToken());
        obj = jsonparser.getCurrentName();
          goto _L7
_L6:
        if (obj1 != JsonToken.VALUE_NULL) goto _L10; else goto _L9
_L9:
        obj1 = jsondeserializer.getNullValue(deserializationcontext);
_L12:
        if (!flag)
            break MISSING_BLOCK_LABEL_258;
        try {
            mapreferringaccumulator.put(obj2, obj1);
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            handleUnresolvedReference(jsonparser, mapreferringaccumulator, obj2, ((UnresolvedForwardReference) (obj)));
        }
        catch (Exception exception) {
            wrapAndThrow(exception, map, ((String) (obj)));
        }
          goto _L11
_L10:
        if (typedeserializer != null)
            break MISSING_BLOCK_LABEL_244;
        obj1 = jsondeserializer.deserialize(jsonparser, deserializationcontext);
          goto _L12
        obj1 = jsondeserializer.deserializeWithType(jsonparser, deserializationcontext, typedeserializer);
          goto _L12
        map.put(obj2, obj1);
          goto _L11
    }

    protected final void _readAndBindStringMap(JsonParser jsonparser, DeserializationContext deserializationcontext, Map map) {
        boolean flag;
        Object obj;
        Object obj1;
        MapReferringAccumulator mapreferringaccumulator;
        JsonDeserializer jsondeserializer;
        TypeDeserializer typedeserializer;
        jsondeserializer = _valueDeserializer;
        typedeserializer = _valueTypeDeserializer;
        mapreferringaccumulator = null;
        if (jsondeserializer.getObjectIdReader() != null)
            flag = true;
        else
            flag = false;
        if (flag)
            mapreferringaccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), map);
        if (!jsonparser.isExpectedStartObjectToken()) goto _L2; else goto _L1
_L1:
        obj = jsonparser.nextFieldName();
_L7:
        if (obj == null) goto _L4; else goto _L3
_L3:
        obj1 = jsonparser.nextToken();
        if (_ignorableProperties == null || !_ignorableProperties.contains(obj)) goto _L6; else goto _L5
_L5:
        jsonparser.skipChildren();
_L11:
        obj = jsonparser.nextFieldName();
          goto _L7
_L2:
        obj = jsonparser.getCurrentToken();
        if (obj != JsonToken.END_OBJECT) goto _L8; else goto _L4
_L4:
        return;
_L8:
        if (obj != JsonToken.FIELD_NAME)
            throw deserializationcontext.mappingException(_mapType.getRawClass(), jsonparser.getCurrentToken());
        obj = jsonparser.getCurrentName();
          goto _L7
_L6:
        if (obj1 != JsonToken.VALUE_NULL) goto _L10; else goto _L9
_L9:
        obj1 = jsondeserializer.getNullValue(deserializationcontext);
_L12:
        if (!flag)
            break MISSING_BLOCK_LABEL_242;
        try {
            mapreferringaccumulator.put(obj, obj1);
        }
        // Misplaced declaration of an exception variable
        catch (Object obj1) {
            handleUnresolvedReference(jsonparser, mapreferringaccumulator, obj, ((UnresolvedForwardReference) (obj1)));
        }
        catch (Exception exception) {
            wrapAndThrow(exception, map, ((String) (obj)));
        }
          goto _L11
_L10:
        if (typedeserializer != null)
            break MISSING_BLOCK_LABEL_228;
        obj1 = jsondeserializer.deserialize(jsonparser, deserializationcontext);
          goto _L12
        obj1 = jsondeserializer.deserializeWithType(jsonparser, deserializationcontext, typedeserializer);
          goto _L12
        map.put(obj, obj1);
          goto _L11
    }

    public JsonDeserializer createContextual(DeserializationContext deserializationcontext, BeanProperty beanproperty) {
        Object obj;
        Object obj1;
        Object obj2;
label0:
        {
            obj1 = _keyDeserializer;
            Object obj3;
            if (obj1 == null) {
                obj = deserializationcontext.findKeyDeserializer(_mapType.getKeyType(), beanproperty);
            } else {
                obj = obj1;
                if (obj1 instanceof ContextualKeyDeserializer)
                    obj = ((ContextualKeyDeserializer)obj1).createContextual(deserializationcontext, beanproperty);
            }
            obj2 = _valueDeserializer;
            obj1 = obj2;
            if (beanproperty != null)
                obj1 = findConvertingContentDeserializer(deserializationcontext, beanproperty, ((JsonDeserializer) (obj2)));
            obj2 = _mapType.getContentType();
            if (obj1 == null)
                obj1 = deserializationcontext.findContextualValueDeserializer(((JavaType) (obj2)), beanproperty);
            else
                obj1 = deserializationcontext.handleSecondaryContextualization(((JsonDeserializer) (obj1)), beanproperty, ((JavaType) (obj2)));
            obj3 = _valueTypeDeserializer;
            obj2 = obj3;
            if (obj3 != null)
                obj2 = ((TypeDeserializer) (obj3)).forProperty(beanproperty);
            obj3 = _ignorableProperties;
            deserializationcontext = deserializationcontext.getAnnotationIntrospector();
            if (deserializationcontext != null && beanproperty != null) {
                beanproperty = beanproperty.getMember();
                if (beanproperty != null) {
                    String as[] = deserializationcontext.findPropertiesToIgnore(beanproperty, false);
                    if (as != null) {
                        int i;
                        int j;
                        if (obj3 == null)
                            deserializationcontext = new HashSet();
                        else
                            deserializationcontext = new HashSet(((java.util.Collection) (obj3)));
                        j = as.length;
                        i = 0;
                        do {
                            beanproperty = deserializationcontext;
                            if (i >= j)
                                break;
                            deserializationcontext.add(as[i]);
                            i++;
                        } while (true);
                        break label0;
                    }
                }
            }
            beanproperty = ((BeanProperty) (obj3));
        }
        return withResolved(((KeyDeserializer) (obj)), ((TypeDeserializer) (obj2)), ((JsonDeserializer) (obj1)), beanproperty);
    }

    public volatile Object deserialize(JsonParser jsonparser, DeserializationContext deserializationcontext) {
        return deserialize(jsonparser, deserializationcontext);
    }

    public volatile Object deserialize(JsonParser jsonparser, DeserializationContext deserializationcontext, Object obj) {
        return deserialize(jsonparser, deserializationcontext, (Map)obj);
    }

    public Map deserialize(JsonParser jsonparser, DeserializationContext deserializationcontext) {
        if (_propertyBasedCreator != null)
            jsonparser = _deserializeUsingCreator(jsonparser, deserializationcontext);
        else
        if (_delegateDeserializer != null) {
            jsonparser = (Map)_valueInstantiator.createUsingDelegate(deserializationcontext, _delegateDeserializer.deserialize(jsonparser, deserializationcontext));
        } else {
            if (!_hasDefaultCreator)
                throw deserializationcontext.instantiationException(getMapClass(), "No default constructor found");
            JsonToken jsontoken = jsonparser.getCurrentToken();
            if (jsontoken != JsonToken.START_OBJECT && jsontoken != JsonToken.FIELD_NAME && jsontoken != JsonToken.END_OBJECT) {
                if (jsontoken == JsonToken.VALUE_STRING)
                    jsonparser = (Map)_valueInstantiator.createFromString(deserializationcontext, jsonparser.getText());
                else
                    jsonparser = (Map)_deserializeFromEmpty(jsonparser, deserializationcontext);
            } else {
                Map map = (Map)_valueInstantiator.createUsingDefault(deserializationcontext);
                if (_standardStringKey) {
                    _readAndBindStringMap(jsonparser, deserializationcontext, map);
                    jsonparser = map;
                } else {
                    _readAndBind(jsonparser, deserializationcontext, map);
                    jsonparser = map;
                }
            }
        }
        return jsonparser;
    }

    public Map deserialize(JsonParser jsonparser, DeserializationContext deserializationcontext, Map map) {
        jsonparser.setCurrentValue(map);
        JsonToken jsontoken = jsonparser.getCurrentToken();
        if (jsontoken != JsonToken.START_OBJECT && jsontoken != JsonToken.FIELD_NAME)
            throw deserializationcontext.mappingException(getMapClass());
        if (_standardStringKey)
            _readAndBindStringMap(jsonparser, deserializationcontext, map);
        else
            _readAndBind(jsonparser, deserializationcontext, map);
        return map;
    }

    public Object deserializeWithType(JsonParser jsonparser, DeserializationContext deserializationcontext, TypeDeserializer typedeserializer) {
        return typedeserializer.deserializeTypedFromObject(jsonparser, deserializationcontext);
    }

    public JsonDeserializer getContentDeserializer() {
        return _valueDeserializer;
    }

    public JavaType getContentType() {
        return _mapType.getContentType();
    }

    public final Class getMapClass() {
        return _mapType.getRawClass();
    }

    public JavaType getValueType() {
        return _mapType;
    }

    public boolean isCachable() {
        boolean flag;
        if (_valueDeserializer == null && _keyDeserializer == null && _valueTypeDeserializer == null && _ignorableProperties == null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public void resolve(DeserializationContext deserializationcontext) {
        if (_valueInstantiator.canCreateUsingDelegate()) {
            JavaType javatype = _valueInstantiator.getDelegateType(deserializationcontext.getConfig());
            if (javatype == null)
                throw new IllegalArgumentException((new StringBuilder()).append("Invalid delegate-creator definition for ").append(_mapType).append(": value instantiator (").append(_valueInstantiator.getClass().getName()).append(") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'").toString());
            _delegateDeserializer = findDeserializer(deserializationcontext, javatype, null);
        }
        if (_valueInstantiator.canCreateFromObjectWith()) {
            SettableBeanProperty asettablebeanproperty[] = _valueInstantiator.getFromObjectArguments(deserializationcontext.getConfig());
            _propertyBasedCreator = PropertyBasedCreator.construct(deserializationcontext, _valueInstantiator, asettablebeanproperty);
        }
        _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer);
    }

    public void setIgnorableProperties(String as[]) {
        if (as == null || as.length == 0)
            as = null;
        else
            as = ArrayBuilders.arrayToSet(as);
        _ignorableProperties = as;
    }

    protected MapDeserializer withResolved(KeyDeserializer keydeserializer, TypeDeserializer typedeserializer, JsonDeserializer jsondeserializer, HashSet hashset) {
        if (_keyDeserializer == keydeserializer && _valueDeserializer == jsondeserializer && _valueTypeDeserializer == typedeserializer && _ignorableProperties == hashset)
            keydeserializer = this;
        else
            keydeserializer = new MapDeserializer(this, keydeserializer, jsondeserializer, typedeserializer, hashset);
        return keydeserializer;
    }

    protected void wrapAndThrow(Throwable throwable, Object obj) {
        wrapAndThrow(throwable, obj, null);
    }
}
