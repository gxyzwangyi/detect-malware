// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.introspect;

import com.fasterxml.jackson.databind.AnnotationIntrospector;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import com.fasterxml.jackson.databind.type.TypeBindings;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.databind.util.Annotations;
import com.fasterxml.jackson.databind.util.ClassUtil;
import java.lang.annotation.*;
import java.lang.reflect.*;
import java.util.*;

// Referenced classes of package com.fasterxml.jackson.databind.introspect:
//            Annotated, TypeResolutionContext, AnnotationMap, AnnotatedMember, 
//            AnnotatedMethodMap, AnnotatedMethod, MemberKey, AnnotatedConstructor, 
//            AnnotatedField

public final class AnnotatedClass extends Annotated
    implements TypeResolutionContext {

    private static final AnnotationMap NO_ANNOTATION_MAPS[] = new AnnotationMap[0];
    protected final AnnotationIntrospector _annotationIntrospector;
    protected final TypeBindings _bindings;
    protected final Class _class;
    protected AnnotationMap _classAnnotations;
    protected List _constructors;
    protected List _creatorMethods;
    protected boolean _creatorsResolved;
    protected AnnotatedConstructor _defaultConstructor;
    protected List _fields;
    protected AnnotatedMethodMap _memberMethods;
    protected final ClassIntrospector.MixInResolver _mixInResolver;
    protected final Class _primaryMixIn;
    protected final List _superTypes;
    protected final JavaType _type;
    protected final TypeFactory _typeFactory;

    private AnnotatedClass(JavaType javatype, Class class1, TypeBindings typebindings, List list, AnnotationIntrospector annotationintrospector, ClassIntrospector.MixInResolver mixinresolver, TypeFactory typefactory, 
            AnnotationMap annotationmap) {
        _creatorsResolved = false;
        _type = javatype;
        _class = class1;
        _bindings = typebindings;
        _superTypes = list;
        _annotationIntrospector = annotationintrospector;
        _typeFactory = typefactory;
        _mixInResolver = mixinresolver;
        if (_mixInResolver == null)
            javatype = null;
        else
            javatype = _mixInResolver.findMixInClassFor(_class);
        _primaryMixIn = javatype;
        _classAnnotations = annotationmap;
    }

    private AnnotationMap _addAnnotationsIfNotPresent(AnnotationMap annotationmap, Annotation aannotation[]) {
        if (aannotation != null) {
            int j = aannotation.length;
            List list = null;
            for (int i = 0; i < j;) {
                Annotation annotation = aannotation[i];
                List list1 = list;
                if (annotationmap.addIfNotPresent(annotation)) {
                    list1 = list;
                    if (_isAnnotationBundle(annotation))
                        list1 = _addFromBundle(annotation, list);
                }
                i++;
                list = list1;
            }

            if (list != null)
                _addAnnotationsIfNotPresent(annotationmap, (Annotation[])list.toArray(new Annotation[list.size()]));
        }
        return annotationmap;
    }

    private void _addAnnotationsIfNotPresent(AnnotatedMember annotatedmember, Annotation aannotation[]) {
        if (aannotation != null) {
            int j = aannotation.length;
            List list1 = null;
            for (int i = 0; i < j;) {
                Annotation annotation = aannotation[i];
                List list = list1;
                if (annotatedmember.addIfNotPresent(annotation)) {
                    list = list1;
                    if (_isAnnotationBundle(annotation))
                        list = _addFromBundle(annotation, list1);
                }
                i++;
                list1 = list;
            }

            if (list1 != null)
                _addAnnotationsIfNotPresent(annotatedmember, (Annotation[])list1.toArray(new Annotation[list1.size()]));
        }
    }

    private List _addFromBundle(Annotation annotation, List list) {
        Annotation aannotation[] = ClassUtil.findClassAnnotations(annotation.annotationType());
        int j = aannotation.length;
        int i = 0;
        annotation = list;
        while (i < j)  {
            Annotation annotation1 = aannotation[i];
            list = annotation;
            if (!(annotation1 instanceof Target))
                if (annotation1 instanceof Retention) {
                    list = annotation;
                } else {
                    list = annotation;
                    if (annotation == null)
                        list = new ArrayList();
                    list.add(annotation1);
                }
            i++;
            annotation = list;
        }
        return annotation;
    }

    private void _addOrOverrideAnnotations(AnnotatedMember annotatedmember, Annotation aannotation[]) {
        if (aannotation != null) {
            int j = aannotation.length;
            List list = null;
            for (int i = 0; i < j;) {
                Annotation annotation = aannotation[i];
                List list1 = list;
                if (annotatedmember.addOrOverride(annotation)) {
                    list1 = list;
                    if (_isAnnotationBundle(annotation))
                        list1 = _addFromBundle(annotation, list);
                }
                i++;
                list = list1;
            }

            if (list != null)
                _addOrOverrideAnnotations(annotatedmember, (Annotation[])list.toArray(new Annotation[list.size()]));
        }
    }

    private AnnotationMap _classAnnotations() {
        AnnotationMap annotationmap;
        AnnotationMap annotationmap1;
        annotationmap1 = _classAnnotations;
        annotationmap = annotationmap1;
        if (annotationmap1 != null) goto _L2; else goto _L1
_L1:
        this;
        JVM INSTR monitorenter ;
        annotationmap1 = _classAnnotations;
        annotationmap = annotationmap1;
        if (annotationmap1 != null)
            break MISSING_BLOCK_LABEL_34;
        annotationmap = _resolveClassAnnotations();
        _classAnnotations = annotationmap;
        this;
        JVM INSTR monitorexit ;
_L2:
        return annotationmap;
        Exception exception;
        exception;
        this;
        JVM INSTR monitorexit ;
        throw exception;
    }

    private AnnotationMap _emptyAnnotationMap() {
        return new AnnotationMap();
    }

    private AnnotationMap[] _emptyAnnotationMaps(int i) {
        if (i != 0) goto _L2; else goto _L1
_L1:
        AnnotationMap aannotationmap[] = NO_ANNOTATION_MAPS;
_L4:
        return aannotationmap;
_L2:
        AnnotationMap aannotationmap1[] = new AnnotationMap[i];
        int j = 0;
        do {
            aannotationmap = aannotationmap1;
            if (j >= i)
                continue;
            aannotationmap1[j] = _emptyAnnotationMap();
            j++;
        } while (true);
        if (true) goto _L4; else goto _L3
_L3:
    }

    private final boolean _isAnnotationBundle(Annotation annotation) {
        boolean flag;
        if (_annotationIntrospector != null && _annotationIntrospector.isAnnotationBundle(annotation))
            flag = true;
        else
            flag = false;
        return flag;
    }

    private boolean _isIncludableConstructor(Constructor constructor) {
        boolean flag;
        if (!constructor.isSynthetic())
            flag = true;
        else
            flag = false;
        return flag;
    }

    private boolean _isIncludableField(Field field) {
        boolean flag;
        flag = false;
        break MISSING_BLOCK_LABEL_2;
        if (!field.isSynthetic() && !Modifier.isStatic(field.getModifiers()))
            flag = true;
        return flag;
    }

    private AnnotationMap _resolveClassAnnotations() {
        AnnotationMap annotationmap = new AnnotationMap();
        if (_annotationIntrospector != null) {
            if (_primaryMixIn != null)
                _addClassMixIns(annotationmap, _class, _primaryMixIn);
            _addAnnotationsIfNotPresent(annotationmap, ClassUtil.findClassAnnotations(_class));
            JavaType javatype;
            for (Iterator iterator = _superTypes.iterator(); iterator.hasNext(); _addAnnotationsIfNotPresent(annotationmap, ClassUtil.findClassAnnotations(javatype.getRawClass()))) {
                javatype = (JavaType)iterator.next();
                _addClassMixIns(annotationmap, javatype);
            }

            _addClassMixIns(annotationmap, java/lang/Object);
        }
        return annotationmap;
    }

    public static AnnotatedClass construct(JavaType javatype, MapperConfig mapperconfig) {
        AnnotationIntrospector annotationintrospector;
        if (mapperconfig.isAnnotationProcessingEnabled())
            annotationintrospector = mapperconfig.getAnnotationIntrospector();
        else
            annotationintrospector = null;
        return new AnnotatedClass(javatype, javatype.getRawClass(), javatype.getBindings(), ClassUtil.findSuperTypes(javatype, null, false), annotationintrospector, mapperconfig, mapperconfig.getTypeFactory(), null);
    }

    public static AnnotatedClass construct(JavaType javatype, MapperConfig mapperconfig, ClassIntrospector.MixInResolver mixinresolver) {
        AnnotationIntrospector annotationintrospector;
        if (mapperconfig.isAnnotationProcessingEnabled())
            annotationintrospector = mapperconfig.getAnnotationIntrospector();
        else
            annotationintrospector = null;
        return new AnnotatedClass(javatype, javatype.getRawClass(), javatype.getBindings(), ClassUtil.findSuperTypes(javatype, null, false), annotationintrospector, mixinresolver, mapperconfig.getTypeFactory(), null);
    }

    public static AnnotatedClass constructWithoutSuperTypes(Class class1, MapperConfig mapperconfig) {
        if (mapperconfig == null) {
            class1 = new AnnotatedClass(null, class1, TypeBindings.emptyBindings(), Collections.emptyList(), null, null, null, null);
        } else {
            AnnotationIntrospector annotationintrospector;
            if (mapperconfig.isAnnotationProcessingEnabled())
                annotationintrospector = mapperconfig.getAnnotationIntrospector();
            else
                annotationintrospector = null;
            class1 = new AnnotatedClass(null, class1, TypeBindings.emptyBindings(), Collections.emptyList(), annotationintrospector, mapperconfig, mapperconfig.getTypeFactory(), null);
        }
        return class1;
    }

    public static AnnotatedClass constructWithoutSuperTypes(Class class1, MapperConfig mapperconfig, ClassIntrospector.MixInResolver mixinresolver) {
        if (mapperconfig == null) {
            class1 = new AnnotatedClass(null, class1, TypeBindings.emptyBindings(), Collections.emptyList(), null, null, null, null);
        } else {
            AnnotationIntrospector annotationintrospector;
            if (mapperconfig.isAnnotationProcessingEnabled())
                annotationintrospector = mapperconfig.getAnnotationIntrospector();
            else
                annotationintrospector = null;
            class1 = new AnnotatedClass(null, class1, TypeBindings.emptyBindings(), Collections.emptyList(), annotationintrospector, mixinresolver, mapperconfig.getTypeFactory(), null);
        }
        return class1;
    }

    private void resolveCreators() {
        boolean flag = false;
        Object aobj[] = ClassUtil.getConstructors(_class);
        int k = aobj.length;
        int i = 0;
        Object obj = null;
        while (i < k)  {
            com.fasterxml.jackson.databind.util.ClassUtil.Ctor ctor = aobj[i];
            Object obj1 = obj;
            if (_isIncludableConstructor(ctor.getConstructor()))
                if (ctor.getParamCount() == 0) {
                    _defaultConstructor = _constructDefaultConstructor(ctor, this);
                    obj1 = obj;
                } else {
                    obj1 = obj;
                    if (obj == null)
                        obj1 = new ArrayList(Math.max(10, aobj.length));
                    ((List) (obj1)).add(_constructNonDefaultConstructor(ctor, this));
                }
            i++;
            obj = obj1;
        }
        if (obj == null)
            _constructors = Collections.emptyList();
        else
            _constructors = ((List) (obj));
        if (_primaryMixIn != null && (_defaultConstructor != null || !_constructors.isEmpty()))
            _addConstructorMixIns(_primaryMixIn);
        if (_annotationIntrospector != null) {
            if (_defaultConstructor != null && _annotationIntrospector.hasIgnoreMarker(_defaultConstructor))
                _defaultConstructor = null;
            if (_constructors != null) {
                i = _constructors.size();
                do {
                    if (--i < 0)
                        break;
                    if (_annotationIntrospector.hasIgnoreMarker((AnnotatedMember)_constructors.get(i)))
                        _constructors.remove(i);
                } while (true);
            }
        }
        aobj = _findClassMethods(_class);
        k = aobj.length;
        obj = null;
        i = ((flag) ? 1 : 0);
        while (i < k)  {
            Method method = aobj[i];
            if (Modifier.isStatic(method.getModifiers())) {
                ArrayList arraylist = ((ArrayList) (obj));
                if (obj == null)
                    arraylist = new ArrayList(8);
                arraylist.add(_constructCreatorMethod(method, this));
                obj = arraylist;
            }
            i++;
        }
        if (obj == null) {
            _creatorMethods = Collections.emptyList();
        } else {
            _creatorMethods = ((List) (obj));
            if (_primaryMixIn != null)
                _addFactoryMixIns(_primaryMixIn);
            if (_annotationIntrospector != null) {
                int j = _creatorMethods.size();
                while (--j >= 0) 
                    if (_annotationIntrospector.hasIgnoreMarker((AnnotatedMember)_creatorMethods.get(j)))
                        _creatorMethods.remove(j);
            }
        }
        _creatorsResolved = true;
    }

    private void resolveFields() {
        Map map = _findFields(_type, this, null);
        if (map == null || map.size() == 0) {
            _fields = Collections.emptyList();
        } else {
            _fields = new ArrayList(map.size());
            _fields.addAll(map.values());
        }
    }

    private void resolveMemberMethods() {
        Object obj;
        _memberMethods = new AnnotatedMethodMap();
        obj = new AnnotatedMethodMap();
        _addMemberMethods(_class, this, _memberMethods, _primaryMixIn, ((AnnotatedMethodMap) (obj)));
        Iterator iterator1 = _superTypes.iterator();
        while (iterator1.hasNext())  {
            JavaType javatype = (JavaType)iterator1.next();
            Class class1;
            if (_mixInResolver == null)
                class1 = null;
            else
                class1 = _mixInResolver.findMixInClassFor(javatype.getRawClass());
            _addMemberMethods(javatype.getRawClass(), new TypeResolutionContext.Basic(_typeFactory, javatype.getBindings()), _memberMethods, class1, ((AnnotatedMethodMap) (obj)));
        }
        if (_mixInResolver != null) {
            Class class2 = _mixInResolver.findMixInClassFor(java/lang/Object);
            if (class2 != null)
                _addMethodMixIns(_class, _memberMethods, class2, ((AnnotatedMethodMap) (obj)));
        }
        if (_annotationIntrospector == null || ((AnnotatedMethodMap) (obj)).isEmpty()) goto _L2; else goto _L1
_L1:
        Iterator iterator = ((AnnotatedMethodMap) (obj)).iterator();
_L3:
        if (!iterator.hasNext())
            break; /* Loop/switch isn't completed */
        obj = (AnnotatedMethod)iterator.next();
        Object obj1 = java/lang/Object.getDeclaredMethod(((AnnotatedMethod) (obj)).getName(), ((AnnotatedMethod) (obj)).getRawParameterTypes());
        if (obj1 != null)
            try {
                obj1 = _constructMethod(((Method) (obj1)), this);
                _addMixOvers(((AnnotatedMethod) (obj)).getAnnotated(), ((AnnotatedMethod) (obj1)), false);
                _memberMethods.add(((AnnotatedMethod) (obj1)));
            }
            catch (Exception exception) { }
        if (true) goto _L3; else goto _L2
_L2:
    }

    protected void _addClassMixIns(AnnotationMap annotationmap, JavaType javatype) {
        if (_mixInResolver != null) {
            javatype = javatype.getRawClass();
            _addClassMixIns(annotationmap, ((Class) (javatype)), _mixInResolver.findMixInClassFor(javatype));
        }
    }

    protected void _addClassMixIns(AnnotationMap annotationmap, Class class1) {
        if (_mixInResolver != null)
            _addClassMixIns(annotationmap, class1, _mixInResolver.findMixInClassFor(class1));
    }

    protected void _addClassMixIns(AnnotationMap annotationmap, Class class1, Class class2) {
        if (class2 != null) {
            _addAnnotationsIfNotPresent(annotationmap, ClassUtil.findClassAnnotations(class2));
            class1 = ClassUtil.findSuperClasses(class2, class1, false).iterator();
            while (class1.hasNext()) 
                _addAnnotationsIfNotPresent(annotationmap, ClassUtil.findClassAnnotations((Class)class1.next()));
        }
    }

    protected void _addConstructorMixIns(Class class1) {
        int i;
        Object obj;
        Constructor constructor;
        int j;
        int i1;
        com.fasterxml.jackson.databind.util.ClassUtil.Ctor actor[];
        if (_constructors == null)
            i = 0;
        else
            i = _constructors.size();
        actor = ClassUtil.getConstructors(class1);
        i1 = actor.length;
        j = 0;
        obj = null;
        if (j >= i1)
            break MISSING_BLOCK_LABEL_218;
        constructor = actor[j].getConstructor();
        if (constructor.getParameterTypes().length != 0)
            break; /* Loop/switch isn't completed */
        class1 = ((Class) (obj));
        if (_defaultConstructor != null) {
            _addMixOvers(constructor, _defaultConstructor, false);
            class1 = ((Class) (obj));
        }
_L4:
        j++;
        obj = class1;
        if (true) goto _L2; else goto _L1
_L2:
        break MISSING_BLOCK_LABEL_25;
_L1:
        int l;
        if (obj == null) {
            obj = new MemberKey[i];
            int k = 0;
            do {
                class1 = ((Class) (obj));
                if (k >= i)
                    break;
                obj[k] = new MemberKey(((AnnotatedConstructor)_constructors.get(k)).getAnnotated());
                k++;
            } while (true);
        } else {
            class1 = ((Class) (obj));
        }
        obj = new MemberKey(constructor);
        l = 0;
        while (l < i)  {
label0:
            {
                if (((MemberKey) (obj)).equals(class1[l]))
                    break label0;
                l++;
            }
        }
        continue; /* Loop/switch isn't completed */
        _addMixOvers(constructor, (AnnotatedConstructor)_constructors.get(l), true);
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected void _addFactoryMixIns(Class class1) {
        int i;
        int l;
        int i1;
        Object obj;
        Method amethod[];
        obj = null;
        i1 = _creatorMethods.size();
        amethod = ClassUtil.getDeclaredMethods(class1);
        l = amethod.length;
        i = 0;
_L2:
        Method method;
        if (i >= l)
            break MISSING_BLOCK_LABEL_192;
        method = amethod[i];
        if (Modifier.isStatic(method.getModifiers()))
            break; /* Loop/switch isn't completed */
        class1 = ((Class) (obj));
_L3:
        i++;
        obj = class1;
        if (true) goto _L2; else goto _L1
_L1:
        int k;
        class1 = ((Class) (obj));
        if (method.getParameterTypes().length != 0) {
            if (obj == null) {
                obj = new MemberKey[i1];
                int j = 0;
                do {
                    class1 = ((Class) (obj));
                    if (j >= i1)
                        break;
                    obj[j] = new MemberKey(((AnnotatedMethod)_creatorMethods.get(j)).getAnnotated());
                    j++;
                } while (true);
            } else {
                class1 = ((Class) (obj));
            }
            obj = new MemberKey(method);
            k = 0;
            while (k < i1)  {
label0:
                {
                    if (((MemberKey) (obj)).equals(class1[k]))
                        break label0;
                    k++;
                }
            }
        }
          goto _L3
        _addMixOvers(method, (AnnotatedMethod)_creatorMethods.get(k), true);
          goto _L3
    }

    protected void _addFieldMixIns(Class class1, Class class2, Map map) {
        for (class1 = ClassUtil.findSuperClasses(class1, class2, true).iterator(); class1.hasNext();) {
            Field afield[] = ClassUtil.getDeclaredFields((Class)class1.next());
            int j = afield.length;
            int i = 0;
            while (i < j)  {
                Field field = afield[i];
                if (_isIncludableField(field)) {
                    class2 = (AnnotatedField)map.get(field.getName());
                    if (class2 != null)
                        _addOrOverrideAnnotations(class2, field.getDeclaredAnnotations());
                }
                i++;
            }
        }

    }

    protected void _addMemberMethods(Class class1, TypeResolutionContext typeresolutioncontext, AnnotatedMethodMap annotatedmethodmap, Class class2, AnnotatedMethodMap annotatedmethodmap1) {
        if (class2 != null)
            _addMethodMixIns(class1, annotatedmethodmap, class2, annotatedmethodmap1);
        if (class1 != null) {
            class1 = _findClassMethods(class1);
            int j = class1.length;
            int i = 0;
            while (i < j)  {
                class2 = class1[i];
                if (_isIncludableMemberMethod(class2)) {
                    AnnotatedMethod annotatedmethod = annotatedmethodmap.find(class2);
                    if (annotatedmethod == null) {
                        annotatedmethod = _constructMethod(class2, typeresolutioncontext);
                        annotatedmethodmap.add(annotatedmethod);
                        class2 = annotatedmethodmap1.remove(class2);
                        if (class2 != null)
                            _addMixOvers(class2.getAnnotated(), annotatedmethod, false);
                    } else {
                        _addMixUnders(class2, annotatedmethod);
                        if (annotatedmethod.getDeclaringClass().isInterface() && !class2.getDeclaringClass().isInterface())
                            annotatedmethodmap.add(annotatedmethod.withMethod(class2));
                    }
                }
                i++;
            }
        }
    }

    protected void _addMethodMixIns(Class class1, AnnotatedMethodMap annotatedmethodmap, Class class2, AnnotatedMethodMap annotatedmethodmap1) {
        for (class1 = ClassUtil.findRawSuperTypes(class2, class1, true).iterator(); class1.hasNext();) {
            class2 = ClassUtil.getDeclaredMethods((Class)class1.next());
            int j = class2.length;
            int i = 0;
            while (i < j)  {
                Method method = class2[i];
                if (_isIncludableMemberMethod(method)) {
                    AnnotatedMethod annotatedmethod = annotatedmethodmap.find(method);
                    if (annotatedmethod != null) {
                        _addMixUnders(method, annotatedmethod);
                    } else {
                        AnnotatedMethod annotatedmethod1 = annotatedmethodmap1.find(method);
                        if (annotatedmethod1 != null)
                            _addMixUnders(method, annotatedmethod1);
                        else
                            annotatedmethodmap1.add(_constructMethod(method, this));
                    }
                }
                i++;
            }
        }

    }

    protected void _addMixOvers(Constructor constructor, AnnotatedConstructor annotatedconstructor, boolean flag) {
        _addOrOverrideAnnotations(annotatedconstructor, constructor.getDeclaredAnnotations());
        if (flag) {
            constructor = constructor.getParameterAnnotations();
            int k = constructor.length;
            for (int i = 0; i < k; i++) {
                Object obj = constructor[i];
                int l = obj.length;
                for (int j = 0; j < l; j++)
                    annotatedconstructor.addOrOverrideParam(i, obj[j]);

            }

        }
    }

    protected void _addMixOvers(Method method, AnnotatedMethod annotatedmethod, boolean flag) {
        _addOrOverrideAnnotations(annotatedmethod, method.getDeclaredAnnotations());
        if (flag) {
            Annotation aannotation[][] = method.getParameterAnnotations();
            int k = aannotation.length;
            for (int i = 0; i < k; i++) {
                method = aannotation[i];
                int l = method.length;
                for (int j = 0; j < l; j++)
                    annotatedmethod.addOrOverrideParam(i, method[j]);

            }

        }
    }

    protected void _addMixUnders(Method method, AnnotatedMethod annotatedmethod) {
        _addAnnotationsIfNotPresent(annotatedmethod, method.getDeclaredAnnotations());
    }

    protected AnnotationMap _collectRelevantAnnotations(Annotation aannotation[]) {
        return _addAnnotationsIfNotPresent(new AnnotationMap(), aannotation);
    }

    protected AnnotationMap[] _collectRelevantAnnotations(Annotation aannotation[][]) {
        int j = aannotation.length;
        AnnotationMap aannotationmap[] = new AnnotationMap[j];
        for (int i = 0; i < j; i++)
            aannotationmap[i] = _collectRelevantAnnotations(aannotation[i]);

        return aannotationmap;
    }

    protected AnnotatedMethod _constructCreatorMethod(Method method, TypeResolutionContext typeresolutioncontext) {
        int i = method.getParameterTypes().length;
        if (_annotationIntrospector == null)
            method = new AnnotatedMethod(typeresolutioncontext, method, _emptyAnnotationMap(), _emptyAnnotationMaps(i));
        else
        if (i == 0)
            method = new AnnotatedMethod(typeresolutioncontext, method, _collectRelevantAnnotations(method.getDeclaredAnnotations()), NO_ANNOTATION_MAPS);
        else
            method = new AnnotatedMethod(typeresolutioncontext, method, _collectRelevantAnnotations(method.getDeclaredAnnotations()), _collectRelevantAnnotations(method.getParameterAnnotations()));
        return method;
    }

    protected AnnotatedConstructor _constructDefaultConstructor(com.fasterxml.jackson.databind.util.ClassUtil.Ctor ctor, TypeResolutionContext typeresolutioncontext) {
        if (_annotationIntrospector == null)
            ctor = new AnnotatedConstructor(typeresolutioncontext, ctor.getConstructor(), _emptyAnnotationMap(), NO_ANNOTATION_MAPS);
        else
            ctor = new AnnotatedConstructor(typeresolutioncontext, ctor.getConstructor(), _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), NO_ANNOTATION_MAPS);
        return ctor;
    }

    protected AnnotatedField _constructField(Field field, TypeResolutionContext typeresolutioncontext) {
        if (_annotationIntrospector == null)
            field = new AnnotatedField(typeresolutioncontext, field, _emptyAnnotationMap());
        else
            field = new AnnotatedField(typeresolutioncontext, field, _collectRelevantAnnotations(field.getDeclaredAnnotations()));
        return field;
    }

    protected AnnotatedMethod _constructMethod(Method method, TypeResolutionContext typeresolutioncontext) {
        if (_annotationIntrospector == null)
            method = new AnnotatedMethod(typeresolutioncontext, method, _emptyAnnotationMap(), null);
        else
            method = new AnnotatedMethod(typeresolutioncontext, method, _collectRelevantAnnotations(method.getDeclaredAnnotations()), null);
        return method;
    }

    protected AnnotatedConstructor _constructNonDefaultConstructor(com.fasterxml.jackson.databind.util.ClassUtil.Ctor ctor, TypeResolutionContext typeresolutioncontext) {
        int i = ctor.getParamCount();
        if (_annotationIntrospector != null) goto _L2; else goto _L1
_L1:
        ctor = new AnnotatedConstructor(typeresolutioncontext, ctor.getConstructor(), _emptyAnnotationMap(), _emptyAnnotationMaps(i));
_L10:
        return ctor;
_L2:
        AnnotationMap aannotationmap1[];
        if (i == 0) {
            ctor = new AnnotatedConstructor(typeresolutioncontext, ctor.getConstructor(), _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), NO_ANNOTATION_MAPS);
            continue; /* Loop/switch isn't completed */
        }
        aannotationmap1 = ctor.getParameterAnnotations();
        if (i == aannotationmap1.length) goto _L4; else goto _L3
_L3:
        Object obj;
        Class class1;
        obj = null;
        class1 = ctor.getDeclaringClass();
        if (!class1.isEnum() || i != aannotationmap1.length + 2) goto _L6; else goto _L5
_L5:
        AnnotationMap aannotationmap[];
        Annotation aannotation[][];
        aannotation = new Annotation[aannotationmap1.length + 2][];
        System.arraycopy(aannotationmap1, 0, aannotation, 2, aannotationmap1.length);
        aannotationmap = _collectRelevantAnnotations(aannotation);
_L8:
        aannotationmap1 = aannotationmap;
        if (aannotationmap == null)
            throw new IllegalStateException((new StringBuilder()).append("Internal error: constructor for ").append(ctor.getDeclaringClass().getName()).append(" has mismatch: ").append(i).append(" parameters; ").append(aannotation.length).append(" sets of annotations").toString());
        break; /* Loop/switch isn't completed */
_L6:
        aannotationmap = obj;
        aannotation = aannotationmap1;
        if (class1.isMemberClass()) {
            aannotationmap = obj;
            aannotation = aannotationmap1;
            if (i == aannotationmap1.length + 1) {
                aannotation = new Annotation[aannotationmap1.length + 1][];
                System.arraycopy(aannotationmap1, 0, aannotation, 1, aannotationmap1.length);
                aannotationmap = _collectRelevantAnnotations(aannotation);
            }
        }
        if (true) goto _L8; else goto _L7
_L4:
        aannotationmap1 = _collectRelevantAnnotations(aannotationmap1);
_L7:
        ctor = new AnnotatedConstructor(typeresolutioncontext, ctor.getConstructor(), _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), aannotationmap1);
        if (true) goto _L10; else goto _L9
_L9:
    }

    protected Method[] _findClassMethods(Class class1) {
        Method amethod[] = ClassUtil.getDeclaredMethods(class1);
        class1 = amethod;
_L2:
        return class1;
        NoClassDefFoundError noclassdeffounderror;
        noclassdeffounderror;
        ClassLoader classloader = Thread.currentThread().getContextClassLoader();
        if (classloader == null)
            throw noclassdeffounderror;
        try {
            class1 = classloader.loadClass(class1.getName());
        }
        // Misplaced declaration of an exception variable
        catch (Class class1) {
            throw noclassdeffounderror;
        }
        class1 = class1.getDeclaredMethods();
        if (true) goto _L2; else goto _L1
_L1:
    }

    protected Map _findFields(JavaType javatype, TypeResolutionContext typeresolutioncontext, Map map) {
        JavaType javatype1 = javatype.getSuperClass();
        if (javatype1 != null) {
            Class class1 = javatype.getRawClass();
            javatype = _findFields(javatype1, ((TypeResolutionContext) (new TypeResolutionContext.Basic(_typeFactory, javatype1.getBindings()))), map);
            Field afield[] = ClassUtil.getDeclaredFields(class1);
            int j = afield.length;
            int i = 0;
            while (i < j)  {
                Field field = afield[i];
                if (_isIncludableField(field)) {
                    map = javatype;
                    if (javatype == null)
                        map = new LinkedHashMap();
                    map.put(field.getName(), _constructField(field, typeresolutioncontext));
                    javatype = map;
                }
                i++;
            }
            typeresolutioncontext = javatype;
            if (_mixInResolver != null) {
                map = _mixInResolver.findMixInClassFor(class1);
                typeresolutioncontext = javatype;
                if (map != null) {
                    _addFieldMixIns(map, class1, javatype);
                    typeresolutioncontext = javatype;
                }
            }
        } else {
            typeresolutioncontext = map;
        }
        return typeresolutioncontext;
    }

    protected boolean _isIncludableMemberMethod(Method method) {
        boolean flag1 = false;
        if (!Modifier.isStatic(method.getModifiers())) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        flag = flag1;
        if (!method.isSynthetic()) {
            flag = flag1;
            if (!method.isBridge()) {
                flag = flag1;
                if (method.getParameterTypes().length <= 2)
                    flag = true;
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public Iterable annotations() {
        return _classAnnotations().annotations();
    }

    public boolean equals(Object obj) {
        boolean flag = true;
        if (obj != this) goto _L2; else goto _L1
_L1:
        return flag;
_L2:
        if (obj == null || obj.getClass() != getClass())
            flag = false;
        else
        if (((AnnotatedClass)obj)._class != _class)
            flag = false;
        if (true) goto _L1; else goto _L3
_L3:
    }

    public Iterable fields() {
        if (_fields == null)
            resolveFields();
        return _fields;
    }

    public AnnotatedMethod findMethod(String s, Class aclass[]) {
        if (_memberMethods == null)
            resolveMemberMethods();
        return _memberMethods.find(s, aclass);
    }

    protected AnnotationMap getAllAnnotations() {
        return _classAnnotations();
    }

    public Class getAnnotated() {
        return _class;
    }

    public volatile AnnotatedElement getAnnotated() {
        return getAnnotated();
    }

    public Annotation getAnnotation(Class class1) {
        return _classAnnotations().get(class1);
    }

    public Annotations getAnnotations() {
        return _classAnnotations();
    }

    public List getConstructors() {
        if (!_creatorsResolved)
            resolveCreators();
        return _constructors;
    }

    public AnnotatedConstructor getDefaultConstructor() {
        if (!_creatorsResolved)
            resolveCreators();
        return _defaultConstructor;
    }

    public int getFieldCount() {
        if (_fields == null)
            resolveFields();
        return _fields.size();
    }

    public int getMemberMethodCount() {
        if (_memberMethods == null)
            resolveMemberMethods();
        return _memberMethods.size();
    }

    public int getModifiers() {
        return _class.getModifiers();
    }

    public String getName() {
        return _class.getName();
    }

    public Class getRawType() {
        return _class;
    }

    public List getStaticMethods() {
        if (!_creatorsResolved)
            resolveCreators();
        return _creatorMethods;
    }

    public JavaType getType() {
        return _type;
    }

    public boolean hasAnnotation(Class class1) {
        return _classAnnotations().has(class1);
    }

    public boolean hasAnnotations() {
        boolean flag;
        if (_classAnnotations().size() > 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public boolean hasOneOf(Class aclass[]) {
        return _classAnnotations().hasOneOf(aclass);
    }

    public int hashCode() {
        return _class.getName().hashCode();
    }

    public Iterable memberMethods() {
        if (_memberMethods == null)
            resolveMemberMethods();
        return _memberMethods;
    }

    public JavaType resolveType(Type type) {
        return _typeFactory.constructType(type, _bindings);
    }

    public String toString() {
        return (new StringBuilder()).append("[AnnotedClass ").append(_class.getName()).append("]").toString();
    }

    public volatile Annotated withAnnotations(AnnotationMap annotationmap) {
        return withAnnotations(annotationmap);
    }

    public AnnotatedClass withAnnotations(AnnotationMap annotationmap) {
        return new AnnotatedClass(_type, _class, _bindings, _superTypes, _annotationIntrospector, _mixInResolver, _typeFactory, annotationmap);
    }

}
