// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind;

import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.core.Versioned;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import com.fasterxml.jackson.databind.introspect.Annotated;
import com.fasterxml.jackson.databind.introspect.AnnotatedClass;
import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
import com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair;
import com.fasterxml.jackson.databind.introspect.NopAnnotationIntrospector;
import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;
import com.fasterxml.jackson.databind.introspect.VisibilityChecker;
import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;
import com.fasterxml.jackson.databind.type.MapLikeType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.databind.util.NameTransformer;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.util.*;

// Referenced classes of package com.fasterxml.jackson.databind:
//            JavaType, JsonMappingException, PropertyName

public abstract class AnnotationIntrospector
    implements Versioned, Serializable {
    public static class ReferenceProperty {

        private final String _name;
        private final Type _type;

        public static ReferenceProperty back(String s) {
            return new ReferenceProperty(Type.BACK_REFERENCE, s);
        }

        public static ReferenceProperty managed(String s) {
            return new ReferenceProperty(Type.MANAGED_REFERENCE, s);
        }

        public String getName() {
            return _name;
        }

        public Type getType() {
            return _type;
        }

        public boolean isBackReference() {
            boolean flag;
            if (_type == Type.BACK_REFERENCE)
                flag = true;
            else
                flag = false;
            return flag;
        }

        public boolean isManagedReference() {
            boolean flag;
            if (_type == Type.MANAGED_REFERENCE)
                flag = true;
            else
                flag = false;
            return flag;
        }

        public ReferenceProperty(Type type, String s) {
            _type = type;
            _name = s;
        }
    }

    public static final class ReferenceProperty.Type extends Enum {

        private static final ReferenceProperty.Type $VALUES[];
        public static final ReferenceProperty.Type BACK_REFERENCE;
        public static final ReferenceProperty.Type MANAGED_REFERENCE;

        public static ReferenceProperty.Type valueOf(String s) {
            return (ReferenceProperty.Type)Enum.valueOf(com/fasterxml/jackson/databind/AnnotationIntrospector$ReferenceProperty$Type, s);
        }

        public static ReferenceProperty.Type[] values() {
            return (ReferenceProperty.Type[])$VALUES.clone();
        }

        static  {
            MANAGED_REFERENCE = new ReferenceProperty.Type("MANAGED_REFERENCE", 0);
            BACK_REFERENCE = new ReferenceProperty.Type("BACK_REFERENCE", 1);
            $VALUES = (new ReferenceProperty.Type[] {
                MANAGED_REFERENCE, BACK_REFERENCE
            });
        }

        private ReferenceProperty.Type(String s, int i) {
            super(s, i);
        }
    }


    public AnnotationIntrospector() {
    }

    public static AnnotationIntrospector nopInstance() {
        return NopAnnotationIntrospector.instance;
    }

    public static AnnotationIntrospector pair(AnnotationIntrospector annotationintrospector, AnnotationIntrospector annotationintrospector1) {
        return new AnnotationIntrospectorPair(annotationintrospector, annotationintrospector1);
    }

    protected Annotation _findAnnotation(Annotated annotated, Class class1) {
        return annotated.getAnnotation(class1);
    }

    protected boolean _hasAnnotation(Annotated annotated, Class class1) {
        return annotated.hasAnnotation(class1);
    }

    protected boolean _hasOneOf(Annotated annotated, Class aclass[]) {
        return annotated.hasOneOf(aclass);
    }

    public Collection allIntrospectors() {
        return Collections.singletonList(this);
    }

    public Collection allIntrospectors(Collection collection) {
        collection.add(this);
        return collection;
    }

    public void findAndAddVirtualProperties(MapperConfig mapperconfig, AnnotatedClass annotatedclass, List list) {
    }

    public VisibilityChecker findAutoDetectVisibility(AnnotatedClass annotatedclass, VisibilityChecker visibilitychecker) {
        return visibilitychecker;
    }

    public String findClassDescription(AnnotatedClass annotatedclass) {
        return null;
    }

    public Object findContentDeserializer(Annotated annotated) {
        return null;
    }

    public Object findContentSerializer(Annotated annotated) {
        return null;
    }

    public com.fasterxml.jackson.annotation.JsonCreator.Mode findCreatorBinding(Annotated annotated) {
        return null;
    }

    public Object findDeserializationContentConverter(AnnotatedMember annotatedmember) {
        return null;
    }

    public Class findDeserializationContentType(Annotated annotated, JavaType javatype) {
        return null;
    }

    public Object findDeserializationConverter(Annotated annotated) {
        return null;
    }

    public Class findDeserializationKeyType(Annotated annotated, JavaType javatype) {
        return null;
    }

    public Class findDeserializationType(Annotated annotated, JavaType javatype) {
        return null;
    }

    public Object findDeserializer(Annotated annotated) {
        return null;
    }

    public String findEnumValue(Enum enum) {
        return enum.name();
    }

    public String[] findEnumValues(Class class1, Enum aenum[], String as[]) {
        int i = 0;
        for (int j = aenum.length; i < j; i++)
            if (as[i] == null)
                as[i] = findEnumValue(aenum[i]);

        return as;
    }

    public Object findFilterId(Annotated annotated) {
        return null;
    }

    public com.fasterxml.jackson.annotation.JsonFormat.Value findFormat(Annotated annotated) {
        return null;
    }

    public Boolean findIgnoreUnknownProperties(AnnotatedClass annotatedclass) {
        return null;
    }

    public String findImplicitPropertyName(AnnotatedMember annotatedmember) {
        return null;
    }

    public Object findInjectableValueId(AnnotatedMember annotatedmember) {
        return null;
    }

    public Object findKeyDeserializer(Annotated annotated) {
        return null;
    }

    public Object findKeySerializer(Annotated annotated) {
        return null;
    }

    public PropertyName findNameForDeserialization(Annotated annotated) {
        return null;
    }

    public PropertyName findNameForSerialization(Annotated annotated) {
        return null;
    }

    public Object findNamingStrategy(AnnotatedClass annotatedclass) {
        return null;
    }

    public Object findNullSerializer(Annotated annotated) {
        return null;
    }

    public ObjectIdInfo findObjectIdInfo(Annotated annotated) {
        return null;
    }

    public ObjectIdInfo findObjectReferenceInfo(Annotated annotated, ObjectIdInfo objectidinfo) {
        return objectidinfo;
    }

    public Class findPOJOBuilder(AnnotatedClass annotatedclass) {
        return null;
    }

    public com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass annotatedclass) {
        return null;
    }

    public String[] findPropertiesToIgnore(Annotated annotated) {
        return findPropertiesToIgnore(annotated, true);
    }

    public String[] findPropertiesToIgnore(Annotated annotated, boolean flag) {
        return null;
    }

    public com.fasterxml.jackson.annotation.JsonProperty.Access findPropertyAccess(Annotated annotated) {
        return null;
    }

    public TypeResolverBuilder findPropertyContentTypeResolver(MapperConfig mapperconfig, AnnotatedMember annotatedmember, JavaType javatype) {
        return null;
    }

    public String findPropertyDefaultValue(Annotated annotated) {
        return null;
    }

    public String findPropertyDescription(Annotated annotated) {
        return null;
    }

    public com.fasterxml.jackson.annotation.JsonInclude.Value findPropertyInclusion(Annotated annotated) {
        return com.fasterxml.jackson.annotation.JsonInclude.Value.empty();
    }

    public Integer findPropertyIndex(Annotated annotated) {
        return null;
    }

    public TypeResolverBuilder findPropertyTypeResolver(MapperConfig mapperconfig, AnnotatedMember annotatedmember, JavaType javatype) {
        return null;
    }

    public ReferenceProperty findReferenceType(AnnotatedMember annotatedmember) {
        return null;
    }

    public PropertyName findRootName(AnnotatedClass annotatedclass) {
        return null;
    }

    public Object findSerializationContentConverter(AnnotatedMember annotatedmember) {
        return null;
    }

    public Class findSerializationContentType(Annotated annotated, JavaType javatype) {
        return null;
    }

    public Object findSerializationConverter(Annotated annotated) {
        return null;
    }

    public com.fasterxml.jackson.annotation.JsonInclude.Include findSerializationInclusion(Annotated annotated, com.fasterxml.jackson.annotation.JsonInclude.Include include) {
        return include;
    }

    public com.fasterxml.jackson.annotation.JsonInclude.Include findSerializationInclusionForContent(Annotated annotated, com.fasterxml.jackson.annotation.JsonInclude.Include include) {
        return include;
    }

    public Class findSerializationKeyType(Annotated annotated, JavaType javatype) {
        return null;
    }

    public String[] findSerializationPropertyOrder(AnnotatedClass annotatedclass) {
        return null;
    }

    public Boolean findSerializationSortAlphabetically(Annotated annotated) {
        return null;
    }

    public Class findSerializationType(Annotated annotated) {
        return null;
    }

    public com.fasterxml.jackson.databind.annotation.JsonSerialize.Typing findSerializationTyping(Annotated annotated) {
        return null;
    }

    public Object findSerializer(Annotated annotated) {
        return null;
    }

    public List findSubtypes(Annotated annotated) {
        return null;
    }

    public String findTypeName(AnnotatedClass annotatedclass) {
        return null;
    }

    public TypeResolverBuilder findTypeResolver(MapperConfig mapperconfig, AnnotatedClass annotatedclass, JavaType javatype) {
        return null;
    }

    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember annotatedmember) {
        return null;
    }

    public Object findValueInstantiator(AnnotatedClass annotatedclass) {
        return null;
    }

    public Class[] findViews(Annotated annotated) {
        return null;
    }

    public PropertyName findWrapperName(Annotated annotated) {
        return null;
    }

    public boolean hasAnyGetterAnnotation(AnnotatedMethod annotatedmethod) {
        return false;
    }

    public boolean hasAnySetterAnnotation(AnnotatedMethod annotatedmethod) {
        return false;
    }

    public boolean hasAsValueAnnotation(AnnotatedMethod annotatedmethod) {
        return false;
    }

    public boolean hasCreatorAnnotation(Annotated annotated) {
        return false;
    }

    public boolean hasIgnoreMarker(AnnotatedMember annotatedmember) {
        return false;
    }

    public Boolean hasRequiredMarker(AnnotatedMember annotatedmember) {
        return null;
    }

    public boolean isAnnotationBundle(Annotation annotation) {
        return false;
    }

    public Boolean isIgnorableType(AnnotatedClass annotatedclass) {
        return null;
    }

    public Boolean isTypeId(AnnotatedMember annotatedmember) {
        return null;
    }

    public JavaType refineDeserializationType(MapperConfig mapperconfig, Annotated annotated, JavaType javatype) {
        TypeFactory typefactory = mapperconfig.getTypeFactory();
        Class class1 = findDeserializationType(annotated, javatype);
        if (class1 != null && !javatype.hasRawClass(class1)) {
            JavaType javatype1;
            try {
                mapperconfig = typefactory.constructSpecializedType(javatype, class1);
            }
            // Misplaced declaration of an exception variable
            catch (MapperConfig mapperconfig) {
                throw new JsonMappingException(null, String.format("Failed to narrow type %s with annotation (value %s), from '%s': %s", new Object[] {
                    javatype, class1.getName(), annotated.getName(), mapperconfig.getMessage()
                }), mapperconfig);
            }
            javatype = mapperconfig;
        }
        mapperconfig = javatype;
        if (javatype.isMapLikeType()) {
            javatype1 = javatype.getKeyType();
            class1 = findDeserializationKeyType(annotated, javatype1);
            mapperconfig = javatype;
            if (class1 != null)
                try {
                    mapperconfig = typefactory.constructSpecializedType(javatype1, class1);
                    mapperconfig = ((MapLikeType)javatype).withKeyType(mapperconfig);
                }
                // Misplaced declaration of an exception variable
                catch (MapperConfig mapperconfig) {
                    throw new JsonMappingException(null, String.format("Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s", new Object[] {
                        javatype, class1.getName(), annotated.getName(), mapperconfig.getMessage()
                    }), mapperconfig);
                }
        }
        javatype1 = mapperconfig.getContentType();
        javatype = mapperconfig;
        if (javatype1 != null) {
            class1 = findDeserializationContentType(annotated, javatype1);
            javatype = mapperconfig;
            if (class1 != null)
                try {
                    javatype = mapperconfig.withContentType(typefactory.constructSpecializedType(javatype1, class1));
                }
                // Misplaced declaration of an exception variable
                catch (JavaType javatype) {
                    throw new JsonMappingException(null, String.format("Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s", new Object[] {
                        mapperconfig, class1.getName(), annotated.getName(), javatype.getMessage()
                    }), javatype);
                }
        }
        return javatype;
    }

    public JavaType refineSerializationType(MapperConfig mapperconfig, Annotated annotated, JavaType javatype) {
        TypeFactory typefactory;
        Class class1;
        typefactory = mapperconfig.getTypeFactory();
        class1 = findSerializationType(annotated);
        if (class1 == null) goto _L2; else goto _L1
_L1:
        if (!javatype.hasRawClass(class1)) goto _L4; else goto _L3
_L3:
        mapperconfig = javatype.withStaticTyping();
_L18:
        javatype = mapperconfig;
        if (!mapperconfig.isMapLikeType()) goto _L6; else goto _L5
_L5:
        JavaType javatype1;
        javatype1 = mapperconfig.getKeyType();
        class1 = findSerializationKeyType(annotated, javatype1);
        javatype = mapperconfig;
        if (class1 == null) goto _L6; else goto _L7
_L7:
        if (!javatype1.hasRawClass(class1)) goto _L9; else goto _L8
_L8:
        javatype = javatype1.withStaticTyping();
_L15:
        javatype = ((MapLikeType)mapperconfig).withKeyType(javatype);
_L6:
        javatype1 = javatype.getContentType();
        mapperconfig = javatype;
        if (javatype1 == null) goto _L11; else goto _L10
_L10:
        class1 = findSerializationContentType(annotated, javatype1);
        mapperconfig = javatype;
        if (class1 == null) goto _L11; else goto _L12
_L12:
        if (!javatype1.hasRawClass(class1)) goto _L14; else goto _L13
_L13:
        mapperconfig = javatype1.withStaticTyping();
_L16:
        mapperconfig = javatype.withContentType(mapperconfig);
_L11:
        return mapperconfig;
_L4:
        mapperconfig = javatype.getRawClass();
        if (class1.isAssignableFrom(mapperconfig)) {
            mapperconfig = typefactory.constructGeneralizedType(javatype, class1);
            continue; /* Loop/switch isn't completed */
        }
        if (mapperconfig.isAssignableFrom(class1)) {
            mapperconfig = typefactory.constructSpecializedType(javatype, class1);
            continue; /* Loop/switch isn't completed */
        } else {
            try {
                mapperconfig = JVM INSTR new #261 <Class JsonMappingException>;
                mapperconfig.JsonMappingException(null, String.format("Can not refine serialization type %s into %s; types not related", new Object[] {
                    javatype, class1.getName()
                }));
                throw mapperconfig;
            }
            // Misplaced declaration of an exception variable
            catch (MapperConfig mapperconfig) {
                throw new JsonMappingException(null, String.format("Failed to widen type %s with annotation (value %s), from '%s': %s", new Object[] {
                    javatype, class1.getName(), annotated.getName(), mapperconfig.getMessage()
                }), mapperconfig);
            }
        }
_L9:
        javatype = javatype1.getRawClass();
label0:
        {
            if (!class1.isAssignableFrom(javatype))
                break label0;
            javatype = typefactory.constructGeneralizedType(javatype1, class1);
        }
          goto _L15
label1:
        {
            if (!javatype.isAssignableFrom(class1))
                break label1;
            javatype = typefactory.constructSpecializedType(javatype1, class1);
        }
          goto _L15
        try {
            javatype = JVM INSTR new #261 <Class JsonMappingException>;
            javatype.JsonMappingException(null, String.format("Can not refine serialization key type %s into %s; types not related", new Object[] {
                javatype1, class1.getName()
            }));
            throw javatype;
        }
        // Misplaced declaration of an exception variable
        catch (JavaType javatype) {
            throw new JsonMappingException(null, String.format("Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s", new Object[] {
                mapperconfig, class1.getName(), annotated.getName(), javatype.getMessage()
            }), javatype);
        }
_L14:
        mapperconfig = javatype1.getRawClass();
label2:
        {
            if (!class1.isAssignableFrom(mapperconfig))
                break label2;
            mapperconfig = typefactory.constructGeneralizedType(javatype1, class1);
        }
          goto _L16
label3:
        {
            if (!mapperconfig.isAssignableFrom(class1))
                break label3;
            mapperconfig = typefactory.constructSpecializedType(javatype1, class1);
        }
          goto _L16
        try {
            mapperconfig = JVM INSTR new #261 <Class JsonMappingException>;
            mapperconfig.JsonMappingException(null, String.format("Can not refine serialization content type %s into %s; types not related", new Object[] {
                javatype1, class1.getName()
            }));
            throw mapperconfig;
        }
        // Misplaced declaration of an exception variable
        catch (MapperConfig mapperconfig) {
            throw new JsonMappingException(null, String.format("Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s", new Object[] {
                javatype, class1.getName(), annotated.getName(), mapperconfig.getMessage()
            }), mapperconfig);
        }
_L2:
        mapperconfig = javatype;
        if (true) goto _L18; else goto _L17
_L17:
    }

    public AnnotatedMethod resolveSetterConflict(MapperConfig mapperconfig, AnnotatedMethod annotatedmethod, AnnotatedMethod annotatedmethod1) {
        return null;
    }

    public abstract Version version();
}
