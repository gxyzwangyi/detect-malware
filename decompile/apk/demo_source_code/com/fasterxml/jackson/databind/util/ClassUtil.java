// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.util;

import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
import com.fasterxml.jackson.databind.annotation.NoClass;
import java.lang.annotation.Annotation;
import java.lang.reflect.*;
import java.util.*;

// Referenced classes of package com.fasterxml.jackson.databind.util:
//            LRUMap

public final class ClassUtil {
    private static final class ClassMetadata {

        private static final Annotation NO_ANNOTATIONS[] = new Annotation[0];
        private static final Ctor NO_CTORS[] = new Ctor[0];
        private Annotation _annotations[];
        private Ctor _constructors[];
        private Field _fields[];
        private final Class _forClass;
        private Type _genericInterfaces[];
        private Boolean _hasEnclosingMethod;
        private Class _interfaces[];
        private Method _methods[];
        private String _packageName;

        private boolean isObjectOrPrimitive() {
            boolean flag;
            if (_forClass == ClassUtil.CLS_OBJECT || _forClass.isPrimitive())
                flag = true;
            else
                flag = false;
            return flag;
        }

        public Ctor[] getConstructors() {
            Ctor actor[];
            Ctor actor1[];
            actor1 = _constructors;
            actor = actor1;
            if (actor1 != null) goto _L2; else goto _L1
_L1:
            if (!_forClass.isInterface() && !isObjectOrPrimitive()) goto _L4; else goto _L3
_L3:
            actor = NO_CTORS;
_L6:
            _constructors = actor;
_L2:
            return actor;
_L4:
            Constructor aconstructor[] = _forClass.getDeclaredConstructors();
            int j = aconstructor.length;
            Ctor actor2[] = new Ctor[j];
            int i = 0;
            do {
                actor = actor2;
                if (i >= j)
                    continue;
                actor2[i] = new Ctor(aconstructor[i]);
                i++;
            } while (true);
            if (true) goto _L6; else goto _L5
_L5:
        }

        public Annotation[] getDeclaredAnnotations() {
            Annotation aannotation1[] = _annotations;
            Annotation aannotation[] = aannotation1;
            if (aannotation1 == null) {
                if (isObjectOrPrimitive())
                    aannotation = NO_ANNOTATIONS;
                else
                    aannotation = _forClass.getDeclaredAnnotations();
                _annotations = aannotation;
            }
            return aannotation;
        }

        public Field[] getDeclaredFields() {
            Field afield1[] = _fields;
            Field afield[] = afield1;
            if (afield1 == null) {
                afield = _forClass.getDeclaredFields();
                _fields = afield;
            }
            return afield;
        }

        public Method[] getDeclaredMethods() {
            Method amethod1[] = _methods;
            Method amethod[] = amethod1;
            if (amethod1 == null) {
                amethod = _forClass.getDeclaredMethods();
                _methods = amethod;
            }
            return amethod;
        }

        public Type[] getGenericInterfaces() {
            Type atype1[] = _genericInterfaces;
            Type atype[] = atype1;
            if (atype1 == null) {
                atype = _forClass.getGenericInterfaces();
                _genericInterfaces = atype;
            }
            return atype;
        }

        public Class[] getInterfaces() {
            Class aclass1[] = _interfaces;
            Class aclass[] = aclass1;
            if (aclass1 == null) {
                aclass = _forClass.getInterfaces();
                _interfaces = aclass;
            }
            return aclass;
        }

        public String getPackageName() {
            String s = _packageName;
            Object obj = s;
            if (s == null) {
                obj = _forClass.getPackage();
                Object obj1;
                if (obj == null)
                    obj = null;
                else
                    obj = ((Package) (obj)).getName();
                obj1 = obj;
                if (obj == null)
                    obj1 = "";
                _packageName = ((String) (obj1));
                obj = obj1;
            }
            obj1 = obj;
            if (obj == "")
                obj1 = null;
            return ((String) (obj1));
        }

        public boolean hasEnclosingMethod() {
            Boolean boolean2 = _hasEnclosingMethod;
            Boolean boolean1 = boolean2;
            if (boolean2 == null) {
                if (isObjectOrPrimitive()) {
                    boolean1 = Boolean.FALSE;
                } else {
                    boolean flag;
                    if (_forClass.getEnclosingMethod() != null)
                        flag = true;
                    else
                        flag = false;
                    boolean1 = Boolean.valueOf(flag);
                }
                _hasEnclosingMethod = boolean1;
            }
            return boolean1.booleanValue();
        }


        public ClassMetadata(Class class1) {
            _forClass = class1;
        }
    }

    public static final class Ctor {

        private Annotation _annotations[];
        public final Constructor _ctor;
        private Annotation _paramAnnotations[][];
        private int _paramCount;

        public Constructor getConstructor() {
            return _ctor;
        }

        public Annotation[] getDeclaredAnnotations() {
            Annotation aannotation1[] = _annotations;
            Annotation aannotation[] = aannotation1;
            if (aannotation1 == null) {
                aannotation = _ctor.getDeclaredAnnotations();
                _annotations = aannotation;
            }
            return aannotation;
        }

        public Class getDeclaringClass() {
            return _ctor.getDeclaringClass();
        }

        public int getParamCount() {
            int j = _paramCount;
            int i = j;
            if (j < 0) {
                i = _ctor.getParameterTypes().length;
                _paramCount = i;
            }
            return i;
        }

        public Annotation[][] getParameterAnnotations() {
            Annotation aannotation1[][] = _paramAnnotations;
            Annotation aannotation[][] = aannotation1;
            if (aannotation1 == null) {
                aannotation = _ctor.getParameterAnnotations();
                _paramAnnotations = aannotation;
            }
            return aannotation;
        }

        public Ctor(Constructor constructor) {
            _paramCount = -1;
            _ctor = constructor;
        }
    }

    private static final class EmptyIterator
        implements Iterator {

        public boolean hasNext() {
            return false;
        }

        public Object next() {
            throw new NoSuchElementException();
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

        private EmptyIterator() {
        }

    }

    private static class EnumTypeLocator {

        static final EnumTypeLocator instance = new EnumTypeLocator();
        private final Field enumMapTypeField = locateField(java/util/EnumMap, "elementType", java/lang/Class);
        private final Field enumSetTypeField = locateField(java/util/EnumSet, "elementType", java/lang/Class);

        private Object get(Object obj, Field field) {
            try {
                obj = field.get(obj);
            }
            // Misplaced declaration of an exception variable
            catch (Object obj) {
                throw new IllegalArgumentException(((Throwable) (obj)));
            }
            return obj;
        }

        private static Field locateField(Class class1, String s, Class class2) {
            int i;
            int j;
            Field afield[];
            afield = ClassUtil.getDeclaredFields(class1);
            j = afield.length;
            i = 0;
_L11:
            if (i >= j)
                break MISSING_BLOCK_LABEL_123;
            class1 = afield[i];
            if (!s.equals(class1.getName()) || class1.getType() != class2) goto _L2; else goto _L1
_L1:
            s = class1;
            if (class1 != null) goto _L4; else goto _L3
_L3:
            j = afield.length;
            i = 0;
_L12:
            if (i >= j) goto _L6; else goto _L5
_L5:
            s = afield[i];
            if (s.getType() != class2) goto _L8; else goto _L7
_L7:
            if (class1 == null) goto _L10; else goto _L9
_L9:
            class1 = null;
_L14:
            return class1;
_L2:
            i++;
              goto _L11
_L8:
            s = class1;
_L10:
            i++;
            class1 = s;
              goto _L12
_L6:
            s = class1;
_L4:
            class1 = s;
            if (s == null) goto _L14; else goto _L13
_L13:
            s.setAccessible(true);
            class1 = s;
              goto _L14
            class1;
            class1 = s;
              goto _L14
            class1 = null;
              goto _L1
        }

        public Class enumTypeFor(EnumMap enummap) {
            if (enumMapTypeField != null)
                return (Class)get(enummap, enumMapTypeField);
            else
                throw new IllegalStateException("Can not figure out type for EnumMap (odd JDK platform?)");
        }

        public Class enumTypeFor(EnumSet enumset) {
            if (enumSetTypeField != null)
                return (Class)get(enumset, enumSetTypeField);
            else
                throw new IllegalStateException("Can not figure out type for EnumSet (odd JDK platform?)");
        }


        private EnumTypeLocator() {
        }
    }


    private static final Class CLS_OBJECT = java/lang/Object;
    private static final EmptyIterator EMPTY_ITERATOR = new EmptyIterator();
    private static final LRUMap sCached = new LRUMap(48, 48);

    public ClassUtil() {
    }

    private static void _addRawSuperTypes(Class class1, Class class2, Collection collection, boolean flag) {
        if (class1 != class2 && class1 != null && class1 != java/lang/Object) goto _L2; else goto _L1
_L1:
        return;
_L2:
        if (flag) {
            if (collection.contains(class1))
                continue; /* Loop/switch isn't completed */
            collection.add(class1);
        }
        Class aclass[] = _interfaces(class1);
        int j = aclass.length;
        for (int i = 0; i < j; i++)
            _addRawSuperTypes(aclass[i], class2, collection, true);

        _addRawSuperTypes(class1.getSuperclass(), class2, collection, true);
        if (true) goto _L1; else goto _L3
_L3:
    }

    private static void _addSuperTypes(JavaType javatype, Class class1, Collection collection, boolean flag) {
        if (javatype != null) goto _L2; else goto _L1
_L1:
        return;
_L2:
        Class class2 = javatype.getRawClass();
        if (class2 == class1 || class2 == java/lang/Object)
            continue; /* Loop/switch isn't completed */
        if (flag) {
            if (collection.contains(javatype))
                continue; /* Loop/switch isn't completed */
            collection.add(javatype);
        }
        for (Iterator iterator = javatype.getInterfaces().iterator(); iterator.hasNext(); _addSuperTypes((JavaType)iterator.next(), class1, collection, true));
        _addSuperTypes(javatype.getSuperClass(), class1, collection, true);
        if (true) goto _L1; else goto _L3
_L3:
    }

    private static ClassMetadata _getMetadata(Class class1) {
        ClassMetadata classmetadata = (ClassMetadata)sCached.get(class1);
        Object obj = classmetadata;
        if (classmetadata == null) {
            obj = new ClassMetadata(class1);
            class1 = (ClassMetadata)sCached.putIfAbsent(class1, obj);
            if (class1 != null)
                obj = class1;
        }
        return ((ClassMetadata) (obj));
    }

    private static Class[] _interfaces(Class class1) {
        return _getMetadata(class1).getInterfaces();
    }

    public static String canBeABeanType(Class class1) {
        if (class1.isAnnotation())
            class1 = "annotation";
        else
        if (class1.isArray())
            class1 = "array";
        else
        if (class1.isEnum())
            class1 = "enum";
        else
        if (class1.isPrimitive())
            class1 = "primitive";
        else
            class1 = null;
        return class1;
    }

    public static void checkAndFixAccess(Member member) {
        checkAndFixAccess(member, false);
    }

    public static void checkAndFixAccess(Member member, boolean flag) {
        AccessibleObject accessibleobject;
        accessibleobject = (AccessibleObject)member;
        if (flag)
            break MISSING_BLOCK_LABEL_36;
        if (Modifier.isPublic(member.getModifiers()) && Modifier.isPublic(member.getDeclaringClass().getModifiers()))
            break MISSING_BLOCK_LABEL_41;
        accessibleobject.setAccessible(true);
_L1:
        return;
        SecurityException securityexception;
        securityexception;
        if (!accessibleobject.isAccessible()) {
            Class class1 = member.getDeclaringClass();
            throw new IllegalArgumentException((new StringBuilder()).append("Can not access ").append(member).append(" (from class ").append(class1.getName()).append("; failed to set access: ").append(securityexception.getMessage()).toString());
        }
          goto _L1
    }

    public static Object createInstance(Class class1, boolean flag) {
        Object obj;
        obj = findConstructor(class1, flag);
        if (obj == null)
            throw new IllegalArgumentException((new StringBuilder()).append("Class ").append(class1.getName()).append(" has no default (no arg) constructor").toString());
        obj = ((Constructor) (obj)).newInstance(new Object[0]);
        class1 = ((Class) (obj));
_L2:
        return class1;
        Exception exception;
        exception;
        unwrapAndThrowAsIAE(exception, (new StringBuilder()).append("Failed to instantiate class ").append(class1.getName()).append(", problem: ").append(exception.getMessage()).toString());
        class1 = null;
        if (true) goto _L2; else goto _L1
_L1:
    }

    public static Object defaultValue(Class class1) {
        if (class1 == Integer.TYPE)
            class1 = Integer.valueOf(0);
        else
        if (class1 == Long.TYPE)
            class1 = Long.valueOf(0L);
        else
        if (class1 == Boolean.TYPE)
            class1 = Boolean.FALSE;
        else
        if (class1 == Double.TYPE)
            class1 = Double.valueOf(0.0D);
        else
        if (class1 == Float.TYPE)
            class1 = Float.valueOf(0.0F);
        else
        if (class1 == Byte.TYPE)
            class1 = Byte.valueOf((byte)0);
        else
        if (class1 == Short.TYPE)
            class1 = Short.valueOf((short)0);
        else
        if (class1 == Character.TYPE)
            class1 = Character.valueOf('\0');
        else
            throw new IllegalArgumentException((new StringBuilder()).append("Class ").append(class1.getName()).append(" is not a primitive type").toString());
        return class1;
    }

    public static Iterator emptyIterator() {
        return EMPTY_ITERATOR;
    }

    public static Class findClass(String s) {
        if (s.indexOf('.') >= 0) goto _L2; else goto _L1
_L1:
        if (!"int".equals(s)) goto _L4; else goto _L3
_L3:
        s = Integer.TYPE;
_L6:
        return s;
_L4:
        if ("long".equals(s)) {
            s = Long.TYPE;
            continue; /* Loop/switch isn't completed */
        }
        if ("float".equals(s)) {
            s = Float.TYPE;
            continue; /* Loop/switch isn't completed */
        }
        if ("double".equals(s)) {
            s = Double.TYPE;
            continue; /* Loop/switch isn't completed */
        }
        if ("boolean".equals(s)) {
            s = Boolean.TYPE;
            continue; /* Loop/switch isn't completed */
        }
        if ("byte".equals(s)) {
            s = Byte.TYPE;
            continue; /* Loop/switch isn't completed */
        }
        if ("char".equals(s)) {
            s = Character.TYPE;
            continue; /* Loop/switch isn't completed */
        }
        if ("short".equals(s)) {
            s = Short.TYPE;
            continue; /* Loop/switch isn't completed */
        }
        if ("void".equals(s)) {
            s = Void.TYPE;
            continue; /* Loop/switch isn't completed */
        }
_L2:
        Object obj;
        ClassLoader classloader;
        obj = null;
        classloader = Thread.currentThread().getContextClassLoader();
        if (classloader == null)
            break MISSING_BLOCK_LABEL_192;
        obj = Class.forName(s, true, classloader);
        s = ((String) (obj));
        continue; /* Loop/switch isn't completed */
        obj;
        obj = getRootCause(((Throwable) (obj)));
        try {
            s = Class.forName(s);
        }
        catch (Exception exception) {
            s = ((String) (obj));
            if (obj == null)
                s = getRootCause(exception);
            if (s instanceof RuntimeException)
                throw (RuntimeException)s;
            else
                throw new ClassNotFoundException(s.getMessage(), s);
        }
        if (true) goto _L6; else goto _L5
_L5:
    }

    public static Annotation[] findClassAnnotations(Class class1) {
        return _getMetadata(class1).getDeclaredAnnotations();
    }

    public static Constructor findConstructor(Class class1, boolean flag) {
        Constructor constructor = class1.getDeclaredConstructor(new Class[0]);
        if (!flag) goto _L2; else goto _L1
_L1:
        checkAndFixAccess(constructor);
        Object obj = constructor;
_L4:
        return ((Constructor) (obj));
_L2:
        obj = constructor;
        if (Modifier.isPublic(constructor.getModifiers())) goto _L4; else goto _L3
_L3:
        obj = JVM INSTR new #186 <Class IllegalArgumentException>;
        StringBuilder stringbuilder = JVM INSTR new #188 <Class StringBuilder>;
        stringbuilder.StringBuilder();
        ((IllegalArgumentException) (obj)).IllegalArgumentException(stringbuilder.append("Default constructor for ").append(class1.getName()).append(" is not accessible (non-public?): not allowed to try modify access via Reflection: can not instantiate type").toString());
        throw obj;
        class1;
_L5:
        obj = null;
          goto _L4
        Exception exception;
        exception;
        unwrapAndThrowAsIAE(exception, (new StringBuilder()).append("Failed to find default constructor of class ").append(class1.getName()).append(", problem: ").append(exception.getMessage()).toString());
          goto _L5
    }

    public static Class findEnumType(Class class1) {
        Class class2 = class1;
        if (class1.getSuperclass() != java/lang/Enum)
            class2 = class1.getSuperclass();
        return class2;
    }

    public static Class findEnumType(Enum enum) {
        Class class1 = enum.getClass();
        enum = class1;
        if (class1.getSuperclass() != java/lang/Enum)
            enum = class1.getSuperclass();
        return enum;
    }

    public static Class findEnumType(EnumMap enummap) {
        if (!enummap.isEmpty())
            enummap = findEnumType((Enum)enummap.keySet().iterator().next());
        else
            enummap = EnumTypeLocator.instance.enumTypeFor(enummap);
        return enummap;
    }

    public static Class findEnumType(EnumSet enumset) {
        if (!enumset.isEmpty())
            enumset = findEnumType((Enum)enumset.iterator().next());
        else
            enumset = EnumTypeLocator.instance.enumTypeFor(enumset);
        return enumset;
    }

    public static List findRawSuperTypes(Class class1, Class class2, boolean flag) {
        if (class1 == null || class1 == class2 || class1 == java/lang/Object) {
            class1 = Collections.emptyList();
        } else {
            ArrayList arraylist = new ArrayList(8);
            _addRawSuperTypes(class1, class2, arraylist, flag);
            class1 = arraylist;
        }
        return class1;
    }

    public static List findSuperClasses(Class class1, Class class2, boolean flag) {
        LinkedList linkedlist = new LinkedList();
        if (class1 == null || class1 == class2) goto _L2; else goto _L1
_L1:
        Class class3;
        class3 = class1;
        if (flag) {
            linkedlist.add(class1);
            class3 = class1;
        }
_L5:
        class3 = class3.getSuperclass();
        if (class3 != null && class3 != class2) goto _L3; else goto _L2
_L2:
        return linkedlist;
_L3:
        linkedlist.add(class3);
        if (true) goto _L5; else goto _L4
_L4:
    }

    public static List findSuperTypes(JavaType javatype, Class class1, boolean flag) {
        if (javatype == null || javatype.hasRawClass(class1) || javatype.hasRawClass(java/lang/Object)) {
            javatype = Collections.emptyList();
        } else {
            ArrayList arraylist = new ArrayList(8);
            _addSuperTypes(javatype, class1, arraylist, flag);
            javatype = arraylist;
        }
        return javatype;
    }

    public static List findSuperTypes(Class class1, Class class2) {
        return findSuperTypes(class1, class2, ((List) (new ArrayList(8))));
    }

    public static List findSuperTypes(Class class1, Class class2, List list) {
        _addRawSuperTypes(class1, class2, list, false);
        return list;
    }

    public static String getClassDescription(Object obj) {
        if (obj == null) {
            obj = "unknown";
        } else {
            if (obj instanceof Class)
                obj = (Class)obj;
            else
                obj = obj.getClass();
            obj = ((Class) (obj)).getName();
        }
        return ((String) (obj));
    }

    public static Ctor[] getConstructors(Class class1) {
        return _getMetadata(class1).getConstructors();
    }

    public static Field[] getDeclaredFields(Class class1) {
        return _getMetadata(class1).getDeclaredFields();
    }

    public static Method[] getDeclaredMethods(Class class1) {
        return _getMetadata(class1).getDeclaredMethods();
    }

    public static Class getDeclaringClass(Class class1) {
        if (isObjectOrPrimitive(class1))
            class1 = null;
        else
            class1 = class1.getDeclaringClass();
        return class1;
    }

    public static Class getEnclosingClass(Class class1) {
        if (isObjectOrPrimitive(class1))
            class1 = null;
        else
            class1 = class1.getEnclosingClass();
        return class1;
    }

    public static Type[] getGenericInterfaces(Class class1) {
        return _getMetadata(class1).getGenericInterfaces();
    }

    public static Type getGenericSuperclass(Class class1) {
        return class1.getGenericSuperclass();
    }

    public static Class getOuterClass(Class class1) {
        Object obj = null;
        if (!hasEnclosingMethod(class1)) goto _L2; else goto _L1
_L1:
        Class class2 = obj;
_L4:
        return class2;
_L2:
        class2 = obj;
        try {
            if (!Modifier.isStatic(class1.getModifiers()))
                class2 = getEnclosingClass(class1);
        }
        // Misplaced declaration of an exception variable
        catch (Class class1) {
            class2 = obj;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public static String getPackageName(Class class1) {
        return _getMetadata(class1).getPackageName();
    }

    public static Throwable getRootCause(Throwable throwable) {
        for (; throwable.getCause() != null; throwable = throwable.getCause());
        return throwable;
    }

    public static boolean hasEnclosingMethod(Class class1) {
        return _getMetadata(class1).hasEnclosingMethod();
    }

    public static boolean hasGetterSignature(Method method) {
        boolean flag1 = false;
        if (!Modifier.isStatic(method.getModifiers())) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        Class aclass[] = method.getParameterTypes();
        if (aclass != null) {
            flag = flag1;
            if (aclass.length != 0)
                continue; /* Loop/switch isn't completed */
        }
        flag = flag1;
        if (Void.TYPE != method.getReturnType())
            flag = true;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public static boolean isBogusClass(Class class1) {
        boolean flag;
        if (class1 == java/lang/Void || class1 == Void.TYPE || class1 == com/fasterxml/jackson/databind/annotation/NoClass)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public static boolean isCollectionMapOrArray(Class class1) {
        boolean flag1 = true;
        if (!class1.isArray()) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        flag = flag1;
        if (!java/util/Collection.isAssignableFrom(class1)) {
            flag = flag1;
            if (!java/util/Map.isAssignableFrom(class1))
                flag = false;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public static boolean isConcrete(Class class1) {
        boolean flag;
        if ((class1.getModifiers() & 0x600) == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public static boolean isConcrete(Member member) {
        boolean flag;
        if ((member.getModifiers() & 0x600) == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public static boolean isJacksonStdImpl(Class class1) {
        boolean flag;
        if (class1.getAnnotation(com/fasterxml/jackson/databind/annotation/JacksonStdImpl) != null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public static boolean isJacksonStdImpl(Object obj) {
        boolean flag;
        if (obj != null && isJacksonStdImpl(obj.getClass()))
            flag = true;
        else
            flag = false;
        return flag;
    }

    public static String isLocalType(Class class1, boolean flag) {
        if (!hasEnclosingMethod(class1)) goto _L2; else goto _L1
_L1:
        class1 = "local/anonymous";
_L3:
        return class1;
_L2:
        if (flag)
            break MISSING_BLOCK_LABEL_42;
        if (Modifier.isStatic(class1.getModifiers()) || getEnclosingClass(class1) == null)
            break MISSING_BLOCK_LABEL_42;
        class1 = "non-static member class";
          goto _L3
        class1;
_L4:
        class1 = null;
          goto _L3
        class1;
          goto _L4
    }

    public static boolean isNonStaticInnerClass(Class class1) {
        boolean flag;
        if (!Modifier.isStatic(class1.getModifiers()) && getEnclosingClass(class1) != null)
            flag = true;
        else
            flag = false;
        return flag;
    }

    public static boolean isObjectOrPrimitive(Class class1) {
        boolean flag;
        if (class1 == CLS_OBJECT || class1.isPrimitive())
            flag = true;
        else
            flag = false;
        return flag;
    }

    public static boolean isProxyType(Class class1) {
        class1 = class1.getName();
        boolean flag;
        if (class1.startsWith("net.sf.cglib.proxy.") || class1.startsWith("org.hibernate.proxy."))
            flag = true;
        else
            flag = false;
        return flag;
    }

    public static Class primitiveType(Class class1) {
        if (!class1.isPrimitive())
            if (class1 == java/lang/Integer)
                class1 = Integer.TYPE;
            else
            if (class1 == java/lang/Long)
                class1 = Long.TYPE;
            else
            if (class1 == java/lang/Boolean)
                class1 = Boolean.TYPE;
            else
            if (class1 == java/lang/Double)
                class1 = Double.TYPE;
            else
            if (class1 == java/lang/Float)
                class1 = Float.TYPE;
            else
            if (class1 == java/lang/Byte)
                class1 = Byte.TYPE;
            else
            if (class1 == java/lang/Short)
                class1 = Short.TYPE;
            else
            if (class1 == java/lang/Character)
                class1 = Character.TYPE;
            else
                class1 = null;
        return class1;
    }

    public static void throwAsIAE(Throwable throwable) {
        throwAsIAE(throwable, throwable.getMessage());
    }

    public static void throwAsIAE(Throwable throwable, String s) {
        if (throwable instanceof RuntimeException)
            throw (RuntimeException)throwable;
        if (throwable instanceof Error)
            throw (Error)throwable;
        else
            throw new IllegalArgumentException(s, throwable);
    }

    public static void throwRootCause(Throwable throwable) {
        throwable = getRootCause(throwable);
        if (throwable instanceof Exception)
            throw (Exception)throwable;
        else
            throw (Error)throwable;
    }

    public static void unwrapAndThrowAsIAE(Throwable throwable) {
        throwAsIAE(getRootCause(throwable));
    }

    public static void unwrapAndThrowAsIAE(Throwable throwable, String s) {
        throwAsIAE(getRootCause(throwable), s);
    }

    public static Class wrapperType(Class class1) {
        if (class1 == Integer.TYPE)
            class1 = java/lang/Integer;
        else
        if (class1 == Long.TYPE)
            class1 = java/lang/Long;
        else
        if (class1 == Boolean.TYPE)
            class1 = java/lang/Boolean;
        else
        if (class1 == Double.TYPE)
            class1 = java/lang/Double;
        else
        if (class1 == Float.TYPE)
            class1 = java/lang/Float;
        else
        if (class1 == Byte.TYPE)
            class1 = java/lang/Byte;
        else
        if (class1 == Short.TYPE)
            class1 = java/lang/Short;
        else
        if (class1 == Character.TYPE)
            class1 = java/lang/Character;
        else
            throw new IllegalArgumentException((new StringBuilder()).append("Class ").append(class1.getName()).append(" is not a primitive type").toString());
        return class1;
    }


}
