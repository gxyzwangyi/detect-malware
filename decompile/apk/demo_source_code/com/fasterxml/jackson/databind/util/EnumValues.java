// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.util;

import com.fasterxml.jackson.core.SerializableString;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import java.io.Serializable;
import java.util.*;

// Referenced classes of package com.fasterxml.jackson.databind.util:
//            ClassUtil

public final class EnumValues
    implements Serializable {

    private static final long serialVersionUID = 1L;
    private transient EnumMap _asMap;
    private final Class _enumClass;
    private final SerializableString _textual[];
    private final Enum _values[];

    private EnumValues(Class class1, SerializableString aserializablestring[]) {
        _enumClass = class1;
        _values = (Enum[])class1.getEnumConstants();
        _textual = aserializablestring;
    }

    public static EnumValues construct(SerializationConfig serializationconfig, Class class1) {
        if (serializationconfig.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING))
            serializationconfig = constructFromToString(serializationconfig, class1);
        else
            serializationconfig = constructFromName(serializationconfig, class1);
        return serializationconfig;
    }

    public static EnumValues constructFromName(MapperConfig mapperconfig, Class class1) {
        Class class2 = ClassUtil.findEnumType(class1);
        Enum aenum[] = (Enum[])class2.getEnumConstants();
        if (aenum == null)
            throw new IllegalArgumentException((new StringBuilder()).append("Can not determine enum constants for Class ").append(class1.getName()).toString());
        String as[] = mapperconfig.getAnnotationIntrospector().findEnumValues(class2, aenum, new String[aenum.length]);
        SerializableString aserializablestring[] = new SerializableString[aenum.length];
        int j = aenum.length;
        for (int i = 0; i < j; i++) {
            Enum enum = aenum[i];
            String s1 = as[i];
            String s = s1;
            if (s1 == null)
                s = enum.name();
            aserializablestring[enum.ordinal()] = mapperconfig.compileString(s);
        }

        return new EnumValues(class1, aserializablestring);
    }

    public static EnumValues constructFromToString(MapperConfig mapperconfig, Class class1) {
        Enum aenum[] = (Enum[])ClassUtil.findEnumType(class1).getEnumConstants();
        if (aenum != null) {
            SerializableString aserializablestring[] = new SerializableString[aenum.length];
            int j = aenum.length;
            for (int i = 0; i < j; i++) {
                Enum enum = aenum[i];
                aserializablestring[enum.ordinal()] = mapperconfig.compileString(enum.toString());
            }

            return new EnumValues(class1, aserializablestring);
        } else {
            throw new IllegalArgumentException((new StringBuilder()).append("Can not determine enum constants for Class ").append(class1.getName()).toString());
        }
    }

    public List enums() {
        return Arrays.asList(_values);
    }

    public Class getEnumClass() {
        return _enumClass;
    }

    public EnumMap internalMap() {
        EnumMap enummap = _asMap;
        Object obj = enummap;
        if (enummap == null) {
            obj = new LinkedHashMap();
            Enum aenum[] = _values;
            int j = aenum.length;
            for (int i = 0; i < j; i++) {
                Enum enum = aenum[i];
                ((Map) (obj)).put(enum, _textual[enum.ordinal()]);
            }

            obj = new EnumMap(((Map) (obj)));
        }
        return ((EnumMap) (obj));
    }

    public SerializableString serializedValueFor(Enum enum) {
        return _textual[enum.ordinal()];
    }

    public Collection values() {
        return Arrays.asList(_textual);
    }
}
