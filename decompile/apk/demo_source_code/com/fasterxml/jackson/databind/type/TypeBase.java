// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.type;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.type.ResolvedType;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
import java.util.*;

// Referenced classes of package com.fasterxml.jackson.databind.type:
//            TypeBindings, TypeFactory

public abstract class TypeBase extends JavaType
    implements JsonSerializable {

    private static final TypeBindings NO_BINDINGS = TypeBindings.emptyBindings();
    private static final JavaType NO_TYPES[] = new JavaType[0];
    private static final long serialVersionUID = 1L;
    protected final TypeBindings _bindings;
    volatile transient String _canonicalName;
    protected final JavaType _superClass;
    protected final JavaType _superInterfaces[];

    protected TypeBase(TypeBase typebase) {
        super(typebase);
        _superClass = typebase._superClass;
        _superInterfaces = typebase._superInterfaces;
        _bindings = typebase._bindings;
    }

    protected TypeBase(Class class1, TypeBindings typebindings, JavaType javatype, JavaType ajavatype[], int i, Object obj, Object obj1, 
            boolean flag) {
        super(class1, i, obj, obj1, flag);
        class1 = typebindings;
        if (typebindings == null)
            class1 = NO_BINDINGS;
        _bindings = class1;
        _superClass = javatype;
        _superInterfaces = ajavatype;
    }

    protected static JavaType _bogusSuperClass(Class class1) {
        if (class1.getSuperclass() == null)
            class1 = null;
        else
            class1 = TypeFactory.unknownType();
        return class1;
    }

    protected static StringBuilder _classSignature(Class class1, StringBuilder stringbuilder, boolean flag) {
        if (!class1.isPrimitive()) goto _L2; else goto _L1
_L1:
        if (class1 == Boolean.TYPE)
            stringbuilder.append('Z');
        else
        if (class1 == Byte.TYPE)
            stringbuilder.append('B');
        else
        if (class1 == Short.TYPE)
            stringbuilder.append('S');
        else
        if (class1 == Character.TYPE)
            stringbuilder.append('C');
        else
        if (class1 == Integer.TYPE)
            stringbuilder.append('I');
        else
        if (class1 == Long.TYPE)
            stringbuilder.append('J');
        else
        if (class1 == Float.TYPE)
            stringbuilder.append('F');
        else
        if (class1 == Double.TYPE)
            stringbuilder.append('D');
        else
        if (class1 == Void.TYPE)
            stringbuilder.append('V');
        else
            throw new IllegalStateException((new StringBuilder()).append("Unrecognized primitive type: ").append(class1.getName()).toString());
_L4:
        return stringbuilder;
_L2:
        stringbuilder.append('L');
        class1 = class1.getName();
        int j = class1.length();
        for (int i = 0; i < j; i++) {
            char c1 = class1.charAt(i);
            char c = c1;
            if (c1 == '.')
                c = '/';
            stringbuilder.append(c);
        }

        if (flag)
            stringbuilder.append(';');
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected String buildCanonicalName() {
        return _class.getName();
    }

    public volatile ResolvedType containedType(int i) {
        return containedType(i);
    }

    public JavaType containedType(int i) {
        return _bindings.getBoundType(i);
    }

    public int containedTypeCount() {
        return _bindings.size();
    }

    public String containedTypeName(int i) {
        return _bindings.getBoundName(i);
    }

    public final JavaType findSuperType(Class class1) {
        if (class1 != _class) goto _L2; else goto _L1
_L1:
        class1 = this;
_L4:
        return class1;
_L2:
        if (class1.isInterface() && _superInterfaces != null) {
            int j = _superInterfaces.length;
            int i = 0;
            do {
                if (i >= j)
                    break;
                JavaType javatype = _superInterfaces[i].findSuperType(class1);
                if (javatype != null) {
                    class1 = javatype;
                    continue; /* Loop/switch isn't completed */
                }
                i++;
            } while (true);
        }
        if (_superClass != null) {
            JavaType javatype1 = _superClass.findSuperType(class1);
            class1 = javatype1;
            if (javatype1 != null)
                continue; /* Loop/switch isn't completed */
        }
        class1 = null;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public JavaType[] findTypeParameters(Class class1) {
        class1 = findSuperType(class1);
        if (class1 == null)
            class1 = NO_TYPES;
        else
            class1 = class1.getBindings().typeParameterArray();
        return class1;
    }

    public TypeBindings getBindings() {
        return _bindings;
    }

    public abstract StringBuilder getErasedSignature(StringBuilder stringbuilder);

    public abstract StringBuilder getGenericSignature(StringBuilder stringbuilder);

    public List getInterfaces() {
        if (_superInterfaces != null) goto _L2; else goto _L1
_L1:
        List list = Collections.emptyList();
_L4:
        return list;
_L2:
        switch (_superInterfaces.length) {
        default:
            list = Arrays.asList(_superInterfaces);
            break;

        case 0: // '\0'
            list = Collections.emptyList();
            break;

        case 1: // '\001'
            list = Collections.singletonList(_superInterfaces[0]);
            break;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public JavaType getSuperClass() {
        return _superClass;
    }

    public Object getTypeHandler() {
        return _typeHandler;
    }

    public Object getValueHandler() {
        return _valueHandler;
    }

    public void serialize(JsonGenerator jsongenerator, SerializerProvider serializerprovider) {
        jsongenerator.writeString(toCanonical());
    }

    public void serializeWithType(JsonGenerator jsongenerator, SerializerProvider serializerprovider, TypeSerializer typeserializer) {
        typeserializer.writeTypePrefixForScalar(this, jsongenerator);
        serialize(jsongenerator, serializerprovider);
        typeserializer.writeTypeSuffixForScalar(this, jsongenerator);
    }

    public String toCanonical() {
        String s1 = _canonicalName;
        String s = s1;
        if (s1 == null)
            s = buildCanonicalName();
        return s;
    }

}
