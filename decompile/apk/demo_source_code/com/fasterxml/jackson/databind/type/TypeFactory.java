// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.type;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.util.*;
import java.io.Serializable;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

// Referenced classes of package com.fasterxml.jackson.databind.type:
//            TypeBindings, SimpleType, TypeParser, CollectionType, 
//            MapType, ReferenceType, TypeModifier, ArrayType, 
//            ClassStack, ResolvedRecursiveType, CollectionLikeType, MapLikeType

public final class TypeFactory
    implements Serializable {

    private static final Class CLS_BOOL;
    private static final Class CLS_CLASS;
    private static final Class CLS_COMPARABLE;
    private static final Class CLS_ENUM;
    private static final Class CLS_INT;
    private static final Class CLS_LONG;
    private static final Class CLS_OBJECT;
    private static final Class CLS_STRING;
    protected static final SimpleType CORE_TYPE_BOOL;
    protected static final SimpleType CORE_TYPE_CLASS;
    protected static final SimpleType CORE_TYPE_COMPARABLE;
    protected static final SimpleType CORE_TYPE_ENUM;
    protected static final SimpleType CORE_TYPE_INT;
    protected static final SimpleType CORE_TYPE_LONG;
    protected static final SimpleType CORE_TYPE_OBJECT;
    protected static final SimpleType CORE_TYPE_STRING;
    protected static final TypeBindings EMPTY_BINDINGS = TypeBindings.emptyBindings();
    private static final JavaType NO_TYPES[] = new JavaType[0];
    protected static final TypeFactory instance = new TypeFactory();
    private static final long serialVersionUID = 1L;
    protected final ClassLoader _classLoader;
    protected final TypeModifier _modifiers[];
    protected final TypeParser _parser;
    protected final LRUMap _typeCache;

    private TypeFactory() {
        _typeCache = new LRUMap(16, 100);
        _parser = new TypeParser(this);
        _modifiers = null;
        _classLoader = null;
    }

    protected TypeFactory(TypeParser typeparser, TypeModifier atypemodifier[]) {
        this(typeparser, atypemodifier, null);
    }

    protected TypeFactory(TypeParser typeparser, TypeModifier atypemodifier[], ClassLoader classloader) {
        _typeCache = new LRUMap(16, 100);
        _parser = typeparser.withFactory(this);
        _modifiers = atypemodifier;
        _classLoader = classloader;
    }

    private TypeBindings _bindingsForSubtype(JavaType javatype, int i, Class class1) {
        boolean flag = false;
        int j = javatype.containedTypeCount();
        if (j == i) {
            if (i == 1)
                javatype = TypeBindings.create(class1, javatype.containedType(0));
            else
            if (i == 2) {
                javatype = TypeBindings.create(class1, javatype.containedType(0), javatype.containedType(1));
            } else {
                ArrayList arraylist = new ArrayList(j);
                for (i = ((flag) ? 1 : 0); i < j; i++)
                    arraylist.add(javatype.containedType(i));

                javatype = TypeBindings.create(class1, arraylist);
            }
        } else {
            javatype = TypeBindings.emptyBindings();
        }
        return javatype;
    }

    private JavaType _collectionType(Class class1, TypeBindings typebindings, JavaType javatype, JavaType ajavatype[]) {
        Object obj = typebindings.getTypeParameters();
        if (((List) (obj)).isEmpty())
            obj = _unknownType();
        else
        if (((List) (obj)).size() == 1)
            obj = (JavaType)((List) (obj)).get(0);
        else
            throw new IllegalArgumentException((new StringBuilder()).append("Strange Collection type ").append(class1.getName()).append(": can not determine type parameters").toString());
        return CollectionType.construct(class1, typebindings, javatype, ajavatype, ((JavaType) (obj)));
    }

    private JavaType _mapType(Class class1, TypeBindings typebindings, JavaType javatype, JavaType ajavatype[]) {
        if (class1 != java/util/Properties) goto _L2; else goto _L1
_L1:
        Object obj;
        Object obj1;
        obj1 = CORE_TYPE_STRING;
        obj = obj1;
_L4:
        return MapType.construct(class1, typebindings, javatype, ajavatype, ((JavaType) (obj)), ((JavaType) (obj1)));
_L2:
        obj1 = typebindings.getTypeParameters();
        switch (((List) (obj1)).size()) {
        case 1: // '\001'
        default:
            throw new IllegalArgumentException((new StringBuilder()).append("Strange Map type ").append(class1.getName()).append(": can not determine type parameters").toString());

        case 0: // '\0'
            obj1 = _unknownType();
            obj = obj1;
            break;

        case 2: // '\002'
            obj = (JavaType)((List) (obj1)).get(0);
            obj1 = (JavaType)((List) (obj1)).get(1);
            break;
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    private JavaType _referenceType(Class class1, TypeBindings typebindings, JavaType javatype, JavaType ajavatype[]) {
        Object obj = typebindings.getTypeParameters();
        if (((List) (obj)).isEmpty())
            obj = _unknownType();
        else
        if (((List) (obj)).size() == 1)
            obj = (JavaType)((List) (obj)).get(0);
        else
            throw new IllegalArgumentException((new StringBuilder()).append("Strange Reference type ").append(class1.getName()).append(": can not determine type parameters").toString());
        return ReferenceType.construct(class1, typebindings, javatype, ajavatype, ((JavaType) (obj)));
    }

    public static TypeFactory defaultInstance() {
        return instance;
    }

    public static Class rawClass(Type type) {
        if (type instanceof Class)
            type = (Class)type;
        else
            type = defaultInstance().constructType(type).getRawClass();
        return type;
    }

    public static JavaType unknownType() {
        return defaultInstance()._unknownType();
    }

    protected JavaType _constructSimple(Class class1, TypeBindings typebindings, JavaType javatype, JavaType ajavatype[]) {
        if (!typebindings.isEmpty()) goto _L2; else goto _L1
_L1:
        JavaType javatype1 = _findWellKnownSimple(class1);
        if (javatype1 == null) goto _L2; else goto _L3
_L3:
        class1 = javatype1;
_L5:
        return class1;
_L2:
        class1 = _newSimpleType(class1, typebindings, javatype, ajavatype);
        if (true) goto _L5; else goto _L4
_L4:
    }

    protected Class _findPrimitive(String s) {
        if ("int".equals(s))
            s = Integer.TYPE;
        else
        if ("long".equals(s))
            s = Long.TYPE;
        else
        if ("float".equals(s))
            s = Float.TYPE;
        else
        if ("double".equals(s))
            s = Double.TYPE;
        else
        if ("boolean".equals(s))
            s = Boolean.TYPE;
        else
        if ("byte".equals(s))
            s = Byte.TYPE;
        else
        if ("char".equals(s))
            s = Character.TYPE;
        else
        if ("short".equals(s))
            s = Short.TYPE;
        else
        if ("void".equals(s))
            s = Void.TYPE;
        else
            s = null;
        return s;
    }

    protected JavaType _findWellKnownSimple(Class class1) {
        if (!class1.isPrimitive()) goto _L2; else goto _L1
_L1:
        if (class1 != CLS_BOOL) goto _L4; else goto _L3
_L3:
        class1 = CORE_TYPE_BOOL;
_L7:
        return class1;
_L4:
        if (class1 == CLS_INT) {
            class1 = CORE_TYPE_INT;
            continue; /* Loop/switch isn't completed */
        }
        if (class1 == CLS_LONG) {
            class1 = CORE_TYPE_LONG;
            continue; /* Loop/switch isn't completed */
        }
          goto _L5
_L2:
        if (class1 == CLS_STRING) {
            class1 = CORE_TYPE_STRING;
            continue; /* Loop/switch isn't completed */
        }
        if (class1 == CLS_OBJECT) {
            class1 = CORE_TYPE_OBJECT;
            continue; /* Loop/switch isn't completed */
        }
_L5:
        class1 = null;
        if (true) goto _L7; else goto _L6
_L6:
    }

    protected JavaType _fromAny(ClassStack classstack, Type type, TypeBindings typebindings) {
        int i;
        int j;
        TypeBindings typebindings1;
        TypeModifier atypemodifier[];
        if (type instanceof Class) {
            classstack = _fromClass(classstack, (Class)type, EMPTY_BINDINGS);
        } else {
label0:
            {
                if (!(type instanceof ParameterizedType))
                    break label0;
                classstack = _fromParamType(classstack, (ParameterizedType)type, typebindings);
            }
        }
_L5:
        typebindings = classstack;
        if (_modifiers == null) goto _L2; else goto _L1
_L1:
        typebindings = classstack.getBindings();
        typebindings1 = typebindings;
        if (typebindings == null)
            typebindings1 = EMPTY_BINDINGS;
        atypemodifier = _modifiers;
        j = atypemodifier.length;
        i = 0;
_L6:
        typebindings = classstack;
        if (i < j) {
            TypeModifier typemodifier = atypemodifier[i];
            typebindings = typemodifier.modifyType(classstack, type, typebindings1, this);
            if (typebindings == null)
                throw new IllegalStateException(String.format("TypeModifier %s (of type %s) return null for type %s", new Object[] {
                    typemodifier, typemodifier.getClass().getName(), classstack
                }));
            break MISSING_BLOCK_LABEL_273;
        }
          goto _L2
        if (!(type instanceof JavaType)) goto _L4; else goto _L3
_L3:
        typebindings = (JavaType)type;
_L2:
        return typebindings;
_L4:
        if (type instanceof GenericArrayType)
            classstack = _fromArrayType(classstack, (GenericArrayType)type, typebindings);
        else
        if (type instanceof TypeVariable)
            classstack = _fromVariable(classstack, (TypeVariable)type, typebindings);
        else
        if (type instanceof WildcardType) {
            classstack = _fromWildcard(classstack, (WildcardType)type, typebindings);
        } else {
            typebindings = (new StringBuilder()).append("Unrecognized Type: ");
            if (type == null)
                classstack = "[null]";
            else
                classstack = type.toString();
            throw new IllegalArgumentException(typebindings.append(classstack).toString());
        }
          goto _L5
        i++;
        classstack = typebindings;
          goto _L6
    }

    protected JavaType _fromArrayType(ClassStack classstack, GenericArrayType genericarraytype, TypeBindings typebindings) {
        return ArrayType.construct(_fromAny(classstack, genericarraytype.getGenericComponentType(), typebindings), typebindings);
    }

    protected JavaType _fromClass(ClassStack classstack, Class class1, TypeBindings typebindings) {
        Object obj;
        JavaType javatype;
        javatype = null;
        obj = _findWellKnownSimple(class1);
        if (obj == null) goto _L2; else goto _L1
_L1:
        return ((JavaType) (obj));
_L2:
        if (typebindings != null && !typebindings.isEmpty()) goto _L4; else goto _L3
_L3:
        Object obj1;
        obj1 = (JavaType)_typeCache.get(class1);
        obj = obj1;
        if (obj1 != null) goto _L1; else goto _L5
_L5:
        Class class2;
        class2 = class1;
        obj = obj1;
_L8:
        if (classstack != null) goto _L7; else goto _L6
_L6:
        obj1 = new ClassStack(class1);
_L9:
        if (class1.isArray()) {
            classstack = ArrayType.construct(_fromAny(((ClassStack) (obj1)), class1.getComponentType(), typebindings), typebindings);
        } else {
            JavaType ajavatype[];
            if (class1.isInterface()) {
                ajavatype = _resolveSuperInterfaces(((ClassStack) (obj1)), class1, typebindings);
            } else {
                javatype = _resolveSuperClass(((ClassStack) (obj1)), class1, typebindings);
                ajavatype = _resolveSuperInterfaces(((ClassStack) (obj1)), class1, typebindings);
            }
            if (class1 == java/util/Properties)
                obj = MapType.construct(class1, typebindings, javatype, ajavatype, CORE_TYPE_STRING, CORE_TYPE_STRING);
            else
            if (javatype != null)
                obj = javatype.refine(class1, typebindings, javatype, ajavatype);
            classstack = ((ClassStack) (obj));
            if (obj == null) {
                obj = _fromWellKnownClass(((ClassStack) (obj1)), class1, typebindings, javatype, ajavatype);
                classstack = ((ClassStack) (obj));
                if (obj == null) {
                    obj = _fromWellKnownInterface(((ClassStack) (obj1)), class1, typebindings, javatype, ajavatype);
                    classstack = ((ClassStack) (obj));
                    if (obj == null)
                        classstack = _newSimpleType(class1, typebindings, javatype, ajavatype);
                }
            }
        }
        ((ClassStack) (obj1)).resolveSelfReferences(classstack);
        obj = classstack;
        if (class2 != null) {
            _typeCache.putIfAbsent(class2, classstack);
            obj = classstack;
        }
          goto _L1
_L4:
        class2 = null;
          goto _L8
_L7:
label0:
        {
            obj1 = classstack.find(class1);
            if (obj1 == null)
                break label0;
            obj = new ResolvedRecursiveType(class1, EMPTY_BINDINGS);
            ((ClassStack) (obj1)).addSelfReference(((ResolvedRecursiveType) (obj)));
        }
          goto _L1
        obj1 = classstack.child(class1);
          goto _L9
    }

    protected JavaType _fromParamType(ClassStack classstack, ParameterizedType parameterizedtype, TypeBindings typebindings) {
        int j;
        Class class1;
        j = 0;
        class1 = (Class)parameterizedtype.getRawType();
        if (class1 != CLS_ENUM) goto _L2; else goto _L1
_L1:
        classstack = CORE_TYPE_ENUM;
_L4:
        return classstack;
_L2:
        int i;
        Type atype[];
        if (class1 == CLS_COMPARABLE) {
            classstack = CORE_TYPE_COMPARABLE;
            continue; /* Loop/switch isn't completed */
        }
        if (class1 == CLS_CLASS) {
            classstack = CORE_TYPE_CLASS;
            continue; /* Loop/switch isn't completed */
        }
        atype = parameterizedtype.getActualTypeArguments();
        if (atype == null)
            i = 0;
        else
            i = atype.length;
        if (i != 0)
            break; /* Loop/switch isn't completed */
        parameterizedtype = EMPTY_BINDINGS;
_L5:
        classstack = _fromClass(classstack, class1, parameterizedtype);
        if (true) goto _L4; else goto _L3
_L3:
        parameterizedtype = new JavaType[i];
        for (; j < i; j++)
            parameterizedtype[j] = _fromAny(classstack, atype[j], typebindings);

        parameterizedtype = TypeBindings.create(class1, parameterizedtype);
          goto _L5
        if (true) goto _L4; else goto _L6
_L6:
    }

    protected JavaType _fromVariable(ClassStack classstack, TypeVariable typevariable, TypeBindings typebindings) {
        String s = typevariable.getName();
        JavaType javatype = typebindings.findBoundType(s);
        if (javatype != null)
            classstack = javatype;
        else
        if (typebindings.hasUnbound(s)) {
            classstack = CORE_TYPE_OBJECT;
        } else {
            typebindings = typebindings.withUnboundVariable(s);
            classstack = _fromAny(classstack, typevariable.getBounds()[0], typebindings);
        }
        return classstack;
    }

    protected JavaType _fromWellKnownClass(ClassStack classstack, Class class1, TypeBindings typebindings, JavaType javatype, JavaType ajavatype[]) {
        if (class1 == java/util/Map)
            classstack = _mapType(class1, typebindings, javatype, ajavatype);
        else
        if (class1 == java/util/Collection)
            classstack = _collectionType(class1, typebindings, javatype, ajavatype);
        else
        if (class1 == java/util/concurrent/atomic/AtomicReference)
            classstack = _referenceType(class1, typebindings, javatype, ajavatype);
        else
            classstack = null;
        return classstack;
    }

    protected JavaType _fromWellKnownInterface(ClassStack classstack, Class class1, TypeBindings typebindings, JavaType javatype, JavaType ajavatype[]) {
        int i;
        int j;
        j = ajavatype.length;
        i = 0;
_L3:
        if (i >= j)
            break MISSING_BLOCK_LABEL_42;
        classstack = ajavatype[i].refine(class1, typebindings, javatype, ajavatype);
        if (classstack == null) goto _L2; else goto _L1
_L1:
        return classstack;
_L2:
        i++;
          goto _L3
        classstack = null;
          goto _L1
    }

    protected JavaType _fromWildcard(ClassStack classstack, WildcardType wildcardtype, TypeBindings typebindings) {
        return _fromAny(classstack, wildcardtype.getUpperBounds()[0], typebindings);
    }

    protected JavaType _newSimpleType(Class class1, TypeBindings typebindings, JavaType javatype, JavaType ajavatype[]) {
        return new SimpleType(class1, typebindings, javatype, ajavatype);
    }

    protected JavaType _resolveSuperClass(ClassStack classstack, Class class1, TypeBindings typebindings) {
        class1 = ClassUtil.getGenericSuperclass(class1);
        if (class1 == null)
            classstack = null;
        else
            classstack = _fromAny(classstack, class1, typebindings);
        return classstack;
    }

    protected JavaType[] _resolveSuperInterfaces(ClassStack classstack, Class class1, TypeBindings typebindings) {
        Type atype[] = ClassUtil.getGenericInterfaces(class1);
        if (atype != null && atype.length != 0) goto _L2; else goto _L1
_L1:
        class1 = NO_TYPES;
_L4:
        return class1;
_L2:
        int j = atype.length;
        JavaType ajavatype[] = new JavaType[j];
        int i = 0;
        do {
            class1 = ajavatype;
            if (i >= j)
                continue;
            ajavatype[i] = _fromAny(classstack, atype[i], typebindings);
            i++;
        } while (true);
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected JavaType _unknownType() {
        return CORE_TYPE_OBJECT;
    }

    protected Class classForName(String s) {
        return Class.forName(s);
    }

    protected Class classForName(String s, boolean flag, ClassLoader classloader) {
        return Class.forName(s, true, classloader);
    }

    public void clearCache() {
        _typeCache.clear();
    }

    public ArrayType constructArrayType(JavaType javatype) {
        return ArrayType.construct(javatype, null);
    }

    public ArrayType constructArrayType(Class class1) {
        return ArrayType.construct(_fromAny(null, class1, null), null);
    }

    public CollectionLikeType constructCollectionLikeType(Class class1, JavaType javatype) {
        class1 = _fromClass(null, class1, TypeBindings.createIfNeeded(class1, javatype));
        if (class1 instanceof CollectionLikeType)
            class1 = (CollectionLikeType)class1;
        else
            class1 = CollectionLikeType.upgradeFrom(class1, javatype);
        return class1;
    }

    public CollectionLikeType constructCollectionLikeType(Class class1, Class class2) {
        return constructCollectionLikeType(class1, _fromClass(null, class2, EMPTY_BINDINGS));
    }

    public CollectionType constructCollectionType(Class class1, JavaType javatype) {
        return (CollectionType)_fromClass(null, class1, TypeBindings.create(class1, javatype));
    }

    public CollectionType constructCollectionType(Class class1, Class class2) {
        return constructCollectionType(class1, _fromClass(null, class2, EMPTY_BINDINGS));
    }

    public JavaType constructFromCanonical(String s) {
        return _parser.parse(s);
    }

    public JavaType constructGeneralizedType(JavaType javatype, Class class1) {
        Class class2 = javatype.getRawClass();
        if (class2 != class1) {
            JavaType javatype1 = javatype.findSuperType(class1);
            if (javatype1 == null)
                if (!class1.isAssignableFrom(class2))
                    throw new IllegalArgumentException(String.format("Class %s not a super-type of %s", new Object[] {
                        class1.getName(), javatype
                    }));
                else
                    throw new IllegalArgumentException(String.format("Internal error: class %s not included as super-type for %s", new Object[] {
                        class1.getName(), javatype
                    }));
            javatype = javatype1;
        }
        return javatype;
    }

    public MapLikeType constructMapLikeType(Class class1, JavaType javatype, JavaType javatype1) {
        class1 = _fromClass(null, class1, TypeBindings.createIfNeeded(class1, new JavaType[] {
            javatype, javatype1
        }));
        if (class1 instanceof MapLikeType)
            class1 = (MapLikeType)class1;
        else
            class1 = MapLikeType.upgradeFrom(class1, javatype, javatype1);
        return class1;
    }

    public MapLikeType constructMapLikeType(Class class1, Class class2, Class class3) {
        return constructMapLikeType(class1, _fromClass(null, class2, EMPTY_BINDINGS), _fromClass(null, class3, EMPTY_BINDINGS));
    }

    public MapType constructMapType(Class class1, JavaType javatype, JavaType javatype1) {
        return (MapType)_fromClass(null, class1, TypeBindings.create(class1, new JavaType[] {
            javatype, javatype1
        }));
    }

    public MapType constructMapType(Class class1, Class class2, Class class3) {
        if (class1 == java/util/Properties) {
            class2 = CORE_TYPE_STRING;
            class3 = class2;
        } else {
            JavaType javatype = _fromClass(null, class2, EMPTY_BINDINGS);
            class2 = _fromClass(null, class3, EMPTY_BINDINGS);
            class3 = javatype;
        }
        return constructMapType(class1, ((JavaType) (class3)), ((JavaType) (class2)));
    }

    public transient JavaType constructParametricType(Class class1, JavaType ajavatype[]) {
        return _fromClass(null, class1, TypeBindings.create(class1, ajavatype));
    }

    public transient JavaType constructParametricType(Class class1, Class aclass[]) {
        int j = aclass.length;
        JavaType ajavatype[] = new JavaType[j];
        for (int i = 0; i < j; i++)
            ajavatype[i] = _fromClass(null, aclass[i], null);

        return constructParametricType(class1, ajavatype);
    }

    public transient JavaType constructParametrizedType(Class class1, Class class2, JavaType ajavatype[]) {
        return constructParametricType(class1, ajavatype);
    }

    public transient JavaType constructParametrizedType(Class class1, Class class2, Class aclass[]) {
        return constructParametricType(class1, aclass);
    }

    public CollectionLikeType constructRawCollectionLikeType(Class class1) {
        return constructCollectionLikeType(class1, unknownType());
    }

    public CollectionType constructRawCollectionType(Class class1) {
        return constructCollectionType(class1, unknownType());
    }

    public MapLikeType constructRawMapLikeType(Class class1) {
        return constructMapLikeType(class1, unknownType(), unknownType());
    }

    public MapType constructRawMapType(Class class1) {
        return constructMapType(class1, unknownType(), unknownType());
    }

    public JavaType constructReferenceType(Class class1, JavaType javatype) {
        return ReferenceType.construct(class1, null, null, null, javatype);
    }

    public JavaType constructSimpleType(Class class1, Class class2, JavaType ajavatype[]) {
        return constructSimpleType(class1, ajavatype);
    }

    public JavaType constructSimpleType(Class class1, JavaType ajavatype[]) {
        return _fromClass(null, class1, TypeBindings.create(class1, ajavatype));
    }

    public JavaType constructSpecializedType(JavaType javatype, Class class1) {
        Class class2 = javatype.getRawClass();
        if (class2 != class1) goto _L2; else goto _L1
_L1:
        JavaType javatype1 = javatype;
_L4:
        return javatype1;
_L2:
        if (class2 != java/lang/Object)
            break; /* Loop/switch isn't completed */
        javatype = _fromClass(null, class1, TypeBindings.emptyBindings());
_L5:
        javatype1 = javatype;
        if (true) goto _L4; else goto _L3
_L3:
        if (!class2.isAssignableFrom(class1))
            throw new IllegalArgumentException(String.format("Class %s not subtype of %s", new Object[] {
                class1.getName(), javatype
            }));
        if (javatype.getBindings().isEmpty()) {
            javatype = _fromClass(null, class1, TypeBindings.emptyBindings());
        } else {
            if (!javatype.isContainerType())
                break; /* Loop/switch isn't completed */
            if (javatype.isMapLikeType()) {
                if (class1 != java/util/HashMap && class1 != java/util/LinkedHashMap && class1 != java/util/EnumMap && class1 != java/util/TreeMap)
                    break; /* Loop/switch isn't completed */
                javatype = _fromClass(null, class1, TypeBindings.create(class1, javatype.getKeyType(), javatype.getContentType()));
            } else {
label0:
                {
                    if (!javatype.isCollectionLikeType())
                        break; /* Loop/switch isn't completed */
                    if (class1 != java/util/ArrayList && class1 != java/util/LinkedList && class1 != java/util/HashSet && class1 != java/util/TreeSet)
                        break label0;
                    javatype = _fromClass(null, class1, TypeBindings.create(class1, javatype.getContentType()));
                }
            }
        }
          goto _L5
        javatype1 = javatype;
        if (class2 == java/util/EnumSet) goto _L4; else goto _L6
_L6:
        int i = class1.getTypeParameters().length;
        if (i == 0) {
            javatype = _fromClass(null, class1, TypeBindings.emptyBindings());
        } else {
            TypeBindings typebindings = _bindingsForSubtype(javatype, i, class1);
            JavaType javatype2;
            if (javatype.isInterface())
                javatype2 = javatype.refine(class1, typebindings, null, new JavaType[] {
                    javatype
                });
            else
                javatype2 = javatype.refine(class1, typebindings, javatype, NO_TYPES);
            javatype = javatype2;
            if (javatype2 == null)
                javatype = _fromClass(null, class1, typebindings);
        }
          goto _L5
    }

    public JavaType constructType(TypeReference typereference) {
        return _fromAny(null, typereference.getType(), EMPTY_BINDINGS);
    }

    public JavaType constructType(Type type) {
        return _fromAny(null, type, EMPTY_BINDINGS);
    }

    public JavaType constructType(Type type, JavaType javatype) {
        if (javatype == null)
            javatype = TypeBindings.emptyBindings();
        else
            javatype = javatype.getBindings();
        return _fromAny(null, type, javatype);
    }

    public JavaType constructType(Type type, TypeBindings typebindings) {
        return _fromAny(null, type, typebindings);
    }

    public JavaType constructType(Type type, Class class1) {
        if (class1 == null)
            class1 = TypeBindings.emptyBindings();
        else
            class1 = constructType(((Type) (class1))).getBindings();
        return _fromAny(null, type, class1);
    }

    public Class findClass(String s) {
        if (s.indexOf('.') >= 0) goto _L2; else goto _L1
_L1:
        Object obj = _findPrimitive(s);
        if (obj == null) goto _L2; else goto _L3
_L3:
        s = ((String) (obj));
_L5:
        return s;
_L2:
        ClassLoader classloader;
        obj = null;
        ClassLoader classloader1 = getClassLoader();
        classloader = classloader1;
        if (classloader1 == null)
            classloader = Thread.currentThread().getContextClassLoader();
        if (classloader == null)
            break MISSING_BLOCK_LABEL_69;
        obj = classForName(s, true, classloader);
        s = ((String) (obj));
        continue; /* Loop/switch isn't completed */
        obj;
        obj = ClassUtil.getRootCause(((Throwable) (obj)));
        try {
            s = classForName(s);
        }
        catch (Exception exception) {
            s = ((String) (obj));
            if (obj == null)
                s = ClassUtil.getRootCause(exception);
            if (s instanceof RuntimeException)
                throw (RuntimeException)s;
            else
                throw new ClassNotFoundException(s.getMessage(), s);
        }
        if (true) goto _L5; else goto _L4
_L4:
    }

    public JavaType[] findTypeParameters(JavaType javatype, Class class1) {
        javatype = javatype.findSuperType(class1);
        if (javatype == null)
            javatype = NO_TYPES;
        else
            javatype = javatype.getBindings().typeParameterArray();
        return javatype;
    }

    public JavaType[] findTypeParameters(Class class1, Class class2) {
        return findTypeParameters(constructType(class1), class2);
    }

    public JavaType[] findTypeParameters(Class class1, Class class2, TypeBindings typebindings) {
        return findTypeParameters(constructType(class1, typebindings), class2);
    }

    public ClassLoader getClassLoader() {
        return _classLoader;
    }

    public JavaType moreSpecificType(JavaType javatype, JavaType javatype1) {
        if (javatype != null) goto _L2; else goto _L1
_L1:
        JavaType javatype2 = javatype1;
_L4:
        return javatype2;
_L2:
        javatype2 = javatype;
        if (javatype1 != null) {
            Class class1 = javatype.getRawClass();
            Class class2 = javatype1.getRawClass();
            javatype2 = javatype;
            if (class1 != class2) {
                javatype2 = javatype;
                if (class1.isAssignableFrom(class2))
                    javatype2 = javatype1;
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    public JavaType uncheckedSimpleType(Class class1) {
        return _constructSimple(class1, EMPTY_BINDINGS, null, null);
    }

    public TypeFactory withClassLoader(ClassLoader classloader) {
        return new TypeFactory(_parser, _modifiers, classloader);
    }

    public TypeFactory withModifier(TypeModifier typemodifier) {
        if (typemodifier == null)
            typemodifier = new TypeFactory(_parser, _modifiers, _classLoader);
        else
        if (_modifiers == null) {
            TypeParser typeparser = _parser;
            ClassLoader classloader = _classLoader;
            typemodifier = new TypeFactory(typeparser, new TypeModifier[] {
                typemodifier
            }, classloader);
        } else {
            typemodifier = new TypeFactory(_parser, (TypeModifier[])ArrayBuilders.insertInListNoDup(_modifiers, typemodifier), _classLoader);
        }
        return typemodifier;
    }

    static  {
        CLS_STRING = java/lang/String;
        CLS_OBJECT = java/lang/Object;
        CLS_COMPARABLE = java/lang/Comparable;
        CLS_CLASS = java/lang/Class;
        CLS_ENUM = java/lang/Enum;
        CLS_BOOL = Boolean.TYPE;
        CLS_INT = Integer.TYPE;
        CLS_LONG = Long.TYPE;
        CORE_TYPE_BOOL = new SimpleType(CLS_BOOL);
        CORE_TYPE_INT = new SimpleType(CLS_INT);
        CORE_TYPE_LONG = new SimpleType(CLS_LONG);
        CORE_TYPE_STRING = new SimpleType(CLS_STRING);
        CORE_TYPE_OBJECT = new SimpleType(CLS_OBJECT);
        CORE_TYPE_COMPARABLE = new SimpleType(CLS_COMPARABLE);
        CORE_TYPE_ENUM = new SimpleType(CLS_ENUM);
        CORE_TYPE_CLASS = new SimpleType(CLS_CLASS);
    }
}
