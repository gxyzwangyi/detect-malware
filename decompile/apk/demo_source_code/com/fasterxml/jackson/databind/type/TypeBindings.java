// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.type;

import com.fasterxml.jackson.databind.JavaType;
import java.io.Serializable;
import java.lang.reflect.TypeVariable;
import java.util.*;

// Referenced classes of package com.fasterxml.jackson.databind.type:
//            ResolvedRecursiveType

public class TypeBindings
    implements Serializable {
    static final class AsKey {

        private final int _hash;
        private final JavaType _params[];
        private final Class _raw;

        public boolean equals(Object obj) {
            boolean flag1 = true;
            if (obj != this) goto _L2; else goto _L1
_L1:
            boolean flag = flag1;
_L4:
            return flag;
_L2:
            if (obj == null) {
                flag = false;
                continue; /* Loop/switch isn't completed */
            }
            if (obj.getClass() != getClass()) {
                flag = false;
                continue; /* Loop/switch isn't completed */
            }
            obj = (AsKey)obj;
            if (_hash == ((AsKey) (obj))._hash && _raw == ((AsKey) (obj))._raw) {
                obj = ((AsKey) (obj))._params;
                int j = _params.length;
                if (j == obj.length) {
                    int i = 0;
                    do {
                        flag = flag1;
                        if (i >= j)
                            continue; /* Loop/switch isn't completed */
                        if (!_params[i].equals(obj[i])) {
                            flag = false;
                            continue; /* Loop/switch isn't completed */
                        }
                        i++;
                    } while (true);
                }
            }
            flag = false;
            if (true) goto _L4; else goto _L3
_L3:
        }

        public int hashCode() {
            return _hash;
        }

        public String toString() {
            return (new StringBuilder()).append(_raw.getName()).append("<>").toString();
        }

        public AsKey(Class class1, JavaType ajavatype[], int i) {
            _raw = class1;
            _params = ajavatype;
            _hash = i;
        }
    }

    static class TypeParamStash {

        private static final TypeVariable VARS_ABSTRACT_LIST[] = java/util/AbstractList.getTypeParameters();
        private static final TypeVariable VARS_ARRAY_LIST[] = java/util/ArrayList.getTypeParameters();
        private static final TypeVariable VARS_COLLECTION[] = java/util/Collection.getTypeParameters();
        private static final TypeVariable VARS_HASH_MAP[] = java/util/HashMap.getTypeParameters();
        private static final TypeVariable VARS_ITERABLE[] = java/lang/Iterable.getTypeParameters();
        private static final TypeVariable VARS_LINKED_HASH_MAP[] = java/util/LinkedHashMap.getTypeParameters();
        private static final TypeVariable VARS_LIST[] = java/util/List.getTypeParameters();
        private static final TypeVariable VARS_MAP[] = java/util/Map.getTypeParameters();

        public static TypeVariable[] paramsFor1(Class class1) {
            if (class1 == java/util/Collection)
                class1 = VARS_COLLECTION;
            else
            if (class1 == java/util/List)
                class1 = VARS_LIST;
            else
            if (class1 == java/util/ArrayList)
                class1 = VARS_ARRAY_LIST;
            else
            if (class1 == java/util/AbstractList)
                class1 = VARS_ABSTRACT_LIST;
            else
            if (class1 == java/lang/Iterable)
                class1 = VARS_ITERABLE;
            else
                class1 = class1.getTypeParameters();
            return class1;
        }

        public static TypeVariable[] paramsFor2(Class class1) {
            if (class1 == java/util/Map)
                class1 = VARS_MAP;
            else
            if (class1 == java/util/HashMap)
                class1 = VARS_HASH_MAP;
            else
            if (class1 == java/util/LinkedHashMap)
                class1 = VARS_LINKED_HASH_MAP;
            else
                class1 = class1.getTypeParameters();
            return class1;
        }


        TypeParamStash() {
        }
    }


    private static final TypeBindings EMPTY;
    private static final String NO_STRINGS[];
    private static final JavaType NO_TYPES[];
    private static final long serialVersionUID = 1L;
    private final int _hashCode;
    private final String _names[];
    private final JavaType _types[];
    private final String _unboundVariables[];

    private TypeBindings(String as[], JavaType ajavatype[], String as1[]) {
        String as2[] = as;
        if (as == null)
            as2 = NO_STRINGS;
        _names = as2;
        as = ajavatype;
        if (ajavatype == null)
            as = NO_TYPES;
        _types = as;
        if (_names.length != _types.length)
            throw new IllegalArgumentException((new StringBuilder()).append("Mismatching names (").append(_names.length).append("), types (").append(_types.length).append(")").toString());
        int j = 1;
        int i = 0;
        for (int k = _types.length; i < k; i++)
            j += _types[i].hashCode();

        _unboundVariables = as1;
        _hashCode = j;
    }

    public static TypeBindings create(Class class1, JavaType javatype) {
        TypeVariable atypevariable[] = TypeParamStash.paramsFor1(class1);
        int i;
        if (atypevariable == null)
            i = 0;
        else
            i = atypevariable.length;
        if (i != 1)
            throw new IllegalArgumentException((new StringBuilder()).append("Can not create TypeBindings for class ").append(class1.getName()).append(" with 1 type parameter: class expects ").append(i).toString());
        else
            return new TypeBindings(new String[] {
                atypevariable[0].getName()
            }, new JavaType[] {
                javatype
            }, null);
    }

    public static TypeBindings create(Class class1, JavaType javatype, JavaType javatype1) {
        TypeVariable atypevariable[] = TypeParamStash.paramsFor2(class1);
        int i;
        if (atypevariable == null)
            i = 0;
        else
            i = atypevariable.length;
        if (i != 2)
            throw new IllegalArgumentException((new StringBuilder()).append("Can not create TypeBindings for class ").append(class1.getName()).append(" with 2 type parameters: class expects ").append(i).toString());
        else
            return new TypeBindings(new String[] {
                atypevariable[0].getName(), atypevariable[1].getName()
            }, new JavaType[] {
                javatype, javatype1
            }, null);
    }

    public static TypeBindings create(Class class1, List list) {
        if (list == null || list.isEmpty())
            list = NO_TYPES;
        else
            list = (JavaType[])list.toArray(new JavaType[list.size()]);
        return create(class1, ((JavaType []) (list)));
    }

    public static TypeBindings create(Class class1, JavaType ajavatype[]) {
        int i;
        JavaType ajavatype1[];
        TypeVariable atypevariable[];
label0:
        {
            i = 0;
            if (ajavatype == null) {
                ajavatype1 = NO_TYPES;
                break label0;
            }
        }
        ajavatype.length;
        JVM INSTR tableswitch 1 2: default 140
    //                   1 146
    //                   2 156;
           goto _L1 _L2 _L3
_L2:
        class1 = create(class1, ajavatype[0]);
_L4:
        return class1;
_L3:
        class1 = create(class1, ajavatype[0], ajavatype[1]);
          goto _L4
_L1:
        ajavatype1 = ajavatype;
        atypevariable = class1.getTypeParameters();
        if (atypevariable == null || atypevariable.length == 0) {
            ajavatype = NO_STRINGS;
            break MISSING_BLOCK_LABEL_32;
        }
        j = atypevariable.length;
        as = new String[j];
_L7:
        ajavatype = as;
        if (i >= j) goto _L6; else goto _L5
_L5:
        as[i] = atypevariable[i].getName();
        i++;
          goto _L7
_L6:
        if (ajavatype.length != ajavatype1.length) {
            stringbuilder = (new StringBuilder()).append("Can not create TypeBindings for class ").append(class1.getName()).append(" with ").append(ajavatype1.length).append(" type parameter");
            int j;
            String as[];
            if (ajavatype1.length == 1)
                class1 = "";
            else
                class1 = "s";
            throw new IllegalArgumentException(stringbuilder.append(class1).append(": class expects ").append(ajavatype.length).toString());
        }
        class1 = new TypeBindings(ajavatype, ajavatype1, null);
          goto _L4
    }

    public static TypeBindings createIfNeeded(Class class1, JavaType javatype) {
        TypeVariable atypevariable[] = class1.getTypeParameters();
        int i;
        if (atypevariable == null)
            i = 0;
        else
            i = atypevariable.length;
        if (i == 0) {
            class1 = EMPTY;
        } else {
            if (i != 1)
                throw new IllegalArgumentException((new StringBuilder()).append("Can not create TypeBindings for class ").append(class1.getName()).append(" with 1 type parameter: class expects ").append(i).toString());
            class1 = new TypeBindings(new String[] {
                atypevariable[0].getName()
            }, new JavaType[] {
                javatype
            }, null);
        }
        return class1;
    }

    public static TypeBindings createIfNeeded(Class class1, JavaType ajavatype[]) {
        TypeVariable atypevariable[] = class1.getTypeParameters();
        if (atypevariable == null || atypevariable.length == 0) {
            class1 = EMPTY;
        } else {
            JavaType ajavatype1[] = ajavatype;
            if (ajavatype == null)
                ajavatype1 = NO_TYPES;
            int j = atypevariable.length;
            ajavatype = new String[j];
            for (int i = 0; i < j; i++)
                ajavatype[i] = atypevariable[i].getName();

            if (ajavatype.length != ajavatype1.length) {
                StringBuilder stringbuilder = (new StringBuilder()).append("Can not create TypeBindings for class ").append(class1.getName()).append(" with ").append(ajavatype1.length).append(" type parameter");
                if (ajavatype1.length == 1)
                    class1 = "";
                else
                    class1 = "s";
                throw new IllegalArgumentException(stringbuilder.append(class1).append(": class expects ").append(ajavatype.length).toString());
            }
            class1 = new TypeBindings(ajavatype, ajavatype1, null);
        }
        return class1;
    }

    public static TypeBindings emptyBindings() {
        return EMPTY;
    }

    public Object asKey(Class class1) {
        return new AsKey(class1, _types, _hashCode);
    }

    public boolean equals(Object obj) {
        boolean flag1 = true;
        if (obj != this) goto _L2; else goto _L1
_L1:
        boolean flag = flag1;
_L4:
        return flag;
_L2:
        int i;
        int j;
        if (obj == null || obj.getClass() != getClass()) {
            flag = false;
            continue; /* Loop/switch isn't completed */
        }
        obj = (TypeBindings)obj;
        j = _types.length;
        if (j != ((TypeBindings) (obj)).size()) {
            flag = false;
            continue; /* Loop/switch isn't completed */
        }
        obj = ((TypeBindings) (obj))._types;
        i = 0;
_L5:
        flag = flag1;
        if (i < j) {
label0:
            {
                if (obj[i].equals(_types[i]))
                    break label0;
                flag = false;
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
        i++;
          goto _L5
        if (true) goto _L4; else goto _L6
_L6:
    }

    public JavaType findBoundType(String s) {
        int i;
        int j;
        i = 0;
        j = _names.length;
_L3:
        if (i >= j)
            break MISSING_BLOCK_LABEL_74;
        if (!s.equals(_names[i])) goto _L2; else goto _L1
_L1:
        JavaType javatype1 = _types[i];
        s = javatype1;
        if (javatype1 instanceof ResolvedRecursiveType) {
            JavaType javatype = ((ResolvedRecursiveType)javatype1).getSelfReferencedType();
            s = javatype1;
            if (javatype != null)
                s = javatype;
        }
_L4:
        return s;
_L2:
        i++;
          goto _L3
        s = null;
          goto _L4
    }

    public String getBoundName(int i) {
        String s;
        if (i < 0 || i >= _names.length)
            s = null;
        else
            s = _names[i];
        return s;
    }

    public JavaType getBoundType(int i) {
        JavaType javatype;
        if (i < 0 || i >= _types.length)
            javatype = null;
        else
            javatype = _types[i];
        return javatype;
    }

    public List getTypeParameters() {
        List list;
        if (_types.length == 0)
            list = Collections.emptyList();
        else
            list = Arrays.asList(_types);
        return list;
    }

    public boolean hasUnbound(String s) {
        if (_unboundVariables == null) goto _L2; else goto _L1
_L1:
        int i = _unboundVariables.length;
_L5:
        int j = i - 1;
        if (j < 0) goto _L2; else goto _L3
_L3:
        i = j;
        if (!s.equals(_unboundVariables[j])) goto _L5; else goto _L4
_L4:
        boolean flag = true;
_L7:
        return flag;
_L2:
        flag = false;
        if (true) goto _L7; else goto _L6
_L6:
    }

    public int hashCode() {
        return _hashCode;
    }

    public boolean isEmpty() {
        boolean flag;
        if (_types.length == 0)
            flag = true;
        else
            flag = false;
        return flag;
    }

    protected Object readResolve() {
        TypeBindings typebindings;
label0:
        {
            if (_names != null) {
                typebindings = this;
                if (_names.length != 0)
                    break label0;
            }
            typebindings = EMPTY;
        }
        return typebindings;
    }

    public int size() {
        return _types.length;
    }

    public String toString() {
        Object obj;
        if (_types.length == 0) {
            obj = "<>";
        } else {
            obj = new StringBuilder();
            ((StringBuilder) (obj)).append('<');
            int i = 0;
            for (int j = _types.length; i < j; i++) {
                if (i > 0)
                    ((StringBuilder) (obj)).append(',');
                ((StringBuilder) (obj)).append(_types[i].getGenericSignature());
            }

            ((StringBuilder) (obj)).append('>');
            obj = ((StringBuilder) (obj)).toString();
        }
        return ((String) (obj));
    }

    protected JavaType[] typeParameterArray() {
        return _types;
    }

    public TypeBindings withUnboundVariable(String s) {
        int i;
        String as[];
        if (_unboundVariables == null)
            i = 0;
        else
            i = _unboundVariables.length;
        if (i == 0)
            as = new String[1];
        else
            as = (String[])Arrays.copyOf(_unboundVariables, i + 1);
        as[i] = s;
        return new TypeBindings(_names, _types, as);
    }

    static  {
        NO_STRINGS = new String[0];
        NO_TYPES = new JavaType[0];
        EMPTY = new TypeBindings(NO_STRINGS, NO_TYPES, null);
    }
}
