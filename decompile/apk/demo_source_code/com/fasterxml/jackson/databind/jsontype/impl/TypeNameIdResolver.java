// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.jsontype.impl;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import com.fasterxml.jackson.databind.jsontype.NamedType;
import com.fasterxml.jackson.databind.type.TypeFactory;
import java.util.*;

// Referenced classes of package com.fasterxml.jackson.databind.jsontype.impl:
//            TypeIdResolverBase

public class TypeNameIdResolver extends TypeIdResolverBase {

    protected final MapperConfig _config;
    protected final Map _idToType;
    protected final Map _typeToId;

    protected TypeNameIdResolver(MapperConfig mapperconfig, JavaType javatype, Map map, Map map1) {
        super(javatype, mapperconfig.getTypeFactory());
        _config = mapperconfig;
        _typeToId = map;
        _idToType = map1;
    }

    protected static String _defaultTypeId(Class class1) {
        class1 = class1.getName();
        int i = class1.lastIndexOf('.');
        if (i >= 0)
            class1 = class1.substring(i + 1);
        return class1;
    }

    public static TypeNameIdResolver construct(MapperConfig mapperconfig, JavaType javatype, Collection collection, boolean flag, boolean flag1) {
        if (flag == flag1)
            throw new IllegalArgumentException();
        HashMap hashmap;
        Object obj;
        if (flag)
            hashmap = new HashMap();
        else
            hashmap = null;
        if (flag1) {
            hashmap = new HashMap();
            obj = new TreeMap();
        } else {
            Object obj1 = null;
            obj = hashmap;
            hashmap = obj1;
        }
        if (collection != null) {
            Iterator iterator = collection.iterator();
            do {
                if (!iterator.hasNext())
                    break;
                collection = (NamedType)iterator.next();
                Class class1 = collection.getType();
                if (collection.hasName())
                    collection = collection.getName();
                else
                    collection = _defaultTypeId(class1);
                if (flag)
                    ((Map) (obj)).put(class1.getName(), collection);
                if (flag1) {
                    JavaType javatype1 = (JavaType)hashmap.get(collection);
                    if (javatype1 == null || !class1.isAssignableFrom(javatype1.getRawClass()))
                        hashmap.put(collection, mapperconfig.constructType(class1));
                }
            } while (true);
        }
        return new TypeNameIdResolver(mapperconfig, javatype, ((Map) (obj)), hashmap);
    }

    protected JavaType _typeFromId(String s) {
        return (JavaType)_idToType.get(s);
    }

    public String getDescForKnownTypeIds() {
        return (new TreeSet(_idToType.keySet())).toString();
    }

    public com.fasterxml.jackson.annotation.JsonTypeInfo.Id getMechanism() {
        return com.fasterxml.jackson.annotation.JsonTypeInfo.Id.NAME;
    }

    protected String idFromClass(Class class1) {
        if (class1 != null) goto _L2; else goto _L1
_L1:
        class1 = null;
_L4:
        return class1;
_L2:
        String s;
        Class class2;
        class2 = _typeFactory.constructType(class1).getRawClass();
        s = class2.getName();
        Map map = _typeToId;
        map;
        JVM INSTR monitorenter ;
        Object obj = (String)_typeToId.get(s);
        class1 = ((Class) (obj));
        if (obj != null)
            break MISSING_BLOCK_LABEL_120;
        class1 = ((Class) (obj));
        if (_config.isAnnotationProcessingEnabled()) {
            class1 = _config.introspectClassAnnotations(class2);
            class1 = _config.getAnnotationIntrospector().findTypeName(class1.getClassInfo());
        }
        obj = class1;
        if (class1 != null)
            break MISSING_BLOCK_LABEL_105;
        obj = _defaultTypeId(class2);
        _typeToId.put(s, obj);
        class1 = ((Class) (obj));
        map;
        JVM INSTR monitorexit ;
        if (true) goto _L4; else goto _L3
_L3:
        class1;
        map;
        JVM INSTR monitorexit ;
        throw class1;
    }

    public String idFromValue(Object obj) {
        return idFromClass(obj.getClass());
    }

    public String idFromValueAndType(Object obj, Class class1) {
        if (obj == null)
            obj = idFromClass(class1);
        else
            obj = idFromValue(obj);
        return ((String) (obj));
    }

    public String toString() {
        StringBuilder stringbuilder = new StringBuilder();
        stringbuilder.append('[').append(getClass().getName());
        stringbuilder.append("; id-to-type=").append(_idToType);
        stringbuilder.append(']');
        return stringbuilder.toString();
    }

    public JavaType typeFromId(DatabindContext databindcontext, String s) {
        return _typeFromId(s);
    }

    public JavaType typeFromId(String s) {
        return _typeFromId(s);
    }
}
