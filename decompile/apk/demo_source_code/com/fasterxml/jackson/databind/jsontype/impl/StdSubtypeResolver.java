// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.fasterxml.jackson.databind.jsontype.impl;

import com.fasterxml.jackson.databind.AnnotationIntrospector;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.cfg.MapperConfig;
import com.fasterxml.jackson.databind.introspect.AnnotatedClass;
import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
import com.fasterxml.jackson.databind.jsontype.NamedType;
import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;
import java.io.Serializable;
import java.util.*;

public class StdSubtypeResolver extends SubtypeResolver
    implements Serializable {

    private static final long serialVersionUID = 1L;
    protected LinkedHashSet _registeredSubtypes;

    public StdSubtypeResolver() {
    }

    protected void _collectAndResolve(AnnotatedClass annotatedclass, NamedType namedtype, MapperConfig mapperconfig, AnnotationIntrospector annotationintrospector, HashMap hashmap) {
        NamedType namedtype1;
        namedtype1 = namedtype;
        if (!namedtype.hasName()) {
            String s = annotationintrospector.findTypeName(annotatedclass);
            namedtype1 = namedtype;
            if (s != null)
                namedtype1 = new NamedType(namedtype.getType(), s);
        }
        if (!hashmap.containsKey(namedtype1)) goto _L2; else goto _L1
_L1:
        if (namedtype1.hasName() && !((NamedType)hashmap.get(namedtype1)).hasName())
            hashmap.put(namedtype1, namedtype1);
_L4:
        return;
_L2:
        hashmap.put(namedtype1, namedtype1);
        annotatedclass = annotationintrospector.findSubtypes(annotatedclass);
        if (annotatedclass != null && !annotatedclass.isEmpty()) {
            namedtype = annotatedclass.iterator();
            while (namedtype.hasNext())  {
                annotatedclass = (NamedType)namedtype.next();
                _collectAndResolve(AnnotatedClass.constructWithoutSuperTypes(annotatedclass.getType(), mapperconfig), ((NamedType) (annotatedclass)), mapperconfig, annotationintrospector, hashmap);
            }
        }
        if (true) goto _L4; else goto _L3
_L3:
    }

    protected void _collectAndResolveByTypeId(AnnotatedClass annotatedclass, NamedType namedtype, MapperConfig mapperconfig, Set set, Map map) {
        AnnotationIntrospector annotationintrospector = mapperconfig.getAnnotationIntrospector();
        NamedType namedtype1 = namedtype;
        if (!namedtype.hasName()) {
            String s = annotationintrospector.findTypeName(annotatedclass);
            namedtype1 = namedtype;
            if (s != null)
                namedtype1 = new NamedType(namedtype.getType(), s);
        }
        if (namedtype1.hasName())
            map.put(namedtype1.getName(), namedtype1);
        if (set.add(namedtype1.getType())) {
            annotatedclass = annotationintrospector.findSubtypes(annotatedclass);
            if (annotatedclass != null && !annotatedclass.isEmpty())
                for (annotatedclass = annotatedclass.iterator(); annotatedclass.hasNext(); _collectAndResolveByTypeId(AnnotatedClass.constructWithoutSuperTypes(namedtype.getType(), mapperconfig), namedtype, mapperconfig, set, map))
                    namedtype = (NamedType)annotatedclass.next();

        }
    }

    protected Collection _combineNamedAndUnnamed(Set set, Map map) {
        ArrayList arraylist = new ArrayList(map.values());
        for (map = map.values().iterator(); map.hasNext(); set.remove(((NamedType)map.next()).getType()));
        for (set = set.iterator(); set.hasNext(); arraylist.add(new NamedType((Class)set.next())));
        return arraylist;
    }

    public Collection collectAndResolveSubtypes(AnnotatedClass annotatedclass, MapperConfig mapperconfig, AnnotationIntrospector annotationintrospector) {
        return collectAndResolveSubtypesByClass(mapperconfig, annotatedclass);
    }

    public Collection collectAndResolveSubtypes(AnnotatedMember annotatedmember, MapperConfig mapperconfig, AnnotationIntrospector annotationintrospector, JavaType javatype) {
        return collectAndResolveSubtypesByClass(mapperconfig, annotatedmember, javatype);
    }

    public Collection collectAndResolveSubtypesByClass(MapperConfig mapperconfig, AnnotatedClass annotatedclass) {
        AnnotationIntrospector annotationintrospector = mapperconfig.getAnnotationIntrospector();
        HashMap hashmap = new HashMap();
        if (_registeredSubtypes != null) {
            Class class1 = annotatedclass.getRawType();
            Iterator iterator = _registeredSubtypes.iterator();
            do {
                if (!iterator.hasNext())
                    break;
                NamedType namedtype = (NamedType)iterator.next();
                if (class1.isAssignableFrom(namedtype.getType()))
                    _collectAndResolve(AnnotatedClass.constructWithoutSuperTypes(namedtype.getType(), mapperconfig), namedtype, mapperconfig, annotationintrospector, hashmap);
            } while (true);
        }
        _collectAndResolve(annotatedclass, new NamedType(annotatedclass.getRawType(), null), mapperconfig, annotationintrospector, hashmap);
        return new ArrayList(hashmap.values());
    }

    public Collection collectAndResolveSubtypesByClass(MapperConfig mapperconfig, AnnotatedMember annotatedmember, JavaType javatype) {
        AnnotationIntrospector annotationintrospector = mapperconfig.getAnnotationIntrospector();
        HashMap hashmap;
        if (javatype == null)
            javatype = annotatedmember.getRawType();
        else
            javatype = javatype.getRawClass();
        hashmap = new HashMap();
        if (_registeredSubtypes != null) {
            Iterator iterator = _registeredSubtypes.iterator();
            do {
                if (!iterator.hasNext())
                    break;
                NamedType namedtype = (NamedType)iterator.next();
                if (javatype.isAssignableFrom(namedtype.getType()))
                    _collectAndResolve(AnnotatedClass.constructWithoutSuperTypes(namedtype.getType(), mapperconfig), namedtype, mapperconfig, annotationintrospector, hashmap);
            } while (true);
        }
        annotatedmember = annotationintrospector.findSubtypes(annotatedmember);
        if (annotatedmember != null) {
            for (Iterator iterator1 = annotatedmember.iterator(); iterator1.hasNext(); _collectAndResolve(AnnotatedClass.constructWithoutSuperTypes(annotatedmember.getType(), mapperconfig), annotatedmember, mapperconfig, annotationintrospector, hashmap))
                annotatedmember = (NamedType)iterator1.next();

        }
        annotatedmember = new NamedType(javatype, null);
        _collectAndResolve(AnnotatedClass.constructWithoutSuperTypes(javatype, mapperconfig), annotatedmember, mapperconfig, annotationintrospector, hashmap);
        return new ArrayList(hashmap.values());
    }

    public Collection collectAndResolveSubtypesByTypeId(MapperConfig mapperconfig, AnnotatedClass annotatedclass) {
        HashSet hashset = new HashSet();
        LinkedHashMap linkedhashmap = new LinkedHashMap();
        _collectAndResolveByTypeId(annotatedclass, new NamedType(annotatedclass.getRawType(), null), mapperconfig, hashset, linkedhashmap);
        if (_registeredSubtypes != null) {
            Class class1 = annotatedclass.getRawType();
            Iterator iterator = _registeredSubtypes.iterator();
            do {
                if (!iterator.hasNext())
                    break;
                annotatedclass = (NamedType)iterator.next();
                if (class1.isAssignableFrom(annotatedclass.getType()))
                    _collectAndResolveByTypeId(AnnotatedClass.constructWithoutSuperTypes(annotatedclass.getType(), mapperconfig), annotatedclass, mapperconfig, hashset, linkedhashmap);
            } while (true);
        }
        return _combineNamedAndUnnamed(hashset, linkedhashmap);
    }

    public Collection collectAndResolveSubtypesByTypeId(MapperConfig mapperconfig, AnnotatedMember annotatedmember, JavaType javatype) {
        AnnotationIntrospector annotationintrospector = mapperconfig.getAnnotationIntrospector();
        LinkedHashMap linkedhashmap;
        HashSet hashset;
        NamedType namedtype1;
        if (javatype == null)
            javatype = annotatedmember.getRawType();
        else
            javatype = javatype.getRawClass();
        hashset = new HashSet();
        linkedhashmap = new LinkedHashMap();
        namedtype1 = new NamedType(javatype, null);
        _collectAndResolveByTypeId(AnnotatedClass.constructWithoutSuperTypes(javatype, mapperconfig), namedtype1, mapperconfig, hashset, linkedhashmap);
        annotatedmember = annotationintrospector.findSubtypes(annotatedmember);
        if (annotatedmember != null) {
            NamedType namedtype;
            for (annotatedmember = annotatedmember.iterator(); annotatedmember.hasNext(); _collectAndResolveByTypeId(AnnotatedClass.constructWithoutSuperTypes(namedtype.getType(), mapperconfig), namedtype, mapperconfig, hashset, linkedhashmap))
                namedtype = (NamedType)annotatedmember.next();

        }
        if (_registeredSubtypes != null) {
            Iterator iterator = _registeredSubtypes.iterator();
            do {
                if (!iterator.hasNext())
                    break;
                annotatedmember = (NamedType)iterator.next();
                if (javatype.isAssignableFrom(annotatedmember.getType()))
                    _collectAndResolveByTypeId(AnnotatedClass.constructWithoutSuperTypes(annotatedmember.getType(), mapperconfig), annotatedmember, mapperconfig, hashset, linkedhashmap);
            } while (true);
        }
        return _combineNamedAndUnnamed(hashset, linkedhashmap);
    }

    public transient void registerSubtypes(NamedType anamedtype[]) {
        if (_registeredSubtypes == null)
            _registeredSubtypes = new LinkedHashSet();
        int j = anamedtype.length;
        for (int i = 0; i < j; i++) {
            NamedType namedtype = anamedtype[i];
            _registeredSubtypes.add(namedtype);
        }

    }

    public transient void registerSubtypes(Class aclass[]) {
        NamedType anamedtype[] = new NamedType[aclass.length];
        int i = 0;
        for (int j = aclass.length; i < j; i++)
            anamedtype[i] = new NamedType(aclass[i]);

        registerSubtypes(anamedtype);
    }
}
