// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package com.netease.LDNetDiagnoService;

import android.os.Handler;
import android.os.Message;
import android.util.Log;
import java.util.concurrent.*;

public abstract class LDNetAsyncTaskEx {
    private static class LDNetAsyncTaskResult {

        final Object mData[];
        final LDNetAsyncTaskEx mTask;

        transient LDNetAsyncTaskResult(LDNetAsyncTaskEx ldnetasynctaskex, Object aobj[]) {
            mTask = ldnetasynctaskex;
            mData = aobj;
        }
    }

    private static class LDNetInternalHandler extends Handler {

        public void handleMessage(Message message) {
            LDNetAsyncTaskResult ldnetasynctaskresult = (LDNetAsyncTaskResult)message.obj;
            message.what;
            JVM INSTR tableswitch 1 3: default 40
        //                       1 41
        //                       2 57
        //                       3 71;
               goto _L1 _L2 _L3 _L4
_L1:
            return;
_L2:
            ldnetasynctaskresult.mTask.finish(ldnetasynctaskresult.mData[0]);
            continue; /* Loop/switch isn't completed */
_L3:
            ldnetasynctaskresult.mTask.onProgressUpdate(ldnetasynctaskresult.mData);
            continue; /* Loop/switch isn't completed */
_L4:
            ldnetasynctaskresult.mTask.onCancelled();
            if (true) goto _L1; else goto _L5
_L5:
        }

        private LDNetInternalHandler() {
        }

    }

    private static abstract class LDNetWorkerRunnable
        implements Callable {

        Object mParams[];

        private LDNetWorkerRunnable() {
        }

    }

    public static final class Status extends Enum {

        private static final Status $VALUES[];
        public static final Status FINISHED;
        public static final Status PENDING;
        public static final Status RUNNING;

        public static Status valueOf(String s) {
            return (Status)Enum.valueOf(com/netease/LDNetDiagnoService/LDNetAsyncTaskEx$Status, s);
        }

        public static Status[] values() {
            return (Status[])$VALUES.clone();
        }

        static  {
            PENDING = new Status("PENDING", 0);
            RUNNING = new Status("RUNNING", 1);
            FINISHED = new Status("FINISHED", 2);
            $VALUES = (new Status[] {
                PENDING, RUNNING, FINISHED
            });
        }

        private Status(String s, int i) {
            super(s, i);
        }
    }


    private static final int MESSAGE_POST_CANCEL = 3;
    private static final int MESSAGE_POST_PROGRESS = 2;
    private static final int MESSAGE_POST_RESULT = 1;
    private static final LDNetInternalHandler sHandler = new LDNetInternalHandler();
    private final FutureTask mFuture;
    private volatile Status mStatus;
    private final LDNetWorkerRunnable mWorker = new LDNetWorkerRunnable() {

        final LDNetAsyncTaskEx this$0;

        public Object call() {
            return doInBackground(mParams);
        }

             {
                this$0 = LDNetAsyncTaskEx.this;
                super();
            }
    }
;

    public LDNetAsyncTaskEx() {
        mStatus = Status.PENDING;
        mFuture = new FutureTask(mWorker) {

            final LDNetAsyncTaskEx this$0;

            protected void done() {
                Object obj = null;
                Object obj2 = get();
                obj = obj2;
_L4:
                LDNetAsyncTaskEx.sHandler.obtainMessage(1, new LDNetAsyncTaskResult(LDNetAsyncTaskEx.this, new Object[] {
                    obj
                })).sendToTarget();
_L2:
                return;
                Object obj3;
                obj3;
                Log.w(getClass().getSimpleName(), ((Throwable) (obj3)));
                continue; /* Loop/switch isn't completed */
                Object obj1;
                obj1;
                throw new RuntimeException("An error occured while executing doInBackground()", ((ExecutionException) (obj1)).getCause());
                obj1;
                LDNetAsyncTaskEx.sHandler.obtainMessage(3, new LDNetAsyncTaskResult(LDNetAsyncTaskEx.this, (Object[])null)).sendToTarget();
                if (true) goto _L2; else goto _L1
_L1:
                obj3;
                if (true) goto _L4; else goto _L3
_L3:
            }

             {
                this$0 = LDNetAsyncTaskEx.this;
                super(callable);
            }
        }
;
    }

    public final boolean cancel(boolean flag) {
        return mFuture.cancel(flag);
    }

    protected transient abstract Object doInBackground(Object aobj[]);

    public final transient LDNetAsyncTaskEx execute(Object aobj[]) {
        if (mStatus == Status.PENDING) goto _L2; else goto _L1
_L1:
        static class _cls3 {

            static final int $SwitchMap$com$netease$LDNetDiagnoService$LDNetAsyncTaskEx$Status[];

            static  {
                $SwitchMap$com$netease$LDNetDiagnoService$LDNetAsyncTaskEx$Status = new int[Status.values().length];
                NoSuchFieldError nosuchfielderror;
                try {
                    $SwitchMap$com$netease$LDNetDiagnoService$LDNetAsyncTaskEx$Status[Status.RUNNING.ordinal()] = 1;
                }
                catch (NoSuchFieldError nosuchfielderror1) { }
                $SwitchMap$com$netease$LDNetDiagnoService$LDNetAsyncTaskEx$Status[Status.FINISHED.ordinal()] = 2;
_L2:
                return;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        _cls3..SwitchMap.com.netease.LDNetDiagnoService.LDNetAsyncTaskEx.Status[mStatus.ordinal()];
        JVM INSTR tableswitch 1 2: default 44
    //                   1 84
    //                   2 94;
           goto _L2 _L3 _L4
_L2:
        mStatus = Status.RUNNING;
        onPreExecute();
        mWorker.mParams = aobj;
        aobj = getThreadPoolExecutor();
        if (aobj != null) {
            ((ThreadPoolExecutor) (aobj)).execute(mFuture);
            aobj = this;
        } else {
            aobj = null;
        }
        return ((LDNetAsyncTaskEx) (aobj));
_L3:
        throw new IllegalStateException("Cannot execute task: the task is already running.");
_L4:
        throw new IllegalStateException("Cannot execute task: the task has already been executed (a task can be executed only once)");
    }

    protected void finish(Object obj) {
        if (isCancelled())
            obj = null;
        onPostExecute(obj);
        mStatus = Status.FINISHED;
    }

    public final Status getStatus() {
        return mStatus;
    }

    protected abstract ThreadPoolExecutor getThreadPoolExecutor();

    public final boolean isCancelled() {
        return mFuture.isCancelled();
    }

    protected void onCancelled() {
    }

    protected void onPostExecute(Object obj) {
    }

    protected void onPreExecute() {
    }

    protected transient void onProgressUpdate(Object aobj[]) {
    }

    protected final transient void publishProgress(Object aobj[]) {
        sHandler.obtainMessage(2, new LDNetAsyncTaskResult(this, aobj)).sendToTarget();
    }


}
