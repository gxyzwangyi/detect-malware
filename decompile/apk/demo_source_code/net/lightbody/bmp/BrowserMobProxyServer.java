// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.lightbody.bmp;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.MapMaker;
import io.netty.handler.codec.http.s;
import io.netty.handler.codec.http.w;
import io.netty.handler.codec.http.z;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Pattern;
import net.lightbody.bmp.client.ClientUtil;
import net.lightbody.bmp.core.har.Har;
import net.lightbody.bmp.core.har.HarLog;
import net.lightbody.bmp.core.har.HarNameVersion;
import net.lightbody.bmp.core.har.HarPage;
import net.lightbody.bmp.core.har.HarPageTimings;
import net.lightbody.bmp.core.har.PageRefFilteredHar;
import net.lightbody.bmp.filters.AddHeadersFilter;
import net.lightbody.bmp.filters.AutoBasicAuthFilter;
import net.lightbody.bmp.filters.BlacklistFilter;
import net.lightbody.bmp.filters.BrowserMobHttpFilterChain;
import net.lightbody.bmp.filters.HarCaptureFilter;
import net.lightbody.bmp.filters.HttpConnectHarCaptureFilter;
import net.lightbody.bmp.filters.HttpsHostCaptureFilter;
import net.lightbody.bmp.filters.HttpsOriginalHostCaptureFilter;
import net.lightbody.bmp.filters.LatencyFilter;
import net.lightbody.bmp.filters.RegisterRequestFilter;
import net.lightbody.bmp.filters.RequestFilter;
import net.lightbody.bmp.filters.ResolvedHostnameCacheFilter;
import net.lightbody.bmp.filters.ResponseFilter;
import net.lightbody.bmp.filters.RewriteUrlFilter;
import net.lightbody.bmp.filters.UnregisterRequestFilter;
import net.lightbody.bmp.filters.WhitelistFilter;
import net.lightbody.bmp.mitm.KeyStoreFileCertificateSource;
import net.lightbody.bmp.mitm.TrustSource;
import net.lightbody.bmp.mitm.keys.ECKeyGenerator;
import net.lightbody.bmp.mitm.keys.RSAKeyGenerator;
import net.lightbody.bmp.mitm.manager.ImpersonatingMitmManager;
import net.lightbody.bmp.proxy.ActivityMonitor;
import net.lightbody.bmp.proxy.BlacklistEntry;
import net.lightbody.bmp.proxy.CaptureType;
import net.lightbody.bmp.proxy.RewriteRule;
import net.lightbody.bmp.proxy.Whitelist;
import net.lightbody.bmp.proxy.auth.AuthType;
import net.lightbody.bmp.proxy.dns.AdvancedHostResolver;
import net.lightbody.bmp.proxy.dns.DelegatingHostResolver;
import net.lightbody.bmp.util.BrowserMobHttpUtil;
import net.lightbody.bmp.util.BrowserMobProxyUtil;
import org.littleshoot.proxy.d;
import org.littleshoot.proxy.i;
import org.littleshoot.proxy.impl.e;
import org.littleshoot.proxy.impl.j;
import org.littleshoot.proxy.impl.l;
import org.littleshoot.proxy.k;
import org.littleshoot.proxy.m;
import org.littleshoot.proxy.n;
import org.littleshoot.proxy.o;
import org.slf4j.b;
import org.slf4j.c;

// Referenced classes of package net.lightbody.bmp:
//            BrowserMobProxy

public class BrowserMobProxyServer
    implements BrowserMobProxy {

    private static final String EC_KEYSTORE_RESOURCE = "/sslSupport/ca-keystore-ec.p12";
    private static final HarNameVersion HAR_CREATOR_VERSION = new HarNameVersion("BrowserMob Proxy", BrowserMobProxyUtil.getVersionString());
    private static final String KEYSTORE_PASSWORD = "password";
    private static final String KEYSTORE_PRIVATE_KEY_ALIAS = "key";
    private static final String KEYSTORE_TYPE = "PKCS12";
    private static final String RSA_KEYSTORE_RESOURCE = "/sslSupport/ca-keystore-rsa.p12";
    public static final String VIA_HEADER_ALIAS = "browsermobproxy";
    private static final b log = c.a(net/lightbody/bmp/BrowserMobProxyServer);
    private final ActivityMonitor activityMonitor = new ActivityMonitor();
    private volatile ConcurrentMap additionalHeaders;
    private final ConcurrentMap basicAuthCredentials = (new MapMaker()).a(1).j();
    private volatile Collection blacklistEntries;
    private volatile String chainedProxyCredentials;
    private volatile d chainedProxyManager;
    private volatile int connectTimeoutMs;
    private volatile HarPage currentHarPage;
    private final DelegatingHostResolver delegatingResolver = new DelegatingHostResolver(ClientUtil.createNativeCacheManipulatingResolver());
    private final List filterFactories = new CopyOnWriteArrayList();
    private volatile Har har;
    private final AtomicBoolean harCaptureFilterEnabled = new AtomicBoolean(false);
    private volatile EnumSet harCaptureTypes;
    private final AtomicInteger harPageCount = new AtomicInteger(0);
    private volatile int idleConnectionTimeoutSec;
    private volatile int latencyMs;
    private volatile boolean mitmDisabled;
    private volatile o mitmManager;
    private volatile m proxyServer;
    private volatile long readBandwidthLimitBps;
    private volatile CopyOnWriteArrayList rewriteRules;
    private volatile InetAddress serverBindAddress;
    private final AtomicBoolean started = new AtomicBoolean(false);
    private final AtomicBoolean stopped = new AtomicBoolean(false);
    private volatile l threadPoolConfiguration;
    private volatile TrustSource trustSource;
    private volatile InetSocketAddress upstreamProxyAddress;
    private volatile boolean useEcc;
    private final AtomicReference whitelist;
    private volatile long writeBandwidthLimitBps;

    public BrowserMobProxyServer() {
        mitmDisabled = false;
        blacklistEntries = new CopyOnWriteArrayList();
        rewriteRules = new CopyOnWriteArrayList();
        harCaptureTypes = EnumSet.noneOf(net/lightbody/bmp/proxy/CaptureType);
        whitelist = new AtomicReference(Whitelist.WHITELIST_DISABLED);
        additionalHeaders = (new MapMaker()).a(1).j();
        trustSource = TrustSource.defaultTrustSource();
        useEcc = false;
    }

    private int getMaximumRequestBufferSize() {
        Iterator iterator = filterFactories.iterator();
        int i = 0;
        do {
            if (!iterator.hasNext())
                break;
            int j = ((k)iterator.next()).getMaximumRequestBufferSizeInBytes();
            if (j > i)
                i = j;
        } while (true);
        return i;
    }

    private int getMaximumResponseBufferSize() {
        Iterator iterator = filterFactories.iterator();
        int i = 0;
        do {
            if (!iterator.hasNext())
                break;
            int j = ((k)iterator.next()).getMaximumResponseBufferSizeInBytes();
            if (j > i)
                i = j;
        } while (true);
        return i;
    }

    public void abort() {
        stop(false);
    }

    protected void addBrowserMobFilters() {
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                return new ResolvedHostnameCacheFilter(z, k1);
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                return new RegisterRequestFilter(z, k1, activityMonitor);
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                return new HttpsOriginalHostCaptureFilter(z, k1);
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                return new BlacklistFilter(z, k1, getBlacklist());
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                Whitelist whitelist1 = (Whitelist)whitelist.get();
                return new WhitelistFilter(z, k1, isWhitelistEnabled(), whitelist1.getStatusCode(), whitelist1.getPatterns());
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                return new AutoBasicAuthFilter(z, k1, basicAuthCredentials);
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                return new RewriteUrlFilter(z, k1, rewriteRules);
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                return new HttpsHostCaptureFilter(z, k1);
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z) {
                return new AddHeadersFilter(z, additionalHeaders);
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z) {
                return new LatencyFilter(z, latencyMs);
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
        addHttpFilterFactory(new org.littleshoot.proxy.l() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                return new UnregisterRequestFilter(z, k1, activityMonitor);
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
);
    }

    public void addFirstHttpFilterFactory(k k1) {
        filterFactories.add(0, k1);
    }

    protected void addHarCaptureFilter() {
        if (harCaptureFilterEnabled.compareAndSet(false, true)) {
            addHttpFilterFactory(new org.littleshoot.proxy.l() {

                final BrowserMobProxyServer this$0;

                public i filterRequest(z z, io.netty.channel.k k1) {
                    String s = null;
                    Har har1 = getHar();
                    if (har1 != null && !j.c(z)) {
                        if (getCurrentHarPage() != null)
                            s = getCurrentHarPage().getId();
                        z = new HarCaptureFilter(z, k1, har1, s, getHarCaptureTypes());
                    } else {
                        z = null;
                    }
                    return z;
                }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
            }
);
            addHttpFilterFactory(new org.littleshoot.proxy.l() {

                final BrowserMobProxyServer this$0;

                public i filterRequest(z z, io.netty.channel.k k1) {
                    Object obj2 = null;
                    Object obj1 = null;
                    Har har1 = getHar();
                    Object obj = obj2;
                    if (har1 != null) {
                        obj = obj2;
                        if (j.c(z)) {
                            if (getCurrentHarPage() == null)
                                obj = obj1;
                            else
                                obj = getCurrentHarPage().getId();
                            obj = new HttpConnectHarCaptureFilter(z, k1, har1, ((String) (obj)));
                        }
                    }
                    return ((i) (obj));
                }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
            }
);
        }
    }

    public void addHeader(String s, String s1) {
        additionalHeaders.put(s, s1);
    }

    public void addHeaders(Map map) {
        ConcurrentMap concurrentmap = (new MapMaker()).a(1).j();
        concurrentmap.putAll(map);
        additionalHeaders = concurrentmap;
    }

    public void addHttpFilterFactory(k k1) {
        filterFactories.add(k1);
    }

    public void addLastHttpFilterFactory(k k1) {
        filterFactories.add(k1);
    }

    public void addRequestFilter(RequestFilter requestfilter) {
        addFirstHttpFilterFactory(new net.lightbody.bmp.filters.RequestFilterAdapter.FilterSource(requestfilter));
    }

    public void addResponseFilter(ResponseFilter responsefilter) {
        addLastHttpFilterFactory(new net.lightbody.bmp.filters.ResponseFilterAdapter.FilterSource(responsefilter));
    }

    public void addWhitelistPattern(String s) {
        Whitelist whitelist1;
        Object obj;
        for (boolean flag = false; !flag; flag = whitelist.compareAndSet(whitelist1, obj)) {
            whitelist1 = (Whitelist)whitelist.get();
            if (!whitelist1.isEnabled())
                throw new IllegalStateException("Whitelist is disabled. Cannot add patterns to a disabled whitelist.");
            int i = whitelist1.getStatusCode();
            obj = new ArrayList(whitelist1.getPatterns().size() + 1);
            for (Iterator iterator = whitelist1.getPatterns().iterator(); iterator.hasNext(); ((List) (obj)).add(((Pattern)iterator.next()).pattern()));
            ((List) (obj)).add(s);
            obj = new Whitelist(((Collection) (obj)), i);
        }

    }

    public void autoAuthorization(String s, String s1, String s2, AuthType authtype) {
        static class _cls16 {

            static final int $SwitchMap$net$lightbody$bmp$proxy$auth$AuthType[];

            static  {
                $SwitchMap$net$lightbody$bmp$proxy$auth$AuthType = new int[AuthType.values().length];
                $SwitchMap$net$lightbody$bmp$proxy$auth$AuthType[AuthType.BASIC.ordinal()] = 1;
_L2:
                return;
                NoSuchFieldError nosuchfielderror;
                nosuchfielderror;
                if (true) goto _L2; else goto _L1
_L1:
            }
        }

        switch (_cls16..SwitchMap.net.lightbody.bmp.proxy.auth.AuthType[authtype.ordinal()]) {
        default:
            throw new UnsupportedOperationException((new StringBuilder()).append("AuthType ").append(authtype).append(" is not supported for HTTP Authorization").toString());

        case 1: // '\001'
            s1 = BrowserMobHttpUtil.base64EncodeBasicCredentials(s1, s2);
            break;
        }
        basicAuthCredentials.put(s, s1);
    }

    public void blacklistRequests(String s, int i) {
        blacklistEntries.add(new BlacklistEntry(s, i));
    }

    public void blacklistRequests(String s, int i, String s1) {
        blacklistEntries.add(new BlacklistEntry(s, i, s1));
    }

    public void chainedProxyAuthorization(String s, String s1, AuthType authtype) {
        switch (_cls16..SwitchMap.net.lightbody.bmp.proxy.auth.AuthType[authtype.ordinal()]) {
        default:
            throw new UnsupportedOperationException((new StringBuilder()).append("AuthType ").append(authtype).append(" is not supported for Proxy Authorization").toString());

        case 1: // '\001'
            chainedProxyCredentials = BrowserMobHttpUtil.base64EncodeBasicCredentials(s, s1);
            break;
        }
    }

    public void clearBlacklist() {
        blacklistEntries.clear();
    }

    public void clearRewriteRules() {
        rewriteRules.clear();
    }

    public Boolean deletePage(HarPage harpage) {
        if (har == null)
            throw new IllegalStateException("No HAR exists for this proxy. Use newHar() to create a new HAR before calling newPage().");
        else
            return har.getLog().deletePage(harpage);
    }

    public void disableHarCaptureTypes(Set set) {
        harCaptureTypes.removeAll(set);
    }

    public transient void disableHarCaptureTypes(CaptureType acapturetype[]) {
        if (acapturetype == null)
            disableHarCaptureTypes(((Set) (EnumSet.noneOf(net/lightbody/bmp/proxy/CaptureType))));
        else
            disableHarCaptureTypes(((Set) (EnumSet.copyOf(Arrays.asList(acapturetype)))));
    }

    public void disableWhitelist() {
        whitelist.set(Whitelist.WHITELIST_DISABLED);
    }

    public void enableEmptyWhitelist(int i) {
        whitelist.set(new Whitelist(i));
    }

    public void enableHarCaptureTypes(Set set) {
        harCaptureTypes.addAll(set);
    }

    public transient void enableHarCaptureTypes(CaptureType acapturetype[]) {
        if (acapturetype == null)
            enableHarCaptureTypes(((Set) (EnumSet.noneOf(net/lightbody/bmp/proxy/CaptureType))));
        else
            enableHarCaptureTypes(((Set) (EnumSet.copyOf(Arrays.asList(acapturetype)))));
    }

    public Har endHar() {
        Har har1 = getHar();
        endPage();
        har = null;
        return har1;
    }

    public void endPage() {
        if (har == null)
            throw new IllegalStateException("No HAR exists for this proxy. Use newHar() to create a new HAR.");
        HarPage harpage = currentHarPage;
        currentHarPage = null;
        if (harpage != null)
            harpage.getPageTimings().setOnLoad(Long.valueOf((new Date()).getTime() - harpage.getStartedDateTime().getTime()));
    }

    public Map getAllHeaders() {
        return ImmutableMap.a(additionalHeaders);
    }

    public Collection getBlacklist() {
        return Collections.unmodifiableCollection(blacklistEntries);
    }

    public InetSocketAddress getChainedProxy() {
        return upstreamProxyAddress;
    }

    public InetAddress getClientBindAddress() {
        InetAddress inetaddress;
        if (started.get())
            inetaddress = proxyServer.c().getAddress();
        else
            inetaddress = null;
        return inetaddress;
    }

    public HarPage getCurrentHarPage() {
        return currentHarPage;
    }

    public List getFilterFactories() {
        return filterFactories;
    }

    public Har getHar() {
        return har;
    }

    public Har getHar(String s) {
        return new PageRefFilteredHar(getHar(), s);
    }

    public Har getHar(Set set) {
        return new PageRefFilteredHar(getHar(), set);
    }

    public EnumSet getHarCaptureTypes() {
        return EnumSet.copyOf(harCaptureTypes);
    }

    public AdvancedHostResolver getHostNameResolver() {
        return delegatingResolver.getResolver();
    }

    public int getPort() {
        int i;
        if (started.get())
            i = proxyServer.c().getPort();
        else
            i = 0;
        return i;
    }

    public long getReadBandwidthLimit() {
        return readBandwidthLimitBps;
    }

    public Map getRewriteRules() {
        com.google.common.collect.ImmutableMap.a a = ImmutableMap.f();
        RewriteRule rewriterule;
        for (Iterator iterator = rewriteRules.iterator(); iterator.hasNext(); a.a(rewriterule.getPattern().pattern(), rewriterule.getReplace()))
            rewriterule = (RewriteRule)iterator.next();

        return a.a();
    }

    public InetAddress getServerBindAddress() {
        return serverBindAddress;
    }

    public int getWhitelistStatusCode() {
        return ((Whitelist)whitelist.get()).getStatusCode();
    }

    public Collection getWhitelistUrls() {
        com.google.common.collect.ImmutableList.a a = ImmutableList.i();
        for (Iterator iterator = ((Whitelist)whitelist.get()).getPatterns().iterator(); iterator.hasNext(); a.c(((Pattern)iterator.next()).pattern()));
        return a.a();
    }

    public long getWriteBandwidthLimit() {
        return writeBandwidthLimitBps;
    }

    public boolean isMitmDisabled() {
        return mitmDisabled;
    }

    public boolean isStarted() {
        return started.get();
    }

    public boolean isStopped() {
        return stopped.get();
    }

    public boolean isWhitelistEnabled() {
        return ((Whitelist)whitelist.get()).isEnabled();
    }

    public Har newHar() {
        return newHar(null);
    }

    public Har newHar(String s) {
        return newHar(s, null);
    }

    public Har newHar(String s, String s1) {
        Har har1 = getHar();
        addHarCaptureFilter();
        harPageCount.set(0);
        har = new Har(new HarLog(HAR_CREATOR_VERSION, this));
        newPage(s, s1);
        return har1;
    }

    public Har newPage() {
        return newPage(null);
    }

    public Har newPage(String s) {
        return newPage(s, null);
    }

    public Har newPage(String s, String s1) {
        this;
        JVM INSTR monitorenter ;
        if (har == null) {
            s = JVM INSTR new #376 <Class IllegalStateException>;
            s.IllegalStateException("No HAR exists for this proxy. Use newHar() to create a new HAR before calling newPage().");
            throw s;
        }
        break MISSING_BLOCK_LABEL_27;
        s;
        this;
        JVM INSTR monitorexit ;
        throw s;
        if (currentHarPage == null) goto _L2; else goto _L1
_L1:
        Object obj;
        obj = currentHarPage.getId();
        endPage();
        obj = BrowserMobProxyUtil.copyHarThroughPageRef(har, ((String) (obj)));
_L4:
        if (s != null)
            break MISSING_BLOCK_LABEL_88;
        s = JVM INSTR new #422 <Class StringBuilder>;
        s.StringBuilder();
        s = s.append("Page ").append(harPageCount.getAndIncrement()).toString();
        String s2;
        s2 = s1;
        if (s1 == null)
            s2 = s;
        s1 = JVM INSTR new #526 <Class HarPage>;
        s1.HarPage(s, s2);
        har.getLog().addPage(s1);
        currentHarPage = s1;
        this;
        JVM INSTR monitorexit ;
        return ((Har) (obj));
_L2:
        obj = null;
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void removeAllHeaders() {
        additionalHeaders.clear();
    }

    public void removeHeader(String s) {
        additionalHeaders.remove(s);
    }

    public void removeRewriteRule(String s) {
        Iterator iterator = rewriteRules.iterator();
        do {
            if (!iterator.hasNext())
                break;
            RewriteRule rewriterule = (RewriteRule)iterator.next();
            if (rewriterule.getPattern().pattern().equals(s))
                rewriteRules.remove(rewriterule);
        } while (true);
    }

    public void rewriteUrl(String s, String s1) {
        rewriteRules.add(new RewriteRule(s, s1));
    }

    public void rewriteUrls(Map map) {
        ArrayList arraylist = new ArrayList(map.size());
        java.util.Map.Entry entry;
        for (map = map.entrySet().iterator(); map.hasNext(); arraylist.add(new RewriteRule((String)entry.getKey(), (String)entry.getValue())))
            entry = (java.util.Map.Entry)map.next();

        rewriteRules = new CopyOnWriteArrayList(arraylist);
    }

    public void setBlacklist(Collection collection) {
        blacklistEntries = new CopyOnWriteArrayList(collection);
    }

    public void setChainedProxy(InetSocketAddress inetsocketaddress) {
        upstreamProxyAddress = inetsocketaddress;
    }

    public void setChainedProxyManager(d d) {
        if (isStarted()) {
            throw new IllegalStateException("Cannot configure chained proxy manager after proxy has started.");
        } else {
            chainedProxyManager = d;
            return;
        }
    }

    public void setConnectTimeout(int i, TimeUnit timeunit) {
        connectTimeoutMs = (int)TimeUnit.MILLISECONDS.convert(i, timeunit);
        if (isStarted())
            proxyServer.b((int)TimeUnit.MILLISECONDS.convert(i, timeunit));
    }

    public void setHarCaptureTypes(Set set) {
        if (set == null || set.isEmpty())
            harCaptureTypes = EnumSet.noneOf(net/lightbody/bmp/proxy/CaptureType);
        else
            harCaptureTypes = EnumSet.copyOf(set);
    }

    public transient void setHarCaptureTypes(CaptureType acapturetype[]) {
        if (acapturetype == null)
            setHarCaptureTypes(((Set) (EnumSet.noneOf(net/lightbody/bmp/proxy/CaptureType))));
        else
            setHarCaptureTypes(((Set) (EnumSet.copyOf(Arrays.asList(acapturetype)))));
    }

    public void setHostNameResolver(AdvancedHostResolver advancedhostresolver) {
        delegatingResolver.setResolver(advancedhostresolver);
    }

    public void setIdleConnectionTimeout(int i, TimeUnit timeunit) {
        long l = TimeUnit.SECONDS.convert(i, timeunit);
        if (l == 0L && i > 0)
            idleConnectionTimeoutSec = 1;
        else
            idleConnectionTimeoutSec = (int)l;
        if (isStarted())
            proxyServer.a(idleConnectionTimeoutSec);
    }

    public void setLatency(long l, TimeUnit timeunit) {
        latencyMs = (int)TimeUnit.MILLISECONDS.convert(l, timeunit);
    }

    public void setMitmDisabled(boolean flag) {
        if (isStarted()) {
            throw new IllegalStateException("Cannot disable MITM after the proxy has been started");
        } else {
            mitmDisabled = flag;
            return;
        }
    }

    public void setMitmManager(o o) {
        mitmManager = o;
    }

    public void setReadBandwidthLimit(long l) {
        readBandwidthLimitBps = l;
        if (isStarted())
            proxyServer.a(readBandwidthLimitBps, writeBandwidthLimitBps);
    }

    public void setRequestTimeout(int i, TimeUnit timeunit) {
        if (idleConnectionTimeoutSec == 0 || (long)idleConnectionTimeoutSec > TimeUnit.SECONDS.convert(i, timeunit))
            setIdleConnectionTimeout(i, timeunit);
    }

    public void setThreadPoolConfiguration(l l) {
        if (isStarted()) {
            throw new IllegalStateException("Cannot configure thread pool after proxy has started.");
        } else {
            threadPoolConfiguration = l;
            return;
        }
    }

    public void setTrustAllServers(boolean flag) {
        if (isStarted())
            throw new IllegalStateException("Cannot disable upstream server verification after the proxy has been started");
        if (!flag) goto _L2; else goto _L1
_L1:
        trustSource = null;
_L4:
        return;
_L2:
        if (trustSource == null)
            trustSource = TrustSource.defaultTrustSource();
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void setTrustSource(TrustSource trustsource) {
        if (isStarted()) {
            throw new IllegalStateException("Cannot change TrustSource after proxy has been started");
        } else {
            trustSource = trustsource;
            return;
        }
    }

    public void setUseEcc(boolean flag) {
        useEcc = flag;
    }

    public void setWriteBandwidthLimit(long l) {
        writeBandwidthLimitBps = l;
        if (isStarted())
            proxyServer.a(readBandwidthLimitBps, writeBandwidthLimitBps);
    }

    public void start() {
        start(0);
    }

    public void start(int i) {
        start(i, null, null);
    }

    public void start(int i, InetAddress inetaddress) {
        start(i, inetaddress, null);
    }

    public void start(int i, InetAddress inetaddress, InetAddress inetaddress1) {
        n n1;
        if (!started.compareAndSet(false, true))
            throw new IllegalStateException("Proxy server is already started. Not restarting.");
        if (inetaddress == null)
            inetaddress = new InetSocketAddress(i);
        else
            inetaddress = new InetSocketAddress(inetaddress, i);
        serverBindAddress = inetaddress1;
        addBrowserMobFilters();
        n1 = e.d().a(new k() {

            final BrowserMobProxyServer this$0;

            public i filterRequest(z z, io.netty.channel.k k1) {
                return new BrowserMobHttpFilterChain(BrowserMobProxyServer.this, z, k1);
            }

            public int getMaximumRequestBufferSizeInBytes() {
                return getMaximumRequestBufferSize();
            }

            public int getMaximumResponseBufferSizeInBytes() {
                return getMaximumResponseBufferSize();
            }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
        }
).a(delegatingResolver).a(inetaddress).b(connectTimeoutMs).a(idleConnectionTimeoutSec).a("browsermobproxy");
        if (inetaddress1 != null)
            n1.b(new InetSocketAddress(inetaddress1, 0));
        if (!mitmDisabled) {
            if (mitmManager == null) {
                inetaddress1 = ImpersonatingMitmManager.builder();
                if (useEcc)
                    inetaddress = "/sslSupport/ca-keystore-ec.p12";
                else
                    inetaddress = "/sslSupport/ca-keystore-rsa.p12";
                inetaddress1 = inetaddress1.rootCertificateSource(new KeyStoreFileCertificateSource("PKCS12", inetaddress, "key", "password"));
                if (useEcc)
                    inetaddress = new ECKeyGenerator();
                else
                    inetaddress = new RSAKeyGenerator();
                mitmManager = inetaddress1.serverKeyGenerator(inetaddress).trustSource(trustSource).build();
            }
            n1.a(mitmManager);
        }
        if (readBandwidthLimitBps > 0L || writeBandwidthLimitBps > 0L)
            n1.a(readBandwidthLimitBps, writeBandwidthLimitBps);
        if (chainedProxyManager == null) goto _L2; else goto _L1
_L1:
        n1.a(chainedProxyManager);
_L4:
        if (threadPoolConfiguration != null)
            n1.a(threadPoolConfiguration);
        proxyServer = n1.a();
        return;
_L2:
        if (upstreamProxyAddress != null)
            n1.a(new d() {

                final BrowserMobProxyServer this$0;

                public void lookupChainedProxies(z z, Queue queue) {
                    z = upstreamProxyAddress;
                    if (z != null)
                        queue.add(z. new org.littleshoot.proxy.c() {

                            final _cls2 this$1;
                            final InetSocketAddress val$upstreamProxy;

                            public void filterRequest(w w) {
                                String s1 = chainedProxyCredentials;
                                if (s1 != null && (w instanceof z))
                                    s.a((z)w, "Proxy-Authorization", (new StringBuilder()).append("Basic ").append(s1).toString());
                            }

                            public InetSocketAddress getChainedProxyAddress() {
                                return upstreamProxy;
                            }

             {
                this$1 = final__pcls2;
                upstreamProxy = InetSocketAddress.this;
                super();
            }
                        }
);
                }

             {
                this$0 = BrowserMobProxyServer.this;
                super();
            }
            }
);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void stop() {
        stop(true);
    }

    protected void stop(boolean flag) {
        if (isStarted()) {
            if (stopped.compareAndSet(false, true)) {
                if (proxyServer != null) {
                    if (flag)
                        proxyServer.a();
                    else
                        proxyServer.b();
                } else {
                    log.c("Attempted to stop proxy server, but proxy was never successfully started.");
                }
                return;
            } else {
                throw new IllegalStateException("Proxy server is already stopped. Cannot re-stop.");
            }
        } else {
            throw new IllegalStateException("Proxy server has not been started");
        }
    }

    public void stopAutoAuthorization(String s) {
        basicAuthCredentials.remove(s);
    }

    public boolean waitForQuiescence(long l, long l1, TimeUnit timeunit) {
        return activityMonitor.waitForQuiescence(l, l1, timeunit);
    }

    public void whitelistRequests(Collection collection, int i) {
        whitelist.set(new Whitelist(collection, i));
    }

    public void whitelistRequests(String as[], int i) {
        if (as == null || as.length == 0)
            enableEmptyWhitelist(i);
        else
            whitelistRequests(((Collection) (Arrays.asList(as))), i);
    }











}
