// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.lightbody.bmp.filters;

import cn.darkal.networkdiagnosis.d.a;
import com.google.common.collect.ImmutableList;
import io.netty.buffer.h;
import io.netty.channel.d;
import io.netty.channel.k;
import io.netty.handler.codec.http.a.f;
import io.netty.handler.codec.http.ac;
import io.netty.handler.codec.http.af;
import io.netty.handler.codec.http.ag;
import io.netty.handler.codec.http.ah;
import io.netty.handler.codec.http.ai;
import io.netty.handler.codec.http.n;
import io.netty.handler.codec.http.s;
import io.netty.handler.codec.http.v;
import io.netty.handler.codec.http.w;
import io.netty.handler.codec.http.z;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.nio.charset.Charset;
import java.util.Calendar;
import java.util.Date;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import net.lightbody.bmp.core.har.Har;
import net.lightbody.bmp.core.har.HarContent;
import net.lightbody.bmp.core.har.HarCookie;
import net.lightbody.bmp.core.har.HarEntry;
import net.lightbody.bmp.core.har.HarLog;
import net.lightbody.bmp.core.har.HarNameValuePair;
import net.lightbody.bmp.core.har.HarNameVersion;
import net.lightbody.bmp.core.har.HarPostData;
import net.lightbody.bmp.core.har.HarPostDataParam;
import net.lightbody.bmp.core.har.HarRequest;
import net.lightbody.bmp.core.har.HarResponse;
import net.lightbody.bmp.core.har.HarTimings;
import net.lightbody.bmp.exception.UnsupportedCharsetException;
import net.lightbody.bmp.filters.support.HttpConnectTiming;
import net.lightbody.bmp.filters.util.HarCaptureUtil;
import net.lightbody.bmp.proxy.CaptureType;
import net.lightbody.bmp.util.BrowserMobHttpUtil;
import org.littleshoot.proxy.impl.j;
import org.slf4j.b;
import org.slf4j.c;

// Referenced classes of package net.lightbody.bmp.filters:
//            HttpsAwareFiltersAdapter, ClientRequestCaptureFilter, ServerResponseCaptureFilter, HttpConnectHarCaptureFilter, 
//            ResolvedHostnameCacheFilter

public class HarCaptureFilter extends HttpsAwareFiltersAdapter {

    private static final b log = c.a(net/lightbody/bmp/filters/HarCaptureFilter);
    private volatile boolean addressResolved;
    private volatile z capturedOriginalRequest;
    private final InetSocketAddress clientAddress;
    private volatile long connectionQueuedNanos;
    private volatile long connectionStartedNanos;
    private final EnumSet dataToCapture;
    private volatile long dnsResolutionStartedNanos;
    private final Har har;
    private final HarEntry harEntry;
    private final AtomicInteger requestBodySize = new AtomicInteger(0);
    private final ClientRequestCaptureFilter requestCaptureFilter;
    private final AtomicInteger responseBodySize = new AtomicInteger(0);
    private final ServerResponseCaptureFilter responseCaptureFilter;
    private volatile long responseReceiveStartedNanos;
    private volatile long sendFinishedNanos;
    private volatile long sendStartedNanos;

    public HarCaptureFilter(z z1, k k1, Har har1, String s1, Set set) {
        super(z1, k1);
        addressResolved = false;
        if (har1 == null)
            throw new IllegalStateException("Attempted har capture when har is null");
        if (j.c(z1))
            throw new IllegalStateException("Attempted har capture for HTTP CONNECT request");
        clientAddress = (InetSocketAddress)k1.a().g();
        if (set != null && !set.isEmpty())
            dataToCapture = EnumSet.copyOf(set);
        else
            dataToCapture = EnumSet.noneOf(net/lightbody/bmp/proxy/CaptureType);
        if (dataToCapture.contains(CaptureType.REQUEST_CONTENT) || dataToCapture.contains(CaptureType.REQUEST_BINARY_CONTENT))
            requestCaptureFilter = new ClientRequestCaptureFilter(z1);
        else
            requestCaptureFilter = null;
        if (dataToCapture.contains(CaptureType.RESPONSE_CONTENT) || dataToCapture.contains(CaptureType.RESPONSE_BINARY_CONTENT))
            responseCaptureFilter = new ServerResponseCaptureFilter(z1, true);
        else
            responseCaptureFilter = null;
        har = har1;
        harEntry = new HarEntry(s1);
    }

    private HarRequest createHarRequestForHttpRequest(z z1) {
        String s1 = getFullUrl(z1);
        return new HarRequest(z1.l().toString(), s1, z1.k().d());
    }

    protected void captureConnectTiming() {
        HttpConnectTiming httpconnecttiming = HttpConnectHarCaptureFilter.consumeConnectTimingForConnection(clientAddress);
        if (httpconnecttiming != null) {
            harEntry.getTimings().setSsl(httpconnecttiming.getSslHandshakeTimeNanos(), TimeUnit.NANOSECONDS);
            harEntry.getTimings().setConnect(httpconnecttiming.getConnectTimeNanos(), TimeUnit.NANOSECONDS);
            harEntry.getTimings().setBlocked(httpconnecttiming.getBlockedTimeNanos(), TimeUnit.NANOSECONDS);
            harEntry.getTimings().setDns(httpconnecttiming.getDnsTimeNanos(), TimeUnit.NANOSECONDS);
        }
    }

    protected void captureHeaders(s s1) {
        for (Iterator iterator = s1.b().iterator(); iterator.hasNext(); harEntry.getRequest().getHeaders().add(new HarNameValuePair((String)s1.getKey(), (String)s1.getValue())))
            s1 = (java.util.Map.Entry)iterator.next();

    }

    protected void captureQueryParameters(z z1) {
        ai ai1 = new ai(z1.m(), Charset.forName("UTF-8"));
        try {
            for (Iterator iterator1 = ai1.a().entrySet().iterator(); iterator1.hasNext();) {
                java.util.Map.Entry entry = (java.util.Map.Entry)iterator1.next();
                Iterator iterator = ((List)entry.getValue()).iterator();
                while (iterator.hasNext())  {
                    String s1 = (String)iterator.next();
                    List list = harEntry.getRequest().getQueryString();
                    HarNameValuePair harnamevaluepair = JVM INSTR new #263 <Class HarNameValuePair>;
                    harnamevaluepair.HarNameValuePair((String)entry.getKey(), s1);
                    list.add(harnamevaluepair);
                }
            }

        }
        catch (IllegalArgumentException illegalargumentexception) {
            harEntry.setComment((new StringBuilder()).append("Unable to decode query parameters on URI: ").append(z1.m()).toString());
            log.b((new StringBuilder()).append("Unable to decode query parameters on URI: ").append(z1.m()).toString(), illegalargumentexception);
        }
    }

    protected void captureRedirectUrl(ac ac1) {
        ac1 = s.a(ac1, "Location");
        if (ac1 != null)
            harEntry.getResponse().setRedirectURL(ac1);
    }

    protected void captureRequestContent(z z1, byte abyte0[]) {
        if (abyte0.length != 0) goto _L2; else goto _L1
_L1:
        return;
_L2:
        Object obj1 = s.a(z1, "Content-Type");
        Object obj = obj1;
        if (obj1 == null) {
            log.d("No content type specified in request to {}. Content will be treated as {}", z1.m(), "application/octet-stream");
            obj = "application/octet-stream";
        }
        obj1 = new HarPostData();
        harEntry.getRequest().setPostData(((HarPostData) (obj1)));
        ((HarPostData) (obj1)).setMimeType(((String) (obj)));
        boolean flag;
        if (((String) (obj)).startsWith("application/x-www-form-urlencoded"))
            flag = true;
        else
            flag = false;
        try {
            obj1 = BrowserMobHttpUtil.readCharsetInContentTypeHeader(((String) (obj)));
        }
        // Misplaced declaration of an exception variable
        catch (byte abyte0[]) {
            log.d("Found unsupported character set in Content-Type header '{}' in HTTP request to {}. Content will not be captured in HAR.", new Object[] {
                obj, z1.m(), abyte0
            });
            continue; /* Loop/switch isn't completed */
        }
        obj = obj1;
        obj1 = obj;
        if (obj == null) {
            obj1 = BrowserMobHttpUtil.DEFAULT_HTTP_CHARSET;
            log.b("No charset specified; using charset {} to decode contents to {}", obj1, z1.m());
        }
        if (flag) {
            abyte0 = new ai(BrowserMobHttpUtil.getContentAsString(abyte0, ((Charset) (obj1))), ((Charset) (obj1)), false);
            z1 = ImmutableList.i();
            for (obj = abyte0.a().entrySet().iterator(); ((Iterator) (obj)).hasNext();) {
                java.util.Map.Entry entry = (java.util.Map.Entry)((Iterator) (obj)).next();
                abyte0 = ((List)entry.getValue()).iterator();
                while (abyte0.hasNext())  {
                    obj1 = (String)abyte0.next();
                    z1.c(new HarPostDataParam((String)entry.getKey(), ((String) (obj1))));
                }
            }

            harEntry.getRequest().getPostData().setParams(z1.a());
        } else {
            z1 = BrowserMobHttpUtil.getContentAsString(abyte0, ((Charset) (obj1)));
            harEntry.getRequest().getPostData().setText(z1);
        }
        if (true) goto _L1; else goto _L3
_L3:
    }

    protected void captureRequestCookies(z z1) {
        z1 = z1.j().b("Cookie");
        if (z1 != null) {
            Iterator iterator = f.b.a(z1).iterator();
            while (iterator.hasNext())  {
                z1 = (io.netty.handler.codec.http.a.b)iterator.next();
                HarCookie harcookie = new HarCookie();
                harcookie.setName(z1.a());
                harcookie.setValue(z1.b());
                harEntry.getRequest().getCookies().add(harcookie);
            }
        }
    }

    protected void captureRequestHeaderSize(z z1) {
        long l1 = (new StringBuilder()).append(z1.l().toString()).append(' ').append(z1.m()).append(' ').append(z1.k().toString()).toString().length() + 6;
        long l = BrowserMobHttpUtil.getHeaderSize(z1.j());
        harEntry.getRequest().setHeadersSize(l1 + l);
    }

    protected void captureRequestHeaders(z z1) {
        captureHeaders(z1.j());
    }

    protected void captureRequestSize(n n1) {
        int i = n1.a().f();
        requestBodySize.addAndGet(i);
    }

    protected void captureResponse(ac ac1) {
        HarResponse harresponse = new HarResponse(ac1.h().a(), ac1.h().b(), ac1.k().d());
        harEntry.setResponse(harresponse);
        captureResponseHeaderSize(ac1);
        captureResponseMimeType(ac1);
        if (dataToCapture.contains(CaptureType.RESPONSE_COOKIES))
            captureResponseCookies(ac1);
        if (dataToCapture.contains(CaptureType.RESPONSE_HEADERS))
            captureResponseHeaders(ac1);
        if (BrowserMobHttpUtil.isRedirect(ac1))
            captureRedirectUrl(ac1);
    }

    protected void captureResponseContent(ac ac1, byte abyte0[]) {
        Object obj = s.a(ac1, "Content-Type");
        ac1 = ((ac) (obj));
        if (obj == null) {
            log.d("No content type specified in response from {}. Content will be treated as {}", originalRequest.m(), "application/octet-stream");
            ac1 = "application/octet-stream";
        }
        boolean flag;
        Charset charset;
        if (responseCaptureFilter.isResponseCompressed() && !responseCaptureFilter.isDecompressionSuccessful()) {
            log.d("Unable to decompress content with encoding: {}. Contents will be encoded as base64 binary data.", responseCaptureFilter.getContentEncoding());
            flag = true;
        } else {
            flag = false;
        }
        obj = BrowserMobHttpUtil.readCharsetInContentTypeHeader(ac1);
        charset = ((Charset) (obj));
        if (obj == null) {
            charset = BrowserMobHttpUtil.DEFAULT_HTTP_CHARSET;
            log.b("No charset specified; using charset {} to decode contents from {}", charset, originalRequest.m());
        }
        if (flag || !BrowserMobHttpUtil.hasTextualContent(ac1)) goto _L2; else goto _L1
_L1:
        ac1 = BrowserMobHttpUtil.getContentAsString(abyte0, charset);
        harEntry.getResponse().getContent().setText(ac1);
_L5:
        harEntry.getResponse().getContent().setSize(abyte0.length);
_L3:
        return;
        abyte0;
        log.d("Found unsupported character set in Content-Type header '{}' in HTTP response from {}. Content will not be captured in HAR.", new Object[] {
            ac1, originalRequest.m(), abyte0
        });
        if (true) goto _L3; else goto _L2
_L2:
        if (dataToCapture.contains(CaptureType.RESPONSE_BINARY_CONTENT)) {
            harEntry.getResponse().getContent().setText(new String(a.a(new String(abyte0))));
            harEntry.getResponse().getContent().setEncoding("base64");
        }
        if (true) goto _L5; else goto _L4
_L4:
    }

    protected void captureResponseCookies(ac ac1) {
        ac1 = ac1.j().c("Set-Cookie");
        if (ac1 != null) goto _L2; else goto _L1
_L1:
        return;
_L2:
        ac1 = ac1.iterator();
_L5:
        if (!ac1.hasNext()) goto _L1; else goto _L3
_L3:
        io.netty.handler.codec.http.a.b b1;
        String s1 = (String)ac1.next();
        b1 = io.netty.handler.codec.http.a.a.b.a(s1);
        if (b1 == null) goto _L1; else goto _L4
_L4:
        HarCookie harcookie = new HarCookie();
        harcookie.setName(b1.a());
        harcookie.setValue(b1.b());
        harcookie.setDomain(b1.c());
        harcookie.setHttpOnly(Boolean.valueOf(b1.g()));
        harcookie.setPath(b1.d());
        harcookie.setSecure(Boolean.valueOf(b1.f()));
        if (b1.e() > 0L) {
            Calendar calendar = Calendar.getInstance();
            calendar.set(14, 0);
            calendar.setTimeInMillis(calendar.getTimeInMillis() + TimeUnit.MILLISECONDS.convert(b1.e(), TimeUnit.SECONDS));
            harcookie.setExpires(calendar.getTime());
        }
        harEntry.getResponse().getCookies().add(harcookie);
          goto _L5
    }

    protected void captureResponseHeaderSize(ac ac1) {
        long l = (new StringBuilder()).append(ac1.k().toString()).append(' ').append(ac1.h().toString()).toString().length() + 6;
        long l1 = BrowserMobHttpUtil.getHeaderSize(ac1.j());
        harEntry.getResponse().setHeadersSize(l + l1);
    }

    protected void captureResponseHeaders(ac ac1) {
        for (Iterator iterator = ac1.j().b().iterator(); iterator.hasNext(); harEntry.getResponse().getHeaders().add(new HarNameValuePair((String)ac1.getKey(), (String)ac1.getValue())))
            ac1 = (java.util.Map.Entry)iterator.next();

    }

    protected void captureResponseMimeType(ac ac1) {
        ac1 = s.a(ac1, "Content-Type");
        if (ac1 != null)
            harEntry.getResponse().getContent().setMimeType(ac1);
    }

    protected void captureResponseSize(n n1) {
        int i = n1.a().f();
        responseBodySize.addAndGet(i);
    }

    protected void captureTrailingHeaders(ah ah1) {
        captureHeaders(ah1.b());
    }

    protected void captureUserAgent(z z1) {
        if (har.getLog().getBrowser() != null)
            break MISSING_BLOCK_LABEL_59;
        z1 = s.a(z1, "User-Agent");
        if (z1 == null || z1.length() <= 0)
            break MISSING_BLOCK_LABEL_59;
        z1 = har.getLog();
        HarNameVersion harnameversion = JVM INSTR new #703 <Class HarNameVersion>;
        harnameversion.HarNameVersion("Mozilla/5.0 (Linux; U; Android 4.3; zh-cn; R8007 Build/JLS36C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30", "1.0.0");
        z1.setBrowser(harnameversion);
_L1:
        return;
        z1;
        log.c("Failed to parse user agent string", z1);
          goto _L1
    }

    public ac clientToProxyRequest(w w) {
        if (requestCaptureFilter != null)
            requestCaptureFilter.clientToProxyRequest(w);
        if (w instanceof z) {
            harEntry.setStartedDateTime(new Date());
            har.getLog().addEntry(harEntry);
            z z1 = (z)w;
            capturedOriginalRequest = z1;
            Object obj = createHarRequestForHttpRequest(z1);
            harEntry.setRequest(((HarRequest) (obj)));
            obj = HarCaptureUtil.createHarResponseForFailure();
            ((HarResponse) (obj)).setError(HarCaptureUtil.getNoResponseReceivedErrorMessage());
            harEntry.setResponse(((HarResponse) (obj)));
            captureQueryParameters(z1);
            captureUserAgent(z1);
            captureRequestHeaderSize(z1);
            if (dataToCapture.contains(CaptureType.REQUEST_COOKIES))
                captureRequestCookies(z1);
            if (dataToCapture.contains(CaptureType.REQUEST_HEADERS))
                captureRequestHeaders(z1);
            captureConnectTiming();
        }
        if (w instanceof n)
            captureRequestSize((n)w);
        if (w instanceof ah) {
            w = (ah)w;
            if (dataToCapture.contains(CaptureType.REQUEST_HEADERS))
                captureTrailingHeaders(w);
            if (dataToCapture.contains(CaptureType.REQUEST_CONTENT))
                captureRequestContent(requestCaptureFilter.getHttpRequest(), requestCaptureFilter.getFullRequestContents());
            harEntry.getRequest().setBodySize(requestBodySize.get());
        }
        return null;
    }

    protected void populateAddressFromCache(z z1) {
        String s1 = getHost(z1);
        if (s1 != null && !s1.isEmpty()) {
            z1 = ResolvedHostnameCacheFilter.getPreviouslyResolvedAddressForHost(s1);
            if (z1 != null)
                harEntry.setServerIPAddress(z1);
            else
                log.a("Unable to find cached IP address for host: {}. IP address in HAR entry will be blank.", s1);
        } else {
            log.d("Unable to identify host from request uri: {}", z1.m());
        }
    }

    public void proxyToServerConnectionFailed() {
        HarResponse harresponse = HarCaptureUtil.createHarResponseForFailure();
        harEntry.setResponse(harresponse);
        harresponse.setError(HarCaptureUtil.getConnectionFailedErrorMessage());
        if (connectionStartedNanos > 0L)
            harEntry.getTimings().setConnect(System.nanoTime() - connectionStartedNanos, TimeUnit.NANOSECONDS);
    }

    public void proxyToServerConnectionQueued() {
        connectionQueuedNanos = System.nanoTime();
    }

    public void proxyToServerConnectionStarted() {
        connectionStartedNanos = System.nanoTime();
    }

    public void proxyToServerConnectionSucceeded(k k1) {
        long l = System.nanoTime();
        if (connectionStartedNanos > 0L)
            harEntry.getTimings().setConnect(l - connectionStartedNanos, TimeUnit.NANOSECONDS);
        else
            harEntry.getTimings().setConnect(0L, TimeUnit.NANOSECONDS);
    }

    public void proxyToServerRequestSending() {
        sendStartedNanos = System.nanoTime();
        if (!addressResolved)
            populateAddressFromCache(capturedOriginalRequest);
    }

    public void proxyToServerRequestSent() {
        sendFinishedNanos = System.nanoTime();
        if (sendStartedNanos > 0L)
            harEntry.getTimings().setSend(sendFinishedNanos - sendStartedNanos, TimeUnit.NANOSECONDS);
        else
            harEntry.getTimings().setSend(0L, TimeUnit.NANOSECONDS);
    }

    public void proxyToServerResolutionFailed(String s1) {
        HarResponse harresponse = HarCaptureUtil.createHarResponseForFailure();
        harEntry.setResponse(harresponse);
        harresponse.setError(HarCaptureUtil.getResolutionFailedErrorMessage(s1));
        if (dnsResolutionStartedNanos > 0L)
            harEntry.getTimings().setDns(System.nanoTime() - dnsResolutionStartedNanos, TimeUnit.NANOSECONDS);
    }

    public InetSocketAddress proxyToServerResolutionStarted(String s1) {
        dnsResolutionStartedNanos = System.nanoTime();
        if (connectionQueuedNanos > 0L)
            harEntry.getTimings().setBlocked(dnsResolutionStartedNanos - connectionQueuedNanos, TimeUnit.NANOSECONDS);
        else
            harEntry.getTimings().setBlocked(0L, TimeUnit.NANOSECONDS);
        return null;
    }

    public void proxyToServerResolutionSucceeded(String s1, InetSocketAddress inetsocketaddress) {
        long l = System.nanoTime();
        if (dnsResolutionStartedNanos > 0L)
            harEntry.getTimings().setDns(l - dnsResolutionStartedNanos, TimeUnit.NANOSECONDS);
        else
            harEntry.getTimings().setDns(0L, TimeUnit.NANOSECONDS);
        s1 = inetsocketaddress.getAddress();
        if (s1 != null) {
            addressResolved = true;
            harEntry.setServerIPAddress(s1.getHostAddress());
        }
    }

    public w serverToProxyResponse(w w) {
        if (responseCaptureFilter != null)
            responseCaptureFilter.serverToProxyResponse(w);
        if (w instanceof ac)
            captureResponse((ac)w);
        if (w instanceof n)
            captureResponseSize((n)w);
        if (w instanceof ah) {
            if (dataToCapture.contains(CaptureType.RESPONSE_CONTENT))
                captureResponseContent(responseCaptureFilter.getHttpResponse(), responseCaptureFilter.getFullResponseContents());
            harEntry.getResponse().setBodySize(responseBodySize.get());
        }
        return super.serverToProxyResponse(w);
    }

    public void serverToProxyResponseReceived() {
        long l = System.nanoTime();
        if (responseReceiveStartedNanos > 0L)
            harEntry.getTimings().setReceive(l - responseReceiveStartedNanos, TimeUnit.NANOSECONDS);
        else
            harEntry.getTimings().setReceive(0L, TimeUnit.NANOSECONDS);
    }

    public void serverToProxyResponseReceiving() {
        responseReceiveStartedNanos = System.nanoTime();
        if (sendFinishedNanos > 0L && sendFinishedNanos < responseReceiveStartedNanos)
            harEntry.getTimings().setWait(responseReceiveStartedNanos - sendFinishedNanos, TimeUnit.NANOSECONDS);
        else
            harEntry.getTimings().setWait(0L, TimeUnit.NANOSECONDS);
    }

    public void serverToProxyResponseTimedOut() {
        long l;
        HarResponse harresponse = HarCaptureUtil.createHarResponseForFailure();
        harEntry.setResponse(harresponse);
        harresponse.setError(HarCaptureUtil.getResponseTimedOutErrorMessage());
        l = System.nanoTime();
        if (sendStartedNanos <= 0L || sendFinishedNanos != 0L) goto _L2; else goto _L1
_L1:
        harEntry.getTimings().setSend(l - sendStartedNanos, TimeUnit.NANOSECONDS);
_L4:
        return;
_L2:
        if (sendFinishedNanos > 0L && responseReceiveStartedNanos == 0L)
            harEntry.getTimings().setWait(l - sendFinishedNanos, TimeUnit.NANOSECONDS);
        else
        if (responseReceiveStartedNanos > 0L)
            harEntry.getTimings().setReceive(l - responseReceiveStartedNanos, TimeUnit.NANOSECONDS);
        if (true) goto _L4; else goto _L3
_L3:
    }

}
