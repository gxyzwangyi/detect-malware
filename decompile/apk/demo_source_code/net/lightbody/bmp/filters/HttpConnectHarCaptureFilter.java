// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.lightbody.bmp.filters;

import com.google.common.cache.CacheBuilder;
import com.google.common.cache.b;
import io.netty.channel.d;
import io.netty.channel.k;
import io.netty.handler.codec.http.ac;
import io.netty.handler.codec.http.ag;
import io.netty.handler.codec.http.v;
import io.netty.handler.codec.http.w;
import io.netty.handler.codec.http.z;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.Date;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import net.lightbody.bmp.core.har.Har;
import net.lightbody.bmp.core.har.HarEntry;
import net.lightbody.bmp.core.har.HarLog;
import net.lightbody.bmp.core.har.HarRequest;
import net.lightbody.bmp.core.har.HarResponse;
import net.lightbody.bmp.core.har.HarTimings;
import net.lightbody.bmp.filters.support.HttpConnectTiming;
import net.lightbody.bmp.filters.util.HarCaptureUtil;
import net.lightbody.bmp.util.HttpUtil;
import org.littleshoot.proxy.impl.j;
import org.slf4j.c;

// Referenced classes of package net.lightbody.bmp.filters:
//            HttpsAwareFiltersAdapter, ModifiedRequestAwareFilter, ResolvedHostnameCacheFilter

public class HttpConnectHarCaptureFilter extends HttpsAwareFiltersAdapter
    implements ModifiedRequestAwareFilter {

    private static final int HTTP_CONNECT_TIMING_CONCURRENCY_LEVEL = 50;
    private static final int HTTP_CONNECT_TIMING_EVICTION_SECONDS = 60;
    private static final ConcurrentMap httpConnectTimes;
    private static final org.slf4j.b log = c.a(net/lightbody/bmp/filters/HttpConnectHarCaptureFilter);
    private final InetSocketAddress clientAddress;
    private volatile long connectionQueuedNanos;
    private volatile long connectionStartedNanos;
    private volatile long connectionSucceededTimeNanos;
    private final String currentPageRef;
    private volatile long dnsResolutionFinishedNanos;
    private volatile long dnsResolutionStartedNanos;
    private final Har har;
    private final HttpConnectTiming httpConnectTiming;
    private volatile z modifiedHttpRequest;
    private volatile Date requestStartTime;
    private volatile InetAddress resolvedAddress;
    private volatile long responseReceiveStartedNanos;
    private volatile long sendFinishedNanos;
    private volatile long sendStartedNanos;
    private volatile long sslHandshakeStartedNanos;

    public HttpConnectHarCaptureFilter(z z1, k k1, Har har1, String s) {
        super(z1, k1);
        if (har1 == null)
            throw new IllegalStateException("Attempted har capture when har is null");
        if (!j.c(z1)) {
            throw new IllegalStateException("Attempted HTTP CONNECT har capture on non-HTTP CONNECT request");
        } else {
            har = har1;
            currentPageRef = s;
            clientAddress = (InetSocketAddress)k1.a().g();
            httpConnectTiming = new HttpConnectTiming();
            httpConnectTimes.put(clientAddress, httpConnectTiming);
            return;
        }
    }

    public static HttpConnectTiming consumeConnectTimingForConnection(InetSocketAddress inetsocketaddress) {
        return (HttpConnectTiming)httpConnectTimes.remove(inetsocketaddress);
    }

    private HarEntry createHarEntryForFailedCONNECT(String s) {
        HarEntry harentry = new HarEntry(currentPageRef);
        harentry.setStartedDateTime(requestStartTime);
        harentry.setRequest(createRequestForFailedConnect(originalRequest));
        HarResponse harresponse = HarCaptureUtil.createHarResponseForFailure();
        harentry.setResponse(harresponse);
        harresponse.setError(s);
        populateTimingsForFailedCONNECT(harentry);
        populateServerIpAddress(harentry);
        return harentry;
    }

    private HarRequest createRequestForFailedConnect(z z1) {
        String s = getFullUrl(z1);
        return new HarRequest(z1.l().toString(), s, z1.k().d());
    }

    private void populateServerIpAddress(HarEntry harentry) {
        if (resolvedAddress != null) {
            harentry.setServerIPAddress(resolvedAddress.getHostAddress());
        } else {
            String s = HttpUtil.getHostFromRequest(modifiedHttpRequest);
            if (s != null && !s.isEmpty()) {
                String s1 = ResolvedHostnameCacheFilter.getPreviouslyResolvedAddressForHost(s);
                if (s1 != null)
                    harentry.setServerIPAddress(s1);
                else
                    log.a("Unable to find cached IP address for host: {}. IP address in HAR entry will be blank.", s);
            } else {
                log.d("Unable to identify host from request uri: {}", modifiedHttpRequest.m());
            }
        }
    }

    private void populateTimingsForFailedCONNECT(HarEntry harentry) {
        harentry = harentry.getTimings();
        if (connectionQueuedNanos > 0L && dnsResolutionStartedNanos > 0L)
            harentry.setBlocked(dnsResolutionStartedNanos - connectionQueuedNanos, TimeUnit.NANOSECONDS);
        if (dnsResolutionStartedNanos > 0L && dnsResolutionFinishedNanos > 0L)
            harentry.setDns(dnsResolutionFinishedNanos - dnsResolutionStartedNanos, TimeUnit.NANOSECONDS);
        if (connectionStartedNanos > 0L && connectionSucceededTimeNanos > 0L) {
            harentry.setConnect(connectionSucceededTimeNanos - connectionStartedNanos, TimeUnit.NANOSECONDS);
            if (sslHandshakeStartedNanos > 0L)
                harentry.setSsl(connectionSucceededTimeNanos - sslHandshakeStartedNanos, TimeUnit.NANOSECONDS);
        }
        if (sendStartedNanos > 0L && sendFinishedNanos >= 0L)
            harentry.setSend(sendFinishedNanos - sendStartedNanos, TimeUnit.NANOSECONDS);
        if (sendFinishedNanos > 0L && responseReceiveStartedNanos >= 0L)
            harentry.setWait(responseReceiveStartedNanos - sendFinishedNanos, TimeUnit.NANOSECONDS);
    }

    public ac clientToProxyRequest(w w) {
        if (w instanceof z)
            requestStartTime = new Date();
        return null;
    }

    public void proxyToServerConnectionFailed() {
        HarEntry harentry = createHarEntryForFailedCONNECT(HarCaptureUtil.getConnectionFailedErrorMessage());
        har.getLog().addEntry(harentry);
        if (connectionStartedNanos > 0L)
            harentry.getTimings().setConnect(System.nanoTime() - connectionStartedNanos, TimeUnit.NANOSECONDS);
        httpConnectTimes.remove(clientAddress);
    }

    public void proxyToServerConnectionQueued() {
        connectionQueuedNanos = System.nanoTime();
    }

    public void proxyToServerConnectionSSLHandshakeStarted() {
        sslHandshakeStartedNanos = System.nanoTime();
    }

    public void proxyToServerConnectionStarted() {
        connectionStartedNanos = System.nanoTime();
    }

    public void proxyToServerConnectionSucceeded(k k1) {
        connectionSucceededTimeNanos = System.nanoTime();
        if (connectionStartedNanos > 0L)
            httpConnectTiming.setConnectTimeNanos(connectionSucceededTimeNanos - connectionStartedNanos);
        else
            httpConnectTiming.setConnectTimeNanos(0L);
        if (sslHandshakeStartedNanos > 0L)
            httpConnectTiming.setSslHandshakeTimeNanos(connectionSucceededTimeNanos - sslHandshakeStartedNanos);
        else
            httpConnectTiming.setSslHandshakeTimeNanos(0L);
    }

    public void proxyToServerRequestSending() {
        sendStartedNanos = System.nanoTime();
    }

    public void proxyToServerRequestSent() {
        sendFinishedNanos = System.nanoTime();
    }

    public void proxyToServerResolutionFailed(String s) {
        s = createHarEntryForFailedCONNECT(HarCaptureUtil.getResolutionFailedErrorMessage(s));
        har.getLog().addEntry(s);
        if (dnsResolutionStartedNanos > 0L)
            s.getTimings().setDns(System.nanoTime() - dnsResolutionStartedNanos, TimeUnit.NANOSECONDS);
        httpConnectTimes.remove(clientAddress);
    }

    public InetSocketAddress proxyToServerResolutionStarted(String s) {
        dnsResolutionStartedNanos = System.nanoTime();
        if (connectionQueuedNanos > 0L)
            httpConnectTiming.setBlockedTimeNanos(dnsResolutionStartedNanos - connectionQueuedNanos);
        else
            httpConnectTiming.setBlockedTimeNanos(0L);
        return null;
    }

    public void proxyToServerResolutionSucceeded(String s, InetSocketAddress inetsocketaddress) {
        dnsResolutionFinishedNanos = System.nanoTime();
        if (dnsResolutionStartedNanos > 0L)
            httpConnectTiming.setDnsTimeNanos(dnsResolutionFinishedNanos - dnsResolutionStartedNanos);
        else
            httpConnectTiming.setDnsTimeNanos(0L);
        resolvedAddress = inetsocketaddress.getAddress();
    }

    public void serverToProxyResponseReceiving() {
        responseReceiveStartedNanos = System.nanoTime();
    }

    public void serverToProxyResponseTimedOut() {
        long l;
        HarEntry harentry;
        harentry = createHarEntryForFailedCONNECT(HarCaptureUtil.getResponseTimedOutErrorMessage());
        har.getLog().addEntry(harentry);
        l = System.nanoTime();
        if (sendStartedNanos <= 0L || sendFinishedNanos != 0L) goto _L2; else goto _L1
_L1:
        harentry.getTimings().setSend(l - sendStartedNanos, TimeUnit.NANOSECONDS);
_L4:
        return;
_L2:
        if (sendFinishedNanos > 0L && responseReceiveStartedNanos == 0L)
            harentry.getTimings().setWait(l - sendFinishedNanos, TimeUnit.NANOSECONDS);
        else
        if (responseReceiveStartedNanos > 0L)
            harentry.getTimings().setReceive(l - responseReceiveStartedNanos, TimeUnit.NANOSECONDS);
        if (true) goto _L4; else goto _L3
_L3:
    }

    public void setModifiedHttpRequest(z z1) {
        modifiedHttpRequest = z1;
    }

    static  {
        httpConnectTimes = CacheBuilder.a().a(60L, TimeUnit.SECONDS).a(50).o().a();
    }
}
