// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.lightbody.bmp.filters;

import io.netty.channel.k;
import io.netty.handler.codec.http.*;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import net.lightbody.bmp.util.BrowserMobHttpUtil;
import org.littleshoot.proxy.j;
import org.slf4j.b;
import org.slf4j.c;

public class ServerResponseCaptureFilter extends j {

    private static final b log = c.a(net/lightbody/bmp/filters/ServerResponseCaptureFilter);
    private volatile String contentEncoding;
    private final boolean decompressEncodedContent;
    private volatile boolean decompressionSuccessful;
    private volatile byte fullResponseContents[];
    private volatile ac httpResponse;
    private final ByteArrayOutputStream rawResponseContents;
    private volatile boolean responseCompressed;
    private volatile s trailingHeaders;

    public ServerResponseCaptureFilter(z z1, k k, boolean flag) {
        super(z1, k);
        rawResponseContents = new ByteArrayOutputStream();
        decompressEncodedContent = flag;
    }

    public ServerResponseCaptureFilter(z z1, boolean flag) {
        super(z1);
        rawResponseContents = new ByteArrayOutputStream();
        decompressEncodedContent = flag;
    }

    protected void captureContentEncoding(ac ac1) {
        contentEncoding = s.a(ac1, "Content-Encoding");
    }

    protected void captureFullResponseContents() {
        fullResponseContents = getRawResponseContents();
        if (contentEncoding != null) {
            responseCompressed = true;
            if (decompressEncodedContent)
                decompressContents();
        } else {
            responseCompressed = false;
        }
    }

    protected void captureTrailingHeaders(ah ah1) {
        trailingHeaders = ah1.b();
        if (trailingHeaders != null) {
            ah1 = trailingHeaders.b("Content-Encoding");
            if (ah1 != null)
                contentEncoding = ah1;
        }
    }

    protected void decompressContents() {
        if (!contentEncoding.equals("gzip"))
            break MISSING_BLOCK_LABEL_81;
        fullResponseContents = BrowserMobHttpUtil.decompressContents(getRawResponseContents());
        decompressionSuccessful = true;
_L1:
        return;
        RuntimeException runtimeexception;
        runtimeexception;
        log.c((new StringBuilder()).append("Failed to decompress response with encoding type ").append(contentEncoding).append(" when decoding request from ").append(originalRequest.m()).toString(), runtimeexception);
          goto _L1
        log.d("Cannot decode unsupported content encoding type {}", contentEncoding);
          goto _L1
    }

    public String getContentEncoding() {
        return contentEncoding;
    }

    public byte[] getFullResponseContents() {
        return fullResponseContents;
    }

    public ac getHttpResponse() {
        return httpResponse;
    }

    public byte[] getRawResponseContents() {
        return rawResponseContents.toByteArray();
    }

    public s getTrailingHeaders() {
        return trailingHeaders;
    }

    public boolean isDecompressionSuccessful() {
        boolean flag;
        if (!decompressEncodedContent)
            flag = false;
        else
            flag = decompressionSuccessful;
        return flag;
    }

    public boolean isResponseCompressed() {
        return responseCompressed;
    }

    public w serverToProxyResponse(w w) {
        if (w instanceof ac) {
            httpResponse = (ac)w;
            captureContentEncoding(httpResponse);
        }
        if (w instanceof n) {
            n n1 = (n)w;
            storeResponseContent(n1);
            if (n1 instanceof ah) {
                captureTrailingHeaders((ah)n1);
                captureFullResponseContents();
            }
        }
        return super.serverToProxyResponse(w);
    }

    protected void storeResponseContent(n n1) {
        n1 = BrowserMobHttpUtil.extractReadableBytes(n1.a());
        rawResponseContents.write(n1);
_L2:
        return;
        n1;
        if (true) goto _L2; else goto _L1
_L1:
    }

}
