// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.lightbody.bmp.proxy.dns;

import com.google.common.collect.ImmutableList;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.*;

// Referenced classes of package net.lightbody.bmp.proxy.dns:
//            AdvancedHostResolver

public class ChainedHostResolver
    implements AdvancedHostResolver {

    private final Lock readLock;
    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final List resolvers;
    private final Lock writeLock;

    public ChainedHostResolver(Collection collection) {
        readLock = readWriteLock.readLock();
        writeLock = readWriteLock.writeLock();
        if (collection == null)
            resolvers = Collections.emptyList();
        else
            resolvers = ImmutableList.a(collection);
    }

    public void clearDNSCache() {
        writeLock.lock();
        for (Iterator iterator = resolvers.iterator(); iterator.hasNext(); ((AdvancedHostResolver)iterator.next()).clearDNSCache());
        break MISSING_BLOCK_LABEL_57;
        Exception exception;
        exception;
        writeLock.unlock();
        throw exception;
        writeLock.unlock();
        return;
    }

    public void clearHostRemappings() {
        writeLock.lock();
        for (Iterator iterator = resolvers.iterator(); iterator.hasNext(); ((AdvancedHostResolver)iterator.next()).clearHostRemappings());
        break MISSING_BLOCK_LABEL_57;
        Exception exception;
        exception;
        writeLock.unlock();
        throw exception;
        writeLock.unlock();
        return;
    }

    public Map getHostRemappings() {
        readLock.lock();
        if (!resolvers.isEmpty()) goto _L2; else goto _L1
_L1:
        Map map = Collections.emptyMap();
        readLock.unlock();
_L4:
        return map;
_L2:
        map = ((AdvancedHostResolver)resolvers.get(0)).getHostRemappings();
        readLock.unlock();
        if (true) goto _L4; else goto _L3
_L3:
        Exception exception;
        exception;
        readLock.unlock();
        throw exception;
    }

    public Collection getOriginalHostnames(String s) {
        readLock.lock();
        if (!resolvers.isEmpty()) goto _L2; else goto _L1
_L1:
        s = Collections.emptyList();
        readLock.unlock();
_L4:
        return s;
_L2:
        s = ((AdvancedHostResolver)resolvers.get(0)).getOriginalHostnames(s);
        readLock.unlock();
        if (true) goto _L4; else goto _L3
_L3:
        s;
        readLock.unlock();
        throw s;
    }

    public Collection getResolvers() {
        return ImmutableList.a(resolvers);
    }

    public void remapHost(String s, String s1) {
        writeLock.lock();
        for (Iterator iterator = resolvers.iterator(); iterator.hasNext(); ((AdvancedHostResolver)iterator.next()).remapHost(s, s1));
        break MISSING_BLOCK_LABEL_59;
        s;
        writeLock.unlock();
        throw s;
        writeLock.unlock();
        return;
    }

    public void remapHosts(Map map) {
        writeLock.lock();
        for (Iterator iterator = resolvers.iterator(); iterator.hasNext(); ((AdvancedHostResolver)iterator.next()).remapHosts(map));
        break MISSING_BLOCK_LABEL_58;
        map;
        writeLock.unlock();
        throw map;
        writeLock.unlock();
        return;
    }

    public void removeHostRemapping(String s) {
        writeLock.lock();
        for (Iterator iterator = resolvers.iterator(); iterator.hasNext(); ((AdvancedHostResolver)iterator.next()).removeHostRemapping(s));
        break MISSING_BLOCK_LABEL_58;
        s;
        writeLock.unlock();
        throw s;
        writeLock.unlock();
        return;
    }

    public Collection resolve(String s) {
        readLock.lock();
        Iterator iterator = resolvers.iterator();
_L4:
        if (!iterator.hasNext()) goto _L2; else goto _L1
_L1:
        boolean flag;
        Collection collection;
        collection = ((AdvancedHostResolver)iterator.next()).resolve(s);
        flag = collection.isEmpty();
        if (flag) goto _L4; else goto _L3
_L3:
        readLock.unlock();
        s = collection;
_L6:
        return s;
_L2:
        s = Collections.emptyList();
        readLock.unlock();
        if (true) goto _L6; else goto _L5
_L5:
        s;
        readLock.unlock();
        throw s;
    }

    public void setNegativeDNSCacheTimeout(int i, TimeUnit timeunit) {
        writeLock.lock();
        for (Iterator iterator = resolvers.iterator(); iterator.hasNext(); ((AdvancedHostResolver)iterator.next()).setNegativeDNSCacheTimeout(i, timeunit));
        break MISSING_BLOCK_LABEL_59;
        timeunit;
        writeLock.unlock();
        throw timeunit;
        writeLock.unlock();
        return;
    }

    public void setPositiveDNSCacheTimeout(int i, TimeUnit timeunit) {
        writeLock.lock();
        for (Iterator iterator = resolvers.iterator(); iterator.hasNext(); ((AdvancedHostResolver)iterator.next()).setPositiveDNSCacheTimeout(i, timeunit));
        break MISSING_BLOCK_LABEL_59;
        timeunit;
        writeLock.unlock();
        throw timeunit;
        writeLock.unlock();
        return;
    }
}
