// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.lightbody.bmp.mitm;

import com.google.common.base.Suppliers;
import com.google.common.base.n;
import java.io.File;
import java.io.IOException;
import net.lightbody.bmp.mitm.exception.CertificateSourceException;
import net.lightbody.bmp.mitm.tools.DefaultSecurityProviderTool;
import net.lightbody.bmp.mitm.tools.SecurityProviderTool;
import org.apache.commons.io.b;
import org.slf4j.c;

// Referenced classes of package net.lightbody.bmp.mitm:
//            CertificateAndKeySource, KeyStoreCertificateSource, CertificateAndKey

public class KeyStoreFileCertificateSource
    implements CertificateAndKeySource {

    private static final org.slf4j.b log = c.a(net/lightbody/bmp/mitm/KeyStoreFileCertificateSource);
    private final n certificateAndKey;
    private final String keyStoreClasspathResource;
    private final File keyStoreFile;
    private final String keyStorePassword;
    private final String keyStoreType;
    private final String privateKeyAlias;
    private SecurityProviderTool securityProviderTool;

    public KeyStoreFileCertificateSource(String s, File file, String s1, String s2) {
        securityProviderTool = new DefaultSecurityProviderTool();
        certificateAndKey = Suppliers.a(new n() {

            final KeyStoreFileCertificateSource this$0;

            public volatile Object get() {
                return get();
            }

            public CertificateAndKey get() {
                return loadKeyStore();
            }

             {
                this$0 = KeyStoreFileCertificateSource.this;
                super();
            }
        }
);
        if (file == null)
            throw new IllegalArgumentException("The KeyStore file cannot be null");
        if (s == null)
            throw new IllegalArgumentException("KeyStore type cannot be null");
        if (s1 == null) {
            throw new IllegalArgumentException("Alias of the private key in the KeyStore cannot be null");
        } else {
            keyStoreFile = file;
            keyStoreClasspathResource = null;
            keyStoreType = s;
            keyStorePassword = s2;
            privateKeyAlias = s1;
            return;
        }
    }

    public KeyStoreFileCertificateSource(String s, String s1, String s2, String s3) {
        securityProviderTool = new DefaultSecurityProviderTool();
        certificateAndKey = Suppliers.a(new _cls1());
        if (s1 == null)
            throw new IllegalArgumentException("The classpath location of the KeyStore cannot be null");
        if (s == null)
            throw new IllegalArgumentException("KeyStore type cannot be null");
        if (s2 == null) {
            throw new IllegalArgumentException("Alias of the private key in the KeyStore cannot be null");
        } else {
            keyStoreClasspathResource = s1;
            keyStoreFile = null;
            keyStoreType = s;
            keyStorePassword = s3;
            privateKeyAlias = s2;
            return;
        }
    }

    private CertificateAndKey loadKeyStore() {
        if (keyStoreFile == null) goto _L2; else goto _L1
_L1:
        Object obj1 = securityProviderTool.loadKeyStore(keyStoreFile, keyStoreType, keyStorePassword);
_L4:
        return (new KeyStoreCertificateSource(((java.security.KeyStore) (obj1)), privateKeyAlias, keyStorePassword)).load();
_L2:
        Object obj;
        Object obj2;
        java.security.KeyStore keystore;
        keystore = null;
        obj2 = null;
        obj1 = obj2;
        obj = keystore;
        Object obj3 = net/lightbody/bmp/mitm/KeyStoreFileCertificateSource.getResourceAsStream(keyStoreClasspathResource);
        obj1 = obj2;
        obj = keystore;
        obj2 = File.createTempFile("keystore", "temp");
        obj1 = obj2;
        obj = obj2;
        b.a(((java.io.InputStream) (obj3)), ((File) (obj2)));
        obj1 = obj2;
        obj = obj2;
        keystore = securityProviderTool.loadKeyStore(((File) (obj2)), keyStoreType, keyStorePassword);
        obj = keystore;
        obj1 = obj;
        if (obj2 == null)
            continue; /* Loop/switch isn't completed */
        b.f(((File) (obj2)));
        obj1 = obj;
        continue; /* Loop/switch isn't completed */
        obj1;
        log.d("Unable to delete temporary KeyStore file: {}.", ((File) (obj2)).getAbsoluteFile());
        obj1 = obj;
        if (true) goto _L4; else goto _L3
_L3:
        IOException ioexception1;
        ioexception1;
        obj = obj1;
        obj2 = JVM INSTR new #136 <Class CertificateSourceException>;
        obj = obj1;
        obj3 = JVM INSTR new #138 <Class StringBuilder>;
        obj = obj1;
        ((StringBuilder) (obj3)).StringBuilder();
        obj = obj1;
        ((CertificateSourceException) (obj2)).CertificateSourceException(((StringBuilder) (obj3)).append("Unable to open KeyStore classpath resource: ").append(keyStoreClasspathResource).toString(), ioexception1);
        obj = obj1;
        throw obj2;
        Exception exception;
        exception;
        if (obj != null)
            try {
                b.f(((File) (obj)));
            }
            catch (IOException ioexception) {
                log.d("Unable to delete temporary KeyStore file: {}.", ((File) (obj)).getAbsoluteFile());
            }
        throw exception;
    }

    public KeyStoreFileCertificateSource certificateTool(SecurityProviderTool securityprovidertool) {
        securityProviderTool = securityprovidertool;
        return this;
    }

    public CertificateAndKey load() {
        return (CertificateAndKey)certificateAndKey.get();
    }


}
