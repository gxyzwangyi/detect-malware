// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.lightbody.bmp.mitm.tools;

import com.google.common.a.c;
import java.io.*;
import java.nio.charset.Charset;
import java.security.*;
import java.security.cert.*;
import javax.net.ssl.KeyManager;
import net.lightbody.bmp.mitm.CertificateAndKey;
import net.lightbody.bmp.mitm.CertificateInfo;
import net.lightbody.bmp.mitm.exception.ImportException;
import net.lightbody.bmp.mitm.exception.KeyStoreAccessException;
import net.lightbody.bmp.mitm.util.KeyStoreUtil;

// Referenced classes of package net.lightbody.bmp.mitm.tools:
//            SecurityProviderTool, BouncyCastleSecurityProviderTool

public class DefaultSecurityProviderTool
    implements SecurityProviderTool {

    private final SecurityProviderTool bouncyCastle = new BouncyCastleSecurityProviderTool();

    public DefaultSecurityProviderTool() {
    }

    public CertificateAndKey createCARootCertificate(CertificateInfo certificateinfo, KeyPair keypair, String s) {
        return bouncyCastle.createCARootCertificate(certificateinfo, keypair, s);
    }

    public KeyStore createRootCertificateKeyStore(String s, CertificateAndKey certificateandkey, String s1, String s2) {
        return KeyStoreUtil.createRootCertificateKeyStore(s, certificateandkey.getCertificate(), s1, certificateandkey.getPrivateKey(), s2, null);
    }

    public CertificateAndKey createServerCertificate(CertificateInfo certificateinfo, X509Certificate x509certificate, PrivateKey privatekey, KeyPair keypair, String s) {
        return bouncyCastle.createServerCertificate(certificateinfo, x509certificate, privatekey, keypair, s);
    }

    public KeyStore createServerKeyStore(String s, CertificateAndKey certificateandkey, X509Certificate x509certificate, String s1, String s2) {
        if (s2 == null)
            throw new IllegalArgumentException("KeyStore password cannot be null");
        if (s1 == null)
            throw new IllegalArgumentException("Private key alias cannot be null");
        s = KeyStoreUtil.createEmptyKeyStore(s, null);
        X509Certificate x509certificate1 = certificateandkey.getCertificate();
        try {
            s.setKeyEntry(s1, certificateandkey.getPrivateKey(), s2.toCharArray(), new Certificate[] {
                x509certificate1, x509certificate
            });
        }
        // Misplaced declaration of an exception variable
        catch (String s) {
            throw new KeyStoreAccessException("Error storing impersonated certificate and private key in KeyStore", s);
        }
        return s;
    }

    public X509Certificate decodePemEncodedCertificate(Reader reader) {
        ByteArrayInputStream bytearrayinputstream = JVM INSTR new #89  <Class ByteArrayInputStream>;
        bytearrayinputstream.ByteArrayInputStream(c.a(reader).getBytes(Charset.forName("US-ASCII")));
        reader = CertificateFactory.getInstance("X.509").generateCertificate(bytearrayinputstream);
        if (!(reader instanceof X509Certificate))
            throw new ImportException("Attempted to import non-X.509 certificate as X.509 certificate");
        else
            return (X509Certificate)reader;
        reader;
_L2:
        throw new ImportException("Unable to read PEM-encoded X509Certificate", reader);
        reader;
        if (true) goto _L2; else goto _L1
_L1:
    }

    public PrivateKey decodePemEncodedPrivateKey(Reader reader, String s) {
        return bouncyCastle.decodePemEncodedPrivateKey(reader, s);
    }

    public String encodeCertificateAsPem(Certificate certificate) {
        return bouncyCastle.encodeCertificateAsPem(certificate);
    }

    public String encodePrivateKeyAsPem(PrivateKey privatekey, String s, String s1) {
        return bouncyCastle.encodePrivateKeyAsPem(privatekey, s, s1);
    }

    public KeyManager[] getKeyManagers(KeyStore keystore, String s) {
        return KeyStoreUtil.getKeyManagers(keystore, s, null, null);
    }

    public KeyStore loadKeyStore(File file, String s, String s1) {
        KeyStore keystore;
        try {
            keystore = KeyStore.getInstance(s);
        }
        // Misplaced declaration of an exception variable
        catch (File file) {
            throw new KeyStoreAccessException((new StringBuilder()).append("Unable to get KeyStore instance of type: ").append(s).toString(), file);
        }
        s = JVM INSTR new #158 <Class FileInputStream>;
        s.FileInputStream(file);
        keystore.load(s, s1.toCharArray());
        return keystore;
        s;
        throw new ImportException((new StringBuilder()).append("Unable to read KeyStore from file: ").append(file.getName()).toString(), s);
        file;
_L2:
        throw new ImportException("Error while reading KeyStore", file);
        file;
        if (true) goto _L2; else goto _L1
_L1:
    }

    public void saveKeyStore(File file, KeyStore keystore, String s) {
        try {
            FileOutputStream fileoutputstream = JVM INSTR new #191 <Class FileOutputStream>;
            fileoutputstream.FileOutputStream(file);
            keystore.store(fileoutputstream, s.toCharArray());
            return;
        }
        // Misplaced declaration of an exception variable
        catch (KeyStore keystore) { }
        // Misplaced declaration of an exception variable
        catch (KeyStore keystore) { }
        // Misplaced declaration of an exception variable
        catch (KeyStore keystore) { }
        // Misplaced declaration of an exception variable
        catch (KeyStore keystore) { }
        throw new KeyStoreAccessException((new StringBuilder()).append("Unable to save KeyStore to file: ").append(file.getName()).toString(), keystore);
    }
}
