// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.lightbody.bmp.mitm.manager;

import com.google.common.base.Suppliers;
import com.google.common.base.n;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.ImmutableList;
import io.netty.buffer.i;
import io.netty.handler.codec.http.z;
import io.netty.handler.ssl.ah;
import io.netty.handler.ssl.ai;
import io.netty.handler.ssl.an;
import java.security.KeyPair;
import java.security.cert.X509Certificate;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLSession;
import net.lightbody.bmp.mitm.CertificateAndKey;
import net.lightbody.bmp.mitm.CertificateAndKeySource;
import net.lightbody.bmp.mitm.CertificateInfo;
import net.lightbody.bmp.mitm.CertificateInfoGenerator;
import net.lightbody.bmp.mitm.HostnameCertificateInfoGenerator;
import net.lightbody.bmp.mitm.RootCertificateGenerator;
import net.lightbody.bmp.mitm.TrustSource;
import net.lightbody.bmp.mitm.exception.MitmException;
import net.lightbody.bmp.mitm.exception.SslContextInitializationException;
import net.lightbody.bmp.mitm.keys.ECKeyGenerator;
import net.lightbody.bmp.mitm.keys.KeyGenerator;
import net.lightbody.bmp.mitm.keys.RSAKeyGenerator;
import net.lightbody.bmp.mitm.stats.CertificateGenerationStatistics;
import net.lightbody.bmp.mitm.tools.DefaultSecurityProviderTool;
import net.lightbody.bmp.mitm.tools.SecurityProviderTool;
import net.lightbody.bmp.mitm.util.EncryptionUtil;
import net.lightbody.bmp.mitm.util.MitmConstants;
import net.lightbody.bmp.mitm.util.SslUtil;
import net.lightbody.bmp.util.HttpUtil;
import org.littleshoot.proxy.o;
import org.slf4j.b;
import org.slf4j.c;

public class ImpersonatingMitmManager
    implements o {
    public static class Builder {

        private int cacheConcurrencyLevel;
        private long cacheExpirationIntervalMs;
        private CertificateInfoGenerator certificateInfoGenerator;
        private Collection clientCiphers;
        private CertificateAndKeySource rootCertificateSource;
        private SecurityProviderTool securityProviderTool;
        private Collection serverCiphers;
        private KeyGenerator serverKeyGenerator;
        private String serverMessageDigest;
        private TrustSource trustSource;

        public ImpersonatingMitmManager build() {
            if (clientCiphers == null)
                clientCiphers = SslUtil.getDefaultCipherList();
            if (serverCiphers == null)
                serverCiphers = SslUtil.getDefaultCipherList();
            return new ImpersonatingMitmManager(rootCertificateSource, serverKeyGenerator, serverMessageDigest, trustSource, cacheConcurrencyLevel, cacheExpirationIntervalMs, securityProviderTool, certificateInfoGenerator, serverCiphers, clientCiphers);
        }

        public Builder cacheConcurrencyLevel(int j) {
            cacheConcurrencyLevel = j;
            return this;
        }

        public Builder cacheExpirationInterval(long l, TimeUnit timeunit) {
            cacheExpirationIntervalMs = TimeUnit.MILLISECONDS.convert(l, timeunit);
            return this;
        }

        public Builder certificateInfoGenerator(CertificateInfoGenerator certificateinfogenerator) {
            certificateInfoGenerator = certificateinfogenerator;
            return this;
        }

        public Builder certificateTool(SecurityProviderTool securityprovidertool) {
            securityProviderTool = securityprovidertool;
            return this;
        }

        public Builder clientCiphers(Collection collection) {
            clientCiphers = collection;
            return this;
        }

        public Builder rootCertificateSource(CertificateAndKeySource certificateandkeysource) {
            rootCertificateSource = certificateandkeysource;
            return this;
        }

        public Builder serverCiphers(Collection collection) {
            serverCiphers = collection;
            return this;
        }

        public Builder serverKeyGenerator(KeyGenerator keygenerator) {
            serverKeyGenerator = keygenerator;
            return this;
        }

        public Builder serverMessageDigest(String s) {
            serverMessageDigest = s;
            return this;
        }

        public Builder trustAllServers(boolean flag) {
            if (!flag) goto _L2; else goto _L1
_L1:
            trustSource = null;
_L4:
            return this;
_L2:
            if (trustSource == null)
                trustSource = TrustSource.defaultTrustSource();
            if (true) goto _L4; else goto _L3
_L3:
        }

        public Builder trustSource(TrustSource trustsource) {
            trustSource = trustsource;
            return this;
        }

        public Builder() {
            rootCertificateSource = RootCertificateGenerator.builder().build();
            serverKeyGenerator = new RSAKeyGenerator();
            trustSource = TrustSource.defaultTrustSource();
            cacheConcurrencyLevel = 8;
            cacheExpirationIntervalMs = TimeUnit.MILLISECONDS.convert(5L, TimeUnit.MINUTES);
            serverMessageDigest = MitmConstants.DEFAULT_MESSAGE_DIGEST;
            securityProviderTool = new DefaultSecurityProviderTool();
            certificateInfoGenerator = new HostnameCertificateInfoGenerator();
        }
    }


    private static final b log = c.a(net/lightbody/bmp/mitm/manager/ImpersonatingMitmManager);
    private final CertificateInfoGenerator certificateInfoGenerator;
    private final List clientCipherSuites;
    private n rootCertificate;
    private final CertificateAndKeySource rootCertificateSource;
    private final SecurityProviderTool securityProviderTool;
    private final String serverCertificateMessageDigest;
    private final List serverCipherSuites;
    private final KeyGenerator serverKeyGenerator;
    private final com.google.common.cache.b sslContextCache;
    private final CertificateGenerationStatistics statistics = new CertificateGenerationStatistics();
    private final TrustSource trustSource;
    private final n upstreamServerSslContext = Suppliers.a(new n() {

        final ImpersonatingMitmManager this$0;

        public ah get() {
            return SslUtil.getUpstreamServerSslContext(serverCipherSuites, trustSource);
        }

        public volatile Object get() {
            return get();
        }

             {
                this$0 = ImpersonatingMitmManager.this;
                super();
            }
    }
);

    public ImpersonatingMitmManager(CertificateAndKeySource certificateandkeysource, KeyGenerator keygenerator, String s, TrustSource trustsource, int j, long l, 
            SecurityProviderTool securityprovidertool, CertificateInfoGenerator certificateinfogenerator, Collection collection, Collection collection1) {
        rootCertificate = Suppliers.a(new n() {

            final ImpersonatingMitmManager this$0;

            public volatile Object get() {
                return get();
            }

            public CertificateAndKey get() {
                return rootCertificateSource.load();
            }

             {
                this$0 = ImpersonatingMitmManager.this;
                super();
            }
        }
);
        if (certificateandkeysource == null)
            throw new IllegalArgumentException("CA root certificate source cannot be null");
        if (keygenerator == null)
            throw new IllegalArgumentException("Server key generator cannot be null");
        if (s == null)
            throw new IllegalArgumentException("Server certificate message digest cannot be null");
        if (securityprovidertool == null)
            throw new IllegalArgumentException("The certificate tool implementation cannot be null");
        if (certificateinfogenerator == null) {
            throw new IllegalArgumentException("Certificate info generator cannot be null");
        } else {
            rootCertificateSource = certificateandkeysource;
            trustSource = trustsource;
            serverCertificateMessageDigest = s;
            serverKeyGenerator = keygenerator;
            sslContextCache = CacheBuilder.a().a(j).b(l, TimeUnit.MILLISECONDS).o();
            securityProviderTool = securityprovidertool;
            certificateInfoGenerator = certificateinfogenerator;
            serverCipherSuites = ImmutableList.a(collection);
            log.b("Allowed ciphers for proxy connections to upstream servers (some ciphers may not be available): {}", collection);
            clientCipherSuites = ImmutableList.a(collection1);
            log.b("Allowed ciphers for client connections to proxy (some ciphers may not be available): {}", collection1);
            return;
        }
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builderWithECC() {
        return (new Builder()).serverKeyGenerator(new ECKeyGenerator()).rootCertificateSource(RootCertificateGenerator.builder().keyGenerator(new ECKeyGenerator()).build());
    }

    private ah createImpersonatingSslContext(SSLSession sslsession, String s) {
        sslsession = SslUtil.getServerCertificate(sslsession);
        return createImpersonatingSslContext(certificateInfoGenerator.generate(Collections.singletonList(s), sslsession));
    }

    private ah createImpersonatingSslContext(CertificateInfo certificateinfo) {
        long l1 = System.currentTimeMillis();
        Object obj2 = serverKeyGenerator.generate();
        Object obj = ((CertificateAndKey)rootCertificate.get()).getCertificate();
        Object obj1 = ((CertificateAndKey)rootCertificate.get()).getPrivateKey();
        if (obj == null || obj1 == null)
            throw new IllegalStateException((new StringBuilder()).append("A CA root certificate and private key are required to sign a server certificate. Root certificate was: ").append(obj).append(". Private key was: ").append(obj1).toString());
        if (EncryptionUtil.isEcKey(((KeyPair) (obj2)).getPrivate()) && EncryptionUtil.isRsaKey(((java.security.Key) (obj1))))
            log.c("CA private key is an RSA key and impersonated server private key is an Elliptic Curve key. JDK bug 8136442 may prevent the proxy server from creating connections to clients due to 'no cipher suites in common'.");
        obj1 = securityProviderTool.createServerCertificate(certificateinfo, ((X509Certificate) (obj)), ((java.security.PrivateKey) (obj1)), ((KeyPair) (obj2)), serverCertificateMessageDigest);
        obj2 = ((CertificateAndKey) (obj1)).getCertificate();
        long l;
        try {
            obj = ai.a(((CertificateAndKey) (obj1)).getPrivateKey(), new X509Certificate[] {
                obj2, obj
            }).a(clientCipherSuites, an.a).b();
        }
        // Misplaced declaration of an exception variable
        catch (CertificateInfo certificateinfo) {
            throw new MitmException("Error creating SslContext for connection to client using impersonated certificate and private key", certificateinfo);
        }
        l = System.currentTimeMillis();
        statistics.certificateCreated(l1, l);
        log.b("Impersonated certificate for {} in {}ms", certificateinfo.getCommonName(), Long.valueOf(l - l1));
        return ((ah) (obj));
    }

    private ah getHostnameImpersonatingSslContext(String s, SSLSession sslsession) {
        try {
            com.google.common.cache.b b1 = sslContextCache;
            Callable callable = JVM INSTR new #12  <Class ImpersonatingMitmManager$3>;
            callable.this. _cls3();
            sslsession = (ah)b1.a(s, callable);
        }
        // Misplaced declaration of an exception variable
        catch (SSLSession sslsession) {
            throw new SslContextInitializationException((new StringBuilder()).append("An error occurred while impersonating the remote host: ").append(s).toString(), sslsession);
        }
        return sslsession;
    }

    public SSLEngine clientSslEngineFor(z z, SSLSession sslsession) {
        z = HttpUtil.getHostFromRequest(z);
        try {
            sslsession = getHostnameImpersonatingSslContext(z, sslsession).a(i.a);
        }
        // Misplaced declaration of an exception variable
        catch (SSLSession sslsession) {
            throw new MitmException((new StringBuilder()).append("Error creating SSLEngine for connection to client to impersonate upstream host: ").append(z).toString(), sslsession);
        }
        return sslsession;
    }

    public CertificateGenerationStatistics getStatistics() {
        return statistics;
    }

    public SSLEngine serverSslEngine() {
        SSLEngine sslengine;
        try {
            sslengine = ((ah)upstreamServerSslContext.get()).a(i.a);
        }
        catch (RuntimeException runtimeexception) {
            throw new MitmException("Error creating SSLEngine for connection to upstream server", runtimeexception);
        }
        return sslengine;
    }

    public SSLEngine serverSslEngine(String s, int j) {
        SSLEngine sslengine;
        try {
            sslengine = ((ah)upstreamServerSslContext.get()).a(i.a, s, j);
            SSLParameters sslparameters = JVM INSTR new #381 <Class SSLParameters>;
            sslparameters.SSLParameters();
            if (android.os.Build.VERSION.SDK_INT >= 24)
                sslparameters.setEndpointIdentificationAlgorithm("HTTPS");
            sslengine.setSSLParameters(sslparameters);
        }
        catch (RuntimeException runtimeexception) {
            throw new MitmException((new StringBuilder()).append("Error creating SSLEngine for connection to upstream server: ").append(s).append(":").append(j).toString(), runtimeexception);
        }
        return sslengine;
    }






    // Unreferenced inner class net/lightbody/bmp/mitm/manager/ImpersonatingMitmManager$3

/* anonymous class */
    class _cls3
        implements Callable {

        final ImpersonatingMitmManager this$0;
        final String val$hostnameToImpersonate;
        final SSLSession val$sslSession;

        public ah call() {
            return createImpersonatingSslContext(sslSession, hostnameToImpersonate);
        }

        public volatile Object call() {
            return call();
        }

             {
                this$0 = ImpersonatingMitmManager.this;
                sslSession = sslsession;
                hostnameToImpersonate = s;
                super();
            }
    }

}
