// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.lightbody.bmp.mitm;

import com.google.common.base.Suppliers;
import com.google.common.base.n;
import java.io.File;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.text.SimpleDateFormat;
import java.util.Date;
import net.lightbody.bmp.mitm.keys.KeyGenerator;
import net.lightbody.bmp.mitm.keys.RSAKeyGenerator;
import net.lightbody.bmp.mitm.tools.DefaultSecurityProviderTool;
import net.lightbody.bmp.mitm.tools.SecurityProviderTool;
import net.lightbody.bmp.mitm.util.EncryptionUtil;
import net.lightbody.bmp.mitm.util.MitmConstants;
import org.slf4j.b;
import org.slf4j.c;

// Referenced classes of package net.lightbody.bmp.mitm:
//            CertificateAndKeySource, CertificateAndKey, CertificateInfo

public class RootCertificateGenerator
    implements CertificateAndKeySource {
    public static class Builder {

        private CertificateInfo certificateInfo;
        private KeyGenerator keyGenerator;
        private String messageDigest;
        private SecurityProviderTool securityProviderTool;

        public RootCertificateGenerator build() {
            return new RootCertificateGenerator(certificateInfo, messageDigest, keyGenerator, securityProviderTool);
        }

        public Builder certificateInfo(CertificateInfo certificateinfo) {
            certificateInfo = certificateinfo;
            return this;
        }

        public Builder certificateTool(SecurityProviderTool securityprovidertool) {
            securityProviderTool = securityprovidertool;
            return this;
        }

        public Builder keyGenerator(KeyGenerator keygenerator) {
            keyGenerator = keygenerator;
            return this;
        }

        public Builder messageDigest(String s) {
            messageDigest = s;
            return this;
        }

        public Builder() {
            certificateInfo = (new CertificateInfo()).commonName(RootCertificateGenerator.getDefaultCommonName()).organization("CA dynamically generated by LittleProxy").notBefore(new Date(System.currentTimeMillis() - 0x57b12c00L)).notAfter(new Date(System.currentTimeMillis() + 0x57b12c00L));
            keyGenerator = new RSAKeyGenerator();
            messageDigest = MitmConstants.DEFAULT_MESSAGE_DIGEST;
            securityProviderTool = new DefaultSecurityProviderTool();
        }
    }


    private static final String DEFAULT_PEM_ENCRYPTION_ALGORITHM = "AES-128-CBC";
    private static final b log = c.a(net/lightbody/bmp/mitm/RootCertificateGenerator);
    private final n generatedCertificateAndKey = Suppliers.a(new n() {

        final RootCertificateGenerator this$0;

        public volatile Object get() {
            return get();
        }

        public CertificateAndKey get() {
            return generateRootCertificate();
        }

             {
                this$0 = RootCertificateGenerator.this;
                super();
            }
    }
);
    private final KeyGenerator keyGenerator;
    private final String messageDigest;
    private final CertificateInfo rootCertificateInfo;
    private final SecurityProviderTool securityProviderTool;

    public RootCertificateGenerator(CertificateInfo certificateinfo, String s, KeyGenerator keygenerator, SecurityProviderTool securityprovidertool) {
        if (certificateinfo == null)
            throw new IllegalArgumentException("CA root certificate cannot be null");
        if (s == null)
            throw new IllegalArgumentException("Message digest cannot be null");
        if (keygenerator == null)
            throw new IllegalArgumentException("Key generator cannot be null");
        if (securityprovidertool == null) {
            throw new IllegalArgumentException("Certificate tool cannot be null");
        } else {
            rootCertificateInfo = certificateinfo;
            messageDigest = s;
            keyGenerator = keygenerator;
            securityProviderTool = securityprovidertool;
            return;
        }
    }

    public static Builder builder() {
        return new Builder();
    }

    private CertificateAndKey generateRootCertificate() {
        long l1 = System.currentTimeMillis();
        Object obj = keyGenerator.generate();
        obj = securityProviderTool.createCARootCertificate(rootCertificateInfo, ((java.security.KeyPair) (obj)), messageDigest);
        long l = System.currentTimeMillis();
        log.c("Generated CA root certificate and private key in {}ms. Key generator: {}. Signature algorithm: {}.", new Object[] {
            Long.valueOf(l - l1), keyGenerator, messageDigest
        });
        return ((CertificateAndKey) (obj));
    }

    private static String getDefaultCommonName() {
        Object obj;
        String s;
        try {
            obj = InetAddress.getLocalHost().getHostName();
        }
        // Misplaced declaration of an exception variable
        catch (Object obj) {
            obj = "localhost";
        }
        s = (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss zzz")).format(new Date());
        obj = (new StringBuilder()).append("Generated CA (").append(((String) (obj))).append(") ").append(s).toString();
        if (((String) (obj)).length() > 64)
            obj = ((String) (obj)).substring(0, 63);
        return ((String) (obj));
    }

    public String encodePrivateKeyAsPem(String s) {
        return securityProviderTool.encodePrivateKeyAsPem(((CertificateAndKey)generatedCertificateAndKey.get()).getPrivateKey(), s, "AES-128-CBC");
    }

    public String encodeRootCertificateAsPem() {
        return securityProviderTool.encodeCertificateAsPem(((CertificateAndKey)generatedCertificateAndKey.get()).getCertificate());
    }

    public CertificateAndKey load() {
        return (CertificateAndKey)generatedCertificateAndKey.get();
    }

    public void savePrivateKeyAsPemFile(File file, String s) {
        EncryptionUtil.writePemStringToFile(file, securityProviderTool.encodePrivateKeyAsPem(((CertificateAndKey)generatedCertificateAndKey.get()).getPrivateKey(), s, "AES-128-CBC"));
    }

    public void saveRootCertificateAndKey(String s, File file, String s1, String s2) {
        CertificateAndKey certificateandkey = (CertificateAndKey)generatedCertificateAndKey.get();
        s = securityProviderTool.createRootCertificateKeyStore(s, certificateandkey, s1, s2);
        securityProviderTool.saveKeyStore(file, s, s2);
    }

    public void saveRootCertificateAsPemFile(File file) {
        EncryptionUtil.writePemStringToFile(file, securityProviderTool.encodeCertificateAsPem(((CertificateAndKey)generatedCertificateAndKey.get()).getCertificate()));
    }



}
