// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) fieldsfirst nonlb space 

package net.gotev.uploadservice.a.a;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.*;
import javax.net.ssl.HttpsURLConnection;
import net.gotev.uploadservice.*;
import net.gotev.uploadservice.a.a;

public class b
    implements a {

    private static final String a = net/gotev/uploadservice/a/a/b.getSimpleName();
    private HttpURLConnection b;

    public b(String s, String s1, boolean flag, boolean flag1, int i, int j) {
        Logger.c(getClass().getSimpleName(), "creating new connection");
        s1 = new URL(s1);
        if (s1.getProtocol().equals("https"))
            b = (HttpsURLConnection)s1.openConnection();
        else
            b = (HttpURLConnection)s1.openConnection();
        b.setDoInput(true);
        b.setDoOutput(true);
        b.setConnectTimeout(i);
        b.setReadTimeout(j);
        b.setUseCaches(flag1);
        b.setInstanceFollowRedirects(flag);
        b.setRequestMethod(s);
    }

    private byte[] a(InputStream inputstream) {
        ByteArrayOutputStream bytearrayoutputstream;
        byte abyte0[];
        bytearrayoutputstream = new ByteArrayOutputStream();
        abyte0 = new byte[UploadService.f];
_L1:
        int i = inputstream.read(abyte0, 0, abyte0.length);
        if (i <= 0)
            break MISSING_BLOCK_LABEL_42;
        bytearrayoutputstream.write(abyte0, 0, i);
          goto _L1
        inputstream;
        return bytearrayoutputstream.toByteArray();
    }

    public int a() {
        return b.getResponseCode();
    }

    public void a(List list, boolean flag, long l) {
        NameValue namevalue;
        if (flag) {
            if (android.os.Build.VERSION.SDK_INT >= 19) {
                b.setFixedLengthStreamingMode(l);
            } else {
                if (l > 0x7fffffffL)
                    throw new RuntimeException("You need Android API version 19 or newer to upload more than 2GB in a single request using fixed size content length. Try switching to chunked mode instead, but make sure your server side supports it!");
                b.setFixedLengthStreamingMode((int)l);
            }
        } else {
            b.setChunkedStreamingMode(0);
        }
        for (list = list.iterator(); list.hasNext(); b.setRequestProperty(namevalue.a(), namevalue.b()))
            namevalue = (NameValue)list.next();

    }

    public void a(byte abyte0[]) {
        b.getOutputStream().write(abyte0, 0, abyte0.length);
    }

    public void a(byte abyte0[], int i) {
        b.getOutputStream().write(abyte0, 0, i);
    }

    public byte[] b() {
        InputStream inputstream;
        InputStream inputstream1;
        inputstream = null;
        inputstream1 = inputstream;
        if (b.getResponseCode() / 100 != 2) goto _L2; else goto _L1
_L1:
        inputstream1 = inputstream;
        inputstream = b.getInputStream();
_L4:
        inputstream1 = inputstream;
        byte abyte0[] = a(inputstream);
        if (inputstream != null)
            try {
                inputstream.close();
            }
            catch (Exception exception) {
                Logger.a(a, "Error while closing server response stream", exception);
            }
        return abyte0;
_L2:
        inputstream1 = inputstream;
        inputstream = b.getErrorStream();
        if (true) goto _L4; else goto _L3
_L3:
        Exception exception1;
        exception1;
        if (inputstream1 != null)
            try {
                inputstream1.close();
            }
            catch (Exception exception2) {
                Logger.a(a, "Error while closing server response stream", exception2);
            }
        throw exception1;
    }

    public LinkedHashMap c() {
        Object obj = b.getHeaderFields();
        LinkedHashMap linkedhashmap;
        if (obj == null) {
            linkedhashmap = null;
        } else {
            linkedhashmap = new LinkedHashMap(((Map) (obj)).size());
            obj = ((Map) (obj)).entrySet().iterator();
            while (((Iterator) (obj)).hasNext())  {
                java.util.Map.Entry entry = (java.util.Map.Entry)((Iterator) (obj)).next();
                if (entry.getKey() != null) {
                    StringBuilder stringbuilder = new StringBuilder();
                    for (Iterator iterator = ((List)entry.getValue()).iterator(); iterator.hasNext(); stringbuilder.append((String)iterator.next()));
                    linkedhashmap.put(entry.getKey(), stringbuilder.toString());
                }
            }
        }
        return linkedhashmap;
    }

    public void d() {
        Logger.c(getClass().getSimpleName(), "closing connection");
        if (b == null)
            break MISSING_BLOCK_LABEL_56;
        Exception exception;
        try {
            b.getInputStream().close();
        }
        catch (Exception exception2) { }
        try {
            b.getOutputStream().flush();
            b.getOutputStream().close();
        }
        catch (Exception exception1) { }
        b.disconnect();
_L1:
        return;
        exception;
        Logger.a(a, "Error while closing connection", exception);
          goto _L1
    }

}
