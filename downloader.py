#!/usr/bin/env python
#coding:utf-8

import sys
import threading
import sqlite3
import time
# import urllib.request
import os
import hashlib
import signal
import queue
# from urllib.request import urlopen
import urllib.request

# import urllib.error
NUM_THREAD = 20
work_queue_lock = threading.Lock()
update_database_lock = threading.Lock()
update_error_lock = threading.Lock()


class Downloader(threading.Thread):
    def __init__(self, work_queue,code_queue ,output_dir, database_filepath):
        threading.Thread.__init__(self)
        self.exit_event = threading.Event()
        self.work_queue = work_queue
        self.code_queue = code_queue
        self.proxies = None
        #Define proxy below
        #self.proxies = {"http": ""}
        self.output_dir = output_dir
        self.current_file_size = 0
        self.file_size = 0
        self.database_filepath = database_filepath
        self.new_output_path=""

    def exit(self):
        print("%s: asked to exit." % self.getName())
        self.exit_event.set()
        self.join()
        return self.report()

    def report(self):
        if self.file_size == 0:
            return 0
        return float(self.current_file_size) / self.file_size

    def run(self):
        while not self.exit_event.isSet():
            work_queue_lock.acquire()
            if not self.work_queue.empty():
                self.url = self.work_queue.get()
                self.code = self.code_queue.get()
                work_queue_lock.release()
                try:
                    self.download()
                    self.save()
                    self.update_database()
                    # self.delete_html()
                except Exception as e:
                    self.update_database(-1)
                    self.update_error(str(e))
            else:
                work_queue_lock.release()
        print("%s: received exit event." % self.getName())

    def download(self):
        print("%s: downloading %s is %s" % (self.getName(), self.url,self.code))
        self.current_file_size = 0
        self.file_size = 0
        proxy_handler = urllib.request.ProxyHandler()
        if (self.proxies):
            proxy_handler = urllib.request.proxyHandler(self.proxies);
        opener = urllib.request.build_opener(proxy_handler)
        opener.addheaders = [
            ('User-Agent', r"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 "
                "(KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11"),
            ('Referer', self.url)
        ]
        urllib.request.install_opener(opener)
        opening = urllib.request.urlopen(self.url,timeout=5)
        meta = opening.info()
        if "android" in meta.get_all("Content-Type")[0]:
            self.file_size = int(meta.get_all("Content-Length")[0])
            temp_file_name = "temp%s.apk" % (self.code)
            temp_dir = self.output_dir + os.sep + "temp"
            self.temp_output_path = temp_dir + os.sep + temp_file_name
            with open(self.temp_output_path, 'wb') as fil:
                block_size = 102400
                while True:
                    buf = opening.read(block_size)
                    self.current_file_size += len(buf)
                    fil.write(buf)
                    if not buf:
                        break

    def save(self):
        # with open(self.temp_output_path, 'r') as fil:
        #     m = hashlib.md5()
        #     m.update(fil.read())
        #     md5_digest = m.hexdigest()

            # new_output_path = self.output_dir + os.sep + md5_digest + ".apk"
        new_output_path = self.output_dir + os.sep + self.code + ".apk"

        if os.path.isfile(new_output_path):
            os.remove(new_output_path)
        os.rename(self.temp_output_path, new_output_path)
        self.new_output_path = new_output_path
        print("%s: %s.apk is completed." % (self.getName(), self.code))

    def delete_html(self):
        if os.path.getsize(self.new_output_path)<1024*20:
            os.remove(self.new_output_path)
            raise NameError('NO APK')
        else:
            pass




    def update_database(self, result=1):
        update_database_lock.acquire()
        try:
            connection = sqlite3.connect(self.database_filepath)
            cursor = connection.cursor()
            cursor.execute('update apps set downloaded = ? where download_url = ?',
                    (result, self.url))
            connection.commit()
        except sqlite3.OperationalError:
            print("%s: Operational Error" % (self.getName()))
        finally:
            connection.close()
            update_database_lock.release()

    def update_error(self,error):
        update_error_lock.acquire()
        try:
            connection = sqlite3.connect(self.database_filepath)
            cursor = connection.cursor()
            cursor.execute('update apps set error = ? where download_url = ?',
                    (error, self.url))
            connection.commit()
        except sqlite3.OperationalError:
            print("%s: Operational Error" % (self.getName()))
        finally:
            connection.close()
            update_error_lock.release()





class Monitor(threading.Thread):
    def __init__(self, threads):
        threading.Thread.__init__(self)
        self.threads = threads
        self.exit_event = threading.Event()
    def exit(self):
        self.exit_event.set()
        self.join()
    def run(self):
        while not self.exit_event.isSet():
            for t in self.threads:
                if t.report() == 0:
                    print(" new"),
                else:
                    print("%3.0f%%" % (t.report()*100)),
            print("")
            time.sleep(1)

def get_undownloaded_url(database_filepath):
    undownloaded_urls = []
    try:
        connection = sqlite3.connect(database_filepath)
        cursor = connection.cursor()
        sql = "select * from urls "
        cursor.execute(sql)
        records = cursor.fetchall()
        undownloaded_urls = [r[14] for r in records]
        undownloaded_code = [r[7] for r in records]
    except sqlite3.OperationalError as e:
        print(e)
    finally:
        connection.close()
    return undownloaded_urls,undownloaded_code

def fill_work_queue(work_queue, code_queue,undownloaded_urls,undownloaded_code):
    for u,v in zip(undownloaded_urls,undownloaded_code):
        work_queue.put(u)
        code_queue.put(v)

def import_work(work_queue, code_queue,database_filepath):
    undownloaded_urls,undownloaded_code = get_undownloaded_url(database_filepath)

    fill_work_queue(work_queue,code_queue, undownloaded_urls,undownloaded_code)
    return len(undownloaded_urls)

class Watcher:
    """this class solves two problems with multithreaded
    programs in Python, (1) a signal might be delivered
    to any thread (which is just a malfeature) and (2) if
    the thread that gets the signal is waiting, the signal
    is ignored (which is a bug).

    The watcher is a concurrent process (not thread) that
    waits for a signal and the process that contains the
    threads.  See Appendix A of The Little Book of Semaphores.
    http://greenteapress.com/semaphores/

    I have only tested this on Linux.  I would expect it to
    work on the Macintosh and not work on Windows.

    Refer to: http://code.activestate.com/recipes/496735-workaround-for-missed-sigint-in-multithreaded-prog/
    """

    def __init__(self):
        """ Creates a child thread, which returns.  The parent
            thread waits for a KeyboardInterrupt and then kills
            the child thread.
        """
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()

    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            # I put the capital B in KeyBoardInterrupt so I can
            # tell when the Watcher gets the SIGINT
            print("KeyBoardInterrupt")
            self.kill()
        sys.exit()

    def kill(self):
        try:
            os.kill(self.child, signal.SIGKILL)
        except OSError: pass

def main():
    # if len(sys.argv) < 2:
    #     print("Usage: %s <SQLite database> <output directory>" % (sys.argv[0]))
    #     sys.exit(1)
    # else:
    database_filepath = "test.db"
    output_dir = "a"

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    temp_dir = output_dir + os.sep + "temp"
    if not os.path.exists(temp_dir):
        os.makedirs(temp_dir)
    Watcher()
    threads = []
    work_queue = queue.Queue()
    code_queue = queue.Queue()
    for i in range(NUM_THREAD):
        t = Downloader(work_queue, code_queue,output_dir, database_filepath)
        t.daemon = True
        t.start()
        threads.append(t)
    monitor_thread = Monitor(threads)
    monitor_thread.daemon = True
    monitor_thread.start()

    exit_flag = 0
    while exit_flag < 2:
        import_work(work_queue, code_queue,database_filepath)
        if work_queue.empty():
            exit_flag += 1
        else:
            exit_flag = 0
        while not work_queue.empty():
            time.sleep(10)
    for t in threads:
        t.exit()
    monitor_thread.exit()

if __name__ == '__main__':
    main()
