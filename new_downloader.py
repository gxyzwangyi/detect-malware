#coding:utf-8

import hashlib
import binascii
# import urllib.error
import os
# import sqlalchemy.exc
# from sqlalchemy import create_engine
# from sqlalchemy.ext.declarative import declarative_base
# from sqlalchemy.orm import sessionmaker
# import sqlalchemy.orm.exc
# from db import APKdata, Downloaded, Base, engine, session, Session, Errors
import os.path
import lxml.html
import urllib.request
import sys
import socket
import logging
import argparse
import time
import MySQLdb
import sqlite3
# import http.client
import requests
from bs4 import BeautifulSoup
from optparse import OptionParser
# from wget import wget
import threading
import signal
import queue

#(name,description,introduce,version,download_number,apk_url,serial_number,category,category_num,package_name,keywords,size,download_icon,download_url)
NUM_THREAD = 20
update_database_lock = threading.Lock()
update_error_lock = threading.Lock()
work_queue_lock = threading.Lock()


class Url(threading.Thread):
    def __init__(self, db,work_queue,tablename):
        threading.Thread.__init__(self)
        self.db = db
        self.tablename=tablename
        self.work_queue = work_queue
        self.exit_event = threading.Event()
        self.current_file_size = 0
        self.file_size = 0
    def exit(self):
        print("%s: asked to exit." % self.getName())
        self.exit_event.set()
        self.join()
        return self.report()
    def report(self):
        if self.file_size == 0:
            return 0
        return float(self.current_file_size) / self.file_size

    def get_apk_content(self,url):
        r=requests.get(url,allow_redirects=False)
        soup= BeautifulSoup(r.content,"html.parser",from_encoding='GB18030')
        if soup.title.string=="":
            return 0,0
        else:
            try:
                
                name = soup.select(".content-right")[0].h1.text
                #description=soup.select("meta")[2].get("content")[0:(lambda x:x.index('，'))(soup.select("meta")[2].get("content"))].replace("'","")
                time = time.strftime('%Y-%m-%d-%H-%I-%M-%S',time.localtime(time.time()))
                introduce=soup.select(".introduction")[0].select('.brief-long')[0].text.replace("'","")
                version= soup.select(".content-right")[0].select(".detail")[0].select(".version")[0].text[4::]
                download_number=soup.select(".content-right")[0].select(".detail")[0].select(".download-num")[0].text[6::]
                apk_url=soup.find_all(rel="canonical")[0].get("href")
                serial_number=apk_url[(lambda x:x.index('e/'))(apk_url)+2:-5]
                category=soup.select(".app-nav")[0].select(".nav")[0].find_all('a')[-1].text
                category_num=soup.select(".app-nav")[0].select(".nav")[0].find_all('a')[-1].get("href")
                package_name=soup.select(".one-setup-btn")[0].get("data_package")
                keywords=soup.select("meta")[1].get("content").replace("'","")
                size=soup.select(".one-setup-btn")[0].get("data_size")
                download_icon=soup.select(".one-setup-btn")[0].get("data_icon")
                download_url=soup.select(".area-download")[0].a["href"]
                downloaded=0
                error=""
            except Exception as ex:
                desc=str(ex)
                return 0
            apk_list=[name,time,introduce,version,download_number,apk_url,serial_number,category,category_num,package_name,keywords,size,download_icon,download_url,downloaded,error]   
            return apk_list 
            
    def run(self):
        while not self.exit_event.isSet():
            work_queue_lock.acquire()
            if not self.work_queue.empty():
                self.url = self.work_queue.get()
                work_queue_lock.release()
                try:
                    self.insert_db()
                except urllib.request.HTTPError:
                    pass
            else:
                work_queue_lock.release()
        print("%s: received exit event." % self.getName())

    def insert_db(self):    
        insertTable=self.tablename
        apk_content_list=self.get_apk_content(self.url)
        if apk_content_list!=0:
            self.db.inserttable(insertTable,apk_content_list)

                                    
class DB:     

    def __init__(self,_dbname,_tbname):
        self._dbname=_dbname
        self._tbname=_tbname


        
     #连接数据库 mysql
    def connectDB(self):
        conn = sqlite3.connect(self._dbname)
        return conn

      #创建表，SQL语言。CREATE TABLE IF NOT EXISTS 表示：表createTableName不存在时就创建
    def creatTable(self):
        createTableSql="CREATE TABLE IF NOT EXISTS  "+ self._tbname+""" ( aid integer PRIMARY KEY autoincrement, name VARCHAR(40), time VARCHAR(200) , introduce  VARCHAR(2000),version VARCHAR(40),download_number VARCHAR(10),  apk_url VARCHAR(100), serial_number VARCHAR(40), category VARCHAR(40), category_num VARCHAR(40),package_name VARCHAR(20),keywords VARCHAR(100),size VARCHAR(20), download_icon  VARCHAR(100), download_url VARCHAR(100),downloaded VARCHAR(5),error VARCHAR(40) )"""
        print(createTableSql)
        DB_create=self.connectDB()
        # cursor_create=DB_create.cursor()
        # cursor_create.execute(createTableSql)
        DB_create.execute(createTableSql)
        DB_create.close()
        print ('creat table '+self._tbname+' successfully' )
        return self._tbname 

    #数据插入表中
    def inserttable(self,insertlist):
        #print(insertlist)
        [insertname,inserttime,insertintroduce,insertversion,insertdownload_number,insertapk_url,insertserial_number,insertcategory,insertcategory_num,insertpackage_name,insertkeywords,insertsize,insertdownload_icon,insertdownload_url,insertdownloaded,inserterror]=insertlist
        insertContentSql="INSERT INTO "+self._tbname+" (aid,name,time,introduce,version,download_number,apk_url,serial_number,category,category_num,package_name,keywords,size,download_icon,download_url,downloaded,error) VALUES (NULL,'%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s')"
        DB_insert=self.connectDB()
        # cursor_insert=DB_insert.cursor()     
        str1=insertContentSql % (insertname,inserttime,insertintroduce,insertversion,insertdownload_number,insertapk_url,insertserial_number,insertcategory,insertcategory_num,insertpackage_name,insertkeywords,insertsize,insertdownload_icon,insertdownload_url,insertdownloaded,inserterror)
        # print(str1)

        DB_insert.execute(str1)
        DB_insert.commit()
        DB_insert.close()
        # print ('insert contents to  '+insertTable+' successfully'  )




    def readlast(self):
        """
        多线程的情况下经常下载会不按照顺序，于是每次取上次下载完的最后一个值不一定是最大的，所以需要取最后20个再取出最大的用于下一次下载的start，以防下载重复
        """
        DB_select=self.connectDB()
        cur = DB_select.cursor()
        selectSql="SELECT serial_number from "+self._tbname+" order by aid DESC limit 20"
        cur.execute(selectSql )
        last_id=max(cur.fetchall())[0]
        print(last_id)
        return last_id


class Downloader(threading.Thread):
    def __init__(self, work_queue,code_queue ,output_dir, database_filepath,tablename):
        threading.Thread.__init__(self)
        self.exit_event = threading.Event()
        self.work_queue = work_queue
        self.code_queue = code_queue
        self.proxies = None
        self.tablename=tablename
        #Define proxy below
        #self.proxies = {"http": ""}
        self.output_dir = output_dir
        self.current_file_size = 0
        self.file_size = 0
        self.database_filepath = database_filepath
        self.new_output_path=""

    def exit(self):
        print("%s: asked to exit." % self.getName())
        self.exit_event.set()
        self.join()
        return self.report()

    def report(self):
        if self.file_size == 0:
            return 0
        return float(self.current_file_size) / self.file_size

    def run(self):
        while not self.exit_event.isSet():
            work_queue_lock.acquire()
            if not self.work_queue.empty():
                self.url = self.work_queue.get()
                self.code = self.code_queue.get()
                work_queue_lock.release()
                try:
                    self.download()
                    self.save()
                    self.update_database()
                    self.delete_html()
                except Exception as e:
                    self.update_database(-1)
                    self.update_error(str(e))
            else:
                work_queue_lock.release()
        print("%s: received exit event." % self.getName())

    def download(self):
        print("%s: downloading %s is %s" % (self.getName(), self.url,self.code))
        self.current_file_size = 0
        self.file_size = 0
        proxy_handler = urllib.request.ProxyHandler()
        if (self.proxies):
            proxy_handler = urllib.request.proxyHandler(self.proxies);
        opener = urllib.request.build_opener(proxy_handler)
        opener.addheaders = [
            ('User-Agent', r"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 "
                "(KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11"),
            ('Referer', self.url)
        ]
        urllib.request.install_opener(opener)
        opening = urllib.request.urlopen(self.url,timeout=5)
        meta = opening.info()
        self.file_size = int(meta.get_all("Content-Length")[0])
        temp_file_name = "temp%s.apk" % (self.code)
        temp_dir = self.output_dir + os.sep + "temp"
        self.temp_output_path = temp_dir + os.sep + temp_file_name
        with open(self.temp_output_path, 'wb') as fil:
            block_size = 10240
            while True:
                buf = opening.read(block_size)
                self.current_file_size += len(buf)
                fil.write(buf)
                if not buf:
                    break

    def save(self):
        # with open(self.temp_output_path, 'r') as fil:
        #     m = hashlib.md5()
        #     m.update(fil.read())
        #     md5_digest = m.hexdigest()

            # new_output_path = self.output_dir + os.sep + md5_digest + ".apk"
        new_output_path = self.output_dir + os.sep + self.code + ".apk"

        if os.path.isfile(new_output_path):
            os.remove(new_output_path)
        os.rename(self.temp_output_path, new_output_path)
        self.new_output_path = new_output_path
        print("%s: %s.apk is completed." % (self.getName(), self.code))

    def delete_html(self):
        if os.path.getsize(self.new_output_path)<1024*20:
            os.remove(self.new_output_path)
            raise NameError('NO APK')
        else:
            pass




    def update_database(self, result=1):
        update_database_lock.acquire()
        try:
            connection = sqlite3.connect(self.database_filepath)
            cursor = connection.cursor()
            cursor.execute('update '+self.tablename+' set downloaded = ? where download_url = ?',
                    (result, self.url))
            connection.commit()
        except sqlite3.OperationalError:
            print("%s: Operational Error" % (self.getName()))
        finally:
            connection.close()
            update_database_lock.release()

    def update_error(self,error):
    
        update_error_lock.acquire()
        try:
            connection = sqlite3.connect(self.database_filepath)
            cursor = connection.cursor()
            cursor.execute('update '+self.tablename+' set error = ? where download_url = ?',
                    (error, self.url))
            connection.commit()
        except sqlite3.OperationalError:
            print("%s: Operational Error" % (self.getName()))
        finally:
            connection.close()
            update_error_lock.release()


class Monitor(threading.Thread):
    def __init__(self, threads):
        threading.Thread.__init__(self)
        self.threads = threads
        self.exit_event = threading.Event()
    def exit(self):
        self.exit_event.set()
        self.join()
    def run(self):
        while not self.exit_event.isSet():
            for t in self.threads:
                if t.report() == 0:
                    pass
                else:
                    print("%3.0f%%" % (t.report()*100)),
            print("")
            time.sleep(1)

class Watcher:
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()
    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            print("KeyBoardInterrupt")
            self.kill()
        sys.exit()
    def kill(self):
        try:
            os.kill(self.child, signal.SIGKILL)
        except OSError: 
            pass



def generate_url(start,work_queue):
    gap=50
    end=start+gap
    for number in range(start,end):    
        url="http://shouji.baidu.com/software/"+str(number)+".html"
        work_queue.put(url)
    return end




def main():
    db_name="test.db"
    Table_name="apps"
    the_db=DB(db_name,Table_name)
    table=the_db.creatTable()
    
    try:
        start=int(the_db.readlast())
    except Exception as e:
        print(e)
        start=0
    
    end=10000000

    threads = []
    work_queue = queue.Queue()



    Watcher()


    for i in range(NUM_THREAD):
        t = Url(the_db,work_queue,Table_name)
        t.daemon = True
        t.start()
        threads.append(t)
    monitor_thread = Monitor(threads)
    monitor_thread.daemon = True
    monitor_thread.start()

    print(work_queue.empty())
    temp=generate_url(start,work_queue)
    exit_flag = 0
    while exit_flag < 2:
        print(exit_flag)
        print(work_queue.qsize())
        if work_queue.empty():
            temp=generate_url(temp,work_queue)
            if temp>end: 
                exit_flag += 1
        else:
            exit_flag = 0
        while not work_queue.empty():
            time.sleep(10)
    for t in threads:
        t.exit()
    monitor_thread.exit()



if __name__ == '__main__':
    main()










 


