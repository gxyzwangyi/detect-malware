#coding:utf-8

import hashlib
import binascii
# import urllib.error
import os
# import sqlalchemy.exc
# from sqlalchemy import create_engine
# from sqlalchemy.ext.declarative import declarative_base
# from sqlalchemy.orm import sessionmaker
# import sqlalchemy.orm.exc
# from db import APKdata, Downloaded, Base, engine, session, Session, Errors
import os.path
import lxml.html
import urllib.request
import sys
import socket
import logging
import argparse
import time
import MySQLdb
import sqlite3
# import http.client
import requests
from bs4 import BeautifulSoup
from optparse import OptionParser
# from wget import wget
import threading
import signal
import queue
import multiprocessing
import base64


#(name,description,introduce,version,download_number,apk_url,serial_number,category,category_num,package_name,keywords,size,download_icon,download_url)
NUM_THREAD = 20
update_try_lock = threading.Lock()
update_error_lock = threading.Lock()
work_queue_lock = threading.Lock()
down_queue_lock=threading.Lock()


                                    
class DB:     
    def __init__(self,_dbname,url_tbname,down_tbname,error_tbname):
        self._dbname=_dbname
        self.url_tbname=url_tbname
        self.down_tbname=down_tbname
        self.error_tbname=error_tbname
     #连接数据库 mysql
    def connectDB(self):
        conn = sqlite3.connect(self._dbname)
        return conn

      #创建表，SQL语言。CREATE TABLE IF NOT EXISTS 表示：表createTableName不存在时就创建
    def creatTable(self):
                

        create_urlTableSql="CREATE TABLE IF NOT EXISTS  "+ self.url_tbname+""" (  aid integer PRIMARY KEY autoincrement,name VARCHAR(40), time VARCHAR(20),introduce  VARCHAR(2000),version VARCHAR(40),download_number VARCHAR(10),  apk_url VARCHAR(100), serial_number VARCHAR(40), category VARCHAR(40), category_num VARCHAR(40),package_name VARCHAR(20),keywords VARCHAR(100),size VARCHAR(20), download_icon  VARCHAR(100), download_url VARCHAR(100),trys INT )"""


        create_downTableSql="CREATE TABLE IF NOT EXISTS  "+ self.down_tbname+""" ( aid integer PRIMARY KEY autoincrement, name VARCHAR(40), time VARCHAR(20) , introduce  VARCHAR(2000),version VARCHAR(40),download_number VARCHAR(10),  apk_url VARCHAR(100), serial_number VARCHAR(40), category VARCHAR(40), category_num VARCHAR(40),package_name VARCHAR(20),keywords VARCHAR(100),size VARCHAR(20), download_icon  VARCHAR(100), download_url VARCHAR(100),sha1 VARCHAR(40))"""


        create_errorTableSql="CREATE TABLE IF NOT EXISTS  "+ self.error_tbname+""" ( aid integer PRIMARY KEY autoincrement, name VARCHAR(40), time VARCHAR(20) , introduce  VARCHAR(2000),version VARCHAR(40),download_number VARCHAR(10),  apk_url VARCHAR(100), serial_number VARCHAR(40), category VARCHAR(40), category_num VARCHAR(40),package_name VARCHAR(20),keywords VARCHAR(100),size VARCHAR(20), download_icon  VARCHAR(100), download_url VARCHAR(100),trys INT,error VARCHAR(40) )"""

 
        # print(create_urlTableSql)
        DB_create=self.connectDB()
        # cursor_create=DB_create.cursor()
        # cursor_create.execute(createTableSql)

        DB_create.execute(create_urlTableSql)
        DB_create.execute(create_downTableSql)
        DB_create.execute(create_errorTableSql)

        DB_create.close()
        print ('creat table  successfully' )
         

    #数据插入url表中
    def inserttable_url(self,insertlist):
        [insertname,inserttime,insertintroduce,insertversion,insertdownload_number,insertapk_url,insertserial_number,insertcategory,insertcategory_num,insertpackage_name,insertkeywords,insertsize,insertdownload_icon,insertdownload_url,inserttrys]=insertlist
        insertContentSql="INSERT INTO "+self.url_tbname+" (aid,name,time,introduce,version,download_number,apk_url,serial_number,category,category_num,package_name,keywords,size,download_icon,download_url,trys) VALUES (NULL,'%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%i')"
        DB_insert=self.connectDB()
        # cursor_insert=DB_insert.cursor()

        str_url=insertContentSql % (insertname,inserttime,insertintroduce,insertversion,insertdownload_number,insertapk_url,insertserial_number,insertcategory,insertcategory_num,insertpackage_name,insertkeywords,insertsize,insertdownload_icon,insertdownload_url,inserttrys)
        # print(str1)

        DB_insert.execute(str_url)
        DB_insert.commit()
        DB_insert.close()
        # print ('insert contents to  '+insertTable+' successfully'  )


    #数据插入apk表中
    def inserttable_down(self,insertlist):
        #print(insertlist)
        [insertname,inserttime,insertintroduce,insertversion,insertdownload_number,insertapk_url,insertserial_number,insertcategory,insertcategory_num,insertpackage_name,insertkeywords,insertsize,insertdownload_icon,insertdownload_url,insertsha1]=insertlist
        insertContentSql="INSERT INTO "+self.down_tbname+" (aid,name,time,introduce,version,download_number,apk_url,serial_number,category,category_num,package_name,keywords,size,download_icon,download_url,sha1) VALUES (NULL,'%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s')"
        DB_insert=self.connectDB()
        # cursor_insert=DB_insert.cursor()     
        str_down=insertContentSql % (insertname,inserttime,insertintroduce,insertversion,insertdownload_number,insertapk_url,insertserial_number,insertcategory,insertcategory_num,insertpackage_name,insertkeywords,insertsize,insertdownload_icon,insertdownload_url,insertsha1)
        # print(str1)

        DB_insert.execute(str_down)
        DB_insert.commit()
        DB_insert.close()
        # print ('insert contents to  '+insertTable+' successfully'  )

    #数据插入apk表中
    def inserttable_error(self,insertlist):
        #print(insertlist)
        [insertname,inserttime,insertintroduce,insertversion,insertdownload_number,insertapk_url,insertserial_number,insertcategory,insertcategory_num,insertpackage_name,insertkeywords,insertsize,insertdownload_icon,insertdownload_url,inserttrys,inserterror]=insertlist
        insertContentSql="INSERT INTO "+self.error_tbname+" (aid,name,time,introduce,version,download_number,apk_url,serial_number,category,category_num,package_name,keywords,size,download_icon,download_url,trys,error) VALUES (NULL,'%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%s','%i','%s')"
        DB_insert=self.connectDB()
        # cursor_insert=DB_insert.cursor()     
        str_error=insertContentSql % (insertname,inserttime,insertintroduce,insertversion,insertdownload_number,insertapk_url,insertserial_number,insertcategory,insertcategory_num,insertpackage_name,insertkeywords,insertsize,insertdownload_icon,insertdownload_url,inserttrys,inserterror)
        # print(str_error)

        DB_insert.execute(str_error)
        DB_insert.commit()
        DB_insert.close()
        # print ('insert contents to  '+insertTable+' successfully'  )



    def update_try(self, aid):
        update_try_lock.acquire()
        try:
            DB_update_try=self.connectDB()
            cursor = DB_update_try.cursor()
            try_str='update '+self.url_tbname+' set trys = trys+1 where aid = %i'%( aid)
            print(try_str)
            cursor.execute(try_str)
            DB_update_try.commit()
        except Exception as e:
            print(138)
            print(e)
        finally:
            DB_update_try.close()
            update_try_lock.release()






    def fetch_max(self):
        DB_select=self.connectDB()
        cur = DB_select.cursor()
        selectSql="select serial_number from "+self.url_tbname+" order by serial_number desc limit 1"
        # print(selectSql)
        try:
            cur.execute(selectSql )
            maxone=cur.fetchall()
            # print("________")
            # print(maxone    )
            return maxone

        except Exception as e:
            print(163)
            print(e)
            return ""


    def fetch_ten( self ):
        DB_select = self.connectDB( )
        cur = DB_select.cursor( )
        selectSql = "select * from " + self.url_tbname + " order by trys desc limit 10"
        try:
            cur.execute( selectSql )
            ten = cur.fetchall( )
            # print( "________" )
            return ten

        except Exception as e:
            print( e )
            return ""


    def delete_downloaded(self,aid):
        DB_delete= self.connectDB( )
        cur = DB_delete.cursor( )
        deleteSql = "delete from " + self.url_tbname + " where aid = %i"%( aid)
        print( deleteSql )

        try:
            cur.execute( deleteSql )
            DB_delete.commit()

        except Exception as e:
            print("delete")
            print( e )
            return ""



class Url(threading.Thread):
    def __init__(self, db,work_queue):
        threading.Thread.__init__(self)
        self.db = db
        self.work_queue = work_queue
        self.exit_event = threading.Event()
        self.current_file_size = 0
        self.file_size = 0
    def exit(self):
        print("%s: asked to exit." % self.getName())
        self.exit_event.set()
        self.join()
        return self.report()
    def report(self):
        if self.file_size == 0:
            return 0
        return float(self.current_file_size) / self.file_size

    def get_apk_content(self,url):
        r=requests.get(url,allow_redirects=False)
        soup= BeautifulSoup(r.content,"html.parser",from_encoding='GB18030')
        # print(soup.select(".area-download")[0].a["href"]==None)
        if soup.title.string==None or soup.select(".area-download")[0].a["href"]==None:
            return 0
        else:
            try:
                name = soup.select(".content-right")[0].h1.text.replace("'","")
                download_time = time.strftime('%Y-%m-%d-%H-%I-%M-%S',time.localtime(time.time()))
                introduce=soup.select(".introduction")[0].select('.brief-long')[0].text.replace("'","")
                version= soup.select(".content-right")[0].select(".detail")[0].select(".version")[0].text[4::]
                download_number=soup.select(".content-right")[0].select(".detail")[0].select(".download-num")[0].text[6::]
                apk_url=soup.find_all(rel="canonical")[0].get("href")
                serial_number=apk_url[(lambda x:x.index('e/'))(apk_url)+2:-5]
                category=soup.select(".app-nav")[0].select(".nav")[0].find_all('a')[-1].text
                category_num=soup.select(".app-nav")[0].select(".nav")[0].find_all('a')[-1].get("href")
                package_name=soup.select(".one-setup-btn")[0].get("data_package")
                keywords=soup.select("meta")[1].get("content").replace("'","")
                size=soup.select(".one-setup-btn")[0].get("data_size")
                download_icon=soup.select(".one-setup-btn")[0].get("data_icon")
                download_url=soup.select(".area-download")[0].a["href"]
                # sha1 = hashlib.sha1((serial_number+version).encode("utf8")).hexdigest()
                trys=0
            except NotAndroiderror as e:
                print( e )
            except Exception as ex:
                # print("aaaaaaaa")
                print(ex)
                # print(url)
                # print(soup.title.string)
                return 0
            apk_list=[name,download_time,introduce,version,download_number,apk_url,serial_number,category,category_num,package_name,keywords,size,download_icon,download_url,trys]   
            print(apk_list)
            return apk_list
            
    def run(self):
        while not self.exit_event.isSet():
            work_queue_lock.acquire()
            if not self.work_queue.empty():
                self.url = self.work_queue.get()
                work_queue_lock.release()
                try:
                    self.insert_db()
                except urllib.request.HTTPError:
                    pass
            else:
                work_queue_lock.release()
        print("%s: received exit event." % self.getName())

    def insert_db(self):    
        apk_content_list=self.get_apk_content(self.url)
        if apk_content_list!=0:
            self.db.inserttable_url(apk_content_list)





class NotAndroiderror(RuntimeError):
    def __init__(self, arg):
        self.args = arg


class Downloader(threading.Thread):
    def __init__(self,db, down_queue ,output_dir):
        threading.Thread.__init__(self)
        self.exit_event = threading.Event()
        self.db = db
        self.down_queue = down_queue
        self.proxies = None
        #self.proxies = {"http": ""}
        self.output_dir = output_dir
        self.current_file_size = 0
        self.file_size = 0
        self.new_output_path=""

    def exit(self):
        print("%s: asked to exit." % self.getName())
        self.exit_event.set()
        self.join()
        return self.report()

    def report(self):
        if self.file_size == 0:
            return 0
        return float(self.current_file_size) / self.file_size

    def run(self):
        while not self.exit_event.isSet():
            down_queue_lock.acquire()
            if not self.down_queue.empty():
                now_queue=self.down_queue.get()
                self.url = now_queue[14]
                # print(self.url)
                self.aid = now_queue[0]
                self.code = now_queue[7]
                self.trys = now_queue[15]

                down_queue_lock.release()
                try:
                    self.download()
                    temp=str(self.temp_output_path)
                    print(temp)

                    sha1 = self.SHA1FileWithName( temp )

                    print(sha1)
                    self.save(sha1)
                    # self.update_database()
                    #去掉id和trys,加上sha1
                    self.db.inserttable_down(list(now_queue[1:-1])+[sha1])
                    self.db.delete_downloaded(self.aid)
                except NotAndroiderror as e:
                    print(e)

                except Exception as e:
                    #trys大于3放到error里
                    if self.trys > 3:
                        self.db.inserttable_error( list( now_queue[ 1:: ] ) + [ str( e ).replace( "'", "" ) ] )
                        self.db.delete_downloaded( self.aid )
                    else:
                        self.db.update_try(self.aid )
                    # self.update_database(-1)
                    # self.db.update_error(str(e))
                    print(305)
                    print(e)
                    print(len(list(now_queue[1::])+[str(e)]))
            else:
                down_queue_lock.release()
        print("%s: received exit event." % self.getName())


    def download(self):
        print("%s: downloading %s is %s" % (self.getName(), self.url,self.code))
        self.current_file_size = 0
        self.file_size = 0
        proxy_handler = urllib.request.ProxyHandler()
        if (self.proxies):
            proxy_handler = urllib.request.proxyHandler(self.proxies);
        opener = urllib.request.build_opener(proxy_handler)
        opener.addheaders = [
            ('User-Agent', r"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.11 "
                "(KHTML, like Gecko) Chrome/23.0.1271.97 Safari/537.11"),
            ('Referer', self.url)
        ]
        urllib.request.install_opener(opener)
        opening = urllib.request.urlopen(self.url,timeout=5)
        meta = opening.info()
        if "android" in meta.get_all("Content-Type")[0]:
            self.file_size = int(meta.get_all("Content-Length")[0])
            temp_file_name = "temp%s.apk" % (self.code)
            temp_dir = self.output_dir + os.sep + "temp"
            self.temp_output_path = temp_dir + os.sep + temp_file_name
            print(self.temp_output_path)
            os.makedirs( os.path.dirname( self.temp_output_path ), exist_ok = True )
            with open(self.temp_output_path, 'wb+') as fil:
                block_size = 10240
                while True:
                    buf = opening.read(block_size)
                    self.current_file_size += len(buf)
                    fil.write(buf)
                    if not buf:
                        break

        else:
            raise NotAndroiderror( "n" )





    def save(self,sha1):
        new_output_path = self.output_dir + os.sep + sha1[0:2] + os.sep+  sha1 + ".apk"
        if os.path.isfile(new_output_path):
            os.remove(new_output_path)
        print(os.path.isfile(self.temp_output_path))
        os.makedirs( os.path.dirname( new_output_path ), exist_ok = True )
        os.rename(self.temp_output_path, new_output_path)
        self.new_output_path = new_output_path
        print("%s: %s.apk is completed." % (self.getName(), self.code))


    def SHA1FileWithName(self,fineName, block_size=64 * 1024):
        print(fineName)
        with open(fineName, 'rb') as f:
            sha1 = hashlib.sha1()
            while True:
                data = f.read(block_size)
                if not data:
                    break
                sha1.update(data)
            # retsha1 = base64.b64encode(sha1.digest())
            retsha1 = sha1.hexdigest()
            return retsha1




class Monitor(threading.Thread):
    def __init__(self, threads):
        threading.Thread.__init__(self)
        self.threads = threads
        self.exit_event = threading.Event()
    def exit(self):
        self.exit_event.set()
        self.join()
    def run(self):
        while not self.exit_event.isSet():
            for t in self.threads:
                if t.report() == 0:
                    pass
                else:
                    print("%3.0f%%" % (t.report()*100)),
            time.sleep(1)

class Watcher:
    def __init__(self):
        self.child = os.fork()
        if self.child == 0:
            return
        else:
            self.watch()
    def watch(self):
        try:
            os.wait()
        except KeyboardInterrupt:
            print("KeyBoardInterrupt")
            self.kill()
        sys.exit()
    def kill(self):
        try:
            os.kill(self.child, signal.SIGKILL)
        except OSError: 
            pass



def generate_url(start,work_queue):
    gap=100
    end=start+gap
    for number in range(start,end):    
        url="http://shouji.baidu.com/software/"+str(number)+".html"
        print(url)
        work_queue.put(url)
    return end



def put_url(ten,down_queue):
    for apk in ten:
        print(apk)
        down_queue.put(apk)
    return 1





def url_thread(the_db):

	end = 10000000
	start = 0

	every_start = int( the_db.fetch_max( )[ 0 ][ 0 ] ) if the_db.fetch_max( ) != [ ] else start

	print( every_start )

	threads = [ ]
	work_queue = queue.Queue( )

	Watcher( )
	for i in range( NUM_THREAD ):
		t = Url( the_db, work_queue )
		t.daemon = True
		t.start( )
		threads.append( t )

	monitor_thread = Monitor( threads )
	monitor_thread.daemon = True
	monitor_thread.start( )
	temp = generate_url( every_start, work_queue )
	exit_flag = 0
	while exit_flag < 2:
		if work_queue.empty( ):
			print( temp )
			temp = generate_url( temp, work_queue )
			if temp > end:
				exit_flag += 1
		else:
			exit_flag = 0
		while not work_queue.empty( ):
			time.sleep( 3 )
	for t in threads:
		t.exit( )
	monitor_thread.exit( )





def download_thread(the_db):



	# print("_______")
	# print(ten)
	# print("_______")




	# ten=the_db.fetch_ten()
	threads = [ ]

	down_queue = queue.Queue( )

	Watcher( )
	for i in range( NUM_THREAD ):
		t = Downloader( the_db, down_queue, os.getcwd()+"/a" )
		t.daemon = True
		t.start( )
		threads.append( t )

	monitor_thread = Monitor( threads )
	monitor_thread.daemon = True
	monitor_thread.start( )


	exit_flag = 0
	while exit_flag < 2:
		if down_queue.empty( ):
			ten = the_db.fetch_ten( )
			put_url(ten,down_queue)
		else:
			exit_flag = 0
		while not down_queue.empty( ):
			time.sleep( 10 )
	for t in threads:
		t.exit( )
	monitor_thread.exit( )






def main():
    db_name="test.db"
    url_name="urls"
    download_name="downloads"
    error_name="errors"

    
    the_db=DB(db_name ,url_name,download_name,error_name)
    table=the_db.creatTable()

    p1 = multiprocessing.Process(target = url_thread, args = (the_db,))
    p2 = multiprocessing.Process(target = download_thread, args = (the_db,))
    p1.start()
    p2.start()

    # url_thread(the_db)
    #
    # dowload_thread( the_db )

    # dowload_thread( the_db )


if __name__ == '__main__':
    main()










 


